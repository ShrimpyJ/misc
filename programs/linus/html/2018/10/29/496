    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2018/10/28/211">First message in thread</a></li><li><a href="/lkml/2018/10/28/211">Linus Torvalds</a><ul><li><a href="/lkml/2018/10/29/20">Linus Torvalds</a><ul><li><a href="/lkml/2018/10/30/742">Mauro Carvalho Chehab</a></li></ul></li><li><a href="/lkml/2018/10/29/414">Jiri Kosina</a><ul><li class="origin"><a href="/lkml/2018/10/29/680">Linus Torvalds</a><ul><li><a href="/lkml/2018/10/29/680">Linus Torvalds</a><ul><li><a href="/lkml/2018/10/30/1">Harry Cutts</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2018/10/29/496/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 29 Oct 2018 08:16:18 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Logitech high-resolution scrolling..</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Oct 29, 2018 at 6:18 AM Jiri Kosina &lt;jikos&#64;kernel.org&gt; wrote:<br />&gt;<br />&gt; Benjamin indicated that Peter probably has found the issue in the code<br />&gt; (failure to properly reset on direction change) that might be causing<br />&gt; this.<br /><br />So honestly, once I looked at that hid_scroll_counter_handle_scroll()<br />function, that's the first thing I tried - get rid of the "half-way<br />threshold" thing, and reset on direction changes.<br /><br />It fixes the instability, and I don't see the "back-and-forth"<br />movements and I don't get the "move the mouse and it generates mouse<br />wheel events" any more.<br /><br />It basically makes the wheel _work_ for me.<br /><br />I'm not entirely convinced it's as good as it used to be, though. It<br />still feels like it might be a bit over-sensitive, but that may be<br />because now I'm just looking for it..<br /><br />Patch I'm using attached. I'm inclined to just commit it, but if<br />somebody has a better idea, I can test alternatives too.<br /><br />                    Linus<br /> drivers/hid/hid-input.c | 43 +++++++++++++++++++++----------------------<br /> 1 file changed, 21 insertions(+), 22 deletions(-)<br /><br />diff --git a/drivers/hid/hid-input.c b/drivers/hid/hid-input.c<br />index 567c3bf64515..a2f74e6adc70 100644<br />--- a/drivers/hid/hid-input.c<br />+++ b/drivers/hid/hid-input.c<br />&#64;&#64; -1855,31 +1855,30 &#64;&#64; EXPORT_SYMBOL_GPL(hidinput_disconnect);<br /> void hid_scroll_counter_handle_scroll(struct hid_scroll_counter *counter,<br /> 				      int hi_res_value)<br /> {<br />-	int low_res_scroll_amount;<br />-	/* Some wheels will rest 7/8ths of a notch from the previous notch<br />-	 * after slow movement, so we want the threshold for low-res events to<br />-	 * be in the middle of the notches (e.g. after 4/8ths) as opposed to on<br />-	 * the notches themselves (8/8ths).<br />-	 */<br />-	int threshold = counter-&gt;resolution_multiplier / 2;<br />+	int low_res_value, remainder, multiplier;<br /> <br /> 	input_report_rel(counter-&gt;dev, REL_WHEEL_HI_RES,<br /> 			 hi_res_value * counter-&gt;microns_per_hi_res_unit);<br /> <br />-	counter-&gt;remainder += hi_res_value;<br />-	if (abs(counter-&gt;remainder) &gt;= threshold) {<br />-		/* Add (or subtract) 1 because we want to trigger when the wheel<br />-		 * is half-way to the next notch (i.e. scroll 1 notch after a<br />-		 * 1/2 notch movement, 2 notches after a 1 1/2 notch movement,<br />-		 * etc.).<br />-		 */<br />-		low_res_scroll_amount =<br />-			counter-&gt;remainder / counter-&gt;resolution_multiplier<br />-			+ (hi_res_value &gt; 0 ? 1 : -1);<br />-		input_report_rel(counter-&gt;dev, REL_WHEEL,<br />-				 low_res_scroll_amount);<br />-		counter-&gt;remainder -=<br />-			low_res_scroll_amount * counter-&gt;resolution_multiplier;<br />-	}<br />+	/*<br />+	 * Update the low-res remainder with the high-res value,<br />+	 * but reset if the direction has changed.<br />+	 */<br />+	remainder = counter-&gt;remainder;<br />+	if ((remainder ^ hi_res_value) &lt; 0)<br />+		remainder = 0;<br />+	remainder += hi_res_value;<br />+<br />+	/*<br />+	 * Then just use the resolution multiplier to see if<br />+	 * we should send a low-res (aka regular wheel) event.<br />+	 */<br />+	multiplier = counter-&gt;resolution_multiplier;<br />+	low_res_value = remainder / multiplier;<br />+	remainder -= low_res_value * multiplier;<br />+	counter-&gt;remainder = remainder;<br />+<br />+	if (low_res_value)<br />+		input_report_rel(counter-&gt;dev, REL_WHEEL, low_res_value);<br /> }<br /> EXPORT_SYMBOL_GPL(hid_scroll_counter_handle_scroll);</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
