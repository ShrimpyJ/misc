    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2018/11/21/378">First message in thread</a></li><li><a href="/lkml/2018/11/23/464">David Laight</a><ul><li><a href="/lkml/2018/11/23/504">David Laight</a><ul><li class="origin"><a href="/lkml/2018/11/23/875">Linus Torvalds</a><ul><li><a href="/lkml/2018/11/23/875">Linus Torvalds</a><ul><li><a href="/lkml/2018/11/24/17">Andy Lutomirski</a></li></ul></li><li><a href="/lkml/2018/11/26/444">David Laight</a></li><li><a href="/lkml/2018/11/26/474">David Laight</a><ul><li><a href="/lkml/2019/1/4/666">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 23 Nov 2018 08:36:01 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] x86: only use ERMS for user copies for larger sizes</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Nov 23, 2018 at 2:12 AM David Laight &lt;David.Laight&#64;aculab.com&gt; wrote:<br />&gt;<br />&gt; I've just patched my driver and redone the test on a 4.13 (ubuntu) kernel.<br />&gt; Calling memcpy_fromio(kernel_buffer, PCIe_address, length)<br />&gt; generates a lot of single byte TLP.<br /><br />I just tested it too - it turns out that the __inline_memcpy() code<br />never triggers, and "memcpy_toio()" just generates a memcpy.<br /><br />So that code seems entirely dead.<br /><br />And, in fact, the codebase I looked at was the historical one, because<br />I had been going back and looking at the history. The modern tree<br />*does* have the "__inline_memcpy()" function I pointed at, but it's<br />not actually hooked up to anything!<br /><br />This actually has been broken for _ages_. The breakage goes back to<br />2010, and commit 6175ddf06b61 ("x86: Clean up mem*io functions"), and<br />it seems nobody really ever noticed - or thought that it was ok.<br /><br />That commit claims that iomem has no special significance on x86, but<br />that really really isn't true, exactly because the access size does<br />matter.<br /><br />And as mentioned, the generic memory copy routines are not at all<br />appropriate, and that has nothing to do with ERMS. Our "do it by hand"<br />memory copy routine does things like this:<br /><br />.Lless_16bytes:<br />        cmpl $8,        %edx<br />        jb   .Lless_8bytes<br />        /*<br />         * Move data from 8 bytes to 15 bytes.<br />         */<br />        movq 0*8(%rsi), %r8<br />        movq -1*8(%rsi, %rdx),  %r9<br />        movq %r8,       0*8(%rdi)<br />        movq %r9,       -1*8(%rdi, %rdx)<br />        retq<br /><br />and note how for a 8-byte copy, it will do *two* reads of the same 8<br />bytes, and *two* writes of the same 8 byte destination. That's<br />perfectly ok for regular memory, and it means that the code can handle<br />an arbitrary 8-15 byte copy without any conditionals or loop counts,<br />but it is *not* ok for iomem.<br /><br />Of course, in practice it all just happens to work in almost all<br />situations (because a lot of iomem devices simply won't care), and<br />manual access to iomem is basically extremely rare these days anyway,<br />but it's definitely entirely and utterly broken.<br /><br />End result: we *used* to do this right. For the last eight years our<br />"memcpy_{to,from}io()" has been entirely broken, and apparently even<br />the people who noticed oddities like David, never reported it as<br />breakage but instead just worked around it in drivers.<br /><br />Ho humm.<br /><br />Let me write a generic routine in lib/iomap_copy.c (which already does<br />the "user specifies chunk size" cases), and hook it up for x86.<br /><br />David, are you using a bus analyzer or something to do your testing?<br />I'll have a trial patch for you asap.<br /><br />               Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
