    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2018/8/22/412">First message in thread</a></li><li><a href="/lkml/2018/8/23/45">Linus Torvalds</a><ul><li><a href="/lkml/2018/8/23/46">Linus Torvalds</a></li><li><a href="/lkml/2018/8/23/54">Nicholas Piggin</a><ul><li class="origin"><a href="/lkml/2018/8/23/79">Linus Torvalds</a><ul><li><a href="/lkml/2018/8/23/79">Nicholas Piggin</a></li><li><a href="/lkml/2018/8/24/181">Peter Zijlstra</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 22 Aug 2018 21:54:48 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 2/4] mm/tlb: Remove tlb_remove_table() non-concurrent condition</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Aug 22, 2018 at 9:16 PM Nicholas Piggin &lt;npiggin&#64;gmail.com&gt; wrote:<br />&gt;<br />&gt; On Wed, 22 Aug 2018 20:35:16 -0700<br />&gt; Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt; &gt;<br />&gt; &gt; And yes, those lazy tlbs are all kernel threads, but they can still<br />&gt; &gt; speculatively load user addresses.<br />&gt;<br />&gt; So?<br />&gt;<br />&gt; If the arch does not shoot those all down after the user page tables<br />&gt; are removed then it's buggy regardless of this short cut.<br /><br />Read the code.<br /><br />That shortcut frees the pages *WITHOUT* doing that TLB flush. It just<br />does __tlb_remove_table(), which does *not* do that whole page<br />queueing so that we can batch flush and then free later.<br /><br />So the fast-case it's buggy, exactly because of the reason you state.<br /><br />The logic used to be that if you were the only cpu that had that tlb,<br />and it was a mid-level table, it didn't need that synchronization at<br />all.<br /><br />And that logic is simply wrong. Exactly because even if mm_users is 1,<br />there can be things looking up TLB entries on other CPU's. Either<br />because of a lazy mm and a hw walker with speculation, or because of<br />use_mm() and a software walker.<br /><br />So the whole "free immediately" shortcut was bogus. You *always* need<br />to queue, then flush the tlb, and then free.<br /><br />That said, that wasn't actually the bug that Jann found. He found the<br />bug a few lines lower down, where the "I can't allocate memory for<br />queueing" ended up *also* not flushing the TLB.<br /><br />&gt; The only real problem I could see would be if a page walk cache still<br />&gt; points to the freed table, then the table gets re-allocated and used<br />&gt; elsewhere, and meanwhile a speculative access tries to load an entry<br />&gt; from the page that is an invalid form of page table that might cause<br />&gt; a machine check or something. That would be (u)arch specific, but if<br />&gt; that's what we're concerned with here it's a different issue and needs<br />&gt; to be documented as such.<br /><br />We've *seen* that case, we had exactly that when we were being<br />aggressive about trying to avoid flushes for the lazy mmu case<br />entirely, because "we can just flush when we activate the lazy mm<br />state instead".<br /><br />The logic was actually solid from a TLB case - who cares what garbage<br />TLB entries we might speculatively fill, when we're going to flush<br />them before they can possibly be used.<br /><br />It turns out that that logic is solid, but hits another problem: at<br />least some AMD CPU's will cause machine checks when the TLB entries<br />are inconsistent with the machine setup. That can't happen with a<br />*good* page table, but when you speculatively walk already freed<br />tables, you can get any garbage.<br /><br />I forget what the exact trigger was, but this was actually reported.<br />So you can't free page directory pages without flushing the tlb first<br />(to make that internal tlb node caches are flushed).<br /><br />So the logic for freeing leaf pages and freeing middle nodes has to be<br />exactly the same: you make the modification to the page table to<br />remove the node/leaf, you queue up the memory for freeing, you flush<br />the tlb, and you then free the page.<br /><br />That's the ordering that tlb_remove_page() has always honored, but<br />that tlb_remove_tabl() didn't.<br /><br />It honored it for the *normal* case, which is why it took so long to<br />notice that the TLB shootdown had been broken on x86 when it moved to<br />the "generic" code. The *normal* case does this all right, and batches<br />things up, and then when the batch fills up it does a<br />tlb_table_flush() which does the TLB flush and schedules the actual<br />freeing.<br /><br />But there were two cases that *didn't* do that. The special "I'm the<br />only thread" fast case, and the "oops I ran out of memory, so now I'll<br />fake it, and just synchronize with page twalkers manually, and then do<br />that special direct remove without flushing the tlb".<br /><br />NOTE! Jann triggered that one by<br /> (a) forcing the machine low on memory<br /> (b) force-poisoning the page tables immediately after free<br /><br />I suspect it's really hard to trigger under normal loads, exactly<br />because the *normal* case gets it right. It's literally the "oops, I<br />can't batch up because I ran out of memory" case that gets it wrong.<br /><br />(And the special single-thread + lazy or use_mm() case, but that's<br />going to be entirely impossible to trigger, because in practice it's<br />just a single thread, and you won't ever hit the magic timing needed<br />that frees the page in the single thread at exactly the same time that<br />some optimistic lazy mm on another cpu happens to speculatively load<br />that address).<br /><br />So the "atomic_read(&amp;mm_users)" case is likely entirely impossible to<br />trigger any sane way. But because Jann found the problem with the 'ran<br />out of memory" case, we started looking at the more theoretical cases<br />that matched the same kind of "no tlb flush before free" pattern.<br /><br />              Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
