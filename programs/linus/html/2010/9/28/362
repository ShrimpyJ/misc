    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2010/9/27/241">First message in thread</a></li><li><a href="/lkml/2010/9/27/241">Boaz Harrosh</a><ul><li><a href="/lkml/2010/9/27/267">Phil Turmel</a></li><li class="origin"><a href="/lkml/2010/9/28/367">Linus Torvalds</a><ul><li><a href="/lkml/2010/9/28/367">Andrew Morton</a><ul><li><a href="/lkml/2010/9/28/368">David Miller</a></li><li><a href="/lkml/2010/9/28/371">Linus Torvalds</a><ul><li><a href="/lkml/2010/9/28/372">David Miller</a></li><li><a href="/lkml/2010/9/29/82">Boaz Harrosh</a></li><li><a href="/lkml/2010/9/29/85">Boaz Harrosh</a></li></ul></li></ul></li><li><a href="/lkml/2010/9/28/376">Al Viro</a><ul><li><a href="/lkml/2010/9/28/383">Al Viro</a><ul><li><a href="/lkml/2010/9/28/389">David Miller</a></li></ul></li></ul></li><li><a href="/lkml/2011/1/26/287">Emil Langrock</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 28 Sep 2010 13:24:40 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: {painfully BISECTED} Please revert f25c80a4b2: arch/um/drivers: remove duplicate structure field initialization</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">Ping, no comments?<br /><br />On Mon, Sep 27, 2010 at 6:17 AM, Boaz Harrosh &lt;bharrosh&#64;panasas.com&gt; wrote:<br />&gt;<br />&gt; [bharrosh&#64;fs2 ~/dev/git/pub/scsi-misc] 1115$ git bisect good<br />&gt; f25c80a4b2bf93c99820f470573626557db35202 is the first bad commit<br />&gt; commit f25c80a4b2bf93c99820f470573626557db35202<br /><br />It looks like that commit is indeed very misleading. The commit message says:<br /><br />  "arch/um/drivers: remove duplicate structure field initialization"<br /><br />but it is in fact not duplicate: there's two field initializations,<br />but they are _different_. Looking at the patch, it has:<br /><br />        .ndo_set_mac_address    = uml_net_set_mac,<br />-       .ndo_set_mac_address    = eth_mac_addr,<br /><br />so it removes the later one, but it is not at all clear which one the<br />compiler actually used. My guess is that it used to use the later one<br />(the standard eth_mac_addr function), and the patch made it suddenly<br />use the uml_net_set_mac function.<br /><br />I didn't check what gcc used to do, but this:<br /><br />&gt; The patch Reverts cleanly on top of 2.6.36-rc5 and after Revert works perfectly as<br />&gt; before.<br /><br />makes me suspect that nobody else checked it either.<br /><br />&gt; &lt;RANT A HEAD CAN BE IGNORED&gt;<br />&gt;<br />&gt; It has become extremely hard to bisect a simple problem in latest Kernels!<br /><br />It's always been extremely hard, it just depends on luck how well it<br />works. Sometimes you never see any problems (except the one you<br />bisect, which is obviously the problem you _want_ to see), and then<br />sometimes bisection is really painful because there are multiple<br />independent ones you hit.<br /><br />&gt; For instance I found the bug I see was already present in 2.6.36-rc2<br />&gt; and that a good point was 2.6.35. Bisecting two bad(s) quickly took me<br />&gt; to some 2.6.35-rc1 Kernel that did not boot at all. So I was clever I<br />&gt; decided to merge in 2.6.35 at each bisect point.<br /><br />That really wasn't clever. Don't do it. It will cause untold pain. All<br />your problems resulted from that initial thing - you were basically<br />bisecting commits that weren't even part of the original "bad" state.<br />After a while, git-bisect ends up hitting those commits that aren't<br />even reachable from 'bad', and now you're screwed.<br /><br />So all the other problems you had were due to that.<br /><br />Now, admittedly, the thing that caused you to do this in the first<br />place (hitting a bad kernel that you couldn't even test) is painful.<br />And no, "git bisect skip" doesn't necessarily work all that well. But<br />what you tried really just made things worse.<br /><br />If the real thing to do, just so you know next time, is to do the "git<br />bisect visualize", and try to pick a good point, and just select that<br />(with "git reset --hard xyzzy").<br /><br />Now, that "good" is obviously a matter of judgement, because you don't<br />want to pick it too close to a known-bad or known-good commit (that<br />just makes bisection not work very efficiently), and seeing that can<br />be hard. But usually a good strategy is to pick something that looks<br />_reasonably_ central in the gitk view, and also looks like it's not in<br />the middle of some big upheaval (and preferably as far as reasonable<br />from the commit you know you can't test - pick a point on a different<br />branch before that got merged, for example)<br /><br /><br /><br />&gt; Then reset and continue.<br />&gt; But for some reason the bisect got mixed up and complained about an impossible<br />&gt; merge common bases. So out of desperation I did a very very^ stupid thing.<br />&gt; []$ git rebase -i v2.6.35 v2.6.36-rc1<br /><br />This _really_ won't work. I mean yes, it can work, but with any kind<br />of complex history, you're setting yourself up for more pain than it's<br />worth. It _can_ be worthwhile, but it's absolutely the last thing you<br />should try.<br /><br />&gt; In short I wish at some 2.6.XX-rc[45] of every Kernel cycle. Maintainers<br />&gt; would rebase their next's tree of [XX+1] to a some what more stable rc.<br />&gt; Sure re-run all the tests. They still have time for the new tree in next<br />&gt; to be tested and verified before the next merge window.<br />&gt; (Hell one of my bisect points took me as back as 2.6.34)<br />&gt;<br />&gt; Please remind me why maintainers should not rebase their trees once<br />&gt; committed, to the point that they don't rebase even for buggy patches<br />&gt; that are already in next, and apply fix patches, all within the same<br />&gt; merge window. The same is also done with merge conflicts with the<br />&gt; rc-cycle of their own code, instead of rebasing.<br /><br />Umm. Rebasing often makes things much _worse_.<br /><br />The real problem is that maintainers often pick random - and not at<br />all stable - points for their development to begin with. They just<br />pick some random "this is where Linus -git tree is today", and do<br />their development on top of that. THAT is the problem - they are<br />unaware that there's some nasty bug in that version.<br /><br />It's actually made worse by rebasing. A lot of people end up rebasing<br />on top of such a random kernel (again, just because it's the 'most<br />recent'). It's very annoying.<br /><br />Not to mention that rebasing easily results in bugs of its own, when<br />you do hit merge conflicts or double-apply something that already got<br />applied (and wasn't seen as a duplicate and merged away automatically,<br />because the code had been further modified since). We had that in the<br />DVB pull request just yesterday.<br /><br />&gt; So in short this is a call for, possibly, cleaner History in main Kernel.<br />&gt; Please remind me why re-writing history is a bad thing.<br /><br />Rebasing doesn't result in cleaner history. It just results in<br />_incorrect_ history that looks simpler.<br /><br />To get cleaner history, people should try to keep their tree clean.<br />Not add random patches to random branches, and not start random<br />branches at random points in time that aren't necessarily stable.<br /><br />                                    Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
