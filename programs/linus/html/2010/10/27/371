    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2010/10/26/281">First message in thread</a></li><li><a href="/lkml/2010/10/27/339">"J. Bruce Fields"</a><ul><li><a href="/lkml/2010/10/27/364">Arnd Bergmann</a><ul><li class="origin"><a href="/lkml/2010/10/27/393">Linus Torvalds</a><ul><li><a href="/lkml/2010/10/27/393">Arnd Bergmann</a><ul><li><a href="/lkml/2010/10/27/398">"J. Bruce Fields"</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2010/10/27/371/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 27 Oct 2010 11:42:55 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: nfsd changes for 2.6.37</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Oct 27, 2010 at 11:20 AM, Arnd Bergmann &lt;arnd&#64;arndb.de&gt; wrote:<br />&gt;<br />&gt; Ok, then let's use your tree with proper changelogs. That should be the<br />&gt; easiest way to make sure that the code you test is the one that gets in.<br /><br />Half of them are yours, and the one that is mine needs the comment<br />fixup. Can you organize it all for me to pull?<br /><br />Here's my patch again, with the comment move and a suggested commit<br />message (and my sign-off and Bruce's tested-by: the only thing that<br />changed in the patch was literally some comment placement so the<br />tested-by should still be perfectly valid).<br /><br />Feel free to edit the message/patch to your hearts content.<br /><br />  Thanks,<br />        Linus<br />From: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />Subject: fasync: re-organize fasync entry insertion to allow it under a spinlock<br /><br />You currently cannot use "fasync_helper()" in an atomic environment to<br />insert a new fasync entry, because it will need to allocate the new<br />"struct fasync_struct". <br /><br />Yet fcntl_setlease() wants to call this under lock_flocks(), which is in<br />the process of being converted from the BKL to a spinlock. <br /><br />In order to fix this, this abstracts out the actual fasync list<br />insertion and the fasync allocations into functions of their own, and<br />teaches fs/locks.c to pre-allocate the fasync_struct entry.  That way<br />the actual list insertion can happen while holding the required<br />spinlock. <br /><br />Signed-off-by: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />Tested-by: Bruce Fields &lt;bfields&#64;fieldses.org&gt;<br />---<br /> fs/fcntl.c         |   62 ++++++++++++++++++++++++++++++++++++++++-----------<br /> fs/locks.c         |   17 +++++++++++++-<br /> include/linux/fs.h |    5 ++++<br /> 3 files changed, 69 insertions(+), 15 deletions(-)<br /><br />diff --git a/fs/fcntl.c b/fs/fcntl.c<br />index f8cc34f..ecc8b39 100644<br />--- a/fs/fcntl.c<br />+++ b/fs/fcntl.c<br />&#64;&#64; -640,7 +640,7 &#64;&#64; static void fasync_free_rcu(struct rcu_head *head)<br />  * match the state "is the filp on a fasync list".<br />  *<br />  */<br />-static int fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)<br />+int fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)<br /> {<br /> 	struct fasync_struct *fa, **fp;<br /> 	int result = 0;<br />&#64;&#64; -666,21 +666,31 &#64;&#64; static int fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)<br /> 	return result;<br /> }<br /> <br />+struct fasync_struct *fasync_alloc(void)<br />+{<br />+	return kmem_cache_alloc(fasync_cache, GFP_KERNEL);<br />+}<br />+<br /> /*<br />- * Add a fasync entry. Return negative on error, positive if<br />- * added, and zero if did nothing but change an existing one.<br />+ * NOTE! This can be used only for unused fasync entries:<br />+ * entries that actually got inserted on the fasync list<br />+ * need to be released by rcu - see fasync_remove_entry.<br />+ */<br />+void fasync_free(struct fasync_struct *new)<br />+{<br />+	kmem_cache_free(fasync_cache, new);<br />+}<br />+<br />+/*<br />+ * Insert a new entry into the fasync list.  Return the pointer to the<br />+ * old one if we didn't use the new one.<br />  *<br />  * NOTE! It is very important that the FASYNC flag always<br />  * match the state "is the filp on a fasync list".<br />  */<br />-static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fapp)<br />+struct fasync_struct *fasync_insert_entry(int fd, struct file *filp, struct fasync_struct **fapp, struct fasync_struct *new)<br /> {<br />-	struct fasync_struct *new, *fa, **fp;<br />-	int result = 0;<br />-<br />-	new = kmem_cache_alloc(fasync_cache, GFP_KERNEL);<br />-	if (!new)<br />-		return -ENOMEM;<br />+        struct fasync_struct *fa, **fp;<br /> <br /> 	spin_lock(&amp;filp-&gt;f_lock);<br /> 	spin_lock(&amp;fasync_lock);<br />&#64;&#64; -691,8 +701,6 &#64;&#64; static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fa<br /> 		spin_lock_irq(&amp;fa-&gt;fa_lock);<br /> 		fa-&gt;fa_fd = fd;<br /> 		spin_unlock_irq(&amp;fa-&gt;fa_lock);<br />-<br />-		kmem_cache_free(fasync_cache, new);<br /> 		goto out;<br /> 	}<br /> <br />&#64;&#64; -702,13 +710,39 &#64;&#64; static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fa<br /> 	new-&gt;fa_fd = fd;<br /> 	new-&gt;fa_next = *fapp;<br /> 	rcu_assign_pointer(*fapp, new);<br />-	result = 1;<br /> 	filp-&gt;f_flags |= FASYNC;<br /> <br /> out:<br /> 	spin_unlock(&amp;fasync_lock);<br /> 	spin_unlock(&amp;filp-&gt;f_lock);<br />-	return result;<br />+	return fa;<br />+}<br />+<br />+/*<br />+ * Add a fasync entry. Return negative on error, positive if<br />+ * added, and zero if did nothing but change an existing one.<br />+ */<br />+static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fapp)<br />+{<br />+	struct fasync_struct *new;<br />+<br />+	new = fasync_alloc();<br />+	if (!new)<br />+		return -ENOMEM;<br />+<br />+	/*<br />+	 * fasync_insert_entry() returns the old (update) entry if<br />+	 * it existed.<br />+	 *<br />+	 * So free the (unused) new entry and return 0 to let the<br />+	 * caller know that we didn't add any new fasync entries.<br />+	 */<br />+	if (fasync_insert_entry(fd, filp, fapp, new)) {<br />+		fasync_free(new);<br />+		return 0;<br />+	}<br />+<br />+	return 1;<br /> }<br /> <br /> /*<br />diff --git a/fs/locks.c b/fs/locks.c<br />index 4de3a26..9ff3f66 100644<br />--- a/fs/locks.c<br />+++ b/fs/locks.c<br />&#64;&#64; -1515,6 +1515,7 &#64;&#64; EXPORT_SYMBOL_GPL(vfs_setlease);<br /> int fcntl_setlease(unsigned int fd, struct file *filp, long arg)<br /> {<br /> 	struct file_lock fl, *flp = &amp;fl;<br />+	struct fasync_struct *new;<br /> 	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;<br /> 	int error;<br /> <br />&#64;&#64; -1523,13 +1524,25 &#64;&#64; int fcntl_setlease(unsigned int fd, struct file *filp, long arg)<br /> 	if (error)<br /> 		return error;<br /> <br />+	new = fasync_alloc();<br />+	if (!new)<br />+		return -ENOMEM;<br />+<br /> 	lock_flocks();<br /> <br /> 	error = __vfs_setlease(filp, arg, &amp;flp);<br /> 	if (error || arg == F_UNLCK)<br /> 		goto out_unlock;<br /> <br />-	error = fasync_helper(fd, filp, 1, &amp;flp-&gt;fl_fasync);<br />+	/*<br />+	 * fasync_insert_entry() returns the old entry if any.<br />+	 * If there was no old entry, then it used 'new' and<br />+	 * inserted it into the fasync list. Clear new so that<br />+	 * we don't release it here.<br />+	 */<br />+	if (!fasync_insert_entry(fd, filp, &amp;flp-&gt;fl_fasync, new))<br />+		new = NULL;<br />+<br /> 	if (error &lt; 0) {<br /> 		/* remove lease just inserted by setlease */<br /> 		flp-&gt;fl_type = F_UNLCK | F_INPROGRESS;<br />&#64;&#64; -1541,6 +1554,8 &#64;&#64; int fcntl_setlease(unsigned int fd, struct file *filp, long arg)<br /> 	error = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);<br /> out_unlock:<br /> 	unlock_flocks();<br />+	if (new)<br />+		fasync_free(new);<br /> 	return error;<br /> }<br /> <br />diff --git a/include/linux/fs.h b/include/linux/fs.h<br />index 240eb1d..d487772 100644<br />--- a/include/linux/fs.h<br />+++ b/include/linux/fs.h<br />&#64;&#64; -1310,6 +1310,11 &#64;&#64; struct fasync_struct {<br /> <br /> /* SMP safe fasync helpers: */<br /> extern int fasync_helper(int, struct file *, int, struct fasync_struct **);<br />+extern struct fasync_struct *fasync_insert_entry(int, struct file *, struct fasync_struct **, struct fasync_struct *);<br />+extern int fasync_remove_entry(struct file *, struct fasync_struct **);<br />+extern struct fasync_struct *fasync_alloc(void);<br />+extern void fasync_free(struct fasync_struct *);<br />+<br /> /* can be called from interrupts */<br /> extern void kill_fasync(struct fasync_struct **, int, int);<br /> </pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
