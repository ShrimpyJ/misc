    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2010/10/26/281">First message in thread</a></li><li><a href="/lkml/2010/10/27/263">Christoph Hellwig</a><ul><li><a href="/lkml/2010/10/27/268">"J. Bruce Fields"</a><ul><li><a href="/lkml/2010/10/27/270">Christoph Hellwig</a></li></ul></li><li><a href="/lkml/2010/10/27/273">Arnd Bergmann</a><ul><li><a href="/lkml/2010/10/27/276">"J. Bruce Fields"</a></li><li><a href="/lkml/2010/10/27/279">Christoph Hellwig</a></li><li class="origin"><a href="/lkml/2010/10/27/316">Linus Torvalds</a><ul><li><a href="/lkml/2010/10/27/316">"J. Bruce Fields"</a><ul><li><a href="/lkml/2010/10/27/338">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2010/10/30/186">"J. Bruce Fields"</a><ul><li><a href="/lkml/2010/10/30/190">"J. Bruce Fields"</a><ul><li><a href="/lkml/2010/10/31/39">Christoph Hellwig</a><ul><li><a href="/lkml/2010/11/1/209">"J. Bruce Fields"</a></li></ul></li></ul></li><li><a href="/lkml/2010/10/30/191">"J. Bruce Fields"</a></li><li><a href="/lkml/2010/10/30/192">"J. Bruce Fields"</a></li><li><a href="/lkml/2010/10/30/194">"J. Bruce Fields"</a><ul><li><a href="/lkml/2010/10/30/224">Christoph Hellwig</a><ul><li><a href="/lkml/2010/10/30/230">"J. Bruce Fields"</a></li></ul></li></ul></li><li><a href="/lkml/2010/10/30/197">Arnd Bergmann</a></li><li><a href="/lkml/2010/10/30/225">Christoph Hellwig</a><ul><li><a href="/lkml/2010/10/30/229">"J. Bruce Fields"</a></li></ul></li><li><a href="/lkml/2010/10/31/49">Christoph Hellwig</a><ul><li><a href="/lkml/2010/10/31/50">Christoph Hellwig</a><ul><li><a href="/lkml/2010/11/3/354">"J. Bruce Fields"</a></li></ul></li><li><a href="/lkml/2010/10/31/51">Christoph Hellwig</a></li><li><a href="/lkml/2010/11/1/133">"J. Bruce Fields"</a><ul><li><a href="/lkml/2010/11/6/147">Christoph Hellwig</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2010/10/27/305/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 27 Oct 2010 09:12:06 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: nfsd changes for 2.6.37</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Oct 27, 2010 at 8:23 AM, Arnd Bergmann &lt;arnd&#64;arndb.de&gt; wrote:<br />&gt;<br />&gt; locks_delete_lock is also called with lock_flocks held and calls<br />&gt; fasync_helper...<br /><br />We don't really have to use fasync_helper.<br /><br />In fact, the whole interface is pretty broken for something like file<br />locking, which isn't actually "fasync()". That whole "on/off as an<br />argument" is just crazy. It would be _trivial_ to expose a version of<br />fasync_helper() that takes a pre-allocated fasync_struct for add, and<br />that has separate helper functions for the add/delete case so that you<br />don't have the pointless crazy arguments (for "delete" the "fd"<br />argument is useless, and I do hate "modal" functions that take what<br />they should do as a flag).<br /><br />Then fcntl_setlease() would trivially just allocate the dang thing before.<br /><br />Something like the attached (UNTESTED!) perhaps?<br /><br />                           Linus<br /> fs/fcntl.c         |   66 +++++++++++++++++++++++++++++++++++++++------------<br /> fs/locks.c         |   17 ++++++++++++-<br /> include/linux/fs.h |    5 ++++<br /> 3 files changed, 71 insertions(+), 17 deletions(-)<br /><br />diff --git a/fs/fcntl.c b/fs/fcntl.c<br />index f8cc34f..dcdbc6f 100644<br />--- a/fs/fcntl.c<br />+++ b/fs/fcntl.c<br />&#64;&#64; -640,7 +640,7 &#64;&#64; static void fasync_free_rcu(struct rcu_head *head)<br />  * match the state "is the filp on a fasync list".<br />  *<br />  */<br />-static int fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)<br />+int fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)<br /> {<br /> 	struct fasync_struct *fa, **fp;<br /> 	int result = 0;<br />&#64;&#64; -666,21 +666,28 &#64;&#64; static int fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)<br /> 	return result;<br /> }<br /> <br />+struct fasync_struct *fasync_alloc(void)<br />+{<br />+	return kmem_cache_alloc(fasync_cache, GFP_KERNEL);<br />+}<br />+<br /> /*<br />- * Add a fasync entry. Return negative on error, positive if<br />- * added, and zero if did nothing but change an existing one.<br />- *<br />- * NOTE! It is very important that the FASYNC flag always<br />- * match the state "is the filp on a fasync list".<br />+ * NOTE! This can be used only for unused fasync entries:<br />+ * entries that actually got inserted on the fasync list<br />+ * need to be released by rcu - see fasync_remove_entry.<br />  */<br />-static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fapp)<br />+void fasync_free(struct fasync_struct *new)<br /> {<br />-	struct fasync_struct *new, *fa, **fp;<br />-	int result = 0;<br />+	kmem_cache_free(fasync_cache, new);<br />+}<br /> <br />-	new = kmem_cache_alloc(fasync_cache, GFP_KERNEL);<br />-	if (!new)<br />-		return -ENOMEM;<br />+/*<br />+ * Insert a new entry into the fasync list.  Return the pointer to the<br />+ * old one if we didn't use the new one.<br />+ */<br />+struct fasync_struct *fasync_insert_entry(int fd, struct file *filp, struct fasync_struct **fapp, struct fasync_struct *new)<br />+{<br />+        struct fasync_struct *fa, **fp;<br /> <br /> 	spin_lock(&amp;filp-&gt;f_lock);<br /> 	spin_lock(&amp;fasync_lock);<br />&#64;&#64; -691,8 +698,6 &#64;&#64; static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fa<br /> 		spin_lock_irq(&amp;fa-&gt;fa_lock);<br /> 		fa-&gt;fa_fd = fd;<br /> 		spin_unlock_irq(&amp;fa-&gt;fa_lock);<br />-<br />-		kmem_cache_free(fasync_cache, new);<br /> 		goto out;<br /> 	}<br /> <br />&#64;&#64; -702,13 +707,42 &#64;&#64; static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fa<br /> 	new-&gt;fa_fd = fd;<br /> 	new-&gt;fa_next = *fapp;<br /> 	rcu_assign_pointer(*fapp, new);<br />-	result = 1;<br /> 	filp-&gt;f_flags |= FASYNC;<br /> <br /> out:<br /> 	spin_unlock(&amp;fasync_lock);<br /> 	spin_unlock(&amp;filp-&gt;f_lock);<br />-	return result;<br />+	return fa;<br />+}<br />+<br />+/*<br />+ * Add a fasync entry. Return negative on error, positive if<br />+ * added, and zero if did nothing but change an existing one.<br />+ *<br />+ * NOTE! It is very important that the FASYNC flag always<br />+ * match the state "is the filp on a fasync list".<br />+ */<br />+static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fapp)<br />+{<br />+	struct fasync_struct *new;<br />+<br />+	new = fasync_alloc();<br />+	if (!new)<br />+		return -ENOMEM;<br />+<br />+	/*<br />+	 * fasync_insert_entry() returns the old (update) entry if<br />+	 * it existed.<br />+	 *<br />+	 * So free the (unused) new entry and return 0 to let the<br />+	 * caller know that we didn't add any new fasync entries.<br />+	 */<br />+	if (fasync_insert_entry(fd, filp, fapp, new)) {<br />+		fasync_free(new);<br />+		return 0;<br />+	}<br />+<br />+	return 1;<br /> }<br /> <br /> /*<br />diff --git a/fs/locks.c b/fs/locks.c<br />index 4de3a26..9ff3f66 100644<br />--- a/fs/locks.c<br />+++ b/fs/locks.c<br />&#64;&#64; -1515,6 +1515,7 &#64;&#64; EXPORT_SYMBOL_GPL(vfs_setlease);<br /> int fcntl_setlease(unsigned int fd, struct file *filp, long arg)<br /> {<br /> 	struct file_lock fl, *flp = &amp;fl;<br />+	struct fasync_struct *new;<br /> 	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;<br /> 	int error;<br /> <br />&#64;&#64; -1523,13 +1524,25 &#64;&#64; int fcntl_setlease(unsigned int fd, struct file *filp, long arg)<br /> 	if (error)<br /> 		return error;<br /> <br />+	new = fasync_alloc();<br />+	if (!new)<br />+		return -ENOMEM;<br />+<br /> 	lock_flocks();<br /> <br /> 	error = __vfs_setlease(filp, arg, &amp;flp);<br /> 	if (error || arg == F_UNLCK)<br /> 		goto out_unlock;<br /> <br />-	error = fasync_helper(fd, filp, 1, &amp;flp-&gt;fl_fasync);<br />+	/*<br />+	 * fasync_insert_entry() returns the old entry if any.<br />+	 * If there was no old entry, then it used 'new' and<br />+	 * inserted it into the fasync list. Clear new so that<br />+	 * we don't release it here.<br />+	 */<br />+	if (!fasync_insert_entry(fd, filp, &amp;flp-&gt;fl_fasync, new))<br />+		new = NULL;<br />+<br /> 	if (error &lt; 0) {<br /> 		/* remove lease just inserted by setlease */<br /> 		flp-&gt;fl_type = F_UNLCK | F_INPROGRESS;<br />&#64;&#64; -1541,6 +1554,8 &#64;&#64; int fcntl_setlease(unsigned int fd, struct file *filp, long arg)<br /> 	error = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);<br /> out_unlock:<br /> 	unlock_flocks();<br />+	if (new)<br />+		fasync_free(new);<br /> 	return error;<br /> }<br /> <br />diff --git a/include/linux/fs.h b/include/linux/fs.h<br />index 240eb1d..d487772 100644<br />--- a/include/linux/fs.h<br />+++ b/include/linux/fs.h<br />&#64;&#64; -1310,6 +1310,11 &#64;&#64; struct fasync_struct {<br /> <br /> /* SMP safe fasync helpers: */<br /> extern int fasync_helper(int, struct file *, int, struct fasync_struct **);<br />+extern struct fasync_struct *fasync_insert_entry(int, struct file *, struct fasync_struct **, struct fasync_struct *);<br />+extern int fasync_remove_entry(struct file *, struct fasync_struct **);<br />+extern struct fasync_struct *fasync_alloc(void);<br />+extern void fasync_free(struct fasync_struct *);<br />+<br /> /* can be called from interrupts */<br /> extern void kill_fasync(struct fasync_struct **, int, int);<br /> </pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
