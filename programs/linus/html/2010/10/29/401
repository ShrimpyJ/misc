    </div></td><td width="32"> </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2010/2/12/41">First message in thread</a></li><li><a href="/lkml/2010/6/27/73">Jan Engelhardt</a><ul><li><a href="/lkml/2010/10/24/154">Jan Engelhardt</a><ul><li class="origin"><a href="/lkml/2010/10/29/403">Linus Torvalds</a><ul><li><a href="/lkml/2010/10/29/403">Linus Torvalds</a><ul><li><a href="/lkml/2010/10/29/406">Linus Torvalds</a></li><li><a href="/lkml/2010/10/29/412">Andrew Morton</a></li><li><a href="/lkml/2010/10/30/61">Christoph Hellwig</a></li></ul></li></ul></li><li><a href="/lkml/2010/10/31/48">Jan Kara</a><ul><li><a href="/lkml/2010/10/31/125">Jan Kara</a><ul><li><a href="/lkml/2010/11/5/232">Jan Kara</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 29 Oct 2010 17:57:31 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Sync writeback still broken</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">Guys, what is the status of this?<br /><br />The original patch in that email thread still makes no sense and the<br />commit log for it cannot be the real issue. But the _problem_ seems to<br />be real, and the code is apparently a total mess, still.<br /><br />And the chunking is necessary - as even quoted in that whole thread:<br /><br />  On Tue, Feb 23, 2010 at 01:53:50PM +1100, Dave Chinner wrote:<br />  &gt;<br />  &gt; Ignoring nr_to_write completely can lead to issues like we used to<br />  &gt; have with XFS - it would write an entire extent (8GB) at a time and<br />  &gt; starve all other writeback. Those starvation problems - which were<br />  &gt; very obvious on NFS servers - went away when we trimmed back the<br />  &gt; amount to write in a single pass to saner amounts...<br /><br />so we can't just stay with one single inode and do that one<br />completely. At the same time, the VFS chunking code itself is at least<br />supposed to try to write out 4MB at a time, which means that the whole<br />"only 400kB/s throughput" thing is pretty damn unlikely - but if it's<br />true, then that obviously means that the chunking is somehow broken.<br /><br />IOW, we haven't seemed to get anywhere, and I haven't seen anybody<br />reply to Jan's plaintive email. Anybody?<br /><br />                         Linus<br /><br />On Sun, Oct 24, 2010 at 4:41 PM, Jan Engelhardt &lt;jengelh&#64;medozas.de&gt; wrote:<br />&gt;&gt;<br />&gt;&gt;What ultimately became of the discussion and/or the patch?<br />&gt;&gt;<br />&gt;&gt;Your original ad-hoc patch certainly still does its job; had no need to<br />&gt;&gt;reboot in 86 days and still counting.<br />&gt;<br />&gt; I still observe this behavior on 2.6.36-rc8. This is starting to<br />&gt; get frustrating, so I will be happily following akpm's advise to<br />&gt; poke people.<br />&gt;<br />&gt; Thread entrypoint: <a href="https://lkml.org/lkml/2010/2/12/41">http://lkml.org/lkml/2010/2/12/41</a><br />&gt;<br />&gt; Previously, many concurrent extractions of tarballs and so on have been<br />&gt; one way to trigger the issue; I now also have a rather small testcase<br />&gt; (below) that freezes the box here (which has 24G RAM, so even if I'm<br />&gt; lacking to call msync, I should be fine) sometime after memset finishes.<br />&gt;<br />&gt; ----<br />&gt; /* calculate all possible 32-bit hashes<br />&gt;   needs 16G of address space, so better have a 64-bit kernel at hand<br />&gt;  */<br />&gt; #define _GNU_SOURCE 1<br />&gt; #include &lt;sys/mman.h&gt;<br />&gt; #include &lt;sys/stat.h&gt;<br />&gt; #include &lt;sys/types.h&gt;<br />&gt; #include &lt;errno.h&gt;<br />&gt; #include &lt;fcntl.h&gt;<br />&gt; #include &lt;limits.h&gt;<br />&gt; #include &lt;stdint.h&gt;<br />&gt; #include &lt;stdio.h&gt;<br />&gt; #include &lt;stdlib.h&gt;<br />&gt; #include &lt;string.h&gt;<br />&gt;<br />&gt; #define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))<br />&gt; #define S_IRUGO (S_IRUSR | S_IRGRP | S_IROTH)<br />&gt; #define S_IWUGO (S_IWUSR | S_IWGRP | S_IWOTH)<br />&gt;<br />&gt; #define jrot(x,k) (((x) &lt;&lt; (k)) | ((x) &gt;&gt; (32 - (k))))<br />&gt;<br />&gt; /* jhash_mix - mix 3 32-bit values reversibly. */<br />&gt; #define jhash_mix(a, b, c) { \<br />&gt;        a -= c; a ^= jrot(c,  4); c += b; \<br />&gt;        b -= a; b ^= jrot(a,  6); a += c; \<br />&gt;        c -= b; c ^= jrot(b,  8); b += a; \<br />&gt;        a -= c; a ^= jrot(c, 16); c += b; \<br />&gt;        b -= a; b ^= jrot(a, 19); a += c; \<br />&gt;        c -= b; c ^= jrot(b,  4); b += a; \<br />&gt; }<br />&gt;<br />&gt; #define jhash_final(a, b, c) { \<br />&gt;        c ^= b; c -= jrot(b, 14); \<br />&gt;        a ^= c; a -= jrot(c, 11); \<br />&gt;        b ^= a; b -= jrot(a, 25); \<br />&gt;        c ^= b; c -= jrot(b, 16); \<br />&gt;        a ^= c; a -= jrot(c,  4);  \<br />&gt;        b ^= a; b -= jrot(a, 14); \<br />&gt;        c ^= b; c -= jrot(b, 24); \<br />&gt; }<br />&gt;<br />&gt; static uint32_t hash_jlookup3(const void *vkey, size_t length)<br />&gt; {<br />&gt;        static const unsigned int JHASH_GOLDEN_RATIO = 0x9e3779b9;<br />&gt;        const uint8_t *key = vkey;<br />&gt;        uint32_t a, b, c;<br />&gt;<br />&gt;        a = b = c = JHASH_GOLDEN_RATIO + length;<br />&gt;        /* All but the last block: affect some 32 bits of (a,b,c) */<br />&gt;        for (; length &gt; 12; length -= 12, key += 12) {<br />&gt;                a += key[0] + ((uint32_t)key[1] &lt;&lt; 8) +<br />&gt;                     ((uint32_t)key[2] &lt;&lt; 16) + ((uint32_t)key[3] &lt;&lt; 24);<br />&gt;                b += key[4] + ((uint32_t)key[5] &lt;&lt; 8) +<br />&gt;                     ((uint32_t)key[6] &lt;&lt; 16) + ((uint32_t)key[7] &lt;&lt; 24);<br />&gt;                c += key[8] + ((uint32_t)key[9] &lt;&lt; 8) +<br />&gt;                     ((uint32_t)key[10] &lt;&lt; 16)+ ((uint32_t)key[11] &lt;&lt; 24);<br />&gt;                jhash_mix(a, b, c);<br />&gt;        }<br />&gt;<br />&gt;        switch (length) {<br />&gt;        case 12: c += ((uint32_t)key[11]) &lt;&lt; 24;<br />&gt;        case 11: c += ((uint32_t)key[10]) &lt;&lt; 16;<br />&gt;        case 10: c += ((uint32_t)key[9])  &lt;&lt; 8;<br />&gt;        case  9: c += key[8];<br />&gt;        case  8: b += ((uint32_t)key[7]) &lt;&lt; 24;<br />&gt;        case  7: b += ((uint32_t)key[6]) &lt;&lt; 16;<br />&gt;        case  6: b += ((uint32_t)key[5]) &lt;&lt; 8;<br />&gt;        case  5: b += key[4];<br />&gt;        case  4: a += ((uint32_t)key[3]) &lt;&lt; 24;<br />&gt;        case  3: a += ((uint32_t)key[2]) &lt;&lt; 16;<br />&gt;        case  2: a += ((uint32_t)key[1]) &lt;&lt; 8;<br />&gt;        case  1: a += key[0];<br />&gt;                break;<br />&gt;        case  0: return c;<br />&gt;        }<br />&gt;<br />&gt;        jhash_final(a,b,c);<br />&gt;        return c;<br />&gt; }<br />&gt;<br />&gt; static uint32_t *freq;<br />&gt; static const unsigned long long freq_size = 0x100000000UL * sizeof(*freq);<br />&gt;<br />&gt; static void map_freq(void)<br />&gt; {<br />&gt;        int fd;<br />&gt;<br />&gt;        fd = open("jenkins3.frq", O_RDWR | O_CREAT, S_IRUGO | S_IWUGO);<br />&gt;        if (fd &lt; 0) {<br />&gt;                perror("open");<br />&gt;                abort();<br />&gt;        }<br />&gt;<br />&gt;        if (ftruncate(fd, freq_size) &lt; 0) {<br />&gt;                perror("ftruncate");<br />&gt;                abort();<br />&gt;        }<br />&gt;<br />&gt;        freq = mmap(NULL, freq_size, PROT_READ | PROT_WRITE,<br />&gt;               MAP_SHARED, fd, 0);<br />&gt;        if (freq == NULL) {<br />&gt;                perror("mmap");<br />&gt;                abort();<br />&gt;        }<br />&gt; }<br />&gt;<br />&gt; static inline void calc_all_hashes(void)<br />&gt; {<br />&gt;        uint32_t x, y;<br />&gt;<br />&gt;        memset(freq, 0, freq_size);<br />&gt;        for (x = 0; x &lt; UINT32_MAX; ++x) {<br />&gt;                if ((x &amp; 0xFFFFF) == 0)<br />&gt;                        fprintf(stderr, "\r\e[2K""fill: %08x", x);<br />&gt;                y = hash_jlookup3(&amp;x, sizeof(x));<br />&gt;                if (freq[y] &lt; UINT32_MAX)<br />&gt;                        ++freq[y];<br />&gt;        }<br />&gt; }<br />&gt;<br />&gt; int main(void)<br />&gt; {<br />&gt;        map_freq();<br />&gt;        calc_all_hashes();<br />&gt;        return 0;<br />&gt; }<br />&gt;<br />--<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
