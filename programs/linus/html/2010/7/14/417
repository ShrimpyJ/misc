    </div></td><td width="32"> </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2010/7/14/204">First message in thread</a></li><li><a href="/lkml/2010/7/14/264">Linus Torvalds</a><ul><li><a href="/lkml/2010/7/14/287">Ingo Molnar</a><ul><li><a href="/lkml/2010/7/14/306">Linus Torvalds</a><ul><li><a href="/lkml/2010/7/14/319">Frederic Weisbecker</a><ul><li><a href="/lkml/2010/7/14/324">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2010/7/14/322">Linus Torvalds</a><ul><li><a href="/lkml/2010/7/14/326">Andi Kleen</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2010/7/14/380">Mathieu Desnoyers</a><ul><li class="origin"><a href="/lkml/2010/7/14/424">Linus Torvalds</a><ul><li><a href="/lkml/2010/7/14/424">"Maciej W. Rozycki"</a><ul><li><a href="/lkml/2010/7/14/425">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2010/7/14/445">Mathieu Desnoyers</a><ul><li><a href="/lkml/2010/7/14/456">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 14 Jul 2010 14:23:06 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [patch 1/2] x86_64 page fault NMI-safe</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Jul 14, 2010 at 1:39 PM, Mathieu Desnoyers<br />&lt;mathieu.desnoyers&#64;efficios.com&gt; wrote:<br />&gt;<br />&gt;&gt;  - load percpu NMI stack frame pointer<br />&gt;&gt;  - if non-zero we know we're nested, and should ignore this NMI:<br />&gt;&gt;     - we're returning to kernel mode, so return immediately by using<br />&gt;&gt; "popf/ret", which also keeps NMI's disabled in the hardware until the<br />&gt;&gt; "real" NMI iret happens.<br />&gt;<br />&gt; Maybe incrementing a per-cpu missed NMIs count could be appropriate here so we<br />&gt; know how many NMIs should be replayed at iret ?<br /><br />No. As mentioned, there is no such counter in real hardware either.<br /><br />Look at what happens for the not-nested case:<br /><br /> - NMI1 triggers. The CPU takes a fault, and runs the NMI handler with<br />NMI's disabled<br /><br /> - NMI2 triggers. Nothing happens, the NMI's are disabled.<br /><br /> - NMI3 triggers. Again, nothing happens, the NMI's are still disabled<br /><br /> - the NMI handler returns.<br /><br /> - What happens now?<br /><br />How many NMI interrupts do you get? ONE. Exactly like my "emulate it<br />in software" approach. The hardware doesn't have any counters for<br />pending NMI's either. Why should the software emulation have them?<br /><br />&gt;&gt;     - before the popf/iret, use the NMI stack pointer to make the NMI<br />&gt;&gt; return stack be invalid and cause a fault<br />&gt;<br />&gt; I assume you mean "popf/ret" here.<br /><br />Yes, that was as typo. The whole point of using popf was obviously to<br />_avoid_ the iret ;)<br /><br />&gt; So assuming we use a frame copy, we should<br />&gt; change the nmi stack pointer in the nesting 0 nmi stack copy, so the nesting 0<br />&gt; NMI iret will trigger the fault<br />&gt;<br />&gt;&gt;   - set the NMI stack pointer to the current stack pointer<br />&gt;<br />&gt; That would mean bringing back the NMI stack pointer to the (nesting - 1) nmi<br />&gt; stack copy.<br /><br />I think you're confused. Or I am by your question.<br /><br />The NMI code would literally just do:<br /><br /> - check if the NMI was nested, by looking at whether the percpu<br />nmi-stack-pointer is non-NULL<br /><br /> - if it was nested, do nothing, an return with a popf/ret. The only<br />stack this sequence might needs is to save/restore the register that<br />we use for the percpu value (although maybe we can just co a "cmpl<br />$0,%_percpu_seg:nmi_stack_ptr" and not even need that), and it's<br />atomic because at this point we know that NMI's are disabled (we've<br />not _yet_ taken any nested faults)<br /><br /> - if it's a regular (non-nesting) NMI, we'd basically do<br /><br />     6* pushq 48(%rsp)<br /><br />   to copy the five words that the NMI pushed (ss/esp/eflags/cs/eip)<br />and the one we saved ourselves (if we needed any, maybe we can make do<br />with just 5 words).<br /><br /> - then we just save that new stack pointer to the percpu thing with a simple<br /><br />     movq %rsp,%__percpu_seg:nmi_stack_ptr<br /><br />and we're all done. The final "iret" will do the right thing (either<br />fault or return), and there are no races that I can see exactly<br />because we use a single nmi-atomic instruction (the "iret" itself) to<br />either re-enable NMI's _or_ test whether we should re-do an NMI.<br /><br />There is a single-instruction window that is interestign in the return<br />path, which is the window between the two final instructions:<br /><br />    movl $0,%__percpu_seg:nmi_stack_ptr<br />    iret<br /><br />where I wonder what happens if we have re-enabled NMI (due to a fault<br />in the NMI handler), but we haven't actually taken the NMI itself yet,<br />so now we _will_ re-use the stack. Hmm. I suspect we need another of<br />those horrible "if the NMI happens at this particular %rip" cases that<br />we already have for the sysenter code on x86-32 for the NMI/DEBUG trap<br />case of fixing up the stack pointer.<br /><br />And maybe I missed something else. But it does look reasonably simple.<br />Subtle, but not a lot of code. And the code is all very much about the<br />NMI itself, not about other random sequences. No?<br /><br />                Linus<br />--<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
