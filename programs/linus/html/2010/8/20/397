    </div></td><td width="32"> </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2010/8/20/232">First message in thread</a></li><li><a href="/lkml/2010/8/20/352">Linus Torvalds</a><ul><li><a href="/lkml/2010/8/20/358">Willy Tarreau</a></li><li><a href="/lkml/2010/8/20/360">Peter Zijlstra</a><ul><li class="origin"><a href="/lkml/2010/8/20/396">Linus Torvalds</a><ul><li><a href="/lkml/2010/8/20/396">Linus Torvalds</a></li><li><a href="/lkml/2010/8/23/71">Peter Zijlstra</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2010/8/20/397/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 20 Aug 2010 14:17:38 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [2/3] mm: fix up some user-visible effects of the stack guard page</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Aug 20, 2010 at 1:42 PM, Peter Zijlstra &lt;peterz&#64;infradead.org&gt; wrote:<br />&gt;<br />&gt; You mean something like the below?<br /><br />Yeah. I looked at exactly something like that. With the same name for<br />vma_next() - except I just passed down 'mm' to it too. Your patch<br />takes it from vma-&gt;mm and then you have a few places do the whole<br />__vma_next() by hand.<br /><br />&gt; Should I look at refreshing that thing (yes, that's a 2007 patch)?<br /><br />Interesting. I generated about half the patch, and then decided that<br />it's not worth it. But the fact that apparently you did the same thing<br />in 2007 means that maybe there really _is_ a pent-up demand for doing<br />this dang thing.<br /><br />I do note that I also did a patch that just added "vm_prev", and it's<br />a lot smaller. It doesn't allow for the cleanups of using the generic<br />list iterators, though. And it has the usual problem with the<br />straightforward doubly-linked lists: you end up with those ugly<br />conditional assignments like<br /><br />  if (prev)<br />     prev-&gt;vm_next = vma;<br />  if (next)<br />     next-&gt;vm_prev = vma;<br /><br />which the list_head approach avoids.<br /><br />Appended is that much smaller patch. It has an ugly and partial<br />"validate_vma()" hack there in find_vma() to catch the worst bugs, but<br />it's really not tested. I did try booting it, and it's not spewing out<br />errors, but who the heck knows. It doesn't look too horrid, but...<br /><br />What do you think?<br /><br />NOTE! I've done _zero_ cleanups. And one of the thing I noticed is<br />that "find_vma_prev()" is sometimes used to find a "prev" even when<br />there is no "vma" (ie growing a grow-up stack at the end of the VM, or<br />adding a new mapping at the end), so my hope that we could get rid of<br />it entirely was naïve. But there should be other things we should be<br />able to simplify when we can get at the prev pointer (all the<br />mprotect/mlock splitting code should work fine without having that<br />'prev' thing passed around etc).<br /><br />                            Linus<br /> include/linux/mm_types.h |    2 +-<br /> kernel/fork.c            |    7 +++++--<br /> mm/mmap.c                |   37 +++++++++++++++++++++++++++++++++----<br /> mm/nommu.c               |    7 +++++--<br /> 4 files changed, 44 insertions(+), 9 deletions(-)<br /><br />diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h<br />index b8bb9a6..ee7e258 100644<br />--- a/include/linux/mm_types.h<br />+++ b/include/linux/mm_types.h<br />&#64;&#64; -134,7 +134,7 &#64;&#64; struct vm_area_struct {<br /> 					   within vm_mm. */<br /> <br /> 	/* linked list of VM areas per task, sorted by address */<br />-	struct vm_area_struct *vm_next;<br />+	struct vm_area_struct *vm_next, *vm_prev;<br /> <br /> 	pgprot_t vm_page_prot;		/* Access permissions of this VMA. */<br /> 	unsigned long vm_flags;		/* Flags, see mm.h. */<br />diff --git a/kernel/fork.c b/kernel/fork.c<br />index 856eac3..b7e9d60 100644<br />--- a/kernel/fork.c<br />+++ b/kernel/fork.c<br />&#64;&#64; -300,7 +300,7 &#64;&#64; out:<br /> #ifdef CONFIG_MMU<br /> static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)<br /> {<br />-	struct vm_area_struct *mpnt, *tmp, **pprev;<br />+	struct vm_area_struct *mpnt, *tmp, *prev, **pprev;<br /> 	struct rb_node **rb_link, *rb_parent;<br /> 	int retval;<br /> 	unsigned long charge;<br />&#64;&#64; -328,6 +328,7 &#64;&#64; static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)<br /> 	if (retval)<br /> 		goto out;<br /> <br />+	prev = NULL;<br /> 	for (mpnt = oldmm-&gt;mmap; mpnt; mpnt = mpnt-&gt;vm_next) {<br /> 		struct file *file;<br /> <br />&#64;&#64; -359,7 +360,7 &#64;&#64; static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)<br /> 			goto fail_nomem_anon_vma_fork;<br /> 		tmp-&gt;vm_flags &amp;= ~VM_LOCKED;<br /> 		tmp-&gt;vm_mm = mm;<br />-		tmp-&gt;vm_next = NULL;<br />+		tmp-&gt;vm_next = tmp-&gt;vm_prev = NULL;<br /> 		file = tmp-&gt;vm_file;<br /> 		if (file) {<br /> 			struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;<br />&#64;&#64; -392,6 +393,8 &#64;&#64; static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)<br /> 		 */<br /> 		*pprev = tmp;<br /> 		pprev = &amp;tmp-&gt;vm_next;<br />+		tmp-&gt;vm_prev = prev;<br />+		prev = tmp;<br /> <br /> 		__vma_link_rb(mm, tmp, rb_link, rb_parent);<br /> 		rb_link = &amp;tmp-&gt;vm_rb.rb_right;<br />diff --git a/mm/mmap.c b/mm/mmap.c<br />index 3100333..b6212c2 100644<br />--- a/mm/mmap.c<br />+++ b/mm/mmap.c<br />&#64;&#64; -388,17 +388,23 &#64;&#64; static inline void<br /> __vma_link_list(struct mm_struct *mm, struct vm_area_struct *vma,<br /> 		struct vm_area_struct *prev, struct rb_node *rb_parent)<br /> {<br />+	struct vm_area_struct *next;<br />+<br />+	vma-&gt;vm_prev = prev;<br /> 	if (prev) {<br />-		vma-&gt;vm_next = prev-&gt;vm_next;<br />+		next = prev-&gt;vm_next;<br /> 		prev-&gt;vm_next = vma;<br /> 	} else {<br /> 		mm-&gt;mmap = vma;<br /> 		if (rb_parent)<br />-			vma-&gt;vm_next = rb_entry(rb_parent,<br />+			next = rb_entry(rb_parent,<br /> 					struct vm_area_struct, vm_rb);<br /> 		else<br />-			vma-&gt;vm_next = NULL;<br />+			next = NULL;<br /> 	}<br />+	vma-&gt;vm_next = next;<br />+	if (next)<br />+		next-&gt;vm_prev = vma;<br /> }<br /> <br /> void __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,<br />&#64;&#64; -483,7 +489,11 &#64;&#64; static inline void<br /> __vma_unlink(struct mm_struct *mm, struct vm_area_struct *vma,<br /> 		struct vm_area_struct *prev)<br /> {<br />-	prev-&gt;vm_next = vma-&gt;vm_next;<br />+	struct vm_area_struct *next = vma-&gt;vm_next;<br />+<br />+	prev-&gt;vm_next = next;<br />+	if (next)<br />+		next-&gt;vm_prev = prev;<br /> 	rb_erase(&amp;vma-&gt;vm_rb, &amp;mm-&gt;mm_rb);<br /> 	if (mm-&gt;mmap_cache == vma)<br /> 		mm-&gt;mmap_cache = prev;<br />&#64;&#64; -1577,6 +1587,21 &#64;&#64; get_unmapped_area(struct file *file, unsigned long addr, unsigned long len,<br /> <br /> EXPORT_SYMBOL(get_unmapped_area);<br /> <br />+static void validate_vma_list(struct vm_area_struct *vma)<br />+{<br />+	static int count;<br />+<br />+	if (((vma-&gt;vm_next &amp;&amp; vma-&gt;vm_next-&gt;vm_prev != vma) ||<br />+	     (vma-&gt;vm_prev &amp;&amp; vma-&gt;vm_prev-&gt;vm_next != vma)) &amp;&amp;<br />+	      count &lt; 100) {<br />+		printk("Badness %p[%p] -&gt; %p -&gt; [%p]%p\n",<br />+			vma-&gt;vm_prev, vma-&gt;vm_prev ? vma-&gt;vm_prev-&gt;vm_next : NULL,<br />+			vma,<br />+			vma-&gt;vm_next ? vma-&gt;vm_next-&gt;vm_prev : NULL, vma-&gt;vm_next);<br />+		count++;<br />+	}<br />+}<br />+<br /> /* Look up the first VMA which satisfies  addr &lt; vm_end,  NULL if none. */<br /> struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)<br /> {<br />&#64;&#64; -1610,6 +1635,7 &#64;&#64; struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)<br /> 				mm-&gt;mmap_cache = vma;<br /> 		}<br /> 	}<br />+if (vma) validate_vma_list(vma);<br /> 	return vma;<br /> }<br /> <br />&#64;&#64; -1915,6 +1941,7 &#64;&#64; detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,<br /> 	unsigned long addr;<br /> <br /> 	insertion_point = (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap);<br />+	vma-&gt;vm_prev = NULL;<br /> 	do {<br /> 		rb_erase(&amp;vma-&gt;vm_rb, &amp;mm-&gt;mm_rb);<br /> 		mm-&gt;map_count--;<br />&#64;&#64; -1922,6 +1949,8 &#64;&#64; detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,<br /> 		vma = vma-&gt;vm_next;<br /> 	} while (vma &amp;&amp; vma-&gt;vm_start &lt; end);<br /> 	*insertion_point = vma;<br />+	if (vma)<br />+		vma-&gt;vm_prev = prev;<br /> 	tail_vma-&gt;vm_next = NULL;<br /> 	if (mm-&gt;unmap_area == arch_unmap_area)<br /> 		addr = prev ? prev-&gt;vm_end : mm-&gt;mmap_base;<br />diff --git a/mm/nommu.c b/mm/nommu.c<br />index efa9a38..88ff091 100644<br />--- a/mm/nommu.c<br />+++ b/mm/nommu.c<br />&#64;&#64; -604,7 +604,7 &#64;&#64; static void protect_vma(struct vm_area_struct *vma, unsigned long flags)<br />  */<br /> static void add_vma_to_mm(struct mm_struct *mm, struct vm_area_struct *vma)<br /> {<br />-	struct vm_area_struct *pvma, **pp;<br />+	struct vm_area_struct *pvma, **pp, *next;<br /> 	struct address_space *mapping;<br /> 	struct rb_node **p, *parent;<br /> <br />&#64;&#64; -664,8 +664,11 &#64;&#64; static void add_vma_to_mm(struct mm_struct *mm, struct vm_area_struct *vma)<br /> 			break;<br /> 	}<br /> <br />-	vma-&gt;vm_next = *pp;<br />+	next = *pp;<br /> 	*pp = vma;<br />+	vma-&gt;vm_next = next;<br />+	if (next)<br />+		next-&gt;vm_prev = vma;<br /> }<br /> <br /> /*</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
