    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2015/8/11/800">First message in thread</a></li><li><a href="/lkml/2015/8/11/800">Stas Sergeev</a><ul><li><a href="/lkml/2015/8/11/806">Andy Lutomirski</a><ul><li><a href="/lkml/2015/8/12/140">Stas Sergeev</a><ul><li><a href="/lkml/2015/8/12/696">Andy Lutomirski</a><ul><li><a href="/lkml/2015/8/12/739">Stas Sergeev</a></li></ul></li></ul></li></ul></li><li class="origin"><a href="/lkml/2015/8/13/439">Linus Torvalds</a><ul><li><a href="/lkml/2015/8/13/439">Andy Lutomirski</a><ul><li><a href="/lkml/2015/8/13/453">Linus Torvalds</a><ul><li><a href="/lkml/2015/8/13/458">Andy Lutomirski</a></li></ul></li><li><a href="/lkml/2015/8/13/503">Brian Gerst</a><ul><li><a href="/lkml/2015/8/18/43">Stas Sergeev</a></li></ul></li><li><a href="/lkml/2015/8/14/76">Cyrill Gorcunov</a></li></ul></li><li><a href="/lkml/2015/8/13/547">Stas Sergeev</a><ul><li><a href="/lkml/2015/8/13/595">Linus Torvalds</a><ul><li><a href="/lkml/2015/8/13/599">Andy Lutomirski</a></li><li><a href="/lkml/2015/8/13/608">Stas Sergeev</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patches in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2015/8/13/435/1">Get diff 1</a></li><li><a href="/lkml/diff/2015/8/13/435/2">Get diff 2</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 13 Aug 2015 08:37:37 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [regression] x86/signal/64: Fix SS handling for signals delivered to 64-bit programs breaks dosemu</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Aug 11, 2015 at 5:17 PM, Stas Sergeev &lt;stsp&#64;list.ru&gt; wrote:<br />&gt;<br />&gt; I realize this patch may be good to have in general, but<br />&gt; breaking userspace without a single warning is a bit<br />&gt; discouraging. Seems like the old "we don't break userspace"<br />&gt; rule have gone.<br /><br />That rule hasn't gone anywhere.<br /><br />Does a plain revert just fix everything? Because if so, that's the<br />right thing to do, and we can just re-visit this later.<br /><br />I don't understand why Andy and Ingo are even discussing this. What<br />the f*ck, guys?<br /><br />Stas, can you verify that this actually fixes it? There's two<br />different versions here: one that reverts *just* that one commit, and<br />one that reverts the fs/gs changes too. Can you test them both?<br /><br />                          Linus<br />commit 68b72e2a41ae36de41a404e14388f73b16c4debe<br />Author: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />Date:   Thu Aug 13 08:25:20 2015 -0700<br /><br />    Revert x86 sigcontext cleanups<br /><br />    This reverts commits 9a036b93a344 ("x86/signal/64: Remove 'fs' and 'gs'<br />    from sigcontext") and c6f2062935c8 ("x86/signal/64: Fix SS handling for<br />    signals delivered to 64-bit programs").<br /><br />    They were cleanups, but they don't really matter,a nd they break dosemu<br />    by changing the signal stack layout.<br /><br />    Reported-by: Stas Sergeev &lt;stsp&#64;list.ru&gt;<br />    Cc: Andy Lutomirski &lt;luto&#64;amacapital.net&gt;<br />    Cc: Ingo Molnar &lt;mingo&#64;kernel.org&gt;<br />    Cc: stable&#64;vger.kernel.org<br />    Signed-off-by: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />---<br /> arch/x86/include/asm/sigcontext.h      |  6 +++---<br /> arch/x86/include/uapi/asm/sigcontext.h | 21 +++------------------<br /> arch/x86/kernel/signal.c               | 26 +++++++++++---------------<br /> 3 files changed, 17 insertions(+), 36 deletions(-)<br /><br />diff --git a/arch/x86/include/asm/sigcontext.h b/arch/x86/include/asm/sigcontext.h<br />index 6fe6b182c998..9dfce4e0417d 100644<br />--- a/arch/x86/include/asm/sigcontext.h<br />+++ b/arch/x86/include/asm/sigcontext.h<br />&#64;&#64; -57,9 +57,9 &#64;&#64; struct sigcontext {<br /> 	unsigned long ip;<br /> 	unsigned long flags;<br /> 	unsigned short cs;<br />-	unsigned short __pad2;	/* Was called gs, but was always zero. */<br />-	unsigned short __pad1;	/* Was called fs, but was always zero. */<br />-	unsigned short ss;<br />+	unsigned short gs;<br />+	unsigned short fs;<br />+	unsigned short __pad0;<br /> 	unsigned long err;<br /> 	unsigned long trapno;<br /> 	unsigned long oldmask;<br />diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h<br />index 0e8a973de9ee..40836a9a7250 100644<br />--- a/arch/x86/include/uapi/asm/sigcontext.h<br />+++ b/arch/x86/include/uapi/asm/sigcontext.h<br />&#64;&#64; -177,24 +177,9 &#64;&#64; struct sigcontext {<br /> 	__u64 rip;<br /> 	__u64 eflags;		/* RFLAGS */<br /> 	__u16 cs;<br />-<br />-	/*<br />-	 * Prior to 2.5.64 ("[PATCH] x86-64 updates for 2.5.64-bk3"),<br />-	 * Linux saved and restored fs and gs in these slots.  This<br />-	 * was counterproductive, as fsbase and gsbase were never<br />-	 * saved, so arch_prctl was presumably unreliable.<br />-	 *<br />-	 * If these slots are ever needed for any other purpose, there<br />-	 * is some risk that very old 64-bit binaries could get<br />-	 * confused.  I doubt that many such binaries still work,<br />-	 * though, since the same patch in 2.5.64 also removed the<br />-	 * 64-bit set_thread_area syscall, so it appears that there is<br />-	 * no TLS API that works in both pre- and post-2.5.64 kernels.<br />-	 */<br />-	__u16 __pad2;		/* Was gs. */<br />-	__u16 __pad1;		/* Was fs. */<br />-<br />-	__u16 ss;<br />+	__u16 gs;<br />+	__u16 fs;<br />+	__u16 __pad0;<br /> 	__u64 err;<br /> 	__u64 trapno;<br /> 	__u64 oldmask;<br />diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c<br />index 206996c1669d..71820c42b6ce 100644<br />--- a/arch/x86/kernel/signal.c<br />+++ b/arch/x86/kernel/signal.c<br />&#64;&#64; -93,8 +93,15 &#64;&#64; int restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc)<br /> 		COPY(r15);<br /> #endif /* CONFIG_X86_64 */<br /> <br />+#ifdef CONFIG_X86_32<br /> 		COPY_SEG_CPL3(cs);<br /> 		COPY_SEG_CPL3(ss);<br />+#else /* !CONFIG_X86_32 */<br />+		/* Kernel saves and restores only the CS segment register on signals,<br />+		 * which is the bare minimum needed to allow mixed 32/64-bit code.<br />+		 * App's signal handler can save/restore other segments if needed. */<br />+		COPY_SEG_CPL3(cs);<br />+#endif /* CONFIG_X86_32 */<br /> <br /> 		get_user_ex(tmpflags, &amp;sc-&gt;flags);<br /> 		regs-&gt;flags = (regs-&gt;flags &amp; ~FIX_EFLAGS) | (tmpflags &amp; FIX_EFLAGS);<br />&#64;&#64; -154,9 +161,8 &#64;&#64; int setup_sigcontext(struct sigcontext __user *sc, void __user *fpstate,<br /> #else /* !CONFIG_X86_32 */<br /> 		put_user_ex(regs-&gt;flags, &amp;sc-&gt;flags);<br /> 		put_user_ex(regs-&gt;cs, &amp;sc-&gt;cs);<br />-		put_user_ex(0, &amp;sc-&gt;__pad2);<br />-		put_user_ex(0, &amp;sc-&gt;__pad1);<br />-		put_user_ex(regs-&gt;ss, &amp;sc-&gt;ss);<br />+		put_user_ex(0, &amp;sc-&gt;gs);<br />+		put_user_ex(0, &amp;sc-&gt;fs);<br /> #endif /* CONFIG_X86_32 */<br /> <br /> 		put_user_ex(fpstate, &amp;sc-&gt;fpstate);<br />&#64;&#64; -451,19 +457,9 &#64;&#64; static int __setup_rt_frame(int sig, struct ksignal *ksig,<br /> <br /> 	regs-&gt;sp = (unsigned long)frame;<br /> <br />-	/*<br />-	 * Set up the CS and SS registers to run signal handlers in<br />-	 * 64-bit mode, even if the handler happens to be interrupting<br />-	 * 32-bit or 16-bit code.<br />-	 *<br />-	 * SS is subtle.  In 64-bit mode, we don't need any particular<br />-	 * SS descriptor, but we do need SS to be valid.  It's possible<br />-	 * that the old SS is entirely bogus -- this can happen if the<br />-	 * signal we're trying to deliver is #GP or #SS caused by a bad<br />-	 * SS value.<br />-	 */<br />+	/* Set up the CS register to run signal handlers in 64-bit mode,<br />+	   even if the handler happens to be interrupting 32-bit code. */<br /> 	regs-&gt;cs = __USER_CS;<br />-	regs-&gt;ss = __USER_DS;<br /> <br /> 	return 0;<br /> } arch/x86/include/asm/sigcontext.h      |  2 +-<br /> arch/x86/include/uapi/asm/sigcontext.h |  2 +-<br /> arch/x86/kernel/signal.c               | 22 +++++++++-------------<br /> 3 files changed, 11 insertions(+), 15 deletions(-)<br /><br />diff --git a/arch/x86/include/asm/sigcontext.h b/arch/x86/include/asm/sigcontext.h<br />index 6fe6b182c998..2cefce9b52bd 100644<br />--- a/arch/x86/include/asm/sigcontext.h<br />+++ b/arch/x86/include/asm/sigcontext.h<br />&#64;&#64; -59,7 +59,7 &#64;&#64; struct sigcontext {<br /> 	unsigned short cs;<br /> 	unsigned short __pad2;	/* Was called gs, but was always zero. */<br /> 	unsigned short __pad1;	/* Was called fs, but was always zero. */<br />-	unsigned short ss;<br />+	unsigned short __pad0;<br /> 	unsigned long err;<br /> 	unsigned long trapno;<br /> 	unsigned long oldmask;<br />diff --git a/arch/x86/include/uapi/asm/sigcontext.h b/arch/x86/include/uapi/asm/sigcontext.h<br />index 0e8a973de9ee..b659f3ee464d 100644<br />--- a/arch/x86/include/uapi/asm/sigcontext.h<br />+++ b/arch/x86/include/uapi/asm/sigcontext.h<br />&#64;&#64; -194,7 +194,7 &#64;&#64; struct sigcontext {<br /> 	__u16 __pad2;		/* Was gs. */<br /> 	__u16 __pad1;		/* Was fs. */<br /> <br />-	__u16 ss;<br />+	__u16 __pad0;<br /> 	__u64 err;<br /> 	__u64 trapno;<br /> 	__u64 oldmask;<br />diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c<br />index 206996c1669d..cecc669d397a 100644<br />--- a/arch/x86/kernel/signal.c<br />+++ b/arch/x86/kernel/signal.c<br />&#64;&#64; -93,8 +93,15 &#64;&#64; int restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc)<br /> 		COPY(r15);<br /> #endif /* CONFIG_X86_64 */<br /> <br />+#ifdef CONFIG_X86_32<br /> 		COPY_SEG_CPL3(cs);<br /> 		COPY_SEG_CPL3(ss);<br />+#else /* !CONFIG_X86_32 */<br />+		/* Kernel saves and restores only the CS segment register on signals,<br />+		 * which is the bare minimum needed to allow mixed 32/64-bit code.<br />+		 * App's signal handler can save/restore other segments if needed. */<br />+		COPY_SEG_CPL3(cs);<br />+#endif /* CONFIG_X86_32 */<br /> <br /> 		get_user_ex(tmpflags, &amp;sc-&gt;flags);<br /> 		regs-&gt;flags = (regs-&gt;flags &amp; ~FIX_EFLAGS) | (tmpflags &amp; FIX_EFLAGS);<br />&#64;&#64; -156,7 +163,6 &#64;&#64; int setup_sigcontext(struct sigcontext __user *sc, void __user *fpstate,<br /> 		put_user_ex(regs-&gt;cs, &amp;sc-&gt;cs);<br /> 		put_user_ex(0, &amp;sc-&gt;__pad2);<br /> 		put_user_ex(0, &amp;sc-&gt;__pad1);<br />-		put_user_ex(regs-&gt;ss, &amp;sc-&gt;ss);<br /> #endif /* CONFIG_X86_32 */<br /> <br /> 		put_user_ex(fpstate, &amp;sc-&gt;fpstate);<br />&#64;&#64; -451,19 +457,9 &#64;&#64; static int __setup_rt_frame(int sig, struct ksignal *ksig,<br /> <br /> 	regs-&gt;sp = (unsigned long)frame;<br /> <br />-	/*<br />-	 * Set up the CS and SS registers to run signal handlers in<br />-	 * 64-bit mode, even if the handler happens to be interrupting<br />-	 * 32-bit or 16-bit code.<br />-	 *<br />-	 * SS is subtle.  In 64-bit mode, we don't need any particular<br />-	 * SS descriptor, but we do need SS to be valid.  It's possible<br />-	 * that the old SS is entirely bogus -- this can happen if the<br />-	 * signal we're trying to deliver is #GP or #SS caused by a bad<br />-	 * SS value.<br />-	 */<br />+	/* Set up the CS register to run signal handlers in 64-bit mode,<br />+	   even if the handler happens to be interrupting 32-bit code. */<br /> 	regs-&gt;cs = __USER_CS;<br />-	regs-&gt;ss = __USER_DS;<br /> <br /> 	return 0;<br /> }</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
