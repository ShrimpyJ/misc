    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2015/10/27/451">First message in thread</a></li><li><a href="/lkml/2015/10/27/451">Aaro Koskinen</a><ul><li><a href="/lkml/2015/10/27/459">Andy Shevchenko</a><ul><li><a href="/lkml/2015/10/27/473">Aaro Koskinen</a></li></ul></li><li class="origin"><a href="/lkml/2015/10/27/1056">Linus Torvalds</a><ul><li><a href="/lkml/2015/10/27/1056">Andy Shevchenko</a><ul><li><a href="/lkml/2015/10/27/1057">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 28 Oct 2015 07:16:11 +0900</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: 4.3-rc7: kmemleak BUG: Redzone overwritten</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Oct 28, 2015 at 12:46 AM, Aaro Koskinen &lt;aaro.koskinen&#64;nokia.com&gt; wrote:<br />&gt;<br />&gt; With 4.3-rc7 and slub_debug=FZUP, I get the below when reading<br />&gt; /sys/kernel/debug/kmemleak with a large number of reported entries.<br />&gt; It's pretty repeatable. HW is MIPS64.<br />&gt;<br />&gt; With the SLUB debugging disabled, box crashes randomly in kmem_cache_free<br />&gt; or kmem_cache_alloc when the kmemleak file is read on a running system.<br />&gt;<br />&gt; Seems to start with 6fc37c490076 ("kmemleak: use seq_hex_dump() to<br />&gt; dump buffers").<br /><br />Well, so that commit itself looks fine - it just uses the seq accessor<br />functions to print things out, instead of doing it by hand.<br /><br />So if that commit causes problems, then I suspect that the real issue<br />is that seq_hex_dump() itself is buggered, and that the commit just<br />exposed it by adding new use-cases. It looks like the hexdump wrote<br />one byte (the terminating NUL) past the end of the buffer:<br /><br />&gt; [   77.706871] BUG kmalloc-4096 (Not tainted): Redzone overwritten<br />&gt; [   77.706877]<br />&gt; [   77.706894] INFO: 0x800000002e939000-0x800000002e939000. First byte 0x0 instead of 0xcc<br />&gt; [   77.706914] INFO: Allocated in seq_buf_alloc+0x24/0x58 age=452 cpu=2 pid=587<br />&gt; [   77.706928]  __slab_alloc.isra.72.constprop.75+0x4a4/0x508<br />&gt; [   77.706938]  __kmalloc+0x30c/0x3f0<br />&gt; [   77.706947]  seq_buf_alloc+0x24/0x58<br />&gt; [   77.706956]  seq_read+0x304/0x4a0<br />&gt; [   77.706968]  __vfs_read+0x3c/0x100<br />&gt; [   77.706977]  vfs_read+0x8c/0x138<br />&gt; [   77.706987]  SyS_read+0x64/0xe8<br />&gt; [   77.707000]  syscall_common+0x34/0x58<br />&gt; [   77.707012] INFO: Freed in seq_release+0x24/0x40 age=3450 cpu=3 pid=584<br />&gt; [   77.707023]  __slab_free+0x340/0x4f0<br />&gt; [   77.707032]  seq_release+0x24/0x40<br />&gt; [   77.707044]  kernfs_fop_release+0x50/0x80<br />&gt; [   77.707055]  __fput+0xa4/0x218<br />&gt; [   77.707066]  task_work_run+0xb0/0x108<br />&gt; [   77.707078]  work_notifysig+0x10/0x18<br />&gt; [   77.707087] INFO: Slab 0x8000000003ec4440 objects=7 used=1 fp=0x800000002e93e7b0 flags=0x200000004081<br />&gt; [   77.707095] INFO: Object 0x800000002e938000 &#64;offset=0 fp=0x800000002e939148<br />&gt; [   77.707095]<br />&gt; [   77.707108] Object 800000002e938000: 75 6e 72 65 66 65 72 65 6e 63 65 64 20 6f 62 6a  unreferenced obj<br />&gt; [   77.707118] Object 800000002e938010: 65 63 74 20 30 78 38 30 30 30 30 30 30 30 32 66  ect 0x800000002f<br />...<br />&gt; [   77.709583] Object 800000002e938f90: 6d 6d 20 22 73 77 61 70 70 65 72 2f 30 22 2c 20  mm "swapper/0",<br />&gt; [   77.709593] Object 800000002e938fa0: 70 69 64 20 31 2c 20 6a 69 66 66 69 65 73 20 34  pid 1, jiffies 4<br />&gt; [   77.709603] Object 800000002e938fb0: 32 39 34 39 33 38 30 35 31 20 28 61 67 65 20 34  294938051 (age 4<br />&gt; [   77.709613] Object 800000002e938fc0: 31 2e 35 37 30 73 29 0a 20 20 68 65 78 20 64 75  1.570s).  hex du<br />&gt; [   77.709623] Object 800000002e938fd0: 6d 70 20 28 66 69 72 73 74 20 33 32 20 62 79 74  mp (first 32 byt<br />&gt; [   77.709633] Object 800000002e938fe0: 65 73 29 3a 0a 20 20 20 20 36 62 20 36 62 20 36  es):.    6b 6b 6<br />&gt; [   77.709643] Object 800000002e938ff0: 62 20 36 62 20 36 62 20 36 62 20 36 62 20 00 20  b 6b 6b 6b 6b .<br />&gt; [   77.709653] Redzone 800000002e939000: 00 cc cc cc cc cc cc cc                          ........<br /><br />So I suspect that some seq function ends up adding a terminating NUL<br />character too much when the buffer overflows.<br /><br />The obvious suspect would be the "hex_dump_to_buffer()" call in<br />seq_hex_dump(). It's the only thing that doesn't use really common<br />core helpers, though.<br /><br />Looking at "hex_dump_to_buffer()", code like this strikes me as<br />particularly dangerous:<br /><br />                        if (linebuflen &lt; lx + 3)<br />                                goto overflow2;<br />     ...<br />    overflow2:<br />            linebuf[lx++] = '\0';<br />    overflow1:<br />            return ascii ? ascii_column + len : (groupsize * 2 + 1) *<br />ngroups - 1;<br /><br />because what if lx == linebuflen in the overflow condition.<br /><br />But the non-overflow condition looks a bit scary too: the<br />"non-overflow" case checks that there is room for three characters,<br />and then adds those three characters (and possible removes the last<br />one). Fine - but what if the three characters *exactly* filled the<br />buffer, and we think we haven't overflowed, and now we just do<br /><br />    nil:<br />            linebuf[lx] = '\0';<br />            return lx;<br /><br />there as the "success" case.<br /><br />So without trying to really analyze this, I do suspect that the<br />problem is in either of those cases.<br /><br />I would suggest the "nil:" case do<br /><br />    nil:<br />            if (lx &lt; linebuflen)<br />                    linebuf[lx] = 0;<br />            return lx;<br /><br />and add something similar to overflow2 too.<br /><br />Hmm? Does that fix your test-case? Added Al Viro as seq_file<br />maintainer to the cc.<br /><br />              Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
