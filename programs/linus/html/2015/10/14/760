    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2015/10/13/909">First message in thread</a></li><li><a href="/lkml/2015/10/14/710">Linus Torvalds</a><ul><li><a href="/lkml/2015/10/14/735">Tejun Heo</a><ul><li class="origin"><a href="/lkml/2015/10/14/779">Linus Torvalds</a><ul><li><a href="/lkml/2015/10/14/779">Christoph Lameter</a><ul><li><a href="/lkml/2015/10/14/802">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2015/10/14/819">Tejun Heo</a><ul><li><a href="/lkml/2015/10/14/836">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2015/10/14/781">Christoph Lameter</a><ul><li><a href="/lkml/2015/10/14/804">Linus Torvalds</a><ul><li><a href="/lkml/2015/10/14/817">Christoph Lameter</a><ul><li><a href="/lkml/2015/10/14/828">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 14 Oct 2015 10:36:50 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [GIT PULL] workqueue fixes for v4.3-rc5</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Oct 14, 2015 at 9:57 AM, Tejun Heo &lt;tj&#64;kernel.org&gt; wrote:<br />&gt;<br />&gt; That enum is a bit of misnomer in this case.  It's more like<br />&gt; WORK_CPU_LOCAL.<br /><br />Well, that clearly is the new semantic guarantees you are pushing. I'm<br />not at all convinced it's a good idea, though.<br /><br />&gt; For both delayed and !delayed work items on per-cpu workqueues,<br />&gt; queueing without specifying a specific CPU always meant queueing on<br />&gt; the local CPU.<br /><br />That's just not true, as far as I can tell.<br /><br />I went back in the history to 2012, and it does<br /><br />          if (unlikely(cpu != WORK_CPU_UNBOUND))<br />                  add_timer_on(timer, cpu);<br />          else<br />                  add_timer(timer);<br /><br />so this whole WORK_CPU_UNBOUND means "add_timer()" without specifying<br />a CPU has been true for at least the last several years.<br /><br />So the documentation, the code, and the name all agree:<br />WORK_CPU_UNBOUND does *not* mean that it's guaranteed to be the local<br />CPU. The documentation says "preferred", the code clearly doesn't<br />specify the CPU, and the name says "not bound to a particular CPU".<br /><br /><br />&gt;&gt; So I feel that this is *obviously* a vmstat bug, and that working<br />&gt;&gt; around it by adding ah-hoc crap to the workqueues is completely the<br />&gt;&gt; wrong thing to do. So I'm not going to pull this, because it seems to<br />&gt;&gt; be hiding the real problem rather than really "fixing" anything.<br />&gt;<br />&gt; I wish this were an ad-hoc thing but this has been the guaranteed<br />&gt; behavior all along.  Switching the specific call-site to<br />&gt; queue_work_on() would still be a good idea tho.<br /><br />I really don't see who you say that it has been guaranteed behavior all along.<br /><br />It clearly has not at all been guaranteed behavior. The fact that you<br />had to change the code to do that should have made it clear.<br /><br />The code has *always* done that non-cpu-specific "add_timer()", as far<br />as I can tell. Even back when that non-bound CPU was indicated by a<br />negative CPU number, and the code did<br /><br />                if (unlikely(cpu &gt;= 0))<br />                        add_timer_on(timer, cpu);<br />                else<br />                        add_timer(timer);<br /><br />(that's from 2007, btw).<br /><br />So I really don't see your "guaranteed behavior" argument. It seems to<br />be downright pure bullshit. The lack of a specific CPU has _always_<br />(where "always" means "at least since 2007") meant "non-specific cpu",<br />rather than "local cpu".<br /><br />If some particular interface ended up then actually using "local cpu"<br />instead, that was neither guaranteed nor implied - it was just a<br />random implementation detail, and shouldn't be something we guarantee<br />at all.<br /><br />We strive to maintain user-space ABI issues even in the face of<br />unintentional bugs and misfeatures. But we do *not* keep broken random<br />in-kernel interfaces alive. We fix breakage and clean up code rather<br />than say "some random in-kernel user expects broken behavior".<br /><br />And it seems very clear that WORK_CPU_UNBOUND does *not* mean "local<br />cpu", and code that depends on it meaning local cpu is broken.<br /><br />Now, there are reasons why the *implementation* might want to choose<br />the local cpu for things - avoiding waking up other cpu's<br />unnecessarily with cross-cpu calls etc - but at the same time I think<br />it's quite clear that mm/vmstat.c is simply broken in using a<br />non-bound interface and then expecting/assuming a particular CPU.<br /><br />&gt;&gt; (That said, it's not obvious to me why we don't just specify the cpu<br />&gt;&gt; in the work structure itself, and just get rid of the "use different<br />&gt;&gt; functions to schedule the work" model. I think it's somewhat fragile<br />&gt;&gt; how you can end up using the same work in different "CPU boundedness"<br />&gt;&gt; models like this).<br />&gt;<br />&gt; Hmmm... you mean associating a delayed work item with the target<br />&gt; pool_workqueue on queueing and sharing the queueing paths for both<br />&gt; delayed and !delayed work items?<br /><br />I wouldn't necessarily even go that far. That's more of an<br />implementation detail.<br /><br />I just wonder if we perhaps should add the CPU boundedness to the init<br />stage, and hide it away in the work structure. So if you just want to<br />do work (delayed or not), you'd continue to do<br /><br />        INIT_DELAYED_WORK(&amp;work, ...);<br /><br />        schedule_delayed_work(&amp;work, delay);<br /><br />but if you want a percpu thing, you'd do<br /><br />        INIT_DELAYED_WORK_CPU(&amp;work, cpu, ...);<br /><br />        schedule_delayed_work(&amp;work, delay);<br /><br />rather than have that "..work_on(cpu, &amp;work, )" interface. The actual<br />*implementation* could stay the same, we'd just hide the CPU bound in<br />the work struct and use it as an implicit argument.<br /><br />But it's not a big deal. I'm just saying that the current interface<br />obviously allows that confusion about whether a work is percpu or not,<br />on a per-call-site basis.<br /><br />I don't think it's normally a problem. But mm/vmstat.c clearly *is*<br />confused, and uses both "schedule_delayed_work_on()" and<br />"schedule_delayed_work()" for the same work.<br /><br />                 Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
