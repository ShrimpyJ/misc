    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2015/12/20/120">First message in thread</a></li><li><a href="/lkml/2015/12/20/120">Linus Torvalds</a><ul><li><a href="/lkml/2015/12/20/126">Christoph Hellwig</a><ul><li class="origin"><a href="/lkml/2015/12/20/187">Linus Torvalds</a><ul><li><a href="/lkml/2015/12/20/187">"Artem S. Tashkinov"</a></li><li><a href="/lkml/2015/12/21/145">Dan Aloni</a></li></ul></li><li><a href="/lkml/2015/12/20/143">Kent Overstreet</a><ul><li><a href="/lkml/2015/12/20/188">"Artem S. Tashkinov"</a></li></ul></li><li><a href="/lkml/2015/12/20/185">"Artem S. Tashkinov"</a><ul><li><a href="/lkml/2015/12/20/189">Kent Overstreet</a><ul><li><a href="/lkml/2015/12/20/190">"Artem S. Tashkinov"</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2015/12/20/184">"Artem S. Tashkinov"</a></li><li><a href="/lkml/2015/12/20/205">Ming Lei</a><ul><li><a href="/lkml/2015/12/20/208">"Artem S. Tashkinov"</a><ul><li><a href="/lkml/2015/12/20/214">Ming Lei</a><ul><li><a href="/lkml/2015/12/20/216">"Artem S. Tashkinov"</a></li></ul></li><li><a href="/lkml/2015/12/20/218">Kent Overstreet</a><ul><li><a href="/lkml/2015/12/20/229">Ming Lei</a></li></ul></li><li><a href="/lkml/2015/12/20/234">Linus Torvalds</a><ul><li><a href="/lkml/2015/12/20/237">"Artem S. Tashkinov"</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2015/12/20/233">Tejun Heo</a><ul><li><a href="/lkml/2015/12/21/2">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2015/12/21/18">Tejun Heo</a><ul><li><a href="/lkml/2015/12/21/26">"Artem S. Tashkinov"</a><ul><li><a href="/lkml/2015/12/21/411">Tejun Heo</a><ul><li><a href="/lkml/2015/12/21/423">Tejun Heo</a></li><li><a href="/lkml/2015/12/21/510">Ming Lei</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2015/12/20/142/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 20 Dec 2015 10:41:44 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: IO errors after "block: remove bio_get_nr_vecs()"</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Dec 20, 2015 at 10:18 AM, Christoph Hellwig &lt;hch&#64;lst.de&gt; wrote:<br />&gt;<br />&gt; Artem,<br />&gt;<br />&gt; can you re-check the commits around this series again?  I would be<br />&gt; extremtly surprised if it's really this particular commit and not<br />&gt; one just before it causing the problem - it just allocates bios<br />&gt; to the biggest possible instead of only allocating up to what<br />&gt; bio_add_page would accept.<br /><br />Judging by Artem's bisect log, the last commit he tested before the<br />bad one was the commit before: commit 6cf66b4caf9c ("fs: use helper<br />bio_add_page() instead of open coding on bi_io_vec") and he marked<br />that one good.<br /><br />Sadly, without CONFIG_LOCALVERSION_AUTO, there's no way to match up<br />the dmesg files (in the same bisection tar-file as the bisection log)<br />with the actual versions. Also, Artem's bisect.log isn't actually the<br />.git/BISECT_LOG file that contains the full information about what was<br />marked good and bad, so it's a bit hard to read (ie I can tell that<br />Artem had to mark commit 6cf66b4caf9c as "good" not because his log<br />says so, but because that explains the next commit to be tested).<br /><br />Of course, it's fairly easy to make a mistake while bisecting (just<br />doing a thinko), but usually bisection miistakes end up causing you to<br />go into some "all good" or "all bad" region of commits, and the fact<br />that Artem seems to have marked the previous commit good and the final<br />commit bad does seem to imply the bisection was successful.<br /><br />But yes, it is always nice to double-check the bisection results. The<br />best way to do it is generally to try to revert the bad commit and<br />verify that things work after that, but that commit doesn't revert<br />cleanly on top of 4.3 due to other changes.<br /><br />Attached is a *COMPLETELY*UNTESTED* revertish patch for 4.3. It's<br />basically a revert of b54ffb73cadc, but with a few fixups to make the<br />revert work on top of 4.3.<br /><br />So Artem, if you can test whether 4.3 works with that revert, and/or<br />double-check booting that b54ffb73cadc again (to verify that it's<br />really bad), and its parent (to double-check that it's really good),<br />that would be a good way to verify that yes, it is really that *one*<br />commit that breaks things for you.<br /><br />                Linus<br /> block/bio.c            | 23 +++++++++++++++++++++++<br /> drivers/md/dm-io.c     |  2 +-<br /> fs/btrfs/compression.c |  5 ++++-<br /> fs/btrfs/extent_io.c   |  9 +++++++--<br /> fs/btrfs/inode.c       |  3 ++-<br /> fs/btrfs/scrub.c       | 18 ++++++++++++++++--<br /> fs/direct-io.c         |  2 +-<br /> fs/ext4/page-io.c      |  3 ++-<br /> fs/ext4/readpage.c     |  2 +-<br /> fs/f2fs/data.c         |  2 +-<br /> fs/gfs2/lops.c         |  9 ++++++++-<br /> fs/logfs/dev_bdev.c    |  4 ++--<br /> fs/mpage.c             |  4 ++--<br /> fs/nilfs2/segbuf.c     |  2 +-<br /> fs/xfs/xfs_aops.c      |  3 ++-<br /> include/linux/bio.h    |  1 +<br /> 16 files changed, 74 insertions(+), 18 deletions(-)<br /><br />diff --git a/block/bio.c b/block/bio.c<br />index ad3f276d74bc..d483dbb0162d 100644<br />--- a/block/bio.c<br />+++ b/block/bio.c<br />&#64;&#64; -694,6 +694,29 &#64;&#64; integrity_clone:<br /> EXPORT_SYMBOL(bio_clone_bioset);<br /> <br /> /**<br />+ *	bio_get_nr_vecs		- return approx number of vecs<br />+ *	&#64;bdev:  I/O target<br />+ *<br />+ *	Return the approximate number of pages we can send to this target.<br />+ *	There's no guarantee that you will be able to fit this number of pages<br />+ *	into a bio, it does not account for dynamic restrictions that vary<br />+ *	on offset.<br />+ */<br />+int bio_get_nr_vecs(struct block_device *bdev)<br />+{<br />+	struct request_queue *q = bdev_get_queue(bdev);<br />+	int nr_pages;<br />+<br />+	nr_pages = min_t(unsigned,<br />+		     queue_max_segments(q),<br />+		     queue_max_sectors(q) / (PAGE_SIZE &gt;&gt; 9) + 1);<br />+<br />+	return min_t(unsigned, nr_pages, BIO_MAX_PAGES);<br />+<br />+}<br />+EXPORT_SYMBOL(bio_get_nr_vecs);<br />+<br />+/**<br />  *	bio_add_pc_page	-	attempt to add page to bio<br />  *	&#64;q: the target queue<br />  *	&#64;bio: destination bio<br />diff --git a/drivers/md/dm-io.c b/drivers/md/dm-io.c<br />index 6f8e83b2a6f8..c84714f70378 100644<br />--- a/drivers/md/dm-io.c<br />+++ b/drivers/md/dm-io.c<br />&#64;&#64; -316,7 +316,7 &#64;&#64; static void do_region(int rw, unsigned region, struct dm_io_region *where,<br /> 		if ((rw &amp; REQ_DISCARD) || (rw &amp; REQ_WRITE_SAME))<br /> 			num_bvecs = 1;<br /> 		else<br />-			num_bvecs = min_t(int, BIO_MAX_PAGES,<br />+			num_bvecs = min_t(int, bio_get_nr_vecs(where-&gt;bdev),<br /> 					  dm_sector_div_up(remaining, (PAGE_SIZE &gt;&gt; SECTOR_SHIFT)));<br /> <br /> 		bio = bio_alloc_bioset(GFP_NOIO, num_bvecs, io-&gt;client-&gt;bios);<br />diff --git a/fs/btrfs/compression.c b/fs/btrfs/compression.c<br />index 57ee8ca29b06..302266ec2cdb 100644<br />--- a/fs/btrfs/compression.c<br />+++ b/fs/btrfs/compression.c<br />&#64;&#64; -97,7 +97,10 &#64;&#64; static inline int compressed_bio_size(struct btrfs_root *root,<br /> static struct bio *compressed_bio_alloc(struct block_device *bdev,<br /> 					u64 first_byte, gfp_t gfp_flags)<br /> {<br />-	return btrfs_bio_alloc(bdev, first_byte &gt;&gt; 9, BIO_MAX_PAGES, gfp_flags);<br />+	int nr_vecs;<br />+<br />+	nr_vecs = bio_get_nr_vecs(bdev);<br />+	return btrfs_bio_alloc(bdev, first_byte &gt;&gt; 9, nr_vecs, gfp_flags);<br /> }<br /> <br /> static int check_compressed_csum(struct inode *inode,<br />diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c<br />index 3915c9473e94..f39f819cf7e8 100644<br />--- a/fs/btrfs/extent_io.c<br />+++ b/fs/btrfs/extent_io.c<br />&#64;&#64; -2803,7 +2803,9 &#64;&#64; static int submit_extent_page(int rw, struct extent_io_tree *tree,<br /> {<br /> 	int ret = 0;<br /> 	struct bio *bio;<br />+	int nr;<br /> 	int contig = 0;<br />+	int this_compressed = bio_flags &amp; EXTENT_BIO_COMPRESSED;<br /> 	int old_compressed = prev_bio_flags &amp; EXTENT_BIO_COMPRESSED;<br /> 	size_t page_size = min_t(size_t, size, PAGE_CACHE_SIZE);<br /> <br />&#64;&#64; -2831,9 +2833,12 &#64;&#64; static int submit_extent_page(int rw, struct extent_io_tree *tree,<br /> 			return 0;<br /> 		}<br /> 	}<br />+	if (this_compressed)<br />+		nr = BIO_MAX_PAGES;<br />+	else<br />+		nr = bio_get_nr_vecs(bdev);<br /> <br />-	bio = btrfs_bio_alloc(bdev, sector, BIO_MAX_PAGES,<br />-			GFP_NOFS | __GFP_HIGH);<br />+	bio = btrfs_bio_alloc(bdev, sector, nr, GFP_NOFS | __GFP_HIGH);<br /> 	if (!bio)<br /> 		return -ENOMEM;<br /> <br />diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c<br />index 611b66d73e80..4e1aea2ec8b7 100644<br />--- a/fs/btrfs/inode.c<br />+++ b/fs/btrfs/inode.c<br />&#64;&#64; -7992,8 +7992,9 &#64;&#64; out:<br /> static struct bio *btrfs_dio_bio_alloc(struct block_device *bdev,<br /> 				       u64 first_sector, gfp_t gfp_flags)<br /> {<br />+	int nr_vecs = bio_get_nr_vecs(bdev);<br /> 	struct bio *bio;<br />-	bio = btrfs_bio_alloc(bdev, first_sector, BIO_MAX_PAGES, gfp_flags);<br />+	bio = btrfs_bio_alloc(bdev, first_sector, nr_vecs, gfp_flags);<br /> 	if (bio)<br /> 		bio_associate_current(bio);<br /> 	return bio;<br />diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c<br />index a39f5d1144e8..3b9296e92cc5 100644<br />--- a/fs/btrfs/scrub.c<br />+++ b/fs/btrfs/scrub.c<br />&#64;&#64; -464,14 +464,27 &#64;&#64; struct scrub_ctx *scrub_setup_ctx(struct btrfs_device *dev, int is_dev_replace)<br /> 	struct scrub_ctx *sctx;<br /> 	int		i;<br /> 	struct btrfs_fs_info *fs_info = dev-&gt;dev_root-&gt;fs_info;<br />+	int pages_per_rd_bio;<br /> 	int ret;<br /> <br />+	/*<br />+	 * the setting of pages_per_rd_bio is correct for scrub but might<br />+	 * be wrong for the dev_replace code where we might read from<br />+	 * different devices in the initial huge bios. However, that<br />+	 * code is able to correctly handle the case when adding a page<br />+	 * to a bio fails.<br />+	 */<br />+	if (dev-&gt;bdev)<br />+		pages_per_rd_bio = min_t(int, SCRUB_PAGES_PER_RD_BIO,<br />+					 bio_get_nr_vecs(dev-&gt;bdev));<br />+	else<br />+		pages_per_rd_bio = SCRUB_PAGES_PER_RD_BIO;<br /> 	sctx = kzalloc(sizeof(*sctx), GFP_NOFS);<br /> 	if (!sctx)<br /> 		goto nomem;<br /> 	atomic_set(&amp;sctx-&gt;refs, 1);<br /> 	sctx-&gt;is_dev_replace = is_dev_replace;<br />-	sctx-&gt;pages_per_rd_bio = SCRUB_PAGES_PER_RD_BIO;<br />+	sctx-&gt;pages_per_rd_bio = pages_per_rd_bio;<br /> 	sctx-&gt;curr = -1;<br /> 	sctx-&gt;dev_root = dev-&gt;dev_root;<br /> 	for (i = 0; i &lt; SCRUB_BIOS_PER_SCTX; ++i) {<br />&#64;&#64; -4053,7 +4066,8 &#64;&#64; static int scrub_setup_wr_ctx(struct scrub_ctx *sctx,<br /> 		return 0;<br /> <br /> 	WARN_ON(!dev-&gt;bdev);<br />-	wr_ctx-&gt;pages_per_wr_bio = SCRUB_PAGES_PER_WR_BIO;<br />+	wr_ctx-&gt;pages_per_wr_bio = min_t(int, SCRUB_PAGES_PER_WR_BIO,<br />+					 bio_get_nr_vecs(dev-&gt;bdev));<br /> 	wr_ctx-&gt;tgtdev = dev;<br /> 	atomic_set(&amp;wr_ctx-&gt;flush_all_writes, 0);<br /> 	return 0;<br />diff --git a/fs/direct-io.c b/fs/direct-io.c<br />index 11256291642e..818c647f36d3 100644<br />--- a/fs/direct-io.c<br />+++ b/fs/direct-io.c<br />&#64;&#64; -655,7 +655,7 &#64;&#64; static inline int dio_new_bio(struct dio *dio, struct dio_submit *sdio,<br /> 	if (ret)<br /> 		goto out;<br /> 	sector = start_sector &lt;&lt; (sdio-&gt;blkbits - 9);<br />-	nr_pages = min(sdio-&gt;pages_in_io, BIO_MAX_PAGES);<br />+	nr_pages = min(sdio-&gt;pages_in_io, bio_get_nr_vecs(map_bh-&gt;b_bdev));<br /> 	BUG_ON(nr_pages &lt;= 0);<br /> 	dio_bio_alloc(dio, sdio, map_bh-&gt;b_bdev, sector, nr_pages);<br /> 	sdio-&gt;boundary = 0;<br />diff --git a/fs/ext4/page-io.c b/fs/ext4/page-io.c<br />index 84ba4d2b3a35..5b3fcb8a010f 100644<br />--- a/fs/ext4/page-io.c<br />+++ b/fs/ext4/page-io.c<br />&#64;&#64; -374,9 +374,10 &#64;&#64; void ext4_io_submit_init(struct ext4_io_submit *io,<br /> static int io_submit_init_bio(struct ext4_io_submit *io,<br /> 			      struct buffer_head *bh)<br /> {<br />+	int nvecs = bio_get_nr_vecs(bh-&gt;b_bdev);<br /> 	struct bio *bio;<br /> <br />-	bio = bio_alloc(GFP_NOIO, BIO_MAX_PAGES);<br />+	bio = bio_alloc(GFP_NOIO, min(nvecs, BIO_MAX_PAGES));<br /> 	if (!bio)<br /> 		return -ENOMEM;<br /> 	wbc_init_bio(io-&gt;io_wbc, bio);<br />diff --git a/fs/ext4/readpage.c b/fs/ext4/readpage.c<br />index 560af0437704..a4823d88ae26 100644<br />--- a/fs/ext4/readpage.c<br />+++ b/fs/ext4/readpage.c<br />&#64;&#64; -284,7 +284,7 &#64;&#64; int ext4_mpage_readpages(struct address_space *mapping,<br /> 					goto set_error_page;<br /> 			}<br /> 			bio = bio_alloc(GFP_KERNEL,<br />-				min_t(int, nr_pages, BIO_MAX_PAGES));<br />+				min_t(int, nr_pages, bio_get_nr_vecs(bdev)));<br /> 			if (!bio) {<br /> 				if (ctx)<br /> 					ext4_release_crypto_ctx(ctx);<br />diff --git a/fs/f2fs/data.c b/fs/f2fs/data.c<br />index a82abe921b89..432496daacae 100644<br />--- a/fs/f2fs/data.c<br />+++ b/fs/f2fs/data.c<br />&#64;&#64; -954,7 +954,7 &#64;&#64; submit_and_realloc:<br /> 			}<br /> <br /> 			bio = bio_alloc(GFP_KERNEL,<br />-				min_t(int, nr_pages, BIO_MAX_PAGES));<br />+				min_t(int, nr_pages, bio_get_nr_vecs(bdev)));<br /> 			if (!bio) {<br /> 				if (ctx)<br /> 					f2fs_release_crypto_ctx(ctx);<br />diff --git a/fs/gfs2/lops.c b/fs/gfs2/lops.c<br />index d5369a109781..4052116959fb 100644<br />--- a/fs/gfs2/lops.c<br />+++ b/fs/gfs2/lops.c<br />&#64;&#64; -261,11 +261,18 &#64;&#64; void gfs2_log_flush_bio(struct gfs2_sbd *sdp, int rw)<br /> static struct bio *gfs2_log_alloc_bio(struct gfs2_sbd *sdp, u64 blkno)<br /> {<br /> 	struct super_block *sb = sdp-&gt;sd_vfs;<br />+	unsigned nrvecs = bio_get_nr_vecs(sb-&gt;s_bdev);<br /> 	struct bio *bio;<br /> <br /> 	BUG_ON(sdp-&gt;sd_log_bio);<br /> <br />-	bio = bio_alloc(GFP_NOIO, BIO_MAX_PAGES);<br />+	while (1) {<br />+		bio = bio_alloc(GFP_NOIO, nrvecs);<br />+		if (likely(bio))<br />+			break;<br />+		nrvecs = max(nrvecs/2, 1U);<br />+	}<br />+<br /> 	bio-&gt;bi_iter.bi_sector = blkno * (sb-&gt;s_blocksize &gt;&gt; 9);<br /> 	bio-&gt;bi_bdev = sb-&gt;s_bdev;<br /> 	bio-&gt;bi_end_io = gfs2_end_log_write;<br />diff --git a/fs/logfs/dev_bdev.c b/fs/logfs/dev_bdev.c<br />index a7fdbd868474..cea0cc9878b7 100644<br />--- a/fs/logfs/dev_bdev.c<br />+++ b/fs/logfs/dev_bdev.c<br />&#64;&#64; -81,7 +81,7 &#64;&#64; static int __bdev_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,<br /> 	unsigned int max_pages;<br /> 	int i;<br /> <br />-	max_pages = min(nr_pages, BIO_MAX_PAGES);<br />+	max_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super-&gt;s_bdev));<br /> <br /> 	bio = bio_alloc(GFP_NOFS, max_pages);<br /> 	BUG_ON(!bio);<br />&#64;&#64; -171,7 +171,7 &#64;&#64; static int do_erase(struct super_block *sb, u64 ofs, pgoff_t index,<br /> 	unsigned int max_pages;<br /> 	int i;<br /> <br />-	max_pages = min(nr_pages, BIO_MAX_PAGES);<br />+	max_pages = min(nr_pages, (size_t) bio_get_nr_vecs(super-&gt;s_bdev));<br /> <br /> 	bio = bio_alloc(GFP_NOFS, max_pages);<br /> 	BUG_ON(!bio);<br />diff --git a/fs/mpage.c b/fs/mpage.c<br />index a7c34274f207..7b0b90e23cbe 100644<br />--- a/fs/mpage.c<br />+++ b/fs/mpage.c<br />&#64;&#64; -278,7 +278,7 &#64;&#64; alloc_new:<br /> 				goto out;<br /> 		}<br /> 		bio = mpage_alloc(bdev, blocks[0] &lt;&lt; (blkbits - 9),<br />-				min_t(int, nr_pages, BIO_MAX_PAGES), gfp);<br />+				min_t(int, nr_pages, bio_get_nr_vecs(bdev)), gfp);<br /> 		if (bio == NULL)<br /> 			goto confused;<br /> 	}<br />&#64;&#64; -605,7 +605,7 &#64;&#64; alloc_new:<br /> 			}<br /> 		}<br /> 		bio = mpage_alloc(bdev, blocks[0] &lt;&lt; (blkbits - 9),<br />-				BIO_MAX_PAGES, GFP_NOFS|__GFP_HIGH);<br />+				bio_get_nr_vecs(bdev), GFP_NOFS|__GFP_HIGH);<br /> 		if (bio == NULL)<br /> 			goto confused;<br /> <br />diff --git a/fs/nilfs2/segbuf.c b/fs/nilfs2/segbuf.c<br />index f63620ce3892..550b10efb14e 100644<br />--- a/fs/nilfs2/segbuf.c<br />+++ b/fs/nilfs2/segbuf.c<br />&#64;&#64; -414,7 +414,7 &#64;&#64; static void nilfs_segbuf_prepare_write(struct nilfs_segment_buffer *segbuf,<br /> {<br /> 	wi-&gt;bio = NULL;<br /> 	wi-&gt;rest_blocks = segbuf-&gt;sb_sum.nblocks;<br />-	wi-&gt;max_pages = BIO_MAX_PAGES;<br />+	wi-&gt;max_pages = bio_get_nr_vecs(wi-&gt;nilfs-&gt;ns_bdev);<br /> 	wi-&gt;nr_vecs = min(wi-&gt;max_pages, wi-&gt;rest_blocks);<br /> 	wi-&gt;start = wi-&gt;end = 0;<br /> 	wi-&gt;blocknr = segbuf-&gt;sb_pseg_start;<br />diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c<br />index 50ab2879b9da..760dd2a5bf05 100644<br />--- a/fs/xfs/xfs_aops.c<br />+++ b/fs/xfs/xfs_aops.c<br />&#64;&#64; -380,7 +380,8 &#64;&#64; STATIC struct bio *<br /> xfs_alloc_ioend_bio(<br /> 	struct buffer_head	*bh)<br /> {<br />-	struct bio		*bio = bio_alloc(GFP_NOIO, BIO_MAX_PAGES);<br />+	int			nvecs = bio_get_nr_vecs(bh-&gt;b_bdev);<br />+	struct bio		*bio = bio_alloc(GFP_NOIO, nvecs);<br /> <br /> 	ASSERT(bio-&gt;bi_private == NULL);<br /> 	bio-&gt;bi_iter.bi_sector = bh-&gt;b_blocknr * (bh-&gt;b_size &gt;&gt; 9);<br />diff --git a/include/linux/bio.h b/include/linux/bio.h<br />index b9b6e046b52e..f2198d5b8be1 100644<br />--- a/include/linux/bio.h<br />+++ b/include/linux/bio.h<br />&#64;&#64; -451,6 +451,7 &#64;&#64; void bio_chain(struct bio *, struct bio *);<br /> extern int bio_add_page(struct bio *, struct page *, unsigned int,unsigned int);<br /> extern int bio_add_pc_page(struct request_queue *, struct bio *, struct page *,<br /> 			   unsigned int, unsigned int);<br />+extern int bio_get_nr_vecs(struct block_device *);<br /> struct rq_map_data;<br /> extern struct bio *bio_map_user_iov(struct request_queue *,<br /> 				    const struct iov_iter *, gfp_t);</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
