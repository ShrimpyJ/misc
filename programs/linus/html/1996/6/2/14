    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/5/31/34">First message in thread</a></li><li><a href="/lkml/1996/6/1/17">Tom May</a><ul><li><a href="/lkml/1996/6/1/30">"Jon M. Taylor"</a><ul><li class="origin"><a href="/lkml/1996/6/2/15">Linus Torvalds</a><ul><li><a href="/lkml/1996/6/2/15">Ingo Molnar</a><ul><li><a href="/lkml/1996/6/2/16">Linus Torvalds</a></li><li><a href="/lkml/1996/6/2/23">Marcus Meissner</a></li></ul></li><li><a href="/lkml/1996/6/2/58">"Jon M. Taylor"</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 2 Jun 1996 14:30:02 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: SVGA kernel chipset drivers.</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sat, 1 Jun 1996, Jon M. Taylor wrote:<br />&gt; &gt; <br />&gt; &gt; &gt;The ONLY solution is X, and anything else is just noise. They should be <br />&gt; &gt; &gt;supported, but not at the cost of extra complexity in the kernel. <br />&gt; &gt; <br />&gt; &gt; Truly.  I have worked on projects where 70% of the coding and<br />&gt; &gt; debugging and testing effort required to support a board under certain<br />&gt; &gt; OSs was wasted on the goddamn text-graphics-hotkey-dos-compatibilty-lcd-<br />&gt; &gt; panel-virtual-device-etc bullshit!  Go into graphics and stay there or<br />&gt; &gt; don't go in at all.  <br />&gt; <br />&gt; 	Jesus, this isn't THAT big of a hassle!  You are exaggerating.<br /><br />Umm.. Look at the state of DOS and Windows 5 years ago..<br /><br />Not having a windowing system is simply unacceptable. Doing graphics in a <br />program "by hand" is like using a PC/XT - it's technology that is going <br />away. People may still use it, but I'm not going to put code into the <br />kernel that I feel has no future..<br /><br />&gt; 	Look there are things wrong now, and kernel video would be a <br />&gt; AWFULLY convenient way to deal with a lot of them in one fell swoop.  <br />&gt; Sure, it isn't going to be a walk in the park, but it'll be worth it and <br />&gt; it IS doable.<br /><br />Sure. It's convenient to just say "do it in the kernel".<br /><br />In short, it's convenient to try to shuffle onto somebody else. That <br />somebody else happens to be ME, which is why I don't think it's in the <br />least convenient, I just think it's a horribly braindead idea.<br /><br />Somebody said that "we have to have the complexity anyway", and he's damned<br />right. However, if he thinks moving the complexity into the kernel is the<br />answer, he's wrong. With X, the complexity is exactly where it should be: in<br />user space, in _one_ trusted binary, and all the graphical programs don't<br />need to be very clever or trusted. <br /><br />&gt; &gt; All the<br />&gt; &gt; high-end cards that I have worked on have frame buffers.  Why?<br /><br />Sure, most of them do have frame buffers, that's not the issue. However, <br />some of them don't, sometimes because they have special hardware like <br />Z-buffering that they don't want to expose to the programmer or stuff <br />like that.<br /><br />&gt; 	At the very least, it is common enough that it isn't worth <br />&gt; worrying about overmuch.<br /><br />Umm.. It may not be worth worrying about on a user level, but it's damn <br />well worth worrying about in the kernel. I'm not going to write a kernel <br />that doesn't work with a certain set of cards or that conceptually <br />cripples them.<br /><br />Don't people understand about the kernel?<br /><br />The kernel is NOT there to make it easy for people. The kernel is <br />supposed to be a MINIMAL resource management thing, and when it comes to <br />graphics it really doesn't belong in the kernel.<br /><br />Other UNIX'es _do_ support framebuffers, but they are often limited to a <br />very specific set of hardware platforms, both when it comes to the actual <br />bus/CPU and when it comes to the graphics device. <br /><br />&gt; &gt; Anybody using a card that is I/O mapped should not complain about the<br />&gt; &gt; performance -- they are using intrinsically suboptimal hardware and<br />&gt; &gt; there is no reason to make hacks for it when they could be using good<br />&gt; &gt; hardware and leave programmers to work on projects which advance the<br />&gt; &gt; state of the art instead of holding it back.<br />&gt; <br />&gt; 	On the other hand, one of the strong points of Linux is that is <br />&gt; supports even old, slow, brain-damaged hardware and pushes it as far as <br />&gt; it can go.<br /><br />Sure. But that support is not necessarily in the kernel. In fact, the <br />fact that the kernel is small and streamlined means we can more easily <br />use Linux on the small and old machines, and people who don't need <br />graphics don't take the performance hit of having lots of graphics <br />complexity in the kernel.<br /><br />In short, the solutions for the slow and brain-damaged hardware without <br />enough memory to run X decently etc is STILL in user-level.<br /><br />&gt; &gt; &gt;Trust me, we're not talking VGA here. We're talking _high_ end graphics, <br />&gt; &gt; &gt;that don't have frame-buffers because that interferes with the normal <br />&gt; &gt; &gt;mode of operations (painting the screen) for no real good reason (the <br />&gt; &gt; &gt;actual drawing is then done using screen commands and/or DMA to the card <br />&gt; &gt; &gt;to fill a area with data).<br />&gt; &gt; <br />&gt; &gt; Are you thinking of the XGA?  That's the only card I can think of that<br />&gt; &gt; uses DMA.<br /><br />Get your mind out of the gutter of PC hardware.. It seems some of the SGI<br />graphics card use DMA exclusively, for example. And I wouldn't call the SGI<br />graphics hardware exactly broken.. <br /><br />I've heard others talk about the new generation 3D-accelerated PC cards <br />too, so it exists even on the PC side. <br /><br />&gt; 	Better that than have that hardware be completely unusable, no?<br /><br />This whole question is _NOT_ about being completely unusable or not. Even<br />without kernel support, you can create usable graphics drivers, and in fact<br />it's usually a hell of a lot easier to debug and program them that way. It's<br />often also noticeably faster, because you don't need to trap into the kernel<br />when you need to do something that needs support from some broken kernel<br />graphics driver. <br /><br />If people are complaining about SVGA programs that lock up and crash and <br />leave the graphics screen in a strange state, they should really start <br />looking at the program itself. For example, people have claimed that a <br />SVGA program needs to be set-uid with all the security problems that <br />entails. This simply IS NOT TRUE!<br /><br />For example, you can obviously write non-setuid programs that write <br />graphics: just look at X. Yes, the X server needs to be setuid, but <br />people generally trust X - it's been well written to gracefully handle <br />most problems.<br /><br />The same way you can create SVGAlib type programs that can much more <br />gracefully handle programming errors. Just as an example of this, you <br />could do this all safely in user mode with something like this:<br /><br />   svgaserver.c (set-uid skeleton program):<br /><br />	int main(..)<br />	{<br />		int pid;<br />		.. move to graphics mode ..<br />		.. map the "frame buffer" by mmapping /dev/mem ..<br />		pid = fork();<br />		if (pid == 0) {<br />			void * program;<br />			/* child process - get rid of all root privileges */<br />			setuid(getuid());<br />			.. get rid of whatever other special privs ..<br />			.. we picked up for graphics and we don't need ..<br /><br />			/* run the supplied dynamic "library" */<br />			program = dl_open(argv[1]);<br />			if (!program)<br />				exit(1);<br />			exit (dlsym(program,"run"))();<br />		}<br />		wait(NULL);<br />		.. return to text-mode, unmap frame buffers ..<br />		return 0;<br />	}<br /><br />See? This is NOT A KERNEL ISSUE!<br /><br />If you do it like the above, you can just have a "svgaserver" program <br />that is _safely_ able to run any user-supplied binary at all, without <br />giving that dynamically loaded binary any super-user privileges. More <br />importantly, you can make the "svgaserver" program handle virtual console <br />switching etc - you just do a simple protocol for that (for example, the <br />parent gets notified when the child gets stopped, so the svgaserver could <br />automatically move into text-mode when that occurs, so you can _force_ <br />this from the outside by just sending the child a SIGSTOP signal or <br />something. <br /><br />The above is a lot more generic than any kernel approach, and gives you <br />everything the kernel could ever give you.. And yes, you end up with a <br />setuid binary, but that's the whole idea with setuid: you can create <br />server binaries that can do error checking and that are trusted, and with <br />the above kind of setup the svgaserver binary really doesn't need to be <br />very large at all.<br /><br />Putting graphics into the kernel is WRONG, and people who keep suggesting <br />that just haven't thought about all the issues.<br /><br />If there are people out there who think they can do graphics programming <br />in the kernel, they should be competent enough to do the above kind of <br />"svgaserver" binary too.<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
