    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/6/5/83">First message in thread</a></li><li><a href="/lkml/1996/6/5/83">Ingo Molnar</a><ul><li class="origin"><a href="/lkml/1996/6/6/28">Linus Torvalds</a><ul><li><a href="/lkml/1996/6/6/28">Ingo Molnar</a></li><li><a href="/lkml/1996/6/6/35">Alan Cox</a></li><li><a href="/lkml/1996/6/6/69">Martin Mares</a></li><li><a href="/lkml/1996/6/6/71">Michael Meskes</a></li><li><a href="/lkml/1996/6/7/30">Michael Meskes</a><ul><li><a href="/lkml/1996/6/7/43">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/1996/6/6/24/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 6 Jun 1996 09:40:16 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: the mmap() problem, a'la "grep x /dev/zero"</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 5 Jun 1996, Ingo Molnar wrote:<br />&gt; <br />&gt; is there anything one could do tracing down this problem? <br /><br />I suspect it's just the fact that Linux doesn't check for memory availability<br />when doing memory mappings. It _does_ check when increasing the bss, so it<br />was just a matter of doing that check in both places (the check should <br />probably be improved too).<br /><br />I'm including totally untested patches - I haven't even rebooted (or <br />compiled) this kernel yet, but the more testers, the merrier. The worst <br />that can happen is that nothing works, it eats your harddisk, and the <br />machine goes up in smoke.,.<br /><br />(most of this patch is actually just moving "sys_brk()" to where it <br />belongs)<br /><br />Please do tell if this makes a difference for you.. <br /><br />		Linus<br /><br />-----<br />diff -u --recursive --new-file pre2.0.12/linux/kernel/sys.c linux/kernel/sys.c<br />--- pre2.0.12/linux/kernel/sys.c	Mon May 13 23:02:50 1996<br />+++ linux/kernel/sys.c	Thu Jun  6 09:28:51 1996<br />&#64;&#64; -18,8 +18,6 &#64;&#64;<br /> #include &lt;linux/stat.h&gt;<br /> #include &lt;linux/mman.h&gt;<br /> #include &lt;linux/mm.h&gt;<br />-#include &lt;linux/pagemap.h&gt;<br />-#include &lt;linux/swap.h&gt;<br /> #include &lt;linux/fcntl.h&gt;<br /> #include &lt;linux/acct.h&gt;<br /> #include &lt;linux/tty.h&gt;<br />&#64;&#64; -548,70 +546,6 &#64;&#64;<br /> 		put_user(current-&gt;cstime,&amp;tbuf-&gt;tms_cstime);<br /> 	}<br /> 	return jiffies;<br />-}<br />-<br />-asmlinkage unsigned long sys_brk(unsigned long brk)<br />-{<br />-	int freepages;<br />-	unsigned long rlim;<br />-	unsigned long newbrk, oldbrk;<br />-<br />-	if (brk &lt; current-&gt;mm-&gt;end_code)<br />-		return current-&gt;mm-&gt;brk;<br />-	newbrk = PAGE_ALIGN(brk);<br />-	oldbrk = PAGE_ALIGN(current-&gt;mm-&gt;brk);<br />-	if (oldbrk == newbrk)<br />-		return current-&gt;mm-&gt;brk = brk;<br />-<br />-	/*<br />-	 * Always allow shrinking brk<br />-	 */<br />-	if (brk &lt;= current-&gt;mm-&gt;brk) {<br />-		current-&gt;mm-&gt;brk = brk;<br />-		do_munmap(newbrk, oldbrk-newbrk);<br />-		return brk;<br />-	}<br />-	/*<br />-	 * Check against rlimit and stack..<br />-	 */<br />-	rlim = current-&gt;rlim[RLIMIT_DATA].rlim_cur;<br />-	if (rlim &gt;= RLIM_INFINITY)<br />-		rlim = ~0;<br />-	if (brk - current-&gt;mm-&gt;end_code &gt; rlim)<br />-		return current-&gt;mm-&gt;brk;<br />-	/*<br />-	 * Check against existing mmap mappings.<br />-	 */<br />-	if (find_vma_intersection(current, oldbrk, newbrk+PAGE_SIZE))<br />-		return current-&gt;mm-&gt;brk;<br />-	/*<br />-	 * stupid algorithm to decide if we have enough memory: while<br />-	 * simple, it hopefully works in most obvious cases.. Easy to<br />-	 * fool it, but this should catch most mistakes.<br />-	 */<br />-	freepages = buffermem &gt;&gt; PAGE_SHIFT;<br />-	freepages += page_cache_size;<br />-	freepages &gt;&gt;= 1;<br />-	freepages += nr_free_pages;<br />-	freepages += nr_swap_pages;<br />-	freepages -= MAP_NR(high_memory) &gt;&gt; 4;<br />-	freepages -= (newbrk-oldbrk) &gt;&gt; PAGE_SHIFT;<br />-	if (freepages &lt; 0)<br />-		return current-&gt;mm-&gt;brk;<br />-#if 0<br />-	freepages += current-&gt;mm-&gt;rss;<br />-	freepages -= oldbrk &gt;&gt; 12;<br />-	if (freepages &lt; 0)<br />-		return current-&gt;mm-&gt;brk;<br />-#endif<br />-	/*<br />-	 * Ok, we have probably got enough memory - let it rip.<br />-	 */<br />-	current-&gt;mm-&gt;brk = brk;<br />-	do_mmap(NULL, oldbrk, newbrk-oldbrk,<br />-		PROT_READ|PROT_WRITE|PROT_EXEC,<br />-		MAP_FIXED|MAP_PRIVATE, 0);<br />-	return brk;<br /> }<br /> <br /> /*<br />diff -u --recursive --new-file pre2.0.12/linux/mm/mmap.c linux/mm/mmap.c<br />--- pre2.0.12/linux/mm/mmap.c	Wed Jun  5 10:41:29 1996<br />+++ linux/mm/mmap.c	Thu Jun  6 09:29:59 1996<br />&#64;&#64; -12,6 +12,8 &#64;&#64;<br /> #include &lt;linux/mman.h&gt;<br /> #include &lt;linux/string.h&gt;<br /> #include &lt;linux/malloc.h&gt;<br />+#include &lt;linux/pagemap.h&gt;<br />+#include &lt;linux/swap.h&gt;<br /> <br /> #include &lt;asm/segment.h&gt;<br /> #include &lt;asm/system.h&gt;<br />&#64;&#64; -40,6 +42,78 &#64;&#64;<br /> };<br /> <br /> /*<br />+ * Check that a process has enough memory to allocate a<br />+ * new virtual mapping.<br />+ */<br />+static inline int vm_enough_memory(long pages)<br />+{<br />+	/*<br />+	 * stupid algorithm to decide if we have enough memory: while<br />+	 * simple, it hopefully works in most obvious cases.. Easy to<br />+	 * fool it, but this should catch most mistakes.<br />+	 */<br />+	long freepages;<br />+	freepages = buffermem &gt;&gt; PAGE_SHIFT;<br />+	freepages += page_cache_size;<br />+	freepages &gt;&gt;= 1;<br />+	freepages += nr_free_pages;<br />+	freepages += nr_swap_pages;<br />+	freepages -= MAP_NR(high_memory) &gt;&gt; 4;<br />+	return freepages &gt; pages;<br />+}<br />+<br />+asmlinkage unsigned long sys_brk(unsigned long brk)<br />+{<br />+	unsigned long rlim;<br />+	unsigned long newbrk, oldbrk;<br />+<br />+	if (brk &lt; current-&gt;mm-&gt;end_code)<br />+		return current-&gt;mm-&gt;brk;<br />+	newbrk = PAGE_ALIGN(brk);<br />+	oldbrk = PAGE_ALIGN(current-&gt;mm-&gt;brk);<br />+	if (oldbrk == newbrk)<br />+		return current-&gt;mm-&gt;brk = brk;<br />+<br />+	/*<br />+	 * Always allow shrinking brk<br />+	 */<br />+	if (brk &lt;= current-&gt;mm-&gt;brk) {<br />+		current-&gt;mm-&gt;brk = brk;<br />+		do_munmap(newbrk, oldbrk-newbrk);<br />+		return brk;<br />+	}<br />+	/*<br />+	 * Check against rlimit and stack..<br />+	 */<br />+	rlim = current-&gt;rlim[RLIMIT_DATA].rlim_cur;<br />+	if (rlim &gt;= RLIM_INFINITY)<br />+		rlim = ~0;<br />+	if (brk - current-&gt;mm-&gt;end_code &gt; rlim)<br />+		return current-&gt;mm-&gt;brk;<br />+<br />+	/*<br />+	 * Check against existing mmap mappings.<br />+	 */<br />+	if (find_vma_intersection(current, oldbrk, newbrk+PAGE_SIZE))<br />+		return current-&gt;mm-&gt;brk;<br />+<br />+	/*<br />+	 * Check if we have enough memory..<br />+	 */<br />+	if (!vm_enough_memory((newbrk-oldbrk) &gt;&gt; PAGE_SHIFT))<br />+		return current-&gt;mm-&gt;brk;<br />+<br />+	/*<br />+	 * Ok, looks good - let it rip.<br />+	 */<br />+	current-&gt;mm-&gt;brk = brk;<br />+	do_mmap(NULL, oldbrk, newbrk-oldbrk,<br />+		PROT_READ|PROT_WRITE|PROT_EXEC,<br />+		MAP_FIXED|MAP_PRIVATE, 0);<br />+	return brk;<br />+}<br />+<br />+/*<br />  * Combine the mmap "prot" and "flags" argument into one "vm_flags" used<br />  * internally. Essentially, translate the "PROT_xxx" and "MAP_xxx" bits<br />  * into "VM_xxx".<br />&#64;&#64; -178,6 +252,14 &#64;&#64;<br /> 	vma-&gt;vm_pte = 0;<br /> <br /> 	do_munmap(addr, len);	/* Clear old maps */<br />+<br />+	/* Private writable mapping? Check memory availability.. */<br />+	if ((vma-&gt;vm_flags &amp; (VM_SHARED | VM_WRITE)) == VM_WRITE) {<br />+		if (!vm_enough_memory(len &gt;&gt; PAGE_SHIFT)) {<br />+			kfree(vma);<br />+			return -ENOMEM;<br />+		}<br />+	}<br /> <br /> 	if (file) {<br /> 		int error = file-&gt;f_op-&gt;mmap(file-&gt;f_inode, file, vma);<br />diff -u --recursive --new-file pre2.0.12/linux/mm/vmscan.c linux/mm/vmscan.c<br />--- pre2.0.12/linux/mm/vmscan.c	Fri Apr 12 15:52:10 1996<br />+++ linux/mm/vmscan.c	Wed Jun  5 14:36:35 1996<br />&#64;&#64; -334,7 +334,12 &#64;&#64;<br /> {<br /> 	static int state = 0;<br /> 	int i=6;<br />+	int stop;<br /> <br />+	/* we don't try as hard if we're not waiting.. */<br />+	stop = 3;<br />+	if (wait)<br />+		stop = 0;<br /> 	switch (state) {<br /> 		do {<br /> 		case 0:<br />&#64;&#64; -349,7 +354,8 &#64;&#64;<br /> 			if (swap_out(i, dma, wait))<br /> 				return 1;<br /> 			state = 0;<br />-		} while (i--);<br />+		i--;<br />+		} while ((i - stop) &gt;= 0);<br /> 	}<br /> 	return 0;<br /> }<br />------<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
