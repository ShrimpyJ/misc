    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/8/7/20">First message in thread</a></li><li class="origin"><a href="/lkml/1996/8/7/44">Linus Torvalds</a><ul><li><a href="/lkml/1996/8/7/44">(Al Longyear)</a><ul><li><a href="/lkml/1996/8/8/6">Linus Torvalds</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 7 Aug 1996 08:10:35 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: proc fs and shared pids</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 6 Aug 1996, Al Longyear wrote:<br />&gt; <br />&gt; Microsoft (yea, yea, I know some people's opinion of commerical<br />&gt; companies, but that is not really the issue that I am trying to make)<br />&gt; did not support threads in their POSIX implementation of Windows NT<br />&gt; for several reasons.<br />&gt; <br />&gt; The reaons are well known, but perhaps the most well known is "What does it<br />&gt; mean if a thread does a call to fork()?"<br /><br />These kinds of issues are _exactly_ why clone() is such a good idea. With <br />clone() there is never any ambiguity when it comes to fork/exec/exit, <br />something that is not true of traditional threads. And the clone() <br />semantics are actually _sane_ for all these cases.<br /><br />If you look at threads as just contexts of execution, WITHOUT the idiotic <br />threads/process separation that traditional threads packages use, the <br />semantics are always clear:<br /><br /> - fork() is exactly the same as "clone(0)", and as such it's just <br />   another way to create a new thread. It's _completely_ orthogonal to <br />   all the other thread operations, and if you think of fork() as <br />   clone(0) (and that's actually how it's implemented inside the kernel <br />   too, not just a "conceptual" idea) there is never any question of what <br />   happens.<br /> - execve() is just a way to change the VM space of a task. Whether that <br />   task is a "thread" or a "process" in traidional parlance is totally <br />   irrelevant. A execve() does not change the VM space of other tasks.<br /> - the exit() system call closes down only the task that called it. <br />   Nothing else makes sense (if you want to have other behaviour you use <br />   "atexit()" to send a signal to the other threads you want to shut <br />   down).<br /> - quite naturally, a terminal signal kills only the task that got the <br />   signal.<br /><br />The above are all problems that exist with "traditional" threads, as you <br />point out. The fact that the problems exist in the first place, and that <br />traditional threads do not have clear-cut answers to them is just another <br />reason why traditional threads are obviously not the right thing. If the <br />semantics aren't clear, you CANNOT consider a interface a good one.<br /><br />&gt; Perhaps the cleanest approach is to simply deny fork() if you have more<br />&gt; than one thread. That too, would work. If you are going to write a multi-<br />&gt; threaded application then do you need fork for creating a copy of your<br />&gt; application to run a second copy with your data? Perhaps a 'create_process'<br />&gt; function could be implemented to start a process in a multi-thread app.<br /><br />"execve()" is actually much worse than "fork()" when it comes to traditional<br />threads. For fork() you can at least come up with _some_ reasonable behaviour<br />(usually that only the fork'ing thread continues execution in the child, but<br />the implementation is usually very ugly). But execve() is _totally_<br />impossible to do sanely with traditional threads. <br /><br />The clone() interface has _none_ of these problems. There simply aren't <br />any ambiguosities with how the path of execution works.<br /><br />&gt; In terms of threads, I am of the opinion that a thread is just the<br />&gt; current cpu state, priority, etc. It does not contain maps to memory,<br />&gt; file tables, etc. Those other items belong to the process. A thread is<br />&gt; just a dispatchable context, or COE.<br /><br />WHY? You just pointed out yourself only _some_ of the problems with that <br />approach. The whole approach is stupidity incarnate. The only reason that <br />people are using the stupid thread/process approach is historical (due to <br />the fact that you can implement that kind of limited threading with no <br />kernel support, by "hiding" the threads inside the processes the kernel <br />knows about). It's only a half-hearted approach at doing threading.<br /><br />The "clone()" approach, on the other hand, makes threads first-class objects.<br />That's _real_ threading, as opposed to the thread/process limited threading. <br /><br />I see that you use "COE": what I meant with COE was the exact opposite of<br />what you say. A COE is not just the CPU state and priority. A COE is<br />_everything_ that is needed to actually run, and thus it includes memory<br />mappings etc. It's the "struct task_struct" in Linux world. After all, you<br />can't dispatch a thread without all the other info.. <br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
