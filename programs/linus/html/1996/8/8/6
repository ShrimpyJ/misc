    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/8/7/20">First message in thread</a></li><li><a href="/lkml/1996/8/7/20">Linus Torvalds</a><ul><li><a href="/lkml/1996/8/7/44">(Al Longyear)</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 7 Aug 1996 20:04:47 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: proc fs and shared pids</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 7 Aug 1996, Al Longyear wrote:<br />&gt; <br />&gt; Does the cloning go forward in time as it does in a traditional thread<br />&gt; model?<br /><br />Yes. When you share some part of the context of execution with another <br />task, the data really _is_ shared, 100%.<br /><br />&gt; Suppose you have a process. It has one thread. It opens a file by<br />&gt; calling the open procedure. Ok. It now has the file open.<br />&gt; <br />&gt; It then calls "create_thread" or "clone(0)" or whatever to create a<br />&gt; new thread.<br />&gt; <br />&gt; Both threads now have the same file open. That is understood by all<br />&gt; models.<br />&gt; <br />&gt; Now, the second thread opens yet another file by calling open().<br />&gt; <br />&gt; Does the first thread get a new descriptor for the newly opened file?<br /><br />Not if you do a "clone(0)". As I mentioned, "clone(0)" is exactly the <br />same as fork(), and essentially copies all of the context of execution so <br />that we have two totally separate tasks (*).<br /><br />(*) Slight simplifications: clone() has more than just one argument, and <br />the bitmask argument also contains a "exit signal" mask, but those are <br />details, not really relevant to the basic ideas.<br /><br />But the argument to clone() is just a bit-mask of which parts of the<br />execution context we want to share, so if you want to share the open files,<br />you do a clone(CLONE_FILES), and now you have created a new task ("context of<br />execution") that shares the files structure with the original one. <br /><br />Thus, if the parent closes or opens a file, that action shows up in the <br />child too (and vice versa, of course).<br /><br />&gt; And, if it is given to the first thread, what do we do about closing<br />&gt; the file? If the file is stored as a process structure item for each<br />&gt; thread then both threads must close the file as there would be two<br />&gt; references to the opened file. Yet, only one thread really opened the<br />&gt; file and only one thread should close it.<br /><br />A close() will close the file in both (or "all" - it doesn't have to <br />be just two tasks) tasks that share the same files. You can open the file <br />in one task and close it in another if you want to (although I suspect <br />that the programmer _really_ has to know what he is doing in order to not <br />mess up if he starts doing stuff like that ;^)<br /><br />&gt; If you don't like files, then substitute signal processing procedures,<br />&gt; memory allocation or semaphores or any other shared resource that you<br />&gt; would want to allocate/reserve for the term 'file' above.<br /><br />Sure, just use "CLONE_SIGHAND" for signal handlers that are shared (when one<br />task installs a signal handler, it shows up in the other tasks too), and<br />"CLONE_VM" when you want to share the virtual memory of two processes. <br />Similarly, CLONE_FS shares "generic filesystem" state (currently that just<br />means pwd/cwd). <br /><br />If you want pthreads behaviour, you probably want to use<br /><br />	clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_PID)<br /><br />so that you essentially share everything (except the CPU state: due to<br />hardware limitations two tasks cannot have the same register state, for<br />understandable reasons - that would be a struly SIMD "clone()" ;)<br /><br />&gt; The kernel dispatches THREADS, not PROCESSES. The threads contain only<br />&gt; the context needed to dispatch the instructions. This would be the<br />&gt; current registers, priority, state, wait list, etc.<br /><br />You cannot dispatch a thread without a process. A "thread" doesn't exist <br />on it's own. In my opinion a "thread" doesn't even make sense at all: <br />what is the CPU state if there is no MMU state? That's why Linux doesn't <br />dispatch threads: it dispatches the totality, the "task".<br /><br />&gt; A thread then has a pointer to the process context. The process<br />&gt; context would contain things such as memory maps, open file lists,<br />&gt; identification (owner and group), etc. It would have all of the<br />&gt; information which was not in the TSS (and I don't consider the map<br />&gt; table, pointed to by the the TSS's cr3 to be "in the TSS") or needed<br />&gt; to dispatch the unit of execution.<br /><br />The "current" pointer is the pointer to the current "struct task_struct". <br />That is the task descriptor, and it has pointers to all of the state of <br />the task ("current-&gt;mm" points to the VM description of the task, <br />"current-&gt;sig" points to the signal handler state etc).<br /><br />The "current" pointer is neither thread or process. It is _both_. It is <br />complete in itself (it doesn't need any external "process" container).<br /><br />&gt; The value of 'current' would point to the thread storage, not the<br />&gt; process storage.<br /><br />It _does_ point to the thread storage, but it _also_ points to the <br />process storage. They aren't separate entities under Linux. You could try <br />to make up something that is the "process" part, and another part that is <br />the "thread" part, but that's not how the kernel actually uses it or how <br />it should be thought about.<br /><br />&gt; Now, if you wish to duplicate all of the process releated information<br />&gt; such as map tables, etc. on a per-thread basis, then that is OK as<br />&gt; well ( for the time being, that is. :) )<br />&gt; <br />&gt; I am sure that whatever scheme that is devised will work. I only<br />&gt; suggest that the more common problems of "well, threads are easy so we<br />&gt; can do them" need to be considered.<br /><br />Note that this all is not something that is being devised. It already <br />exists. It does work. People are actually using it for threads already, <br />and as such the basic approach has validated itself.<br /><br />The thing being discussed is the "frills": the stuff to make it easier to <br />create a 100% pthreads compatible library efficiently. Stuff like hiding <br />an extra "thread ID" inside the pid, so that we have a good interface to <br />do thr_kill() that just directly maps on top of the native "kill()" <br />system call. The details that haven't been needed yet and thus haven't <br />crystallized completely because clone() is only now starting to get used <br />for real..<br /><br />&gt; If you duplicate the information then you need to be concerned about<br />&gt; currency. (This is true even if you declare that you won't keep the<br />&gt; copies current -- at least you did consider the problem at one point.)<br />&gt; Again, there is no "one" solution. You just need to choose. Either<br />&gt; solution is BOTH good AND bad.<br /><br />Clone() doesn't duplicate any information: it uses shared pointers to shared<br />in-kernel data structures that have resource counters to make<br />allocation/deallocation work correctly. So when you use "CLONE_VM", what<br />happens is that instead of doing a COW of the page tables and creatign a new<br />"struct mm_struct" etc, Linux just points the new task to point to the same<br />old "struct mm_struct", and increments the usage pointer. Same goes for<br />sharing file descriptors etc. (And for this reason a clone() that shares<br />everything is _really_ quick under Linux). <br /><br />Plan-9 has a similar "rfork()" interface, and SGI has another thing that<br />looks pretty much like the Linux clone(). So it's not a totally new way of<br />looking at this. The plan-9 rfork() has some serious design problems in the<br />MM department, though, that Linux avoided. I haven't looked into the details<br />of the SGI thing. <br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
