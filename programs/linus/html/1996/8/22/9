    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/8/19/12">First message in thread</a></li><li><a href="/lkml/1996/8/21/42">Tom May</a><ul><li><a href="/lkml/1996/8/21/69">(Steven S. Dick)</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 22 Aug 1996 08:38:45 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: CLONE_FILES problem.</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 21 Aug 1996, Steven S. Dick wrote:<br />&gt; <br />&gt; Tom May  &lt;alfred!ucf-cs!netcom.com!ftom&gt; wrote:<br />&gt; &gt;I recently wrote a device driver for NeXTSTEP in which a close() from<br />&gt; &gt;one thread forces an EBADF error on any pending reads in other<br />&gt; &gt;threads.  This was ideal behaviour for the application I was<br />&gt; &gt;supporting, but I have no idea whether it would be a good thing in the<br />&gt; &gt;general case.<br /><br />This is not the right thing to do, imho. And the reason it's not the right<br />thing is that it doesn't "fit" UNIX. <br /><br />This is actually a case that UNIX already handles, albeit in another area.<br />The "unlink()" system call is more-or-less _exactly_ the same thing, except<br />that instead of removing the file descriptor (as in close) we remove the file<br />name.<br /><br />In both cases we actually remove a "name", rather than the thing itself<br />(close() doesn't actually free up the in-kernel file descriptor: think of<br />multiple processes sharing the same open file after "fork()" or similar.<br />close() only removes a name mapping, the same way "unlink()"  does, and then<br />when there are no mappings left the file descriptor is free'd). <br /><br />But when UNIX "unlink()" is called, that doesn't mean that any open files<br />will return errors. The file name is gone, but open files continue to work<br />until you close them. <br /><br />This case is actually pretty equivalent to "close()" and system calls that<br />use a fd (except we've moved "up" one level in the system: from "struct<br />inode" to "struct file").  Essentially, think of close() removing the "name"<br />from the "file descriptor namespace".  Any subsequent operations that try to<br />use that name will fail, but operations that already have an active version<br />of the fd continue to use it. <br /><br />I actually did that in 2.0.14 - it was trivial (and I've known about these<br />things with clone() for a long time), and I've done it for read() and<br />write(). Other operations still need to be handled too: but now I've done the<br />"groundwork" and it should be even more trivial to do. <br /><br /><br />&gt; What if the programmer has a thread that does nothing but close unused<br />&gt; files and open needed files....  and another thread that does nothing<br />&gt; but handle read requests in a queue.  It might mark a file as "finished"<br />&gt; and the close thread would then close it, and open another file...<br />&gt; The read thread might then notice and read again from the same fd,<br />&gt; with the desire to get data from the new file.<br />&gt; <br />&gt; How do you propose the read thread should tell the kernel that it wants<br />&gt; the new file instead of the old one?  Open the file itself??<br />&gt; <br />&gt; If a thread is using a file while another thread closes it, it is a<br />&gt; programming error.  Nothing special should be done about this except<br />&gt; that the kernel shouldn't fault because of a race condition in buggy code.<br /><br />Not necessarily. We need to have a good set of semantics for everything:  if<br />we don't have well-defined semantics then there is something basically wrong<br />with any model. <br /><br />Non-UNIX people think it's a "programming error" to delete a file while it's<br />still in use. But in UNIX there are well-defined semantics for such things,<br />and it's not really a problem. In fact, some programs take advantage of the<br />fact that you can do things like that. Similarly, maybe somebody can come up<br />with a program that takes advantage of the fact that you can close file<br />descriptors while they are in use (and know that the close will be delayed<br />until the last usage, while being able to re-use the "namespace", ie the fd<br />number for something else). <br /><br />		Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
