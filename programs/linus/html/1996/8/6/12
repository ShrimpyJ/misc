    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/8/6/4">First message in thread</a></li><li><a href="/lkml/1996/8/6/4">"Peter P. Eiserloh"</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/1996/8/6/41">Albert Cahalan</a><ul><li><a href="/lkml/1996/8/7/26">Linus Torvalds</a></li><li><a href="/lkml/1996/8/7/40">(Peter Eriksson)</a><ul><li><a href="/lkml/1996/8/8/26">"Theodore Y. Ts'o"</a><ul><li><a href="/lkml/1996/8/9/11">"Stephen C. Tweedie"</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 6 Aug 1996 12:47:31 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: proc fs and shared pids</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 5 Aug 1996, Peter P. Eiserloh wrote:<br />&gt; <br />&gt; We need to keep a clear the concept of threads.  Too many people<br />&gt; seem to confuse a thread with a process.  The following discussion<br />&gt; does not reflect the current state of linux, but rather is an<br />&gt; attempt to stay at a high level discussion.<br /><br />NO!<br /><br />There is NO reason to think that "threads" and "processes" are separate<br />entities. That's how it's traditionally done, but I personally think it's a<br />major mistake to think that way. The only reason to think that way is<br />historical baggage. <br /><br />Both threads and processes are really just one thing: a "context of<br />execution".  Trying to artificially distinguish different cases is just<br />self-limiting. <br /><br />A "context of execution", hereby called COE, is just the conglomerate of <br />all the state of that COE. That state includes things like CPU state <br />(registers etc), MMU state (page mappings), permission state (uid, gid) <br />and various "communication states" (open files, signal handlers etc).<br /><br />Traditionally, the difference between a "thread" and a "process" has been<br />mainly that a threads has CPU state (+ possibly some other minimal state),<br />while all the other context comes from the process. However, that's just<br />_one_ way of dividing up the total state of the COE, and there is nothing<br />that says that it's the right way to do it. Limiting yourself to that kind of<br />image is just plain stupid. <br /><br />The way Linux thinks about this (and the way I want things to work) is that<br />there _is_ no such thing as a "process" or a "thread". There is only the<br />totality of the COE (called "task" by Linux). Different COE's can share parts<br />of their context with each other, and one _subset_ of that sharing is the<br />traditional "thread"/"process" setup, but that should really be seen as ONLY<br />a subset (it's an important subset, but that importance comes not from<br />design, but from standards: we obviusly want to run standards-conforming<br />threads programs on top of Linux too). <br /><br />In short: do NOT design around the thread/process way of thinking. The <br />kernel should be designed around the COE way of thinking, and then the <br />pthreads _library_ can export the limited pthreads interface to users who <br />want to use that way of looking at COE's.<br /><br />Just as an example of what becomes possible when you think COE as opposed <br />to thread/process:<br /><br /> - You can do a external "cd" program, something that is traditionally<br />   impossible in UNIX and/or process/thread (silly example, but the idea <br />   is that you can have these kinds of "modules" that aren't limited to <br />   the traditional UNIX/threads setup). Do a:<br /><br />	clone(CLONE_VM|CLONE_FS);<br />	child: execve("external-cd");<br />	/* the "execve()" will disassociate the VM, so the only reason we <br />	   used CLONE_VM was to make the act of cloning faster */<br /><br /> - You can do "vfork()" naturally (it meeds minimal kernel support, but <br />   that support fits the CUA way of thinking perfectly):<br /><br />	clone(CLONE_VM);<br />	child: continue to run, eventually execve()<br />	mother: wait for execve<br /><br /> - you can do external "IO deamons":<br /><br />	clone(CLONE_FILES);<br />	child: open file descriptors etc<br />	mother: use the fd's the child opened and vv.<br /><br />All of the above work because you aren't tied to the thread/process way of<br />thinking. Think of a web server for example, where the CGI scripts are done<br />as "threads of execution". You can't do that with traditional threads,<br />because traditional threads always have to share the whole address space, so<br />you'd have to link in everything you ever wanted to do in the web server<br />itself (a "thread" can't run another executable). <br /><br />Thinking of this as a "context of execution" problem instead, your tasks can<br />now chose to execute external programs (= separate the address space from the<br />parent) etc if they want to, or they can for example share everything with<br />the parent _except_ for the file descriptors (so that the sub-"threads" can<br />open lots of files without the parent needing to worry about them: they close<br />automatically when the sub-"thread" exits, and it doesn't use up fd's in the<br />parent). <br /><br />Think of a threaded "inetd", for example. You want low overhead fork+exec, so<br />with the Linux way you can instead of using a "fork()" you write a<br />multi-threaded inetd where each thread is created with just CLONE_VM (share<br />address space, but don't share file descriptors etc).  Then the child can<br />execve if it was a external service (rlogind, for example), or maybe it was<br />one of the internal inetd services (echo, timeofday) in which case it just<br />does it's thing and exits. <br /><br />You can't do that with "thread"/"process".<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
