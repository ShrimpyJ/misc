    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/8/2/28">First message in thread</a></li><li><a href="/lkml/1996/8/2/28">Jim Nance</a><ul><li><a href="/lkml/1996/8/4/3">"Michael O'Reilly"</a><ul><li class="origin"><a href="/lkml/1997/2/10/55">Linus Torvalds</a><ul><li><a href="/lkml/1997/2/10/55">Kevin Lentin</a><ul><li><a href="/lkml/1997/2/10/115">Jesse Thilo</a></li><li><a href="/lkml/1997/2/10/137">John Gotts</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 4 Aug 1996 13:33:36 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: More kernel profiling</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sun, 4 Aug 1996, Michael O'Reilly wrote:<br />&gt; <br />&gt; No, you're off the mark here. You're reading the output of readprofile<br />&gt; wrong. That floating point number is actually the number of counts,<br />&gt; divided by the size of the routine, which produces a number, but<br />&gt; probably isn't a very useful number (at least, I couldn't think of a<br />&gt; use for it. :) <br /><br />That's a _really_ useless number, I wonder why that was used?<br /><br />I'm including my personal profil.c here, which also allows you to profile <br />a single function if you want to (the profile data is _very_ raw, but <br />it's useful together with a "disassemble fn_name" with "gdb vmlinux" to <br />find out where int he function the time is spent).<br /><br />This will also give you the numbers in percentage of time spent in the <br />kernel. That is at least a somewhat useful metric (good for comparing <br />different runs of the same thing under different kernels).<br /><br />(Oh, this assumes a profile shift of "2", so use a kernel command line of <br />"profile=2" when you use this. It could read the profile shift <br />dynamically, but I never bothered to do that as I always use 2 myself).<br /><br />Oh, if you profile single functions, I'd suggest using "gdb vmlinux" to <br />find the actual addresses (which show up in the profile output), and in a <br />parallell window you'd look at the actual assembly code as generated by <br />gcc, as that's a lot more readable than the stuff gdb shows. <br /><br />		Linus<br /><br />-----<br />/*<br /> * Original by Ramon Garcia Fernandez &lt;ramon&#64;juguete.quim.ucm.es&gt;<br /> * Hacked to death by linus<br /> */<br />#include &lt;unistd.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;sys/fcntl.h&gt;<br />#include &lt;linux/autoconf.h&gt;<br /><br />#define prof_func "do_no_page"<br /><br />#define BUFSIZE 1024<br /><br />#ifndef CONFIG_PROFILE_SHIFT<br />#define CONFIG_PROFILE_SHIFT 2<br />#endif<br /><br />struct entry {<br />	struct entry * next;<br />	unsigned long time;<br />	unsigned long address;<br />	char name[1];<br />};<br /><br />struct entry * list = NULL;<br /><br />void do_symbol(int time, unsigned long address, char * name)<br />{<br />	struct entry * entry = malloc(sizeof(struct entry) + strlen(name));<br />	struct entry ** tmp;<br /><br />	entry-&gt;time = time;<br />	entry-&gt;address = address;<br />	strcpy(entry-&gt;name, name + (*name == '_'));<br />	tmp = &amp;list;<br />	while (*tmp) {<br />		if ((*tmp)-&gt;time &gt; entry-&gt;time)<br />			break;<br />		tmp = &amp;(*tmp)-&gt;next;<br />	}<br />	entry-&gt;next = *tmp;<br />	*tmp = entry;<br />}<br /><br />void show_symbols(unsigned long total)<br />{<br />	struct entry * entry = list;<br /><br />	while (entry) {<br />		printf("%10u %5d.%02d%% %08x %s\n" ,<br />			entry-&gt;time,<br />			(entry-&gt;time*10000/total) / 100,<br />			(entry-&gt;time*10000/total) % 100,<br />			entry-&gt;address, entry-&gt;name);<br />		entry = entry-&gt;next;<br />	}<br />}<br /><br />/* If you do not speak Spanish:<br /> * valor_simbolo_actual: current_symbol_value<br /> * valor_simbolo_siguiente: next_symbol_value<br /> * simbolo_actual: current_symbol<br /> * next_symbol: next_symbol<br /> * leidos: read (past participle)<br /> * total: total<br />*/<br /><br />int main(int argc, char ** argv)<br />{<br />	int fp;<br />	char * func = prof_func;<br />	FILE *kmap;<br />	int current_symbol_value , next_symbol_value;<br />	char current_symbol[80] , next_symbol[80];<br />	int has_read , total = 0, j;<br /><br />	if (argc == 2)<br />		func = argv[1];<br /><br />	fp = open("/proc/profile", O_RDONLY);<br />	if (fp &lt; 0) {<br />		perror("/proc/profile");<br />		exit(1);<br />	}<br />	kmap = fopen("/System.map","r");<br />	if (!kmap) {<br />		kmap = fopen("/usr/src/linux/System.map","r");<br />		if (!kmap) {<br />			perror("System.map");<br />			exit(1);<br />		}<br />	}<br />	fscanf(kmap , "%x %*s %s\n" , &amp;current_symbol_value , current_symbol );<br />	fscanf(kmap , "%x %*s %s\n" , &amp;next_symbol_value , next_symbol );<br />	puts(func);<br /><br />	for (;;) {<br />		unsigned int buffer[(next_symbol_value - current_symbol_value) &gt;&gt; CONFIG_PROFILE_SHIFT];<br />		unsigned int tiempo = 0;<br /><br />		if (next_symbol_value == current_symbol_value) {<br />			strcpy(current_symbol, next_symbol);<br />			fscanf(kmap, "%x %*s %s\n", &amp;next_symbol_value, next_symbol);<br />			continue;<br />		}<br />		lseek (fp , sizeof(unsigned int)+current_symbol_value-0x100000 , SEEK_SET);<br />		has_read = read (fp , buffer , sizeof(buffer) );<br />		for ( j = 0 ; j &lt; has_read/sizeof(unsigned int) ; j++) {<br />			if (!strcmp(func, current_symbol))<br />				printf("%08x %d\n", j*4+current_symbol_value, buffer[j]);<br />			tiempo += buffer[j];<br />		}<br />		if (tiempo != 0) {<br />			do_symbol(tiempo, current_symbol_value, current_symbol);<br />			total += tiempo;<br />		}<br />		if (has_read &lt; (next_symbol_value -current_symbol_value)<br />				&gt;&gt; CONFIG_PROFILE_SHIFT * sizeof(unsigned long) || <br />			next_symbol_value == current_symbol_value )<br />			break;<br />		strcpy ( current_symbol , next_symbol );<br />		current_symbol_value = next_symbol_value;<br />		fscanf(kmap , "%x %*s %s\n" , &amp;next_symbol_value , next_symbol );<br />	}<br />	do_symbol(total, 0, "total");<br />	show_symbols(total);<br />	return(0);<br />}<br /><br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
