    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/7/16/58">First message in thread</a></li><li><a href="/lkml/1996/7/16/58"> Thomas.Koenig&#64;ciw ...</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/1996/7/19/59">Ian Reid</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 17 Jul 1996 07:09:55 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Mapping kernel memory into user space</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 16 Jul 1996 Thomas.Koenig&#64;ciw.uni-karlsruhe.de wrote writing for <br />Hubert Schreier:<br />&gt; <br />&gt; I am writing a device driver for a PCI video capture board that writes image<br />&gt; data directly into the memory of the computer. As it is impossible to obtain<br />&gt; large contiguos memory areas in kernel space, I use blocks of 4k and program<br />&gt; the framegrabber's processor to write to them. To obtain fast acces to the<br />&gt; image data, I want to use memory mapped acces. However, I cannot figure out<br />&gt; how to map these 4k blocks to a contiguos area in user space memory. For<br />&gt; allocating the blocks I use<br />&gt; <br />&gt;     get_free_page();<br />&gt; <br />&gt; The driver works fine when using my read(), which copies the data to user<br />&gt; memory via memcpy_to_fs(). In the drivers mmap() function, I tried to<br />&gt; subsequently map the blocks to user space via remap_page_range(). This does<br />&gt; not work at all, not even for the first page.<br /><br />Don't use remap_page_range, what you should do instead is to just have a <br />"nopage()" handler in your driver, and when the mm layer then calls you <br />for a page, you give the appropriate page to the mm layer.<br /><br />Look into the file "mm/filemap.c", and look at how the code uses "struct <br />vm_operations_struct". You don't need "swapin/swapout" - just leave those <br />as NULL, and the mm code will do the right thing.<br /><br />(in fact, look at the "private" mapping struct: it _only_ contains the <br />"nopage" function, and that may be enough for you too. You may want to <br />add the "unmap" and "sync" entries if you need to start any write-back IO <br />to the device, though).<br /><br />&gt; Q1: How can I map non-contiguos memory pages in kernel space to a <br />&gt;     contiguos area in user space?<br /><br />Let the mm layer worry about that, and call you when the user accesses a <br />page it can't find - then it will call your "nopage" function, and you <br />just return the correct page for the offset given.<br /><br />Note that memory mapping devices is subtle, so you should read the<br />appropriate parts of filemap.c file closely, but you should also remember<br />that filemap.c does a lot of things you don't actually need (writing the data<br />back to a shared file, handling the file cache etc). <br /><br />&gt; Q2: Is there a way to use shared memory, so I could use XShmPutImage()<br />&gt;     to write to a window?<br /><br />No. If you want that, then you shouldn't mmap() the device, instead you <br />should just create a shared memory area in your application and do a <br />"read()" on the device. The device could look up the physical addresses <br />of the pages etc.. HOWEVER: BE VERY CAREFUL WHEN DOING THIS!<br /><br />&gt; Q3: Which flags for get_free_page() insure that the pages won't be<br />&gt;     swapped out?<br /><br />The kernel never swaps out kernel data, so get_free_page() needs no such <br />flags. <br /><br />The kernel _will_ swap out the pages that are mapped in user space, but <br />that just means you should increase the usage counter of the page (with <br />"atomic_inc(&amp;mmem_map[PAGE_NR(page)].count)") before handing it off to <br />the memory manager in your "nopage" routine. That way the page won't <br />actually disappear from under you (it might get unmapped from the page <br />tables, but even that is unlikely).<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
