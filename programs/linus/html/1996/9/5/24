    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/9/3/34">First message in thread</a></li><li><a href="/lkml/1996/9/4/38">(Alan Cox)</a><ul><li><a href="/lkml/1996/9/4/30">"David S. Miller"</a><ul><li class="origin"><a href="/lkml/1996/9/6/63">Linus Torvalds</a><ul><li><a href="/lkml/1996/9/6/63">(Alan Cox)</a></li><li><a href="/lkml/1996/9/7/18">Ingo Molnar</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 5 Sep 1996 08:03:30 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Preempting kernel tasks</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 4 Sep 1996, David S. Miller wrote:<br />&gt; Alan Cox said:<br />&gt;    Its extremely useful for high performance polled IO drivers (such<br />&gt;    as the Quickcam). Checking if I need to reschedule costs me about<br />&gt;    5% performance on the camera.<br />&gt; <br />&gt; I do not argue it's usefulness, it is indeed useful as you have<br />&gt; shown.  Other applications exist as well.  What I was trying to state<br />&gt; was that the ends need to be acquired in a cleaner fashion, not<br />&gt; that the ends are unnecessary.<br /><br />Like David, I do not like the idea of pre-empting kernel tasks. It implies a<br />more complex locking setup than I'd really like. <br /><br />HOWEVER, I'm all for having "user processes" in kernel mode. That's not too<br />hard - if only implies that we have to change the way we test for "user vs<br />kernel" a bit. <br /><br />Right now, the way the kernel "return to user mode" stuff checks for user<br />mode is to look at the saved x86 CS segment register, and looking if the<br />protection level of the code segment we return to is non-zero (ie user). <br />That actually means we also have to check the eflags register to see whether<br />it's a vm86 return (because if it is, then we can't look at the CS register). <br /><br />However, it would not be very hard at all to instead of checking that kind of<br />hardware thing we'd check a software flag instead (it essentially just<br />involves having a per-process "kernel entry" counter, and checking for zero).<br />And then we could make a kernel thread pre-emptable by just changing the<br />software flag to "user mode" for that thread - voila, instant "user mode<br />behavior" together with all the kernel services..<br /><br />(such a process would obviously have to be careful about not doing anything<br />that causes re-entrancy problems, but that kind of kernel thread would be <br />most useful for a very simple kind of loop anyway, so that's not really a <br />problem - just don't do anything stupid).<br /><br />		Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
