    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/9/26/43">First message in thread</a></li><li><a href="/lkml/1996/9/26/43">Keith Owens</a><ul><li class="origin"><a href="/lkml/1996/9/27/1">Linus Torvalds</a><ul><li><a href="/lkml/1996/9/27/1">Keith Owens</a></li><li><a href="/lkml/1996/9/27/49">Matthias Urlichs</a></li><li><a href="/lkml/1996/9/27/51">Frank Breure</a></li></ul></li><li><a href="/lkml/1996/9/27/33">Eric Youngdale</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 26 Sep 1996 09:16:31 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: pre-2.1, AHA1542 fixes, WD7000</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 26 Sep 1996, Keith Owens wrote:<br />&gt; <br />&gt; aha1542.c assumes kernel == real in quite a few places, fixes follow.  I<br />&gt; don't claim to have got all of them but it works for my 1542C with 2 disks<br />&gt; (Micropolis 3243, IBM DORS-32160) and a cdrom (Panasonic CR-533).  I also<br />&gt; changed the 16M tests slightly to look at the end of the data, not just<br />&gt; the start. <br /><br />Thanks. I applied your patch, although I'll just take this opportunity to<br />tell all device driver writers on this list about the ugly secrets of<br />portability..  Because things are actually worse than just physical and<br />virtual addresses. And instead of using the __pa() macro you should have used<br />"virt_to_bus()". Explanations to follow: <br /><br />[ WARNING! Device driver writer technical material follows, you may want <br />  to close your eyes if you are sensitive ]<br /><br />The aha1542 is a bus-master device, and your patch makes the driver give the<br />controller the physical address of the buffers, which is correct on x86<br />(because all bus master devices see the physical memory mappings directly). <br /><br />However, on many setups, there are actually _three_ different ways of looking<br />at memory addresses, and in this case we actually want the third, the<br />so-called "bus address". <br /><br />Essentially, the three ways of addressing memory are (this is "real memory",<br />ie normal RAM, see later about other details): <br /><br /> - CPU untranslated. This is the "physical" address, ie physical address <br />   0 is what the CPU sees when it drives zeroes on the memory bus.<br /><br /> - CPU translated address. This is the "virtual" address, and is <br />   completely internal to the CPU itself with the CPU doing the appropriate<br />   translations into "CPU untranslated". <br /><br /> - bus address. This is the address of memory as seen by OTHER devices, <br />   not the CPU. Now, in theory there could be many different bus <br />   addresses, with each device seeing memory in some device-specific way, but<br />   happily most hardware designers aren't actually actively trying to make<br />   things any more complex than necessary, so you can assume that all <br />   external hardware sees the memory the same way. <br /><br />Now, on normal PC's the bus address is exactly the same as the physical<br />address, and things are very simple indeed. However, they are that simple<br />because the memory and the devices share the same address space, and that is<br />not generally necessarily true on other PCI/ISA setups. <br /><br />Now, just as an example, on the PReP (PowerPC Reference Platform), the <br />CPU sees a memory map something like this (this is from memory):<br /><br />	0-2GB	"real memory"<br />	2GB-3GB	"system IO" (ie inb/out type accesses on x86)<br />	3GB-4GB "IO memory" (ie shared memory over the IO bus)<br /><br />Now, that looks simple enough. However, when you look at the same thing from<br />the viewpoint of the devices, you have the reverse, and the physical memory<br />address 0 actually shows up as address 2GB for any IO master.<br /><br />So when the CPU wants any bus master to write to physical memory 0, it <br />has to give the master address 0x80000000 as the memory address.<br /><br />So, for example, depending on how the kernel is actually mapped on the <br />PPC, you can end up with a setup like this:<br /><br /> physical address:	0<br /> virtual address:	0xC0000000<br /> bus address:		0x80000000<br /><br />where all the addresses actually point to the same thing, it's just seen <br />through different translations..<br /><br />Similarly, on the alpha, the normal translation is<br /><br /> physical address:	0<br /> virtual address:	0xfffffc0000000000<br /> bus address:		0x40000000<br /><br />(but there are also alpha's where the physical address and the bus address<br />are the same). <br /><br />Anyway, the way to look up all these translations, you do<br /><br />	#include &lt;asm/io.h&gt;<br /><br />	phys_addr = virt_to_phys(virt_addr);<br />	virt_addr = phys_to_virt(phys_addr);<br />	 bus_addr = virt_to_bus(virt_addr);<br />	virt_addr = bus_to_virt(bus_addr);<br /><br />Now, when do you need these?<br /><br />You want the _virtual_ address when you are actually going to access that <br />pointer from the kernel. So you can have something like this:<br /><br />	/*<br />	 * this is the hardware "mailbox" we use to communicate with<br />	 * the controller. The controller sees this directly.<br />	 */<br />	struct mailbox {<br />		__u32 status;<br />		__u32 bufstart;<br />		__u32 buflen;<br />		..<br />	} mbox;<br /><br />		unsigned char * retbuffer;<br /><br />		/* get the address from the controller */<br />		retbuffer = bus_to_virt(mbox.bufstart);<br />		switch (retbuffer[0]) {<br />			case STATUS_OK:<br />				...<br /><br />on the other hand, you want the bus address when you have a buffer that <br />you want to give to the controller:<br /><br />	/* ask the controller to read the sense status into "sense_buffer" */<br />	mbox.bufstart = virt_to_bus(&amp;sense_buffer);<br />	mbox.buflen = sizeof(sense_buffer);<br />	mbox.status = 0;<br />	notify_controller(&amp;mbox);<br /><br />And you generally _never_ want to use the physical address, because you can't<br />use that from the CPU (the CPU only uses translated virtual addresses), and<br />you can't use it from the bus master. <br /><br />So why do we care about the physical address at all? We do need the physical<br />address in some cases, it's just not very often in normal code.  The physical<br />address is needed if you use memory mappings, for example, because the<br />"remap_page_range()" mm function wants the physical address of the memory to<br />be remapped (the memory management layer doesn't know about devices outside<br />the CPU, so it shouldn't need to know about "bus addresses" etc). <br /><br />NOTE NOTE NOTE! The above is only one part of the whole equation. The above<br />only talks about "real memory", ie CPU memory, ie RAM. <br /><br />There is a completely different type of memory too, and that's the "shared<br />memory" on the PCI or ISA bus. That's generally not RAM (although in the case<br />of a video graphics card it can be normal DRAM that is just used for a frame<br />buffer), but can be things like a packet buffer in a network card etc. <br /><br />This memory is called "PCI memory" or "shared memory" or "IO memory" or<br />whatever, and there is only one way to access it: the readb/writeb and<br />related functions. You should never take the address of such memory, because<br />there is really nothing you can do with such an address: it's not<br />conceptually in the same memory space as "real memory" at all, so you cannot<br />just dereference a pointer. (Sadly, on x86 it _is_ in the same memory space,<br />so on x86 it actually works to just deference a pointer, but it's not<br />portable). <br /><br />For such memory, you can do things like<br /><br /> - reading:<br />	/*<br />	 * read first 32 bits from ISA memory at 0xC0000, aka<br />	 * C000:0000 in DOS terms<br />	 */<br />	unsigned int signature = readl(0xC0000);<br /><br /> - remapping and writing:<br />	/*<br />	 * remap framebuffer PCI memory area at 0xFC000000,<br />	 * size 1MB, so that we can access it: We can directly<br />	 * access only the 640k-1MB area, so anything else<br />	 * has to be remapped.<br />	 */<br />	char * baseptr = ioremap(0xFC000000, 1024*1024);<br /><br />	/* write a 'A' to the offset 10 of the area */<br />	writeb('A',baseptr+10);<br /><br />	/* unmap when we unload the driver */<br />	iounmap(baseptr);<br /><br /> - copying and clearing:<br />	/* get the 6-byte ethernet address at ISA address E000:0040 */<br />	memcpy_fromio(kernel_buffer, 0xE0040, 6);<br />	/* write a packet to the driver */<br />	memcpy_toio(0xE1000, skb-&gt;data, skb-&gt;len);<br />	/* clear the frame buffer */<br />	memset_io(0xA0000, 0, 0x10000);<br /><br />Ok, that just about covers the basics of accessing IO portably.  Questions?<br />Comments? You may think that all the above is overly complex, but one day you<br />might find yourself with a 500MHz alpha in front of you, and then you'll be<br />happy that your driver works ;)<br /><br />And the above sounds worse than it really is. Most real drivers really don't<br />do all that complex things (or rather: the complexity is not so much in the<br />actual IO accesses as in error handling and timeouts etc). It's generally <br />not hard to fix drivers, and in many cases the code actually looks better <br />afterwards:<br /><br />	unsigned long signature = *(unsigned int *) 0xC0000;<br />		vs<br />	unsigned long signature = readl(0xC0000);<br /><br />I think the second version actually is more readable, no?<br /><br />		Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
