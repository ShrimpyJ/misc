    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/9/13/30">First message in thread</a></li><li><a href="/lkml/1996/9/15/10">Linus Torvalds</a><ul><li><a href="/lkml/1996/9/15/23">Luca Lizzeri</a><ul><li><a href="/lkml/1996/9/15/34">Jason Burrell</a></li><li class="origin"><a href="/lkml/1997/2/4/41">Linus Torvalds</a><ul><li><a href="/lkml/1997/2/4/41">Kevin Lentin</a><ul><li><a href="/lkml/1997/2/5/3">Charlie Ross</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/1996/9/16/1">"Erik Walthinsen (Omega)"</a></li><li><a href="/lkml/1996/9/24/42">Erik B Andersen</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 16 Sep 1996 09:01:11 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Perl make depend made faster</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sun, 15 Sep 1996, Luca Lizzeri wrote:<br />&gt; <br />&gt; I think I will just stare at mkdep.c for a couple of days and ponder on<br />&gt; the ways of the wizards, hoping that I will learn as much more of C as I<br />&gt; did of Perl while writing depend.pl.<br /><br />Umm.. "mkdep.c" isn't exactly a thing of beauty. What it _is_ is my way of<br />writing state machines, and an efficient one. I don't think you should<br />actually show it to impressionable people, or people with heart disease. <br /><br />I have fixed up "mkdep.c" to be more portable (it worked fine on Linux<br />systems, but if you're cross-compiling from other systems you might have had<br />problems with "mmap()" and "munmap()" wanting to always have a page-aligned<br />argument to them).<br /><br />I also made it do the memory accesses a "long" at a time, which helps a lot<br />on architectures that don't have fast byte accesses.  That should actually<br />speed it up on x86 too, especially the newer ones (or the really old ones<br />without any cache at all). <br /><br />The new version is really sick, but I had fun writing it. You should compile<br />it with "-S -O2 -fomit-frame-pointer" to see all the subtleties by looking at<br />the generated assembly code. <br /><br />Ok, now it's a competition: is anobody able to shave another second off this<br />one? On my alpha it runs in eight seconds on the whole source tree once<br />things are cached (22 secs on a P166). <br /><br />Subtleties you should keep in mind when looking at it:<br /> (a) use "mmap()" to avoid a copy from kernel space<br /> (b) map in the whole file to avoid having to worry about boundary conditions<br /> (c) do ugly things when loading a "long" at a time, it doesn't work if the<br />     source file has NUL-characters in it<br /> (d) partition the functions so that gcc can allocate registers sanely<br /> (e) not so subtle: "goto" is your friend if you're doing state machines<br /><br />		Linus<br /><br />-----<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />#include &lt;string.h&gt;<br />#include &lt;sys/types.h&gt;<br />#include &lt;sys/stat.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;sys/fcntl.h&gt;<br />#include &lt;sys/mman.h&gt;<br /><br />char *filename, *command, __depname[256] = "\n\t&#64;touch ";<br />int needsconfig, hasconfig, hasdep;<br /><br />#define depname (__depname+9)<br /><br />struct path_struct {<br />	int len;<br />	char buffer[256-sizeof(int)];<br />} path_array[2] = {<br />	{ 23, "/usr/src/linux/include/" },<br />	{  0, "" }<br />};<br /><br />static void handle_include(int type, char *name, int len)<br />{<br />	int plen;<br />	struct path_struct *path = path_array+type;<br /><br />	if (len == 14 &amp;&amp; !memcmp(name, "linux/config.h", len))<br />		hasconfig = 1;<br /><br />	plen = path-&gt;len;<br />	memcpy(path-&gt;buffer+plen, name, len);<br />	len += plen;<br />	path-&gt;buffer[len] = '\0';<br />	if (access(path-&gt;buffer, F_OK))<br />		return;<br /><br />	if (!hasdep) {<br />		hasdep = 1;<br />		printf("%s:", depname);<br />	}<br />	printf(" \\\n   %s", path-&gt;buffer);<br />}<br /><br />static void handle_config(void)<br />{<br />	hasconfig = 1;<br />	if (!hasdep)<br />		fprintf(stderr,<br />			"%s needs config but has not included config file\n",<br />			filename);<br />}<br /><br />#if defined(__alpha__) || defined(__i386__)<br />#define LE_MACHINE<br />#endif<br /><br />#ifdef LE_MACHINE<br />#define first_byte(x) current = (unsigned char) x; x &gt;&gt;= 8;<br />#else<br />#define first_byte(x) current = x &gt;&gt; 8*(sizeof(unsigned long)-1); x &lt;&lt;= 8;<br />#endif<br /><br />#define GETNEXT { \<br />if (!__buf) { \<br />	__buf = *(unsigned long *) next; \<br />	if (!__buf) \<br />		break; \<br />} first_byte(__buf); next++; }<br />#define CASE(c,label) if (current == c) goto label<br />#define NOTCASE(c,label) if (current != c) goto label<br /><br />static void state_machine(char *next)<br />{<br />	for(;;) {<br />	unsigned long __buf = 0;<br />	unsigned char current;<br /><br />normal:<br />	GETNEXT<br />__normal:<br />	CASE('/',slash);<br />	CASE('"',string);<br />	CASE('\'',char_const);<br />	CASE('#',preproc);<br />	goto normal;<br /><br />slash:<br />	GETNEXT<br />	CASE('*',comment);<br />	goto __normal;<br /><br />string:<br />	GETNEXT<br />	CASE('"',normal);<br />	NOTCASE('\\',string);<br />	GETNEXT<br />	goto string;<br /><br />char_const:<br />	GETNEXT<br />	CASE('\'',normal);<br />	NOTCASE('\\',char_const);<br />	GETNEXT<br />	goto char_const;<br /><br />comment:<br />	GETNEXT<br />__comment:<br />	NOTCASE('*',comment);<br />	GETNEXT<br />	CASE('/',normal);<br />	goto __comment;<br /><br />preproc:<br />	GETNEXT<br />	CASE('\n',normal);<br />	CASE(' ',preproc);<br />	CASE('\t',preproc);<br />	CASE('i',i_preproc);<br />	GETNEXT<br /><br />skippreproc:<br />	CASE('\n',normal);<br />	GETNEXT<br />	goto skippreproc;<br /><br />i_preproc:<br />	GETNEXT<br />	CASE('f',if_line);<br />	NOTCASE('n',skippreproc);<br />	GETNEXT<br />	NOTCASE('c',skippreproc);<br />	GETNEXT<br />	NOTCASE('l',skippreproc);<br />	GETNEXT<br />	NOTCASE('u',skippreproc);<br />	GETNEXT<br />	NOTCASE('d',skippreproc);<br />	GETNEXT<br />	NOTCASE('e',skippreproc);<br /><br />/* "# include" found */<br />include_line:<br />	GETNEXT<br />	CASE('\n',normal);<br />	CASE('&lt;', std_include_file);<br />	NOTCASE('"', include_line);<br /><br />/* "local" include file */<br />{<br />	char *incname = next;<br />local_include_name:<br />	GETNEXT<br />	CASE('\n',normal);<br />	NOTCASE('"', local_include_name);<br />	handle_include(1, incname, next-incname-1);<br />	goto skippreproc;<br />}<br /><br />/* &lt;std&gt; include file */<br />std_include_file:<br />{<br />	char *incname = next;<br />std_include_name:<br />	GETNEXT<br />	CASE('\n',normal);<br />	NOTCASE('&gt;', std_include_name);<br />	handle_include(0, incname, next-incname-1);<br />	goto skippreproc;<br />}<br /><br />if_line:<br />	if (hasconfig)<br />		goto skippreproc;<br />if_start:<br />	if (!memcmp("CONFIG_", next, 7)) {<br />		handle_config();<br />		goto skippreproc;<br />	}<br />	GETNEXT<br />	CASE('\n', normal);<br />	CASE('_', if_middle);<br />	if (current &gt;= 'a' &amp;&amp; current &lt;= 'z')<br />		goto if_middle;<br />	if (current &lt; 'A' || current &gt; 'Z')<br />		goto if_start;<br />if_middle:<br />	GETNEXT<br />	CASE('\n', normal);<br />	CASE('_', if_middle);<br />	if (current &gt;= 'a' &amp;&amp; current &lt;= 'z')<br />		goto if_middle;<br />	if (current &lt; 'A' || current &gt; 'Z')<br />		goto if_start;<br />	goto if_middle;<br />	}<br />}<br /><br />static void do_depend(void)<br />{<br />	char *map;<br />	int mapsize;<br />	int pagesizem1 = getpagesize()-1;<br />	int fd = open(filename, O_RDONLY);<br />	struct stat st;<br /><br />	if (fd &lt; 0)<br />		return;<br />	fstat(fd, &amp;st);<br />	mapsize = st.st_size + 2*sizeof(unsigned long);<br />	mapsize = (mapsize+pagesizem1) &amp; ~pagesizem1;<br />	map = mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, fd, 0);<br />	if (-1 == (long)map) {<br />		close(fd);<br />		return;<br />	}<br />	state_machine(map);<br />	munmap(map, mapsize);<br />	if (hasdep)<br />		puts(command);<br />}<br /><br />int main(int argc, char **argv)<br />{<br />	int len;<br />	char * hpath;<br /><br />	hpath = getenv("HPATH");<br />	if (!hpath)<br />		hpath = "/usr/src/linux/include";<br />	len = strlen(hpath);<br />	memcpy(path_array[0].buffer, hpath, len);<br />	if (len &amp;&amp; hpath[len-1] != '/') {<br />		path_array[0].buffer[len] = '/';<br />		len++;<br />	}<br />	path_array[0].buffer[len] = '\0';<br />	path_array[0].len = len;<br /><br />	while (--argc &gt; 0) {<br />		int len;<br />		char *name = *++argv;<br /><br />		filename = name;<br />		len = strlen(name);<br />		memcpy(depname, name, len+1);<br />		command = __depname;<br />		if (len &gt; 2 &amp;&amp; name[len-2] == '.') {<br />			switch (name[len-1]) {<br />				case 'c':<br />				case 'S':<br />					depname[len-1] = 'o';<br />					command = "";<br />			}<br />		}<br />		needsconfig = hasconfig = hasdep = 0;<br />		do_depend();<br />	}<br />	return 0;<br />}<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
