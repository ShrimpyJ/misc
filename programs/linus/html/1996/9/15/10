    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/9/13/30">First message in thread</a></li><li><a href="/lkml/1996/9/14/47">Luca Lizzeri</a><ul><li><a href="/lkml/1996/9/15/2">Edward Welbon</a><ul><li class="origin"><a href="/lkml/1996/9/15/23">Linus Torvalds</a><ul><li><a href="/lkml/1996/9/15/23">Luca Lizzeri</a><ul><li><a href="/lkml/1996/9/15/34">Jason Burrell</a></li><li><a href="/lkml/1996/9/16/5">Linus Torvalds</a></li></ul></li><li><a href="/lkml/1996/9/16/1">"Erik Walthinsen (Omega)"</a></li><li><a href="/lkml/1996/9/24/42">Erik B Andersen</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/1996/9/15/10/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 15 Sep 1996 13:28:08 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Perl make depend made faster</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />If you want to make "make depend" faster, I don't see why perl would be <br />the answer. Perl has the problem that it easily uses lots of memory, and <br />also that it isn't always there. If people really care, how about <br />optimizing this patch instead?<br /><br />(This just does the thing in C - you end compiling "mkdep", but it does <br />have the advantage that we know that a C compiler is always installed, <br />because we couldn't compile the kernel without one anyway).<br /><br />		Linus<br /><br />-----<br />diff -u --recursive --new-file v2.0.20/linux/Makefile linux/Makefile<br />--- v2.0.20/linux/Makefile	Sun Sep 15 10:19:09 1996<br />+++ linux/Makefile	Sun Sep 15 12:59:23 1996<br />&#64;&#64; -327,7 +327,7 &#64;&#64;<br /> 	rm -f .menuconfig .menuconfig.log<br /> 	rm -f include/asm<br /> 	rm -f .depend `find . -name .depend -print`<br />-	rm -f .hdepend<br />+	rm -f .hdepend scripts/mkdep<br /> 	rm -f $(TOPDIR)/include/linux/modversions.h<br /> 	rm -f $(TOPDIR)/include/linux/modules/*<br /> <br />&#64;&#64; -344,8 +344,8 &#64;&#64;<br /> sums:<br /> 	find . -type f -print | sort | xargs sum &gt; .SUMS<br /> <br />-dep-files: archdep .hdepend include/linux/version.h<br />-	$(AWK) -f scripts/depend.awk init/*.c &gt; .tmpdepend<br />+dep-files: scripts/mkdep archdep .hdepend include/linux/version.h<br />+	scripts/mkdep init/*.c &gt; .tmpdepend<br /> 	set -e; for i in $(SUBDIRS); do $(MAKE) -C $$i fastdep; done<br /> 	mv .tmpdepend .depend<br /> <br />&#64;&#64; -383,7 +383,10 &#64;&#64;<br /> # This generates dependencies for the .h files.<br /> #<br /> <br />-.hdepend: dummy<br />+scripts/mkdep: scripts/mkdep.c<br />+	$(HOSTCC) -O -o scripts/mkdep scripts/mkdep.c<br />+<br />+.hdepend: scripts/mkdep<br /> 	rm -f $&#64;<br />-	$(AWK) -f scripts/depend.awk `find $(HPATH) -name \*.h ! -name modversions.h -print` &gt; .$&#64;<br />+	scripts/mkdep `find $(HPATH) -name \*.h ! -name modversions.h -print` &gt; .$&#64;<br /> 	mv .$&#64; $&#64;<br />diff -u --recursive --new-file v2.0.20/linux/Rules.make linux/Rules.make<br />--- v2.0.20/linux/Rules.make	Sat Jun 29 14:59:38 1996<br />+++ linux/Rules.make	Sun Sep 15 12:58:24 1996<br />&#64;&#64; -83,7 +83,7 &#64;&#64;<br /> #<br /> fastdep: dummy<br /> 	if [ -n "$(wildcard *.[chS])" ]; then \<br />-	$(AWK) -f $(TOPDIR)/scripts/depend.awk *.[chS] &gt; .depend; fi<br />+	$(TOPDIR)/scripts/mkdep *.[chS] &gt; .depend; fi<br /> ifdef ALL_SUB_DIRS<br /> 	set -e; for i in $(ALL_SUB_DIRS); do $(MAKE) -C $$i fastdep; done<br /> endif<br />diff -u --recursive --new-file v2.0.20/linux/drivers/block/ide_modes.h linux/drivers/block/ide_modes.h<br />--- v2.0.20/linux/drivers/block/ide_modes.h	Fri Aug  9 19:26:50 1996<br />+++ linux/drivers/block/ide_modes.h	Sun Sep 15 13:00:06 1996<br />&#64;&#64; -6,6 +6,8 &#64;&#64;<br />  *  Copyright (C) 1996  Linus Torvalds, Igor Abramov, and Mark Lord<br />  */<br /> <br />+#include &lt;linux/config.h&gt;<br />+<br /> /*<br />  * Shared data/functions for determining best PIO mode for an IDE drive.<br />  * Most of this stuff originally lived in cmd640.c, and changes to the<br />diff -u --recursive --new-file v2.0.20/linux/drivers/scsi/g_NCR5380.h linux/drivers/scsi/g_NCR5380.h<br />--- v2.0.20/linux/drivers/scsi/g_NCR5380.h	Sun May 19 18:23:20 1996<br />+++ linux/drivers/scsi/g_NCR5380.h	Sun Sep 15 13:13:04 1996<br />&#64;&#64; -32,6 +32,8 &#64;&#64;<br /> #ifndef GENERIC_NCR5380_H<br /> #define GENERIC_NCR5380_H<br /> <br />+#include &lt;linux/config.h&gt;<br />+<br /> #define GENERIC_NCR5380_PUBLIC_RELEASE 1<br /> <br /> #ifdef NCR53C400<br />diff -u --recursive --new-file v2.0.20/linux/drivers/sound/dev_table.h linux/drivers/sound/dev_table.h<br />--- v2.0.20/linux/drivers/sound/dev_table.h	Thu Jul 11 19:14:10 1996<br />+++ linux/drivers/sound/dev_table.h	Sun Sep 15 13:00:54 1996<br />&#64;&#64; -15,6 +15,7 &#64;&#64;<br /> #ifndef _DEV_TABLE_H_<br /> #define _DEV_TABLE_H_<br /> <br />+#include &lt;linux/config.h&gt;<br /> <br /> /*<br />  * Sound card numbers 27 to 999. (1 to 26 are defined in soundcard.h)<br />diff -u --recursive --new-file v2.0.20/linux/scripts/mkdep.c linux/scripts/mkdep.c<br />--- v2.0.20/linux/scripts/mkdep.c	Thu Jan  1 02:00:00 1970<br />+++ linux/scripts/mkdep.c	Sun Sep 15 13:11:19 1996<br />&#64;&#64; -0,0 +1,236 &#64;&#64;<br />+#include &lt;stdio.h&gt;<br />+#include &lt;stdlib.h&gt;<br />+<br />+#include &lt;string.h&gt;<br />+#include &lt;sys/types.h&gt;<br />+#include &lt;sys/stat.h&gt;<br />+#include &lt;unistd.h&gt;<br />+#include &lt;sys/fcntl.h&gt;<br />+#include &lt;sys/mman.h&gt;<br />+<br />+char *filename, *command, __depname[256] = "\n\t&#64;touch ";<br />+int needsconfig, hasconfig, hasdep;<br />+<br />+#define depname (__depname+9)<br />+<br />+struct path_struct {<br />+	int len;<br />+	char buffer[256-sizeof(int)];<br />+} path_array[2] = {<br />+	{ 23, "/usr/src/linux/include/" },<br />+	{  0, "" }<br />+};<br />+<br />+static void handle_include(int type, char *name, int len)<br />+{<br />+	int plen;<br />+	char namebuffer[128];<br />+	struct path_struct *path = path_array;<br />+<br />+	if (type == '"')<br />+		path++;<br />+<br />+	if (len == 14 &amp;&amp; !memcmp(name, "linux/config.h", len))<br />+		hasconfig = 1;<br />+<br />+	plen = path-&gt;len;<br />+	memcpy(path-&gt;buffer+plen, name, len);<br />+	len += plen;<br />+	path-&gt;buffer[len] = '\0';<br />+	if (access(path-&gt;buffer, F_OK))<br />+		return;<br />+<br />+	if (!hasdep) {<br />+		hasdep = 1;<br />+		printf("%s:", depname);<br />+	}<br />+	printf(" \\\n   %s", path-&gt;buffer);<br />+}<br />+<br />+static void handle_config(void)<br />+{<br />+	hasconfig = 1;<br />+	if (!hasdep)<br />+		fprintf(stderr,<br />+			"%s needs config but has not included config file\n",<br />+			filename);<br />+}<br />+<br />+#define GETNEXT { if (!left) break; current = *next; left--; next++; }<br />+#define CASE(c,label) if (current == c) goto label<br />+#define NOTCASE(c,label) if (current != c) goto label<br />+<br />+static void do_depend(void)<br />+{<br />+	char *map;<br />+	char *next;<br />+	int mapsize;<br />+	int left = 0;<br />+	int fd = open(filename, O_RDONLY);<br />+	struct stat st;<br />+<br />+	if (fd &lt; 0)<br />+		return;<br />+	fstat(fd, &amp;st);<br />+	left = st.st_size;<br />+	map = mmap(NULL, left, PROT_READ, MAP_PRIVATE, fd, 0);<br />+	if (-1 == (long)map) {<br />+		close(fd);<br />+		return;<br />+	}<br />+	next = map;<br />+	for(;;) {<br />+		char current;<br />+<br />+normal:<br />+	GETNEXT<br />+__normal:<br />+	CASE('/',slash);<br />+	CASE('"',string);<br />+	CASE('\'',char_const);<br />+	CASE('#',preproc);<br />+	goto normal;<br />+<br />+slash:<br />+	GETNEXT<br />+	CASE('*',comment);<br />+	goto __normal;<br />+<br />+string:<br />+	GETNEXT<br />+	CASE('"',normal);<br />+	NOTCASE('\\',string);<br />+	GETNEXT<br />+	goto string;<br />+<br />+char_const:<br />+	GETNEXT<br />+	CASE('\'',normal);<br />+	NOTCASE('\\',char_const);<br />+	GETNEXT<br />+	goto char_const;<br />+<br />+comment:<br />+	GETNEXT<br />+__comment:<br />+	NOTCASE('*',comment);<br />+	GETNEXT<br />+	CASE('/',normal);<br />+	goto __comment;<br />+<br />+preproc:<br />+	GETNEXT<br />+	CASE('\n',normal);<br />+	CASE(' ',preproc);<br />+	CASE('\t',preproc);<br />+	CASE('i',i_preproc);<br />+	GETNEXT<br />+<br />+skippreproc:<br />+	CASE('\n',normal);<br />+	GETNEXT<br />+	goto skippreproc;<br />+<br />+i_preproc:<br />+	GETNEXT<br />+	CASE('f',if_line);<br />+	NOTCASE('n',skippreproc);<br />+	GETNEXT<br />+	NOTCASE('c',skippreproc);<br />+	GETNEXT<br />+	NOTCASE('l',skippreproc);<br />+	GETNEXT<br />+	NOTCASE('u',skippreproc);<br />+	GETNEXT<br />+	NOTCASE('d',skippreproc);<br />+	GETNEXT<br />+	NOTCASE('e',skippreproc);<br />+<br />+include_line:<br />+{<br />+	char type;<br />+	GETNEXT<br />+	CASE('\n',normal);<br />+	type = '&gt;';<br />+	CASE('&lt;', include_file);<br />+	type = '"';<br />+	NOTCASE('"', include_line);<br />+include_file:<br />+{<br />+	char *incname = next;<br />+include_name:<br />+	GETNEXT<br />+	CASE('\n',normal);<br />+	NOTCASE(type, include_name);<br />+	handle_include(type, incname, next-incname-1);<br />+	goto skippreproc;<br />+}}<br />+<br />+if_line:<br />+	if (hasconfig)<br />+		goto skippreproc;<br />+if_start:<br />+	if (!memcmp("CONFIG_", next, 7)) {<br />+		handle_config();<br />+		goto skippreproc;<br />+	}<br />+	GETNEXT<br />+	CASE('\n', normal);<br />+	CASE('_', if_middle);<br />+	if (current &gt;= 'a' &amp;&amp; current &lt;= 'z')<br />+		goto if_middle;<br />+	if (current &lt; 'A' || current &gt; 'Z')<br />+		goto if_start;<br />+if_middle:<br />+	GETNEXT<br />+	CASE('\n', normal);<br />+	CASE('_', if_middle);<br />+	if (current &gt;= 'a' &amp;&amp; current &lt;= 'z')<br />+		goto if_middle;<br />+	if (current &lt; 'A' || current &gt; 'Z')<br />+		goto if_start;<br />+	goto if_middle;<br />+	}<br />+	munmap(map, st.st_size);<br />+	if (hasdep)<br />+		puts(command);<br />+}<br />+<br />+int main(int argc, char **argv)<br />+{<br />+	int len;<br />+	char * hpath;<br />+<br />+	hpath = getenv("HPATH");<br />+	if (!hpath)<br />+		hpath = "/usr/src/linux/include";<br />+	len = strlen(hpath);<br />+	memcpy(path_array[0].buffer, hpath, len);<br />+	if (len &amp;&amp; hpath[len-1] != '/') {<br />+		path_array[0].buffer[len] = '/';<br />+		len++;<br />+	}<br />+	path_array[0].buffer[len] = '\0';<br />+	path_array[0].len = len;<br />+<br />+	while (--argc &gt; 0) {<br />+		int len;<br />+		char *name = *++argv;<br />+<br />+		filename = name;<br />+		len = strlen(name);<br />+		memcpy(depname, name, len+1);<br />+		command = __depname;<br />+		if (len &gt; 2 &amp;&amp; name[len-2] == '.') {<br />+			switch (name[len-1]) {<br />+				case 'c':<br />+				case 'S':<br />+					depname[len-1] = 'o';<br />+					command = "";<br />+			}<br />+		}<br />+		needsconfig = hasconfig = hasdep = 0;<br />+		do_depend();<br />+	}<br />+	return 0;<br />+}<br />-----<br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
