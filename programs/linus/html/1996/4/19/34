    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/4/19/18">First message in thread</a></li><li><a href="/lkml/1996/4/19/18"> Andries.Brouwer&#64;cwi ...</a><ul><li class="origin"><a href="/lkml/1996/4/19/68">Linus Torvalds</a><ul><li><a href="/lkml/1996/4/19/68">Matthew Lepper</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/1996/4/19/34/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 19 Apr 1996 15:19:59 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Ext2 Problem</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">&gt; I could have a look at it tonight, postponing the SCSI patch by a day.<br />&gt; Sounds a bit messy, however, especially if the fs turns out to be non-minix<br />&gt; and we have to undo/invalidate all that was done.<br />&gt; This is a very minor problem (strange, nobody ever complained that I<br />&gt; noticed, and now we have three cases in one week) and not worth a lot of<br />&gt; code. <br /><br />Don't bother with the patch: I thinkI have something that does what I want.<br />It's untested, but maybe somebody could try this out?<br /><br />This patch essentially makes the minix mount operation do a lot more checks<br />before it accepts the filesystem as a real minix filesystem. It checks that the<br />root inode really is a directory, and then it reads the first block of the root<br />directory and checks that "." and ".." exist, and have the right inode numbers.<br /><br />While doing that it also checks how far apart they are, giving us the directory<br />entry size.. The funny thing is that while I was doing this, a m68k patch came<br />in that did some of this but not as complete..<br /><br />I don't actually have any minix filesystems left, so could somebody else test<br />this out?  Preferably somebody who has a filesystem that can be confused with<br />something else..<br /><br />		Linusdiff -u --recursive --new-file v1.3.91/linux/Makefile linux/Makefile<br />--- v1.3.91/linux/Makefile	Fri Apr 19 10:07:57 1996<br />+++ linux/Makefile	Fri Apr 19 07:35:35 1996<br />&#64;&#64; -1,6 +1,6 &#64;&#64;<br /> VERSION = 1<br /> PATCHLEVEL = 3<br />-SUBLEVEL = 91<br />+SUBLEVEL = 92<br /> <br /> ARCH = i386<br /> <br />diff -u --recursive --new-file v1.3.91/linux/arch/alpha/defconfig linux/arch/alpha/defconfig<br />--- v1.3.91/linux/arch/alpha/defconfig	Mon Apr 15 12:20:17 1996<br />+++ linux/arch/alpha/defconfig	Fri Apr 19 10:51:45 1996<br />&#64;&#64; -75,6 +75,7 &#64;&#64;<br /> # CONFIG_IPX is not set<br /> # CONFIG_ATALK is not set<br /> # CONFIG_AX25 is not set<br />+# CONFIG_BRIDGE is not set<br /> # CONFIG_NETLINK is not set<br /> <br /> #<br />&#64;&#64; -106,6 +107,7 &#64;&#64;<br /> # CONFIG_SCSI_AHA1740 is not set<br /> # CONFIG_SCSI_AIC7XXX is not set<br /> # CONFIG_SCSI_BUSLOGIC is not set<br />+# CONFIG_SCSI_DTC3280 is not set<br /> # CONFIG_SCSI_EATA_DMA is not set<br /> # CONFIG_SCSI_EATA_PIO is not set<br /> # CONFIG_SCSI_U14_34F is not set<br />&#64;&#64; -114,6 +116,7 &#64;&#64;<br /> CONFIG_SCSI_NCR53C7xx=y<br /> CONFIG_SCSI_NCR53C7xx_sync=y<br /> CONFIG_SCSI_NCR53C7xx_FAST=y<br />+# CONFIG_SCSI_NCR53C7xx_DISCONNECT is not set<br /> # CONFIG_SCSI_IN2000 is not set<br /> # CONFIG_SCSI_PAS16 is not set<br /> # CONFIG_SCSI_QLOGIC is not set<br />&#64;&#64; -134,6 +137,7 &#64;&#64;<br /> # CONFIG_SLIP is not set<br /> # CONFIG_PPP is not set<br /> # CONFIG_STRIP is not set<br />+# CONFIG_WIC is not set<br /> # CONFIG_SCC is not set<br /> # CONFIG_PLIP is not set<br /> # CONFIG_EQUALIZER is not set<br />diff -u --recursive --new-file v1.3.91/linux/arch/alpha/mm/fault.c linux/arch/alpha/mm/fault.c<br />--- v1.3.91/linux/arch/alpha/mm/fault.c	Tue Mar 12 15:31:10 1996<br />+++ linux/arch/alpha/mm/fault.c	Fri Apr 19 13:28:06 1996<br />&#64;&#64; -18,6 +18,22 &#64;&#64;<br /> #include &lt;asm/system.h&gt;<br /> #include &lt;asm/segment.h&gt;<br /> #include &lt;asm/pgtable.h&gt;<br />+#include &lt;asm/mmu_context.h&gt;<br />+<br />+unsigned long asn_cache = ASN_FIRST_VERSION;<br />+<br />+#ifndef BROKEN_ASN<br />+/*<br />+ * Select a new ASN and reload the context. This is<br />+ * not inlined as this expands to a pretty large<br />+ * function.<br />+ */<br />+void get_new_asn_and_reload(struct task_struct *tsk, struct mm_struct *mm)<br />+{<br />+	get_new_mmu_context(tsk, mm, asn_cache);<br />+	reload_context(tsk);<br />+}<br />+#endif<br /> <br /> extern void die_if_kernel(char *,struct pt_regs *,long);<br /> <br />diff -u --recursive --new-file v1.3.91/linux/arch/i386/kernel/process.c linux/arch/i386/kernel/process.c<br />--- v1.3.91/linux/arch/i386/kernel/process.c	Fri Apr 12 15:51:46 1996<br />+++ linux/arch/i386/kernel/process.c	Fri Apr 19 07:35:25 1996<br />&#64;&#64; -266,6 +266,22 &#64;&#64;<br /> <br /> 	for (i=0 ; i&lt;8 ; i++)<br /> 		current-&gt;debugreg[i] = 0;<br />+<br />+	/*<br />+	 * Forget coprocessor state..<br />+	 */<br />+#ifdef __SMP__<br />+	if (current-&gt;flags &amp; PF_USEDFPU) {<br />+		stts();<br />+	}<br />+#else<br />+	if (last_task_used_math == current) {<br />+		last_task_used_math = NULL;<br />+		stts();<br />+	}<br />+#endif<br />+	current-&gt;used_math = 0;<br />+	current-&gt;flags &amp;= PF_USEDFPU;<br /> }<br /> <br /> void release_thread(struct task_struct *dead_task)<br />diff -u --recursive --new-file v1.3.91/linux/fs/exec.c linux/fs/exec.c<br />--- v1.3.91/linux/fs/exec.c	Mon Apr  8 19:01:44 1996<br />+++ linux/fs/exec.c	Fri Apr 19 07:35:25 1996<br />&#64;&#64; -436,9 +436,6 &#64;&#64;<br /> 		if (FD_ISSET(i,&amp;current-&gt;files-&gt;close_on_exec))<br /> 			sys_close(i);<br /> 	FD_ZERO(&amp;current-&gt;files-&gt;close_on_exec);<br />-	if (last_task_used_math == current)<br />-		last_task_used_math = NULL;<br />-	current-&gt;used_math = 0;<br /> }<br /> <br /> /* <br />diff -u --recursive --new-file v1.3.91/linux/fs/minix/inode.c linux/fs/minix/inode.c<br />--- v1.3.91/linux/fs/minix/inode.c	Mon Jan 15 07:59:11 1996<br />+++ linux/fs/minix/inode.c	Fri Apr 19 15:07:22 1996<br />&#64;&#64; -117,6 +117,50 &#64;&#64;<br /> 	return 0;<br /> }<br /> <br />+/*<br />+ * Check the root directory of the filesystem to make sure<br />+ * it really _is_ a minix filesystem, and to check the size<br />+ * of the directory entry.<br />+ */<br />+static const char * minix_checkroot(struct super_block *s)<br />+{<br />+	struct inode * dir;<br />+	struct buffer_head *bh;<br />+	struct minix_dir_entry *de;<br />+	const char * errmsg;<br />+	int dirsize;<br />+<br />+	dir = s-&gt;s_mounted;<br />+	if (!S_ISDIR(dir-&gt;i_mode))<br />+		return "root directory is not a directory";<br />+<br />+	bh = minix_bread(dir, 0, 0);<br />+	if (!bh)<br />+		return "unable to read root directory";<br />+<br />+	de = (struct minix_dir_entry *) bh-&gt;b_data;<br />+	errmsg = "bad root directory '.' entry";<br />+	dirsize = BLOCK_SIZE;<br />+	if (de-&gt;inode == MINIX_ROOT_INO &amp;&amp; strcmp(de-&gt;name, ".") == 0) {<br />+		errmsg = "bad root directory '..' entry";<br />+		dirsize = 8;<br />+	}<br />+<br />+	while ((dirsize &lt;&lt;= 1) &lt; BLOCK_SIZE) {<br />+		de = (struct minix_dir_entry *) (bh-&gt;b_data + dirsize);<br />+		if (de-&gt;inode != MINIX_ROOT_INO)<br />+			continue;<br />+		if (strcmp(de-&gt;name, ".."))<br />+			continue;<br />+		s-&gt;u.minix_sb.s_dirsize = dirsize;<br />+		s-&gt;u.minix_sb.s_namelen = dirsize - 2;<br />+		errmsg = NULL;<br />+		break;<br />+	}<br />+	brelse(bh);<br />+	return errmsg;<br />+}<br />+<br /> struct super_block *minix_read_super(struct super_block *s,void *data, <br /> 				     int silent)<br /> {<br />&#64;&#64; -124,6 +168,7 &#64;&#64;<br /> 	struct minix_super_block *ms;<br /> 	int i, block;<br /> 	kdev_t dev = s-&gt;s_dev;<br />+	const char * errmsg;<br /> <br /> 	if (32 != sizeof (struct minix_inode))<br /> 		panic("bad V1 i-node size");<br />&#64;&#64; -186,6 +231,15 &#64;&#64;<br /> 		s-&gt;u.minix_sb.s_imap[i] = NULL;<br /> 	for (i=0;i &lt; MINIX_Z_MAP_SLOTS;i++)<br /> 		s-&gt;u.minix_sb.s_zmap[i] = NULL;<br />+	if (s-&gt;u.minix_sb.s_zmap_blocks &gt; MINIX_Z_MAP_SLOTS) {<br />+		s-&gt;s_dev = 0;<br />+		unlock_super (s);<br />+		brelse (bh);<br />+		if (!silent)<br />+			printk ("MINIX-fs: filesystem too big\n");<br />+		MOD_DEC_USE_COUNT;<br />+		return NULL;<br />+	}<br /> 	block=2;<br /> 	for (i=0 ; i &lt; s-&gt;u.minix_sb.s_imap_blocks ; i++)<br /> 		if ((s-&gt;u.minix_sb.s_imap[i]=bread(dev,block,BLOCK_SIZE)) != NULL)<br />&#64;&#64; -219,10 +273,23 &#64;&#64;<br /> 	if (!s-&gt;s_mounted) {<br /> 		s-&gt;s_dev = 0;<br /> 		brelse(bh);<br />-		printk("MINIX-fs: get root inode failed\n");<br />+		if (!silent)<br />+			printk("MINIX-fs: get root inode failed\n");<br /> 		MOD_DEC_USE_COUNT;<br /> 		return NULL;<br /> 	}<br />+<br />+	errmsg = minix_checkroot(s);<br />+	if (errmsg) {<br />+		if (!silent)<br />+			printk("MINIX-fs: %s\n", errmsg);<br />+		iput (s-&gt;s_mounted);<br />+		s-&gt;s_dev = 0;<br />+		brelse (bh);<br />+		MOD_DEC_USE_COUNT;<br />+		return NULL;<br />+	}<br />+<br /> 	if (!(s-&gt;s_flags &amp; MS_RDONLY)) {<br /> 		ms-&gt;s_state &amp;= ~MINIX_VALID_FS;<br /> 		mark_buffer_dirty(bh, 1);<br />&#64;&#64; -314,7 +381,7 &#64;&#64;<br /> 	return tmp;<br /> }<br /> <br />-int V2_minix_bmap(struct inode * inode,int block)<br />+static int V2_minix_bmap(struct inode * inode,int block)<br /> {<br /> 	int i;<br /> <br />diff -u --recursive --new-file v1.3.91/linux/fs/nfs/nfsroot.c linux/fs/nfs/nfsroot.c<br />--- v1.3.91/linux/fs/nfs/nfsroot.c	Wed Apr 17 09:06:32 1996<br />+++ linux/fs/nfs/nfsroot.c	Fri Apr 19 09:19:53 1996<br />&#64;&#64; -90,6 +90,7 &#64;&#64;<br /> #include &lt;net/route.h&gt;<br /> #include &lt;net/sock.h&gt;<br /> <br />+#include &lt;asm/segment.h&gt;<br /> <br /> /* Range of privileged ports */<br /> #define STARTPORT	600<br />diff -u --recursive --new-file v1.3.91/linux/fs/super.c linux/fs/super.c<br />--- v1.3.91/linux/fs/super.c	Mon Apr 15 12:20:21 1996<br />+++ linux/fs/super.c	Fri Apr 19 08:21:49 1996<br />&#64;&#64; -796,6 +796,8 &#64;&#64;<br /> 	vma = find_vma(current, (unsigned long) data);<br /> 	if (!vma || (unsigned long) data &lt; vma-&gt;vm_start)<br /> 		return -EFAULT;<br />+	if (!(vma-&gt;vm_flags &amp; VM_READ))<br />+		return -EFAULT;<br /> 	i = vma-&gt;vm_end - (unsigned long) data;<br /> 	if (PAGE_SIZE &lt;= (unsigned long) i)<br /> 		i = PAGE_SIZE-1;<br />diff -u --recursive --new-file v1.3.91/linux/include/asm-alpha/mmu_context.h linux/include/asm-alpha/mmu_context.h<br />--- v1.3.91/linux/include/asm-alpha/mmu_context.h	Thu Feb 29 08:59:44 1996<br />+++ linux/include/asm-alpha/mmu_context.h	Fri Apr 19 13:28:06 1996<br />&#64;&#64; -36,12 +36,32 &#64;&#64;<br /> #define MAX_ASN 127<br /> #else<br /> #define MAX_ASN 63<br />+#define BROKEN_ASN 1<br /> #endif<br /> <br />+extern unsigned long asn_cache;<br />+<br /> #define ASN_VERSION_SHIFT 16<br /> #define ASN_VERSION_MASK ((~0UL) &lt;&lt; ASN_VERSION_SHIFT)<br /> #define ASN_FIRST_VERSION (1UL &lt;&lt; ASN_VERSION_SHIFT)<br /> <br />+extern inline void get_new_mmu_context(struct task_struct *p,<br />+	struct mm_struct *mm,<br />+	unsigned long asn)<br />+{<br />+	/* check if it's legal.. */<br />+	if ((asn &amp; ~ASN_VERSION_MASK) &gt; MAX_ASN) {<br />+		/* start a new version, invalidate all old asn's */<br />+		tbiap(); imb();<br />+		asn = (asn &amp; ASN_VERSION_MASK) + ASN_FIRST_VERSION;<br />+		if (!asn)<br />+			asn = ASN_FIRST_VERSION;<br />+	}<br />+	asn_cache = asn + 1;<br />+	mm-&gt;context = asn;			/* full version + asn */<br />+	p-&gt;tss.asn = asn &amp; ~ASN_VERSION_MASK;	/* just asn */<br />+}<br />+<br /> /*<br />  * NOTE! The way this is set up, the high bits of the "asn_cache" (and<br />  * the "mm-&gt;context") are the ASN _version_ code. A version of 0 is<br />&#64;&#64; -55,28 +75,14 &#64;&#64;<br />  */<br /> extern inline void get_mmu_context(struct task_struct *p)<br /> {<br />-#ifdef CONFIG_ALPHA_EV5<br />-	static unsigned long asn_cache = ASN_FIRST_VERSION;<br />+#ifndef BROKEN_ASN<br /> 	struct mm_struct * mm = p-&gt;mm;<br /> <br /> 	if (mm) {<br />-		unsigned long asn = mm-&gt;context;<br />+		unsigned long asn = asn_cache;<br /> 		/* Check if our ASN is of an older version and thus invalid */<br />-		if ((asn_cache ^ asn) &amp; ASN_VERSION_MASK) {<br />-			/* get a new asn of the current version */<br />-			asn = asn_cache++;<br />-			/* check if it's legal.. */<br />-			if ((asn &amp; ~ASN_VERSION_MASK) &gt; MAX_ASN) {<br />-				/* start a new version, invalidate all old asn's */<br />-				tbiap(); imb();<br />-				asn_cache = (asn_cache &amp; ASN_VERSION_MASK) + ASN_FIRST_VERSION;<br />-				if (!asn_cache)<br />-					asn_cache = ASN_FIRST_VERSION;<br />-				asn = asn_cache++;<br />-			}<br />-			mm-&gt;context = asn;			/* full version + asn */<br />-			p-&gt;tss.asn = asn &amp; ~ASN_VERSION_MASK;	/* just asn */<br />-		}<br />+		if ((mm-&gt;context ^ asn) &amp; ASN_VERSION_MASK)<br />+			get_new_mmu_context(p, mm, asn);<br /> 	}<br /> #endif<br /> }<br />diff -u --recursive --new-file v1.3.91/linux/include/asm-alpha/pgtable.h linux/include/asm-alpha/pgtable.h<br />--- v1.3.91/linux/include/asm-alpha/pgtable.h	Wed Apr  3 16:06:56 1996<br />+++ linux/include/asm-alpha/pgtable.h	Fri Apr 19 13:38:28 1996<br />&#64;&#64; -10,6 +10,7 &#64;&#64;<br />  */<br /> <br /> #include &lt;asm/system.h&gt;<br />+#include &lt;asm/mmu_context.h&gt;<br /> <br /> /* Caches aren't brain-dead on the alpha. */<br /> #define flush_cache_all()			do { } while (0)<br />&#64;&#64; -19,11 +20,63 &#64;&#64;<br /> #define flush_page_to_ram(page)			do { } while (0)<br /> <br /> /*<br />+ * Force a context reload. This is needed when we<br />+ * change the page table pointer or when we update<br />+ * the ASN of the current process.<br />+ */<br />+static inline void reload_context(struct task_struct *task)<br />+{<br />+	__asm__ __volatile__(<br />+		"bis %0,%0,$16\n\t"<br />+		"call_pal %1"<br />+		: /* no outputs */<br />+		: "r" (&amp;task-&gt;tss), "i" (PAL_swpctx)<br />+		: "$0", "$1", "$16", "$22", "$23", "$24", "$25");<br />+}<br />+<br />+/*<br />+ * Use a few helper functions to hide the ugly broken ASN<br />+ * numbers on early alpha's (ev4 and ev45)<br />+ */<br />+#ifdef BROKEN_ASN<br />+<br />+#define flush_tlb_current(x) tbiap()<br />+#define flush_tlb_other(x) do { } while (0)<br />+<br />+#else<br />+<br />+extern void get_new_asn_and_reload(struct task_struct *, struct mm_struct *);<br />+<br />+#define flush_tlb_current(mm) get_new_asn_and_reload(current, mm)<br />+#define flush_tlb_other(mm) do { (mm)-&gt;context = 0; } while (0)<br />+<br />+#endif<br />+<br />+/*<br />+ * Flush just one page in the current TLB set.<br />+ * We need to be very careful about the icache here, there<br />+ * is no way to invalidate a specific icache page..<br />+ */<br />+static inline void flush_tlb_current_page(struct mm_struct * mm,<br />+	struct vm_area_struct *vma,<br />+	unsigned long addr)<br />+{<br />+#ifdef BROKEN_ASN<br />+	tbi(2 + ((vma-&gt;vm_flags &amp; VM_EXEC) != 0), addr);<br />+#else<br />+	if (vma-&gt;vm_flags &amp; VM_EXEC)<br />+		flush_tlb_current(mm);<br />+	else<br />+		tbi(2, addr);<br />+#endif<br />+}<br />+<br />+/*<br />  * Flush current user mapping.<br />  */<br /> static inline void flush_tlb(void)<br /> {<br />-	tbiap();<br />+	flush_tlb_current(current-&gt;mm);<br /> }<br /> <br /> /*<br />&#64;&#64; -41,9 +94,9 &#64;&#64;<br /> static inline void flush_tlb_mm(struct mm_struct *mm)<br /> {<br /> 	if (mm != current-&gt;mm)<br />-		mm-&gt;context = 0;<br />+		flush_tlb_other(mm);<br /> 	else<br />-		tbiap();<br />+		flush_tlb_current(mm);<br /> }<br /> <br /> /*<br />&#64;&#64; -60,9 +113,9 &#64;&#64;<br /> 	struct mm_struct * mm = vma-&gt;vm_mm;<br /> <br /> 	if (mm != current-&gt;mm)<br />-		mm-&gt;context = 0;<br />+		flush_tlb_other(mm);<br /> 	else<br />-		tbi(2 + ((vma-&gt;vm_flags &amp; VM_EXEC) != 0), addr);<br />+		flush_tlb_current_page(mm, vma, addr);<br /> }<br /> <br /> /*<br />&#64;&#64; -72,10 +125,7 &#64;&#64;<br /> static inline void flush_tlb_range(struct mm_struct *mm,<br /> 	unsigned long start, unsigned long end)<br /> {<br />-	if (mm != current-&gt;mm)<br />-		mm-&gt;context = 0;<br />-	else<br />-		tbiap();<br />+	flush_tlb_mm(mm);<br /> }<br /> <br /> /* Certain architectures need to do special things when pte's<br />&#64;&#64; -291,12 +341,7 &#64;&#64;<br /> 	pgd_val(pgdir[PTRS_PER_PGD]) = pte_val(mk_pte((unsigned long) pgdir, PAGE_KERNEL));<br /> 	tsk-&gt;tss.ptbr = ((unsigned long) pgdir - PAGE_OFFSET) &gt;&gt; PAGE_SHIFT;<br /> 	if (tsk == current)<br />-		__asm__ __volatile__(<br />-			"bis %0,%0,$16\n\t"<br />-			"call_pal %1"<br />-			: /* no outputs */<br />-			: "r" (&amp;tsk-&gt;tss), "i" (PAL_swpctx)<br />-			: "$0", "$1", "$16", "$22", "$23", "$24", "$25");<br />+		reload_context(tsk);<br /> }<br /> <br /> #define PAGE_DIR_OFFSET(tsk,address) pgd_offset((tsk),(address))<br />diff -u --recursive --new-file v1.3.91/linux/net/ipv4/udp.c linux/net/ipv4/udp.c<br />--- v1.3.91/linux/net/ipv4/udp.c	Fri Apr 19 10:08:03 1996<br />+++ linux/net/ipv4/udp.c	Fri Apr 19 08:13:59 1996<br />&#64;&#64; -578,6 +578,7 &#64;&#64;<br /> 	if(uh_cache_sk==sk)<br /> 		udp_cache_zap();<br /> 	release_sock(sk);<br />+	sk-&gt;dead = 1;<br /> 	destroy_sock(sk);<br /> }<br /> </pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
