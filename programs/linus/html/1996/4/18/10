    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/4/17/157">First message in thread</a></li><li><a href="/lkml/1996/4/17/157">"J.J. Burgess"</a><ul><li><a href="/lkml/1996/4/17/167">"David S. Miller"</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li><li><a href="/lkml/1996/4/23/13">Michael B Herf</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/1996/4/18/10/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 18 Apr 1996 09:09:26 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Swapping algorithm</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 17 Apr 1996, David S. Miller wrote:<br />&gt; <br />&gt;    I believe that an improvement could be made to the swapping algorithm if <br />&gt;    it looks for large continuous areas of memory to throw out, rather than <br />&gt;    single pages, the reason for this is that the swapping drive will be much <br />&gt;    slower at gathering multiple single pages (i.e. 1 seek (10ms) 1 page <br />&gt;    transfer (4k / 4MB/s = 1ms)) is much slower than if the pages swapped <br />&gt;    were continuous in the process space. It would be good if this was in <br />&gt;    addition to LRU.<br />&gt; <br />&gt; Wheee... sounds a lot like what Larry McVoy suggested to Linus and<br />&gt; Stephen many moons ago.  I like it myself too, however Linus and<br />&gt; Stephen have some reservations about it.  mea culpa<br /><br />I don't like the approach, no.<br /><br />However, that doesn't mean that linux has to be stupid about swapping out <br />larger blocks of memory. The current setup is quite able to swap out <br />things as one _huge_ write request - both the memory management and the <br />device drivers support that kind of page-out.<br /><br />The reason you don't see large swap-outs is<br /> - the "get_swap_page()" function which allocates swap pages tries to <br />   cluster the pages, but it also does a kind of striping across disks, <br />   which will partly mean that the clustering gets scattered anyway if <br />   you have multiple swap devices.<br /> - much more importantly, try_to_swap_out() will try to swap out only one <br />   page at a time. It should not be very hard to make try_to_swap_out() <br />   do a small loop so that it tries to swap out a few contiguous<br />   (ie _virtuallly_ contiguous) pages if "p-&gt;swap_cnt" is large.<br /><br />Note that I'd be more than happy if somebody would like to look into <br />this, but you need to be aware that it's not one of the "obvious" parts <br />of the kernel, to say the least. Most importantly, try_to_swap_out() may <br />not sleep at inopportune times, because the process that it tries to swap <br />out might just disappear from under it if try_to_swap_out sleeps ;-)<br /><br />Umm.. If somebody wants to test, there is a rather simple way to do this, <br />and I'm appending patches which may or may not work. Totally untested, as <br />usual..  There are probably other issues here too, but somebody who knows <br />something about the mm layer may find this approach a good starting point.<br /><br />Essentially, instead of returning immediately when we find something to <br />swap out, we try to swap out multiple pages from the same process. The <br />"wait" behaviour is not very good, though (if wait is true, we should do <br />the wait at the very end of the swap-out not for each page).<br /><br />NOTE NOTE NOTE! Not only is this untested, it really isn't the "right" <br />way to fix the problem (this one does it in swap_out() instead of <br />try_to_swap_out()). This patch is _not_ going into my current kernel. <br />It's meant solely as a starting point if somebody wants to play around <br />with things.<br /><br />		Linus<br /><br />-----<br />--- /usr/src/linux/mm/vmscan.c	Fri Apr 12 09:49:48 1996<br />+++ experimental/mm/vmscan.c	Thu Apr 18 09:00:37 1996<br />&#64;&#64; -277,6 +277,7 &#64;&#64;<br /> 	static int swap_task;<br /> 	int loop, counter;<br /> 	struct task_struct *p;<br />+	int success = 0;<br /> <br /> 	counter = ((PAGEOUT_WEIGHT * nr_tasks) &gt;&gt; 10) &gt;&gt; priority;<br /> 	for(; counter &gt;= 0; counter--) {<br />&#64;&#64; -288,9 +289,9 &#64;&#64;<br /> 		while(1) {<br /> 			if (swap_task &gt;= NR_TASKS) {<br /> 				swap_task = 1;<br />-				if (loop)<br />+				if (loop || success)<br /> 					/* all processes are unswappable or already swapped out */<br />-					return 0;<br />+					return success;<br /> 				loop = 1;<br /> 			}<br /> <br />&#64;&#64; -299,6 +300,8 &#64;&#64;<br /> 				break;<br /> <br /> 			swap_task++;<br />+			if (success)<br />+				return success;<br /> 		}<br /> <br /> 		/*<br />&#64;&#64; -309,20 +312,27 &#64;&#64;<br /> 			   multiplying by (RSS / 1MB) */<br /> 			p-&gt;swap_cnt = AGE_CLUSTER_SIZE(p-&gt;mm-&gt;rss);<br /> 		}<br />-		if (!--p-&gt;swap_cnt)<br />+		if (!--p-&gt;swap_cnt) {<br /> 			swap_task++;<br />+			if (success)<br />+				break;<br />+		}<br /> 		switch (swap_out_process(p, dma, wait)) {<br /> 			case 0:<br />-				if (p-&gt;swap_cnt)<br />+				if (p-&gt;swap_cnt) {<br /> 					swap_task++;<br />+					if (success)<br />+						return success;<br />+				}<br /> 				break;<br /> 			case 1:<br />-				return 1;<br />+				success = 1;<br />+				/* fall through */<br /> 			default:<br /> 				break;<br /> 		}<br /> 	}<br />-	return 0;<br />+	return success;<br /> }<br /> <br /> /*<br />-----<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
