    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/4/11/44">First message in thread</a></li><li><a href="/lkml/1996/4/11/44">"Nicholas C. Weaver"</a><ul><li class="origin"><a href="/lkml/1996/4/13/1">Linus Torvalds</a><ul><li><a href="/lkml/1996/4/13/1">Robert L Krawitz</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 12 Apr 1996 09:32:13 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Tracing memory-&gt;memory copies in linux...</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">&gt; <br />&gt;      Does anyone have trace information on what fraction of the time<br />&gt; linux spends performing memory-&gt;memory copies, how big these copies are,<br />&gt; etc?  Or a pointer to what I need to know to get the information myself?<br /><br />Depending on what you do, the kernel may spend about 20% of the time in just a<br />loop that clears a page - you can get some statistics with the kernel profiler<br />code (I'm including my current silly profiling code as an attachement: enable<br />the code with a kernel command line of "profile=2" at the LILO prompt for any<br />reasonably new kernel).<br /><br />Note that most of the stuff is inlined, so you may see "do_no_page()" using up<br />lots of time, for example. That's not because do_no_page is inefficient (it<br />isn't), but simply because it ends up zeroing out the new bss pages it gives to<br />processes, and that takes time.. (my silly profile program has some capability<br />to do a instruction-by-instruction profile, but you need to compile in the<br />function name for the function you want to profile and then look at the profile<br />by hand (using gdb's "disassemble" to see the kernel code side by side with the<br />instruction profile).<br /><br />The profil.c file is based on somebody else's code, sorry for the lack of<br />attributions. I've fixed it to sort the output and do some other things better,<br />and it's almost usable if you know exactly what you're doing. You may need to<br />read the source code to know exactly what it does, though.<br /><br />Oh, if you want to reset the profiling info, just do a "echo &gt; /proc/profile",<br />then run the particular mix of programs you want to profile the kernel on, and<br />then run the profile.c program to parse the information..<br /><br />		Linus#include &lt;unistd.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;sys/fcntl.h&gt;<br />#include &lt;linux/autoconf.h&gt;<br /><br />#define prof_func "verify_area"<br /><br />#define BUFSIZE 1024<br /><br />#ifndef CONFIG_PROFILE_SHIFT<br />#define CONFIG_PROFILE_SHIFT 2<br />#endif<br /><br />struct entry {<br />	struct entry * next;<br />	unsigned long time;<br />	unsigned long address;<br />	char name[1];<br />};<br /><br />struct entry * list = NULL;<br /><br />void do_symbol(int time, unsigned long address, char * name)<br />{<br />	struct entry * entry = malloc(sizeof(struct entry) + strlen(name));<br />	struct entry ** tmp;<br /><br />	entry-&gt;time = time;<br />	entry-&gt;address = address;<br />	strcpy(entry-&gt;name, name + (*name == '_'));<br />	tmp = &amp;list;<br />	while (*tmp) {<br />		if ((*tmp)-&gt;time &gt; entry-&gt;time)<br />			break;<br />		tmp = &amp;(*tmp)-&gt;next;<br />	}<br />	entry-&gt;next = *tmp;<br />	*tmp = entry;<br />}<br /><br />void show_symbols(unsigned long total)<br />{<br />	struct entry * entry = list;<br /><br />	while (entry) {<br />		printf("%10u %5d.%02d%% %08x %s\n" ,<br />			entry-&gt;time,<br />			(entry-&gt;time*10000/total) / 100,<br />			(entry-&gt;time*10000/total) % 100,<br />			entry-&gt;address, entry-&gt;name);<br />		entry = entry-&gt;next;<br />	}<br />}<br /><br />/* If you do not speak Spanish:<br /> * valor_simbolo_actual: current_symbol_value<br /> * valor_simbolo_siguiente: next_symbol_value<br /> * simbolo_actual: current_symbol<br /> * next_symbol: next_symbol<br /> * leidos: read (past participle)<br /> * total: total<br />*/<br /><br />int main(void)<br />{<br />	int fp;<br />	FILE *kmap;<br />	int current_symbol_value , next_symbol_value;<br />	char current_symbol[80] , next_symbol[80];<br />	int has_read , total = 0, j;<br /><br />	fp = open("/proc/profile", O_RDONLY);<br />	if (fp &lt; 0) {<br />		perror("/proc/profile");<br />		exit(1);<br />	}<br />	kmap = fopen("/System.map","r");<br />	if (!kmap) {<br />		kmap = fopen("/usr/src/linux/System.map","r");<br />		if (!kmap) {<br />			perror("System.map");<br />			exit(1);<br />		}<br />	}<br />	fscanf(kmap , "%x %*s %s\n" , &amp;current_symbol_value , current_symbol );<br />	fscanf(kmap , "%x %*s %s\n" , &amp;next_symbol_value , next_symbol );<br />	puts(prof_func);<br /><br />	for (;;) {<br />		unsigned int buffer[(next_symbol_value - current_symbol_value) &gt;&gt; CONFIG_PROFILE_SHIFT];<br />		unsigned int tiempo = 0;<br /><br />		if (next_symbol_value == current_symbol_value) {<br />			strcpy(current_symbol, next_symbol);<br />			fscanf(kmap, "%x %*s %s\n", &amp;next_symbol_value, next_symbol);<br />			continue;<br />		}<br />		lseek (fp , sizeof(unsigned int)+current_symbol_value-0x100000 , SEEK_SET);<br />		has_read = read (fp , buffer , sizeof(buffer) );<br />		for ( j = 0 ; j &lt; has_read/sizeof(unsigned int) ; j++) {<br />			if (!strcmp(prof_func, current_symbol))<br />				printf("%08x %d\n", j*4+current_symbol_value, buffer[j]);<br />			tiempo += buffer[j];<br />		}<br />		if (tiempo != 0) {<br />			do_symbol(tiempo, current_symbol_value, current_symbol);<br />			total += tiempo;<br />		}<br />		if (has_read &lt; (next_symbol_value -current_symbol_value)<br />				&gt;&gt; CONFIG_PROFILE_SHIFT * sizeof(unsigned long) || <br />			next_symbol_value == current_symbol_value )<br />			break;<br />		strcpy ( current_symbol , next_symbol );<br />		current_symbol_value = next_symbol_value;<br />		fscanf(kmap , "%x %*s %s\n" , &amp;next_symbol_value , next_symbol );<br />	}<br />	do_symbol(total, 0, "total");<br />	show_symbols(total);<br />	return(0);<br />}<br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
