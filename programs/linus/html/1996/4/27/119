    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/4/27/119">First message in thread</a></li><li class="origin"><a href="/lkml/1996/4/29/115">Linus Torvalds</a><ul><li><a href="/lkml/1996/4/29/115">Matthias Urlichs</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 27 Apr 1996 11:53:17 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Kernel panic debugging (was Re: 1.3.95 is not stable)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 26 Apr 1996, Joe wrote:<br />&gt;<br />&gt; &gt; [ my kernel disassembly and code corruption oratory ]<br />&gt; <br />&gt; HOW do you do this?  Sure, I know it's your beast, but it seems<br />&gt; kind of strange to know the conversion from/to x86 machine language,<br />&gt; assembly, and C offhand. <br />&gt; <br />&gt; Any tricks we don't know about? :)<br /><br />The main trick is having 5 years of experience with those pesky oops <br />messages ;-)<br /><br />Actually, there are things you can do that make this easier. I have two <br />separate approached:<br /><br />	gdb /usr/src/linux/vmlinux<br />	gdb&gt; disassemble &lt;offending_function&gt;<br /><br />That's the easy way to find the problem, at least if the bug-report is <br />well made (like this one was - run through ksymoops to get the <br />information of which function and the offset in the function that it <br />happened in).<br /><br />Oh, it helps if the report happens on a kernel that is compiled with the <br />same compiler and similar setups.<br /><br />The other thing to do is disassemble the "Code:" part of the bugreprot: <br />ksymoops will do this too with the correct tools (and new version of <br />ksymoops), but if you don't have the tools you can just do a silly <br />program:<br /><br />	char str[] = "\xXX\xXX\xXX...";<br />	main(){}<br /><br />and compile it with gcc -g and then do "disassemble str" (where the "XX" <br />stuff are the values reported by the Oops - you can just cut-and-paste <br />and do a replace of spaces to "\x" - that's what I do, as I'm too lazy <br />to write a prigram to automate this all).<br /><br />Finally, if you want to see where the code comes from, you can do<br /><br />	cd /usr/src/linux<br />	make fs/buffer.s 	# or whatever file the bug happened in<br /><br />and then you get a better idea of what happens than with the gdb <br />disassembly.<br /><br />Now, the trick is just then to combine all the data you have: the C <br />sources (and general knowledge of what it _should_ do, the assembly <br />listing and the code disassembly (and additionally the register dump you <br />also get from the "oops" message - that can be useful to see _what_ the <br />corrupted pointers were, and when you have the assembler listing you can <br />also match the other registers to whatever C expressions they were used <br />for).<br /><br />Essentially, you just look at what doesn't match (in this case it was the <br />"Code" disassembly that didn't match with what the compiler generated). <br />Then you need to find out _why_ they don't match. Often it's simple - you <br />see that the code uses a NULL pointer and then you look at the code and <br />wonder how the NULL pointer got there, and if it's a valid thing to do <br />you just check against it..<br /><br />Now, if somebody gets the idea that this is time-consuming and requires <br />some small amount of concentration, you're right. Which is why I will <br />mostly just ignore any panic reports that don't have the symbol table <br />info etc looked up: it simply gets too hard to look it up (I have some <br />programs to search for specific patterns in the kernel code segment, and <br />sometimes I have been able to look up those kinds of panics too, but <br />that really requires pretty good knowledge of the kernel just to be able <br />to pick out the right sequences etc..)<br /><br />_Sometimes_ it happens that I just see the disassembled code sequence <br />from the panic, and I know immediately where it's coming from. That's when <br />I get worried that I've been doing this for too long ;-)<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
