    </div></td><td width="32"> </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/4/23/52">First message in thread</a></li><li><a href="/lkml/1996/4/25/99">Linus Torvalds</a><ul><li><a href="/lkml/1996/4/26/48">root</a><ul><li><a href="/lkml/1996/4/26/70">root</a><ul><li><a href="/lkml/1996/4/28/80">Jos Vos</a></li></ul></li><li><a href="/lkml/1996/4/27/97">()</a></li></ul></li><li><a href="/lkml/1996/4/27/30">Robert Wuest</a></li><li><a href="/lkml/1996/4/27/88">Ben Wing</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/1996/4/27/37">Ben Wing</a></li><li><a href="/lkml/1996/4/28/27">Gerard Roudier</a><ul><li><a href="/lkml/1996/4/28/144">"Robert V. Schipper"</a></li></ul></li><li><a href="/lkml/1996/4/28/123">(Thomas Koenig)</a></li><li><a href="/lkml/1996/4/30/112">(Kai Henningsen)</a><ul><li><a href="/lkml/1996/5/3/7">(Kai Henningsen)</a></li></ul></li></ul></li><li><a href="/lkml/1996/4/28/90">(H. Peter Anvin)</a><ul><li><a href="/lkml/1996/4/27/92"> Andries.Brouwer&#64;cwi ...</a></li><li><a href="/lkml/1996/4/29/61">Matthew J Brown</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 26 Apr 1996 11:58:46 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: signal(SIGFPE,SIG_IGN), possible solution?</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 25 Apr 1996, Ben Wing wrote:<br />&gt; <br />&gt; Linus (who has obviously gotten a bit frazzled from working so hard<br />&gt; on the kernel lately) sees fit to rant:<br /><br />guilty as charged..<br /><br />&gt; You've sent this whole long flame, but completely missed the point<br />&gt; that I was *NOT* talking about division by zero, but rather about<br />&gt; overflow -- e.g. if I divide 0xFFFFFFFFFFFFFFFF (a 64-bit number)<br />&gt; by 0xFFFFFFF (a 28-bit number) using the idivl instruction, the<br />&gt; processor issues an exception because the result does not fit into<br />&gt; 32 bit, but takes 36 bits.  Returning MAX_INT here is NOT random --<br />&gt; it's the closest reasonable approximation.<br /><br />You don't see the problem, do you?<br /><br />I did notice that you were talking about overflow rather than division by <br />zero, but that doesn't really change anything. It's the same thing: do we <br />accept software that gives unpredictable results or not?<br /><br />For _you_ it is acceptable to get a rounding error.<br /><br />For somebody else it may not be. And the kernel has to assume the worst, <br />for the simple reason that it can't _tell_ what the program wants. I have <br />yet to add the ESP-driver to the kernel to read the mind of the user..<br /><br />&gt; And yes, I had considered longjmp()ing out of a signal handler.<br />&gt; However, this idivl instruction occurs HUNDREDS, maybe thousands,<br />&gt; of times in the renderer.  Can you imagine the pain involved in<br />&gt; ensuring there was a setjmp() everywhere?<br /><br />You don't need to do that. In fact, you don't _want_ to do that, for the <br />same reason you don't want to check the arguments to the division.<br /><br />Now, you're obviously using inline assembly or something, as I don't <br />think gcc will ever compile any division to do the 64/32-&gt;32 thing. If <br />you're ready to do that kind of thing, then you must be ready to play <br />around a bit in a signal handler or play with longjump.<br /><br />In a signal handler, you could even do<br /><br />	#include &lt;asm/sigcontext.h&gt;<br /><br />	void sigfpe_handler(int signr, struct sigcontext context)<br />	{<br />		fixup(&amp;context);<br />	}<br /><br />Where the "fixup()" routine does a disassembly of the %eip that faulted, <br />and jumps over it. (Depending on how you have written your inline macro, <br />you may know that the division is always done with a register, so then <br />the "fixup" can be as simple as just doing<br /><br />	context.eip += 2;<br />	context.eax = ~0;<br />	context.edx = ~0;<br /><br />and that's it..<br /><br />Notice that by NOT doing in the kernel, you win, because<br /> - your program can know when the overflow occurs, and in some cases <br />   that's important so that it can mark a certain pixel as having <br />   overflowed. <br /> - the kernel doesn't have to worry about what the user wants to do this <br />   time.<br /> - because you know what you're doing, you don't need to do extra work <br />   like the kernel would have had to (you can skip the disassembly, for <br />   example.<br /> - you have a chance in hell of porting your program to some other <br />   platform in the future (the linux signal stack bears a remarkable <br />   similarity to the IBCS2 standard x86 unix signal stack)<br /> - you can round the result any way _you_ want to. In fact, you can play <br />   games to make it very easy for youself by having a fixed sequence of <br />   instructions to handle it.<br /><br />And because you handle it youself, you have any flexibility you want to <br />with error handling. For example, you can make the fault handler jump to <br />some specified point in your function with something like this:<br /><br />	__label__ error_handler;<br />	__asm__("divl %2"<br />		:"=a" (low), "=d" (high)<br />		:"g" (divisor), "c" (&amp;&amp;error_handler))<br />	... do normal cases ...<br /><br />error_handler:<br />	... check against zero division or overflow, so whatever you want to ..<br /><br /><br />Then, your handler for SIGFPE needs only to do something like<br /><br />	context.eip = context.ecx;<br /><br />and there is no overhead at all for taking a fault and _knowing_ about it <br />for the normal case when you don't fault (well, the __asm__ statement <br />sets up %ecx to point to the fault handler, but thatäs one instruction <br />and one register, so it may well be worth it for you).<br /><br />In short, you've been barking up the wrong tree all the time. Instead of <br />trying to ignore SIGFPE which is arguably totally idiotic, you should <br />_handle_ them. If your application is speed critical, then the handling <br />might be something like the above (whcih is certainly not pretty, but at <br />least it's _clever_).<br /><br />And if it isn't _that_ speed critical, then you can do it portably right, <br />and use siglongjmp().<br /><br />Notice? By doing it in the user process, you have the _choice_, and you <br />can do it right. If Linux did it in the kernel, you could never do it <br />right for everybody..<br /><br />&gt; Do I REALLY have to set up my own signal handler that looked at<br />&gt; the assembly and stepped the program counter over the instruction?<br />&gt; Isn't that more than a bit absurd?<br /><br />"more than a bit absurd"?<br /><br />That's _exactly_ what you asked _me_ to do in the kernel.. How does it <br />feel to have the tables turned on you? <br /><br />You essentially asked me to do the same "absurd" thing, but for no real <br />reason, and from the kernel which is unpageable and where every little <br />piece of memory _stays_ in memory even though 99.95% of all programs <br />don't care or even _want_ this functionality..<br /><br />THAT is why I think people have no grip on reality on this thing. <br /><br />&gt; Is it braindamage if I expect that if I say 'signal (SIGFPE, SIG_IGN)'<br />&gt; then the machine will ignore the SIGFPE and continue in its merry<br />&gt; way?  If the only way to get this braindamage is to **explicitly<br />&gt; request it**, how can it possibly make all other programs unsafe?<br /><br />It's braindead, because you're confusing the act of handling a signal <br />with the act of _generating_ one.<br /><br />When your program does a "signal(SIGFPE, SIG_IGN)", that means that it <br />will ignore any signals sent to it, and the kernel honours that.<br /><br />That does not mean that the kernel should stop generating them (or try to <br />make the hardware stop generating them). You told the symptoms to go <br />away, but you didn't fix the problem - why do you expect the problem to <br />go away?<br /><br />Oh, btw, this discussion _has_ resulted in something. As of 1.3.96, the <br />kernel will totally ignore and override any signal blocking and/or <br />SIG_IGN for errors that it can't (or won't) recover from.<br /><br />  "My name is Linus Torvalds, you messed with my kernel, prepare to die"<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
