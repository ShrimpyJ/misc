    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/12/13/24">First message in thread</a></li><li><a href="/lkml/1996/12/13/24">Wolfram Gloger</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 13 Dec 1996 15:17:47 +0200 (EET)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Longstanding bug in tty_write/swap/nfs_readpage interaction</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br /><br />On Fri, 13 Dec 1996, Wolfram Gloger wrote:<br />&gt; <br />&gt; Ever since the asynchronous NFS client code was installed (sometime in<br />&gt; the 1.3.x series), I had modem getty processes (whose executables lie<br />&gt; on an NFS-mounted system) mysteriously hang in the disk wait state.<br />&gt; Now, I finally tracked down the problem.  write_chan() from the serial<br />&gt; driver code does:<br />&gt; <br />&gt; ...<br />&gt; 	add_wait_queue(&amp;tty-&gt;write_wait, &amp;wait);<br />&gt; 	while (1) {<br />&gt; 		current-&gt;state = TASK_INTERRUPTIBLE;<br />&gt; ...<br />&gt; 		if(...)<br />&gt; 		else<br />&gt; 			c = tty-&gt;driver.write(tty, 1, b, nr);<br />&gt; ...<br />&gt; 		schedule();<br />&gt; 	}<br />&gt; 	current-&gt;state = TASK_RUNNING;<br />&gt; 	remove_wait_queue(&amp;tty-&gt;write_wait, &amp;wait);<br /><br />This is correct.<br /><br />&gt; ...<br />&gt; <br />&gt; But when tty-&gt;driver.write() is rs_write(), it does a memcpy_fromfs()<br />&gt; (or whatever it is now called in 2.1; the problem probably remains the<br />&gt; same) which may have to swap-in a page via nfs_readpage(), which only<br />&gt; works when current-&gt;state is TASK_RUNNING (the asynchronous NFS code<br />&gt; calls schedule()).<br /><br />Hmm.. This looks like a bug in nfs_readpage(), or possibly the memory<br />management. The code above is correct, and these kinds of "lie and say<br />we're asleep" cases are needed to handle race conditions. Personally I<br />think this is a NFS problem - the page-read function shouldn't care about<br />process state details like TASK_RUNNING because reading a page isn't<br />really a "process" thing at all. <br /><br />Note that it's entirely ok to _return_ from the page fault with<br />TASK_RUNNING - that's why there is a while-loop and the task state set to<br />TASK_INTERRUPTIBLE. So one option is to just add<br /><br />	current-&gt;state = TASK_RUNNING;<br /><br />to the nfs page_read() function - or even better make the NFS page_read()<br />function totally unaware of these details.<br /><br />&gt; I've discussed this with Olaf Kirch, and he thinks that current-&gt;state<br />&gt; should possibly be only set _after_ calling the tty-&gt;driver.write()<br />&gt; handler, so as to maintain the invariant that every task can call<br />&gt; schedule() without looking at current-&gt;state first.<br /><br />No. That results in potential race conditions - a wake-up event that is<br />missed because it happens before we have gone to sleep but after we have<br />done some of the tests. The tty layer is correct, the bug is definitely in<br />the NFS layer (but it could also be "fixed" by just making the memory<br />management do the "current-&gt;state" stuff). <br /><br />&gt; But if the serial code isn't the only place where this situation can<br />&gt; occur, perhaps the NFS code needs to be changed.<br /><br />The tty code is definitely not the only palce, although the tty code does<br />happen to be one of the more usual cases where the wait-queues are used<br />like this. Also, more importantly, the whole idea with wait-queues is that<br />you can avoid races by "lying" and saying you're asleep a lot earlier than<br />you actually go to sleep, because that way you can catch wake-up events<br />over a longer timeframe and thus avoid race conditions. <br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
