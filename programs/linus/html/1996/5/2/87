    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/5/2/33">First message in thread</a></li><li><a href="/lkml/1996/5/2/33">(Tom May)</a><ul><li><a href="/lkml/1996/5/2/84">Alan Cox</a><ul><li><a href="/lkml/1996/5/3/31">Bryn Paul Arnold Jones</a></li></ul></li><li class="origin"><a href="/lkml/1996/5/3/18">Linus Torvalds</a><ul><li><a href="/lkml/1996/5/3/18">Tom May</a></li><li><a href="/lkml/1996/5/5/17">Bryn Paul Arnold Jones</a></li></ul></li><li><a href="/lkml/1996/5/3/10">Ingo Molnar</a></li><li><a href="/lkml/1996/5/3/48">"David S. Miller"</a></li><li><a href="/lkml/1996/5/3/54">Matthias Urlichs</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 2 May 1996 15:49:32 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Is clobber "memory" in include/asm-i386/system.h necessary?</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">&gt; In include/asm-i386/system.h there are numerous uses of __asm__ which<br />&gt; clobber "memory".  For reference, here they are:<br />&gt; <br />&gt; #define mb()  __asm__ __volatile__ (""   : : :"memory")<br />&gt; #define sti() __asm__ __volatile__ ("sti": : :"memory")<br />&gt; #define cli() __asm__ __volatile__ ("cli": : :"memory")<br />&gt; <br />&gt; #define save_flags(x) \<br />&gt; __asm__ __volatile__("pushfl ; popl %0":"=g" (x): /* no input */ :"memory")<br />&gt; <br />&gt; #define restore_flags(x) \<br />&gt; __asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory")<br />&gt; <br />&gt; #define iret() __asm__ __volatile__ ("iret": : :"memory")<br />&gt; <br />&gt; (Uh, iret() is never even used . . .)<br />&gt; <br />&gt; This clobber seems unnecessary since none of these instructions modify<br />&gt; memory that gcc doesn't know about, and any memory that is modified by<br />&gt; other means (hardware, interrupt handlers, etc.) is (should be?)<br />&gt; accounted for in other ways such as by using volatile.<br /><br />No, the memory clobber is _important_. The Sparc version didn't have it, and it<br />resulted in not-so-nice bugs.<br /><br />Essentially, think of the "memory" thing as a serializing flag rather than as a<br />"this instruction changes memory" flag. It is extremely important that gcc<br />_not_ re-order memory instructions across these serializing instructions,<br />because otherwise you might find that gcc moves a memory load over the<br />serializing instruction and then you lose (because you use a value that was<br />true _before_ interrupts were disabled)..<br /><br />Using "volatile" for any data structures that can be modified by interrupts etc<br />is also very broken, because then you take a noticeable performance hit because<br />then gcc can't do any optimizations _at_all_ with that variable (and see below<br />about more on the total braindamage of that whole approach).<br /><br />In short, it's much better to tell gcc not to optimize around these<br />instructions, so that it then can optimize safely everywhere else. It's like<br />the whole idea behind RISC: take a performance hit for the unusual case, but<br />optimize the normal case.<br /><br />&gt; As an experiment, I removed the clobbers, built a kernel, and it ran<br />&gt; fine (but if you try this at home, you will trigger the gcc common<br />&gt; subexpression elimination bug, so until it is fixed for real, your<br />&gt; kernel may or may not work).<br /><br />It will seem to work even without the memory clobber, but you'll have races you<br />don't even know about. It's just that you aren't aware of them, because they<br />happen very rarely (which makes them all the more insidious).<br /><br />&gt; So what's up with these clobbers?  If they aren't necessary, they<br />&gt; should be removed because they have a detrimental effect on code<br />&gt; generation.  If they are necessary, how about a comment explaining<br />&gt; why?<br /><br />Simple example, and one which actually bit the Sparc people:<br /><br />	int del_timer(struct timer_list * timer)  <br />	{<br />		int ret = 0;<br />		if (timer-&gt;next) {<br />	                unsigned long flags;<br />	                struct timer_list * next;<br />	                save_flags(flags);<br />	                cli();<br />	                if ((next = timer-&gt;next) != NULL) {<br />	                        (next-&gt;prev = timer-&gt;prev)-&gt;next = next;<br />	                        timer-&gt;next = timer-&gt;prev = NULL;<br />	                        ret = 1;<br />	                }<br />	                restore_flags(flags);<br />	        }<br />	        return ret;<br />	}<br /><br />Look at how this is done - we first check if "timer-&gt;next" is non-zero, and<br />only if it's non-zero do we bother to do the (expensive) linked list fixup.<br />Note that the expense is not so much the linked list handling in itself, as the<br />fact that we have to disable interrupts around it, and as we often call<br />"del_timer()" when something isn't on the timer list (the caller can't know<br />that before it tries to delete it), it makes sense to have a special fast case<br />for the case where we don't need to do anything.<br /><br />HOWEVER, if the interrupt setting stuff didn't force memory access<br />serialization, then gcc might (and does) cache the value of "timer-&gt;next"<br />across the interrupt disable, and that is definitely incorrect.<br /><br />Now, somebody is bound to say "volatile" here, but I refuse to use volatiles<br />because if the linked list entries were made volatile than gcc would be doing<br />lots of unnecessary things in _other_ places. Besides, "volatile" really<br />doesn't make any sense at all, and I think C would be better off without it.<br /><br />One reason I hate "volatile" is that using it for things that are changed by<br />interrupts is _fundamentally_ broken. And because I'm a real preacher, I'll<br />tell you all why:<br /><br /> - if you use a value that can change from under you with no warning, you're<br />    _asking_ for bugs. You should _always_ make sure you have locked the value<br />    down some way. Either by disabling interrupts, or by using semaphores or<br />    similar to enter a critical section. If you don't do that, you deserve to<br />    lose, and "volatile" doesn't buy you anything.<br /><br />Essentially, using "volatile" is a way of saying "yes, I know this code doesn't<br />work, but I hope the compiler will magically make the problem go away". People<br />like that should be shot on the spot.<br /><br />Right after this I have to mention a few exceptions to the rule: there _are_<br />two circumstances where using "volatile" is acceptable.<br /><br /> 1) for a clock. Look at "jiffies". The whole _idea_ with a clock is that it<br />    changes, and it's _ok_. A clock is not a linked list or anything like that.<br /> 2) For accessing hardware registers internally. No kernel code should do it<br />    (they should use "readb()" etc that should take care of it), but in that<br />    context it's ok. Again, for the same reason as in (1) - it's not a data<br />    structure, it's just a very special "value".<br /><br />Ok, enough preaching.  But the above hopefully explains why the interrupt<br />inline asm statements are marked as clobbering memory, and if you take a look<br />at the "mb()" statement and the use of that for "start_bh_atomic()" etc, you'll<br />see the same logic at work (without any other inline assembly at all).<br /><br />Essentially, you can think of the memory clobbers as barriers, and think of<br />"cli" and "sti" as<br /><br />	cli();<br />	barrier();<br /><br />and<br /><br />	barrier();<br />	sti();<br /><br />respectively.<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
