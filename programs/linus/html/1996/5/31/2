    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/5/30/54">First message in thread</a></li><li><a href="/lkml/1996/5/30/54">(really )</a><ul><li class="origin"><a href="/lkml/1996/5/31/54">Linus Torvalds</a><ul><li><a href="/lkml/1996/5/31/54">Craig Milo Rogers</a><ul><li><a href="/lkml/1996/6/1/4">Matthias Urlichs</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 31 May 1996 07:57:39 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: pre2.0.9 (was Re: CD-ROM Access Crashes)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On 30 May 1996, really kuznet&#64;ms2.inr.ac.ru wrote:<br />&gt; <br />&gt; Linus Torvalds (torvalds&#64;cs.helsinki.FI) wrote:<br />&gt; <br />&gt; : Note that you might want to try out #9 of the pre-2.0 series. There were<br />&gt; : still some problems in the generic read handling when errors occurred, and I<br />&gt; : hope those are finally fixed (knock wood - the code is certainly not trivial,<br />&gt; : and I haven't been able to test).<br />&gt; <br />&gt; It works!<br /><br />Ok, good.. And you found another buglet.<br /><br />&gt; Only one note on filemap_nopage:<br />&gt; <br />&gt; 	if (inode-&gt;i_op-&gt;readpage(inode, page) != 0)<br />&gt; 		goto failure;		       _<br />&gt; 	if (PageError(page))			|<br />&gt; 		goto failure;			|<br />&gt; 	if (PageUptodate(page))			|<br />&gt; 		goto success;			|<br />&gt; 						|<br />&gt; If it was block device, page is still locked at this moment and<br />&gt; flags can change at any moment (race condition!).<br />&gt; It is pretty silly to check them here,<br />&gt; they will be !error &amp;&amp; !uptodate (provided we have not<br />&gt; super-fast device 8))<br />&gt; If it was NFS, it is correct but ugly.<br />&gt; More clean solution is to use PG_error bit as bit triggering<br />&gt; synchronous readpage returning error code on failure,<br />&gt; rather than result of page operation and check it before readpage.<br /><br />No, we actually _have_ to call readpage regardless of any old <br />error-status, because the error might go away (maybe the error was due to <br />protection problems with the previous user, but now we're another person <br />so..).<br /><br />But you're right - this is a bug, and we just need to handle it correctly <br />like in generic_file_read: we need to do a "wait_on_page(page)" to make <br />sure the IO has actually completed (look at generic_file_read() which has <br />the same kind of setup, and does this right - doing a synchronous read <br />is not a performance problem because this happens only for the error <br />case anyway).<br /><br />In short, we shouldn't look at PageError() as being any kind of final error<br />condition - it can go away by retrying. Try it with NFS, first reading a file<br />as root (and getting a protection error back dur to root being mapped to<br />"nobody" on the server side), and then a bit later reading the file as the<br />real owner. <br /><br />Now, you may consider it a bad idea to do the readpage() on other devices <br />than NFS, because on them the protection state doesn't really change (all <br />the protection checks have already been done by the time we do the <br />physical read). However, even there it's the prudent thing to do - and as <br />this is not really in the "normal" flow of control anyway it doesn't <br />really hurt to try to re-read the disk in the hope that the error <br />condition has gone away.<br /><br />[ Umm, that showed another problem: brw_page() never cleared the error <br />  flag before the operation, so even if it _did_ succeed the next time <br />  around we wouldn't have gotten an error-free return ]<br /><br />Anyway, the code worked correctly for NFS (because the NFS code does the<br />readpage synchronously anyway for the error condition), and while it was<br />broken for disk IO it didn't really matter (because the error bit was always<br />set regadless of the operation).<br /><br />So the #9 code is slightly wrong, but it gets the right results anyway. But<br />if you want to have the right code, you need to add the "wait_on_page()" to<br />filemap_nopage(), and add a "clear_bit(PG_error, &amp;page-&gt;flags)" to brw_page<br />(the same place as we clear the uptodate flag). Could you check with <br />those fixes?<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
