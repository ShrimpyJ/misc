    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1996/5/2/1">First message in thread</a></li><li><a href="/lkml/1996/5/2/89">Linus Torvalds</a><ul><li><a href="/lkml/1996/5/3/20">Alan Cox</a></li><li><a href="/lkml/1996/5/3/57">(Wolfram Gloger)</a></li><li><a href="/lkml/1996/5/4/29">"Christopher J. Shaulis"</a><ul><li class="origin"><a href="/lkml/1996/5/11/17">Linus Torvalds</a><ul><li><a href="/lkml/1996/5/11/17">Tom May</a></li></ul></li></ul></li><li><a href="/lkml/1996/5/5/1">"Patrick J. LoPresti"</a></li><li><a href="/lkml/1996/5/6/20">(Ben Wing)</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 3 May 1996 11:54:37 +0300 (EET DST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: clone() and pthreads?</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 2 May 1996, Christopher J. Shaulis wrote:<br />&gt; <br />&gt; I'm actively experimenting with clone() threads on one of my personal<br />&gt; projects. The idea is to code a 3rd generation web server with<br />&gt; dedicated threads accepting/processing requests, sending the requested<br />&gt; objects to the requestor, and executing dynamicly loaded CGI "modules"<br />&gt; which live in the server's space. Thanks to Randy Chapman for helping<br />&gt; me organize my thoughts on it.<br /><br />Ok, it seems people _are_ experimenting with clone(). That's nice, I had <br />been starting to give up on it completely (I was originally hoping for a <br />threaded X server, but that never happened so now I have to hope that <br />somebody else comes up with a "worthwhile" threaded project).<br /><br />&gt; The biggest obsticle to doing things with clone() threads is the<br />&gt; complete lack of support. Neither X, libc, db, or anything else is<br />&gt; threadsafe out of the box.<br /><br />Indeed. It needs to be jump-started some way, and threads programming is <br />not exactly simple..<br /><br />&gt;						 And there are no<br />&gt; existing locking/syncronization functions -- though alan cox was nice<br />&gt; enough to assult me with a clue stick, and I'm trying to learn GAS's<br />&gt; asm syntax well enough to make an cmpxchg inline so I can make a<br />&gt; decent semaphore.<br /><br />Umm.. My suggestion for a semaphore would be something along these lines:<br /><br />	struct semaphore {<br />		long count;<br />		unsigned long waiting; /* bitmap of interested threads */<br />	};<br /><br />	__asm__("lock ; decl %0\n\t"		/* subtract one from sem-&gt;count */<br />		"jns 1f\n\t"			/* success? */<br />		"pushl %1\n\t"<br />		"jsr __wait_semaphore\n\t"<br />		"popl %1\n"<br />		"1:"<br />		:"=m" (sem-&gt;count)<br />		:"r" (sem)<br />		:"ax","dx","cx","memory");	/* clobbered by function call */<br /><br />It does an atomic decrement, and if the semaphore count goes negative it<br />calls a "__wait_semaphore" function that needs to be done carefully. But the<br />default case (lock successful) has very little overhead, and the case where<br />we need to sleep isn't that performance critical anyway (because by that time<br />we usually have to enter the kernel, so it's going to be expensive anyway). <br /><br />The unlock action would be something like this:<br /><br />	__asm__("lock ; incl %0"<br />		:"=m" (sem-&gt;count));<br />	if (sem-&gt;waiting)<br />		__wakeup_semaphore(sem);<br /><br />Again, the default case would be fast: a unlock of the semaphore when <br />nobody was waiting on us. The __wait_semaphore and __wakup_semaphore <br />functions are more complex, because they are the ones that really handle <br />race conditions, and it's important to do things in the correct order. <br />Something like<br /><br />	/*<br />	 * Silly implementation: threads must be numbered 0-31 due to<br />	 * the way we implement the wakeup thing<br />	 */<br />	void __wait_semaphore(struct semaphore * sem)<br />	{<br />		int threadnr = current_thread_number();<br />		sig_block(SIGUSR1); /* whatever we use to wake up a sleeper */<br />		/* tell any wakeups that we're waiting for the semaphore */<br />		set_bit(threadnr, &amp;sem-&gt;waiting);<br /><br />		/*<br />		 * increment the semaphore count - we decremented it to<br />		 * be negative before entering this routine..<br />		 */<br />	repeat:<br />		__asm__("lock ; incl %0":"=m" (sem-&gt;count));<br /><br />		/*<br />		 * Maybe the locker already unlocked before we blocked<br />		 * signals, so we can't depend on only the signal..<br />		 */<br />		if (sem-&gt;count &lt;= 0)<br />			sigsuspend(...);<br /><br />		/*<br />		 * Now "count" _should_ be positive, but maybe somebody else <br />		 * gets it before we do so we need to be careful<br />		 */<br />		__asm__("lock ; decl %0; js %1"<br />			:"=m" (sem-&gt;count),"=q" (negative));<br /><br />		if (negative)<br />			goto repeat;<br /><br />		/* Ok, we got the semaphore, remove us from the wait list */<br />		clear_bit(threadnr, &amp;sem-&gt;waiting);<br />	}<br /><br />And then __wakeup_semaphore() goes through the "waiting" bitmap and sends<br />signals to one of the waiting entries (you obviosuly need a pid &lt;-&gt;<br />threadnumber mapping there). Or something like this. <br /><br />Note: the above is written on the fly as I wrote this mail, so don't <br />expect it to work as-is. The exact semantics of "sigblock/suspend()" etc <br />escape my mind, and you most likely need to do some of the same playing <br />with the mind of gcc as the linux kernel does in asm-i386/atomic.h to <br />stop it from optimizing any of the "count" accesses, but maybe the above <br />is roughly usable. The main idea is that we try to avoid doing anything <br />at all when we can get the lock immediately (that makes __wait_semaphore <br />a bit more complex, but we don't want to enter the kernel for the "no <br />contention" case).<br /><br />There are also starvation issues, and it might make sense to _not_ <br />increment the semaphore counter before going to sleep, and force the <br />counter to be zero or negative until the wakeup code selects a process <br />(round-robin according to the "waiting" bitmask or whatever) that it <br />wakes up - the above is a rough draft and by no means perfect.<br /><br />&gt; The only real "problem" that I've noticed, and maybe its not even a<br />&gt; problem, is that when a thread's parent dies, the thread will continue<br />&gt; happily until it finds its own reason to die. I sorta expected a<br />&gt; dying process to take all its child threads with it.<br /><br />That's the intended behaviour of linux kernel threads - I wanted the <br />kernel threads to be really just a superset of normal processes. There is <br />no real distinction between a "process" and a "thread" in linux like <br />there is in most other environments with threads. In Linux a thread is a <br />first-class entity, so to say, and when the parent dies that doesn't <br />affect the children.<br /><br />For pthreads compliance, we obviously need some way to tell "original <br />parent died, all threads go away now please", but that should be done in <br />user level with "at_exit" or maybe a "super-parent" that waits for the <br />"pthreads" parent and then sends a SIGKILL to the other subthreads to get <br />the behaviour that other broken threading implementations have.<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
