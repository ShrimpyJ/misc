    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2012/9/14/99">First message in thread</a></li><li><a href="/lkml/2012/9/15/95">Alan Cox</a><ul><li><a href="/lkml/2012/9/16/2">Mike Galbraith</a><ul><li class="origin"><a href="/lkml/2012/9/17/65">Linus Torvalds</a><ul><li><a href="/lkml/2012/9/17/65">Mike Galbraith</a><ul><li><a href="/lkml/2012/9/17/148">Ingo Molnar</a></li></ul></li></ul></li><li><a href="/lkml/2012/9/19/178">Mike Galbraith</a><ul><li><a href="/lkml/2012/9/19/252">Ingo Molnar</a><ul><li><a href="/lkml/2012/9/19/263">Mike Galbraith</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 16 Sep 2012 12:57:00 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: 20% performance drop on PostgreSQL 9.2 from kernel 3.5.3 to 3.6-rc5 on AMD chipsets - bisected</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sat, Sep 15, 2012 at 9:35 PM, Mike Galbraith &lt;efault&#64;gmx.de&gt; wrote:<br />&gt;<br />&gt; Oh, while I'm thinking about it, there's another scenario that could<br />&gt; cause the select_idle_sibling() change to affect pgbench on largeish<br />&gt; packages, but it boils down to preemption odds as well.<br /><br />So here's a possible suggestion..<br /><br />Let's assume that the scheduler code to find the next idle CPU on the<br />package is actually a good idea, and we shouldn't mess with the idea.<br /><br />But at the same time, it's clearly an *expensive* idea, which is why<br />you introduced the "only test a single CPU buddy" approach instead.<br />But that didn't work, and you can come up with multiple reasons why it<br />wouldn't work. Plus, quite fundamentally, it's rather understandable<br />that "try to find an idle CPU on the same package" really would be a<br />good idea, right?<br /><br />So instead of limiting the "try to find an idle CPU on the same<br />package" to "pick *one* idle CPU on the same package to try", how<br />about just trying to make the whole "find another idle CPU" much<br />cheaper, and much more scalable that way?<br /><br />Quite frankly, the loop in select_idle_sibling() is insanely expensive<br />for what it really wants to do. All it really wants to do is:<br /> - iterate over idle processors on this package<br /> - make sure that idle processor is in the cpu's allowed.<br /><br />Right?<br /><br />But the whole use of "cpumask_intersects()" etc is quite expensive,<br />and there's that crazy double loop to do the above. So no wonder that<br />it's expensive and causes scalability problems. That would be<br />*especially* true if nr_cpumask_bits is big, and we have<br />CONFIG_CPUMASK_OFFSTACK defined.<br /><br />So I would suggest:<br /> (a) revert the original commit (already done in my tree)<br /> (b) look at just making the loop *much* cheaper.<br /><br />For example, all those "cpumask_intersects()" and "cpumask_first()"<br />things are *really* expensive, and expand to tons of code especially<br />for the OFFSTACK case (and aren't exactly free even for the smaller<br />case). And it really is all stupidly and badly done. I bet we can make<br />that code faster without really changing the  end result at all, just<br />changing the algorithm.<br /><br />For example, what if we got rid of all the crazy "sd groups" crap at<br />run-time, and just built a single linked circular list of CPU's on the<br />same package?<br /><br />Then we'd replace that crazy-expensive double loop over sd-&gt;groups and<br />for_each_cpu() crap (not to mention cpumask_first_and() etc) with just<br />a simple loop over that (and pick the *next* idle cpu, instead of<br />doing that crazy "pick first one in a bitmask after and'ing").<br /><br />In fact, looking at select_idle_sibling(), I just want to puke. The<br />thing is crazy.<br /><br />Why the hell isn't the *very* first thing that function does just a simple<br /><br />    if (idle_cpu(target))<br />        return target;<br /><br />instead it does totally f*cking insane things, and checks whether<br />"target == cpu &amp;&amp; idle_cpu(cpu)".<br /><br />The code is shit. Just fix the shit, instead of trying to come up with<br />some totally different model. Ok? I bet just fixing it to not have<br />insane double loops would already get 90% of the speedup that Mike's<br />original patch did, but without the downsides of having to pick just a<br />single idle-buddy.<br /><br />We might also possibly add a "look at SMT buddy first" case, because<br />Mike is probably right that bouncing all over the package isn't<br />necessarily a good idea unless we really need to. But that would be a<br />different thing.<br /><br />            Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
