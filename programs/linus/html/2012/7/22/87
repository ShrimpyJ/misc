    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2012/7/22/17">First message in thread</a></li><li><a href="/lkml/2012/7/22/17">Al Viro</a><ul><li class="origin"><a href="/lkml/2012/7/22/116">Linus Torvalds</a><ul><li><a href="/lkml/2012/7/22/116">Al Viro</a><ul><li><a href="/lkml/2012/7/23/17">Al Viro</a><ul><li><a href="/lkml/2012/7/23/27">Stephen Rothwell</a></li></ul></li><li><a href="/lkml/2012/7/23/57">Boaz Harrosh</a><ul><li><a href="/lkml/2012/7/23/86">Al Viro</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 22 Jul 2012 10:34:10 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [git pull] vfs.git; pile 1</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">I'm not pulling this until the mess with the NFS tree is sorted out.<br />Apparently you rebased your (public!) VFS tree, and now half of your<br />old pre-rebase patches are in the NFS tree.<br /><br />Rebasing public trees IS NOT A VALID OPERATION! Exactly because of<br />messes like this.<br /><br />So no. No way am I pulling a big VFS tree that apparently has random<br />unknown aliased commits in other trees.<br /><br />                  Linus<br /><br />On Sun, Jul 22, 2012 at 3:09 AM, Al Viro &lt;viro&#64;zeniv.linux.org.uk&gt; wrote:<br />&gt; This one is *big* and changes quite a few things around VFS.  What's in there:<br />&gt;<br />&gt;         * the first of two really major architecture changes - death to<br />&gt; open intents.  The former is finally there; it was very long in making,<br />&gt; but with Miklos getting through really hard and messy final push in<br />&gt; fs/namei.c, we finally have it.  Unlike his variant, this one doesn't<br />&gt; introduce struct opendata; what we have instead is -&gt;atomic_open()<br />&gt; taking preallocated struct file * and passing everything via its fields.<br />&gt; Instead of returning struct file *, it returns -E... on error, 0 on success<br />&gt; and 1 in "deal with it yourself" case (e.g. symlink found on server,<br />&gt; etc.).  See comments before fs/namei.c:atomic_open().  That made a lot of<br />&gt; goodies finally possible and quite a few are in that pile: -&gt;lookup(),<br />&gt; -&gt;d_revalidate() and -&gt;create() do not get struct nameidata * anymore;<br />&gt; -&gt;lookup() and -&gt;d_revalidate() get lookup flags instead, -&gt;create()<br />&gt; gets "do we want it exclusive" flag.  With the introduction of new helper<br />&gt; (kern_path_locked()) we are rid of all struct nameidata instances outside<br />&gt; of fs/namei.c; it's still visible in namei.h, but not for long.  Come the<br />&gt; next cycle, declaration will move either to fs/internal.h or to fs/namei.c<br />&gt; itself. [me, miklos, hch]<br />&gt;<br />&gt;         * the second major change: behaviour of final fput().  Now we<br />&gt; have __fput() done without any locks held by caller *and* not from deep<br />&gt; in call stack.  That obviously lifts a lot of constraints on the locking<br />&gt; in there.  Moreover, it's legal now to call fput() from atomic contexts<br />&gt; (which has immediately simplified life for aio.c).  We also don't need<br />&gt; anti-recursion logics in __scm_destroy() anymore.  There is a price,<br />&gt; though - the damn thing has become partially asynchronous.  For fput()<br />&gt; from normal process we are guaranteed that pending __fput() will be done<br />&gt; before the caller returns to userland, exits or gets stopped for ptrace.<br />&gt; For kernel threads and atomic contexts it's done via schedule_work(),<br />&gt; so theoretically we might need a way to make sure it's finished; so far<br />&gt; only one such place had been found, but there might be more.  There's<br />&gt; flush_delayed_fput() (do all pending __fput()) and there's __fput_sync()<br />&gt; (fput() analog doing __fput() immediately).  I hope we won't need them<br />&gt; often; see warnings in fs/file_table.c for details. [me, based on task_work<br />&gt; series from Oleg merged last cycle]<br />&gt;<br />&gt;         * sync series from Jan<br />&gt;<br />&gt;         * large part of "death to sync_supers()" work from Artem; the only<br />&gt; bits missing here are exofs and ext4 ones.  As far as I understand, those<br />&gt; are going via the exofs and ext4 trees resp.; once they are in, we can<br />&gt; put -&gt;write_super() to the rest, along with the thread calling it.<br />&gt;<br />&gt;         * preparatory bits from unionmount series (from dhowells).<br />&gt;<br />&gt;         * assorted cleanups and fixes all over the place, as usual.<br />&gt;<br />&gt; This is not the last pile for this cycle; there's at least jlayton's<br />&gt; ESTALE work and fsfreeze series (the latter - in dire need of<br />&gt; fixes, so I'm not sure it'll make the cut this cycle).  I'll<br />&gt; probably throw symlink/hardlink restrictions stuff from Kees into<br />&gt; the next pile, too.  Plus there's a lot of misc patches I hadn't<br />&gt; thrown into that one - it's large enough as it is...<br />&gt;<br />&gt; Please, pull from the usual place -<br />&gt; git://git.kernel.org/pub/scm/linux/kernel/git/viro/vfs.git for-linus<br />&gt;<br />&gt; Shortlog:<br />&gt; Al Viro (61):<br />&gt;       get rid of -&gt;mnt_longterm<br />&gt;       get rid of magic in proc_namespace.c<br />&gt;       qnx6: don't bother with -&gt;i_dentry in inode-freeing callback<br />&gt;       cifs: don't bother with -&gt;i_dentry in -&gt;destroy_inode()<br />&gt;       adfs: don't bother with -&gt;i_dentry in -&gt;destroy_inode()<br />&gt;       vfs: update documentation on -&gt;i_dentry handling<br />&gt;       affs: get rid of open-coded list_for_each_entry()<br />&gt;       affs: unobfuscate affs_fix_dcache()<br />&gt;       ocfs2: use list_for_each_entry in ocfs2_find_local_alias()<br />&gt;       ext4: get rid of open-coded d_find_any_alias()<br />&gt;       vfs: switch i_dentry/d_alias to hlist<br />&gt;       coda: use list_for_each_entry<br />&gt;       namei.c: let follow_link() do put_link() on failure<br />&gt;       -&gt;atomic_open() prototype change - pass int * instead of bool *<br />&gt;       don't modify od-&gt;filp at all<br />&gt;       make -&gt;atomic_open() return int<br />&gt;       kill opendata-&gt;{mnt,dentry}<br />&gt;       kill struct opendata<br />&gt;       fs/namei.c: get do_last() and friends return int<br />&gt;       make finish_no_open() return int<br />&gt;       switch do_dentry_open() to returning int<br />&gt;       fold __dentry_open() into its sole caller<br />&gt;       do_dentry_open(): take initialization of file-&gt;f_path to caller<br />&gt;       switch nfs_lookup_check_intent() away from nameidata<br />&gt;       nfs_lookup_verify_inode() - nd is *always* non-NULL here<br />&gt;       fs/nfs/dir.c: switch to passing nd-&gt;flags instead of nd wherever possible<br />&gt;       stop passing nameidata * to -&gt;d_revalidate()<br />&gt;       fs/namei.c: don't pass nameidata to d_revalidate()<br />&gt;       fs/namei.c: don't pass namedata to lookup_dcache()<br />&gt;       stop passing nameidata to -&gt;lookup()<br />&gt;       fs/namei.c: don't pass nameidata to __lookup_hash() and lookup_real()<br />&gt;       don't pass nameidata to -&gt;create()<br />&gt;       don't pass nameidata * to vfs_create()<br />&gt;       get rid of kern_path_parent()<br />&gt;       sysfs: switch to -&gt;s_d_op and -&gt;d_release()<br />&gt;       sysfs: just use d_materialise_unique()<br />&gt;       __d_unalias() should refuse to move mountpoints<br />&gt;       debugfs: make sure that debugfs_create_file() gets used only for regulars<br />&gt;       debugfs: fold debugfs_create_by_name() into the only caller<br />&gt;       debugfs: get rid of useless arguments to debugfs_{mkdir,symlink}<br />&gt;       mark_files_ro(): don't bother with mntget/mntput<br />&gt;       do_dentry_open(): close the race with mark_files_ro() in failure exit<br />&gt;       signal: make sure we don't get stopped with pending task_work<br />&gt;       trimming task_work: kill -&gt;data<br />&gt;       trim task_work: get rid of hlist<br />&gt;       merge task_work and rcu_head, get rid of separate allocation for keyring case<br />&gt;       move exit_task_work() past exit_files() et.al.<br />&gt;       deal with task_work callbacks adding more work<br />&gt;       switch fput to task_work_add<br />&gt;       aio: now fput() is OK from interrupt context; get rid of manual delayed __fput()<br />&gt;       get rid of -&gt;scm_work_list<br />&gt;       hold task_lock around checks in keyctl<br />&gt;       unobfuscate follow_up() a bit<br />&gt;       tidy up namei.c a bit<br />&gt;       don't expose I_NEW inodes via dentry-&gt;d_inode<br />&gt;       ecryptfs: don't reinvent the wheels, please - use struct completion<br />&gt;       zoran: don't bother with struct file * in zoran_map<br />&gt;       spufs: shift dget/mntget towards dentry_open()<br />&gt;       switch dentry_open() to struct path, make it grab references itself<br />&gt;       btrfs: switch btrfs_ioctl_balance() to mnt_want_write_file()<br />&gt;       ext4: switch EXT4_IOC_RESIZE_FS to mnt_want_write_file()<br />&gt;<br />&gt; Andrew Morton (1):<br />&gt;       notify_change(): check that i_mutex is held<br />&gt;<br />&gt; Artem Bityutskiy (23):<br />&gt;       affs: stop setting bm_flags<br />&gt;       affs: remove useless superblock writeout on unmount<br />&gt;       affs: remove useless superblock writeout on remount<br />&gt;       affs: re-structure superblock locking a bit<br />&gt;       affs: stop using lock_super<br />&gt;       affs: introduce VFS superblock object back-reference<br />&gt;       affs: get rid of affs_sync_super<br />&gt;       hfsplus: make hfsplus_sync_fs static<br />&gt;       hfsplus: amend debugging print<br />&gt;       hfsplus: remove useless check<br />&gt;       hfsplus: get rid of write_super<br />&gt;       hfs: push lock_super down<br />&gt;       hfs: get rid of lock_super<br />&gt;       hfs: remove extra mdb write on unmount<br />&gt;       hfs: simplify a bit checking for R/O<br />&gt;       hfs: introduce VFS superblock object back-reference<br />&gt;       hfs: get rid of hfs_sync_super<br />&gt;       fs/sysv: remove useless write_super call<br />&gt;       fs/sysv: remove another useless write_super call<br />&gt;       fs/sysv: stop using write_super and s_dirt<br />&gt;       fs/ufs: remove extra superblock write on unmount<br />&gt;       fs/ufs: re-arrange the code a bit<br />&gt;       fs/ufs: get rid of write_super<br />&gt;<br />&gt; Christoph Hellwig (2):<br />&gt;       fs: move path_put on failure out of -&gt;follow_link<br />&gt;       fs: add nd_jump_link<br />&gt;<br />&gt; David Howells (6):<br />&gt;       VFS: Fix the banner comment on lookup_open()<br />&gt;       VFS: Make chown() and lchown() call fchownat()<br />&gt;       VFS: Make clone_mnt()/copy_tree()/collect_mounts() return errors<br />&gt;       VFS: Comment mount following code<br />&gt;       VFS: Pass mount flags to sget()<br />&gt;       VFS: Split inode_permission()<br />&gt;<br />&gt; Eric Sandeen (3):<br />&gt;       vfs: allow custom EOF in generic_file_llseek code<br />&gt;       ext4: use core vfs llseek code for dir seeks<br />&gt;       ext3: pass custom EOF to generic_file_llseek_size()<br />&gt;<br />&gt; Jan Kara (8):<br />&gt;       vfs: Move noop_backing_dev_info check from sync into writeback<br />&gt;       quota: Split dquot_quota_sync() to writeback and cache flushing part<br />&gt;       quota: Move quota syncing to -&gt;sync_fs method<br />&gt;       vfs: Reorder operations during sys_sync<br />&gt;       vfs: Create function for iterating over block devices<br />&gt;       vfs: Make sys_sync writeout also block device inodes<br />&gt;       vfs: Remove unnecessary flushing of block devices<br />&gt;       vfs: Avoid unnecessary WB_SYNC_NONE writeback during sys_sync and reorder sync passes<br />&gt;<br />&gt; Julia Lawall (1):<br />&gt;       fs/direct-io.c: adjust suspicious bit operation<br />&gt;<br />&gt; Miklos Szeredi (21):<br />&gt;       vfs: do_last(): inline lookup_slow()<br />&gt;       vfs: do_last(): separate O_CREAT specific code<br />&gt;       vfs: do_last(): common slow lookup<br />&gt;       vfs: add lookup_open()<br />&gt;       vfs: lookup_open(): expand lookup_hash()<br />&gt;       vfs: add i_op-&gt;atomic_open()<br />&gt;       nfs: implement i_op-&gt;atomic_open()<br />&gt;       nfs: clean up -&gt;create in nfs_rpc_ops<br />&gt;       nfs: don't use nd-&gt;intent.open.flags<br />&gt;       nfs: don't use intents for checking atomic open<br />&gt;       fuse: implement i_op-&gt;atomic_open()<br />&gt;       cifs: implement i_op-&gt;atomic_open()<br />&gt;       ceph: remove unused arg from ceph_lookup_open()<br />&gt;       ceph: implement i_op-&gt;atomic_open()<br />&gt;       9p: implement i_op-&gt;atomic_open()<br />&gt;       vfs: remove open intents from nameidata<br />&gt;       vfs: do_last(): clean up error handling<br />&gt;       vfs: do_last(): clean up labels<br />&gt;       vfs: do_last(): clean up bool<br />&gt;       vfs: do_last(): clean up retry<br />&gt;       vfs: move O_DIRECT check to common code<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
