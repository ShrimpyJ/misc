    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2005/10/14/159">First message in thread</a></li><li><a href="/lkml/2005/10/15/17">Benjamin Herrenschmidt</a><ul><li><a href="/lkml/2005/10/15/24">Herbert Xu</a><ul><li class="origin"><a href="/lkml/2005/10/15/84">Linus Torvalds</a><ul><li><a href="/lkml/2005/10/15/84">"David S. Miller"</a><ul><li><a href="/lkml/2005/10/15/101">Benjamin Herrenschmidt</a></li></ul></li><li><a href="/lkml/2005/10/15/114">Nick Piggin</a></li></ul></li></ul></li><li><a href="/lkml/2005/10/15/30">Nick Piggin</a><ul><li><a href="/lkml/2005/10/15/46">Herbert Xu</a><ul><li><a href="/lkml/2005/10/15/53">Nick Piggin</a></li><li><a href="/lkml/2005/10/15/72">Andrea Arcangeli</a><ul><li><a href="/lkml/2005/10/15/86">Herbert Xu</a></li><li><a href="/lkml/2005/10/15/102">Benjamin Herrenschmidt</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2005/10/15/67/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 15 Oct 2005 09:57:47 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Possible memory ordering bug in page reclaim?</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sat, 15 Oct 2005, Herbert Xu wrote:<br />&gt;<br />&gt; Benjamin Herrenschmidt &lt;benh&#64;kernel.crashing.org&gt; wrote:<br />&gt;<br />&gt; &gt; yup, now the question is wether PG_Dirty will be visible to CPU 2 before<br />&gt; &gt; the page count is decremented right ? That depends on put_page, I<br />&gt; &gt; suppose. If it's doing a simple atomic, there is an issue. But atomics<br />&gt; &gt; with return has been so often abused as locks that they may have been<br />&gt; &gt; implemented with a barrier... (On ppc64, it will do an eieio, thus I<br />&gt; &gt; think it should be ok).<br />&gt; <br />&gt; Yes atomic_add_negative should always be a barrier.<br /><br />I disagree. That would be very expensive on anything but x86, where it <br />just happens to be true for other reasons. Atomics do _not_ implement <br />barriers.<br /><br />Normally, we really don't care about any other decrement than the one that <br />goes to zero, and that one tends to come with its own serialization logic.<br /><br />In this case, we don't even care.<br /><br />I agree, however, that it looks like PG_dirty is racy. Probably not in <br />practice, but still.<br /><br />So I'd suggest adding a smp_wmb() into set_page_dirty, and the rmb where <br />Nick suggested.<br /><br />So I'd suggest a patch something more like this.. Marking the dirty/count <br />cases unlikely too in mm/page-writeback.c, since we should have tested for <br />these conditions optimistically outside the lock.<br /><br />Comments? Nick, did you have some test-case that you think might actually <br />have been impacted by this?<br /><br />		Linus<br /><br />---<br />diff --git a/mm/page-writeback.c b/mm/page-writeback.c<br />index 0166ea1..722779c 100644<br />--- a/mm/page-writeback.c<br />+++ b/mm/page-writeback.c<br />&#64;&#64; -668,8 +668,14 &#64;&#64; int fastcall set_page_dirty(struct page <br /> 			return (*spd)(page);<br /> 		return __set_page_dirty_buffers(page);<br /> 	}<br />-	if (!PageDirty(page))<br />+	if (!PageDirty(page)) {<br /> 		SetPageDirty(page);<br />+		/*<br />+		 * Make sure the dirty bit percolates out<br />+		 * to other CPU's before we release the page<br />+		 */<br />+		smp_wmb();<br />+	}<br /> 	return 0;<br /> }<br /> EXPORT_SYMBOL(set_page_dirty);<br />diff --git a/mm/vmscan.c b/mm/vmscan.c<br />index 0ea71e8..64f9570 100644<br />--- a/mm/vmscan.c<br />+++ b/mm/vmscan.c<br />&#64;&#64; -511,10 +511,11 &#64;&#64; static int shrink_list(struct list_head <br /> 		 * PageDirty _after_ making sure that the page is freeable and<br /> 		 * not in use by anybody. 	(pagecache + us == 2)<br /> 		 */<br />-		if (page_count(page) != 2 || PageDirty(page)) {<br />-			write_unlock_irq(&amp;mapping-&gt;tree_lock);<br />-			goto keep_locked;<br />-		}<br />+		if (unlikely(page_count(page) != 2))<br />+			goto cannot_free;<br />+		smp_rmb();<br />+		if (unlikely(PageDirty(page)))<br />+			goto cannot_free;<br /> <br /> #ifdef CONFIG_SWAP<br /> 		if (PageSwapCache(page)) {<br />&#64;&#64; -538,6 +539,10 &#64;&#64; free_it:<br /> 			__pagevec_release_nonlru(&amp;freed_pvec);<br /> 		continue;<br /> <br />+cannot_free:<br />+		write_unlock_irq(&amp;mapping-&gt;tree_lock);<br />+		goto keep_locked;<br />+<br /> activate_locked:<br /> 		SetPageActive(page);<br /> 		pgactivate++;<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
