    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2005/8/19/54">First message in thread</a></li><li><a href="/lkml/2005/8/19/160">Linus Torvalds</a><ul><li><a href="/lkml/2005/8/19/177">Anton Altaparmakov</a><ul><li class="origin"><a href="/lkml/2005/8/19/199">Linus Torvalds</a><ul><li><a href="/lkml/2005/8/19/199">Al Viro</a><ul><li><a href="/lkml/2005/8/19/200">Al Viro</a></li><li><a href="/lkml/2005/8/19/236">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2005/8/20/33">Anton Altaparmakov</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2005/8/19/185/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 19 Aug 2005 15:04:52 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Kernel bug: Bad page state: related to generic symlink code and mmap</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 19 Aug 2005, Anton Altaparmakov wrote:<br />&gt; <br />&gt; Yes, sure.  I have applied your patch to our 2.6.11.4 tree (with the one <br />&gt; liner change I emailed you just now) and have kicked off a compile.<br /><br />Actually, hold on. The original patch had another problem: it returned an<br />uninitialized "page" pointer when page_getlink() failed.<br /><br />This one should have that fixed, and has converted a few other <br />filesystems. Most of them trivially, but I took the opportunity to just <br />simplify NFS while I was at it, since it now has no reason to need to save <br />off the "struct page *" any more.<br /><br />It's still not tested, but at least I've looked at it a bit more ;)<br /><br />		Linus<br /><br />---<br />diff --git a/fs/autofs/symlink.c b/fs/autofs/symlink.c<br />--- a/fs/autofs/symlink.c<br />+++ b/fs/autofs/symlink.c<br />&#64;&#64; -12,11 +12,12 &#64;&#64;<br /> <br /> #include "autofs_i.h"<br /> <br />-static int autofs_follow_link(struct dentry *dentry, struct nameidata *nd)<br />+/* Nothing to release.. */<br />+static void *autofs_follow_link(struct dentry *dentry, struct nameidata *nd)<br /> {<br /> 	char *s=((struct autofs_symlink *)dentry-&gt;d_inode-&gt;u.generic_ip)-&gt;data;<br /> 	nd_set_link(nd, s);<br />-	return 0;<br />+	return NULL;<br /> }<br /> <br /> struct inode_operations autofs_symlink_inode_operations = {<br />diff --git a/fs/cifs/cifsfs.h b/fs/cifs/cifsfs.h<br />--- a/fs/cifs/cifsfs.h<br />+++ b/fs/cifs/cifsfs.h<br />&#64;&#64; -83,8 +83,8 &#64;&#64; extern int cifs_dir_notify(struct file *<br /> extern struct dentry_operations cifs_dentry_ops;<br /> <br /> /* Functions related to symlinks */<br />-extern int cifs_follow_link(struct dentry *direntry, struct nameidata *nd);<br />-extern void cifs_put_link(struct dentry *direntry, struct nameidata *nd);<br />+extern void *cifs_follow_link(struct dentry *direntry, struct nameidata *nd);<br />+extern void cifs_put_link(struct dentry *direntry, struct nameidata *nd, void *);<br /> extern int cifs_readlink(struct dentry *direntry, char __user *buffer, <br /> 			 int buflen);<br /> extern int cifs_symlink(struct inode *inode, struct dentry *direntry,<br />diff --git a/fs/cifs/link.c b/fs/cifs/link.c<br />--- a/fs/cifs/link.c<br />+++ b/fs/cifs/link.c<br />&#64;&#64; -92,7 +92,7 &#64;&#64; cifs_hl_exit:<br /> 	return rc;<br /> }<br /> <br />-int<br />+void *<br /> cifs_follow_link(struct dentry *direntry, struct nameidata *nd)<br /> {<br /> 	struct inode *inode = direntry-&gt;d_inode;<br />&#64;&#64; -148,7 +148,7 &#64;&#64; out:<br /> out_no_free:<br /> 	FreeXid(xid);<br /> 	nd_set_link(nd, target_path);<br />-	return 0;<br />+	return NULL;	/* No cookie */<br /> }<br /> <br /> int<br />&#64;&#64; -330,7 +330,7 &#64;&#64; cifs_readlink(struct dentry *direntry, c<br /> 	return rc;<br /> }<br /> <br />-void cifs_put_link(struct dentry *direntry, struct nameidata *nd)<br />+void cifs_put_link(struct dentry *direntry, struct nameidata *nd, void *cookie)<br /> {<br /> 	char *p = nd_get_link(nd);<br /> 	if (!IS_ERR(p))<br />diff --git a/fs/ext2/symlink.c b/fs/ext2/symlink.c<br />--- a/fs/ext2/symlink.c<br />+++ b/fs/ext2/symlink.c<br />&#64;&#64; -21,11 +21,11 &#64;&#64;<br /> #include "xattr.h"<br /> #include &lt;linux/namei.h&gt;<br /> <br />-static int ext2_follow_link(struct dentry *dentry, struct nameidata *nd)<br />+static void *ext2_follow_link(struct dentry *dentry, struct nameidata *nd)<br /> {<br /> 	struct ext2_inode_info *ei = EXT2_I(dentry-&gt;d_inode);<br /> 	nd_set_link(nd, (char *)ei-&gt;i_data);<br />-	return 0;<br />+	return NULL;<br /> }<br /> <br /> struct inode_operations ext2_symlink_inode_operations = {<br />diff --git a/fs/ext3/symlink.c b/fs/ext3/symlink.c<br />--- a/fs/ext3/symlink.c<br />+++ b/fs/ext3/symlink.c<br />&#64;&#64; -23,11 +23,11 &#64;&#64;<br /> #include &lt;linux/namei.h&gt;<br /> #include "xattr.h"<br /> <br />-static int ext3_follow_link(struct dentry *dentry, struct nameidata *nd)<br />+static void * ext3_follow_link(struct dentry *dentry, struct nameidata *nd)<br /> {<br /> 	struct ext3_inode_info *ei = EXT3_I(dentry-&gt;d_inode);<br /> 	nd_set_link(nd, (char*)ei-&gt;i_data);<br />-	return 0;<br />+	return NULL;<br /> }<br /> <br /> struct inode_operations ext3_symlink_inode_operations = {<br />diff --git a/fs/namei.c b/fs/namei.c<br />--- a/fs/namei.c<br />+++ b/fs/namei.c<br />&#64;&#64; -501,6 +501,7 &#64;&#64; struct path {<br /> static inline int __do_follow_link(struct path *path, struct nameidata *nd)<br /> {<br /> 	int error;<br />+	void *cookie;<br /> 	struct dentry *dentry = path-&gt;dentry;<br /> <br /> 	touch_atime(path-&gt;mnt, dentry);<br />&#64;&#64; -508,13 +509,15 &#64;&#64; static inline int __do_follow_link(struc<br /> <br /> 	if (path-&gt;mnt == nd-&gt;mnt)<br /> 		mntget(path-&gt;mnt);<br />-	error = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, nd);<br />-	if (!error) {<br />+	cookie = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, nd);<br />+	error = PTR_ERR(cookie);<br />+	if (!IS_ERR(cookie)) {<br /> 		char *s = nd_get_link(nd);<br />+		error = 0;<br /> 		if (s)<br /> 			error = __vfs_follow_link(nd, s);<br /> 		if (dentry-&gt;d_inode-&gt;i_op-&gt;put_link)<br />-			dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, nd);<br />+			dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, nd, cookie);<br /> 	}<br /> 	dput(dentry);<br /> 	mntput(path-&gt;mnt);<br />&#64;&#64; -2344,15 +2347,17 &#64;&#64; out:<br /> int generic_readlink(struct dentry *dentry, char __user *buffer, int buflen)<br /> {<br /> 	struct nameidata nd;<br />-	int res;<br />+	void *cookie;<br />+<br /> 	nd.depth = 0;<br />-	res = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, &amp;nd);<br />-	if (!res) {<br />-		res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&amp;nd));<br />+	cookie = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, &amp;nd);<br />+	if (!IS_ERR(cookie)) {<br />+		int res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&amp;nd));<br /> 		if (dentry-&gt;d_inode-&gt;i_op-&gt;put_link)<br />-			dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, &amp;nd);<br />+			dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, &amp;nd, cookie);<br />+		cookie = ERR_PTR(res);<br /> 	}<br />-	return res;<br />+	return PTR_ERR(cookie);<br /> }<br /> <br /> int vfs_follow_link(struct nameidata *nd, const char *link)<br />&#64;&#64; -2395,23 +2400,20 &#64;&#64; int page_readlink(struct dentry *dentry,<br /> 	return res;<br /> }<br /> <br />-int page_follow_link_light(struct dentry *dentry, struct nameidata *nd)<br />+void *page_follow_link_light(struct dentry *dentry, struct nameidata *nd)<br /> {<br />-	struct page *page;<br />+	struct page *page = NULL;<br /> 	nd_set_link(nd, page_getlink(dentry, &amp;page));<br />-	return 0;<br />+	return page;<br /> }<br /> <br />-void page_put_link(struct dentry *dentry, struct nameidata *nd)<br />+void page_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)<br /> {<br />-	if (!IS_ERR(nd_get_link(nd))) {<br />-		struct page *page;<br />-		page = find_get_page(dentry-&gt;d_inode-&gt;i_mapping, 0);<br />-		if (!page)<br />-			BUG();<br />+	struct page *page = cookie;<br />+<br />+	if (page) {<br /> 		kunmap(page);<br /> 		page_cache_release(page);<br />-		page_cache_release(page);<br /> 	}<br /> }<br /> <br />diff --git a/fs/nfs/symlink.c b/fs/nfs/symlink.c<br />--- a/fs/nfs/symlink.c<br />+++ b/fs/nfs/symlink.c<br />&#64;&#64; -27,26 +27,14 &#64;&#64;<br /> <br /> /* Symlink caching in the page cache is even more simplistic<br />  * and straight-forward than readdir caching.<br />- *<br />- * At the beginning of the page we store pointer to struct page in question,<br />- * simplifying nfs_put_link() (if inode got invalidated we can't find the page<br />- * to be freed via pagecache lookup).<br />- * The NUL-terminated string follows immediately thereafter.<br />  */<br /> <br />-struct nfs_symlink {<br />-	struct page *page;<br />-	char body[0];<br />-};<br />-<br /> static int nfs_symlink_filler(struct inode *inode, struct page *page)<br /> {<br />-	const unsigned int pgbase = offsetof(struct nfs_symlink, body);<br />-	const unsigned int pglen = PAGE_SIZE - pgbase;<br /> 	int error;<br /> <br /> 	lock_kernel();<br />-	error = NFS_PROTO(inode)-&gt;readlink(inode, page, pgbase, pglen);<br />+	error = NFS_PROTO(inode)-&gt;readlink(inode, page, 0, PAGE_SIZE);<br /> 	unlock_kernel();<br /> 	if (error &lt; 0)<br /> 		goto error;<br />&#64;&#64; -60,11 +48,10 &#64;&#64; error:<br /> 	return -EIO;<br /> }<br /> <br />-static int nfs_follow_link(struct dentry *dentry, struct nameidata *nd)<br />+static void *nfs_follow_link(struct dentry *dentry, struct nameidata *nd)<br /> {<br /> 	struct inode *inode = dentry-&gt;d_inode;<br /> 	struct page *page;<br />-	struct nfs_symlink *p;<br /> 	void *err = ERR_PTR(nfs_revalidate_inode(NFS_SERVER(inode), inode));<br /> 	if (err)<br /> 		goto read_failed;<br />&#64;&#64; -78,28 +65,20 &#64;&#64; static int nfs_follow_link(struct dentry<br /> 		err = ERR_PTR(-EIO);<br /> 		goto getlink_read_error;<br /> 	}<br />-	p = kmap(page);<br />-	p-&gt;page = page;<br />-	nd_set_link(nd, p-&gt;body);<br />-	return 0;<br />+	nd_set_link(nd, kmap(page));<br />+	return page;<br /> <br /> getlink_read_error:<br /> 	page_cache_release(page);<br /> read_failed:<br /> 	nd_set_link(nd, err);<br />-	return 0;<br />+	return NULL;<br /> }<br /> <br />-static void nfs_put_link(struct dentry *dentry, struct nameidata *nd)<br />+static void nfs_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)<br /> {<br />-	char *s = nd_get_link(nd);<br />-	if (!IS_ERR(s)) {<br />-		struct nfs_symlink *p;<br />-		struct page *page;<br />-<br />-		p = container_of(s, struct nfs_symlink, body[0]);<br />-		page = p-&gt;page;<br />-<br />+	if (cookie) {<br />+		struct page *page = cookie;<br /> 		kunmap(page);<br /> 		page_cache_release(page);<br /> 	}<br />diff --git a/fs/sysfs/symlink.c b/fs/sysfs/symlink.c<br />--- a/fs/sysfs/symlink.c<br />+++ b/fs/sysfs/symlink.c<br />&#64;&#64; -151,17 +151,17 &#64;&#64; static int sysfs_getlink(struct dentry *<br /> <br /> }<br /> <br />-static int sysfs_follow_link(struct dentry *dentry, struct nameidata *nd)<br />+static void *sysfs_follow_link(struct dentry *dentry, struct nameidata *nd)<br /> {<br /> 	int error = -ENOMEM;<br /> 	unsigned long page = get_zeroed_page(GFP_KERNEL);<br /> 	if (page)<br /> 		error = sysfs_getlink(dentry, (char *) page); <br /> 	nd_set_link(nd, error ? ERR_PTR(error) : (char *)page);<br />-	return 0;<br />+	return NULL;<br /> }<br /> <br />-static void sysfs_put_link(struct dentry *dentry, struct nameidata *nd)<br />+static void sysfs_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)<br /> {<br /> 	char *page = nd_get_link(nd);<br /> 	if (!IS_ERR(page))<br />diff --git a/include/linux/fs.h b/include/linux/fs.h<br />--- a/include/linux/fs.h<br />+++ b/include/linux/fs.h<br />&#64;&#64; -993,8 +993,8 &#64;&#64; struct inode_operations {<br /> 	int (*rename) (struct inode *, struct dentry *,<br /> 			struct inode *, struct dentry *);<br /> 	int (*readlink) (struct dentry *, char __user *,int);<br />-	int (*follow_link) (struct dentry *, struct nameidata *);<br />-	void (*put_link) (struct dentry *, struct nameidata *);<br />+	void * (*follow_link) (struct dentry *, struct nameidata *);<br />+	void (*put_link) (struct dentry *, struct nameidata *, void *);<br /> 	void (*truncate) (struct inode *);<br /> 	int (*permission) (struct inode *, int, struct nameidata *);<br /> 	int (*setattr) (struct dentry *, struct iattr *);<br />&#64;&#64; -1602,8 +1602,8 &#64;&#64; extern struct file_operations generic_ro<br /> extern int vfs_readlink(struct dentry *, char __user *, int, const char *);<br /> extern int vfs_follow_link(struct nameidata *, const char *);<br /> extern int page_readlink(struct dentry *, char __user *, int);<br />-extern int page_follow_link_light(struct dentry *, struct nameidata *);<br />-extern void page_put_link(struct dentry *, struct nameidata *);<br />+extern void *page_follow_link_light(struct dentry *, struct nameidata *);<br />+extern void page_put_link(struct dentry *, struct nameidata *, void *);<br /> extern int page_symlink(struct inode *inode, const char *symname, int len);<br /> extern struct inode_operations page_symlink_inode_operations;<br /> extern int generic_readlink(struct dentry *, char __user *, int);<br />diff --git a/mm/shmem.c b/mm/shmem.c<br />--- a/mm/shmem.c<br />+++ b/mm/shmem.c<br />&#64;&#64; -1773,32 +1773,27 &#64;&#64; static int shmem_symlink(struct inode *d<br /> 	return 0;<br /> }<br /> <br />-static int shmem_follow_link_inline(struct dentry *dentry, struct nameidata *nd)<br />+static void *shmem_follow_link_inline(struct dentry *dentry, struct nameidata *nd)<br /> {<br /> 	nd_set_link(nd, (char *)SHMEM_I(dentry-&gt;d_inode));<br />-	return 0;<br />+	return NULL;<br /> }<br /> <br />-static int shmem_follow_link(struct dentry *dentry, struct nameidata *nd)<br />+static void *shmem_follow_link(struct dentry *dentry, struct nameidata *nd)<br /> {<br /> 	struct page *page = NULL;<br /> 	int res = shmem_getpage(dentry-&gt;d_inode, 0, &amp;page, SGP_READ, NULL);<br /> 	nd_set_link(nd, res ? ERR_PTR(res) : kmap(page));<br />-	return 0;<br />+	return page;<br /> }<br /> <br />-static void shmem_put_link(struct dentry *dentry, struct nameidata *nd)<br />+static void shmem_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)<br /> {<br /> 	if (!IS_ERR(nd_get_link(nd))) {<br />-		struct page *page;<br />-<br />-		page = find_get_page(dentry-&gt;d_inode-&gt;i_mapping, 0);<br />-		if (!page)<br />-			BUG();<br />+		struct page *page = cookie;<br /> 		kunmap(page);<br /> 		mark_page_accessed(page);<br /> 		page_cache_release(page);<br />-		page_cache_release(page);<br /> 	}<br /> }<br /> <br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
