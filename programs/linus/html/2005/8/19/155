    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2005/8/19/54">First message in thread</a></li><li><a href="/lkml/2005/8/19/121">Christoph Hellwig</a><ul><li><a href="/lkml/2005/8/19/140">Al Viro</a><ul><li><a href="/lkml/2005/8/19/142">Matthew Wilcox</a><ul><li><a href="/lkml/2005/8/19/144">Al Viro</a><ul><li><a href="/lkml/2005/8/19/165">Christoph Hellwig</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2005/8/19/166">Linus Torvalds</a><ul><li><a href="/lkml/2005/8/19/166">Anton Altaparmakov</a><ul><li><a href="/lkml/2005/8/19/176">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2005/8/19/178">Al Viro</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2005/8/19/155/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 19 Aug 2005 13:35:49 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Kernel bug: Bad page state: related to generic symlink code and mmap</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 19 Aug 2005, Al Viro wrote:<br />&gt; <br />&gt; FWIW, I'd rather take page_symlink(), page_symlink_inode_operations,<br />&gt; page_put_link(), page_follow_link_light(), page_readlink(), page_getlink(),<br />&gt; generic_readlink() and vfs_readlink() to the same place where these guys<br />&gt; would live.  They all belong together and none of them has any business<br />&gt; in fs/namei.c.  Options: fs/libfs.c or separate library since fs/libfs.c<br />&gt; is getting crowded.  Linus, do you have any objections to that or suggestions<br />&gt; on filename here?<br /><br />I'm not sure if this merits a new file or new organization (hey,<br />fs/lib/xxx might be good in theory). In particular, I had actually been<br />hoping to release 2.6.13 today, but this seems like a valid thing to hold <br />things up for - but not if we're going to re-organize things.<br /><br />The one thing that strikes me is that we might actually have less pain if<br />we just changed the calling convention for follow_link/put_link slightly<br />instead of creating a new library function. The existing "page cache"  <br />thing really _does_ work very well, and would work fine for NFS and ncpfs<br />too, if we just allowed an extra cookie to be passed along from<br />"follow_link()" to "put_link()".<br /><br />A patch like this (totally untested, and you'd need to update any<br />filesystems that don't use the regular page_follow_link interface) would<br />seem to clean up the mess nicely.. The basic change is that follow_link() <br />returns a error-pointer cookie instead of just zero or error, and that is <br />passed into put_link().<br /><br />That simple calling convention change solves all problems. It so _happens_ <br />that any old binary code also continues to work (the cookie will be zero, <br />and put_link will ignore it), so it shouldn't even break any unconverted <br />stuff (unless they mix using their own functions _and_ using the helpher <br />functions, which is of course possible).<br /><br />The "shouldn't break nonconverted filesystems" makes me think this is a <br />safe change. Comments?<br /><br />NOTE NOTE NOTE! Let me say again that it's untested. It might not break <br />nonconverted filesystems, but it equally well migth break even the <br />converted ones ;)<br /><br />		Linus<br /><br />----<br />diff --git a/fs/namei.c b/fs/namei.c<br />--- a/fs/namei.c<br />+++ b/fs/namei.c<br />&#64;&#64; -501,6 +501,7 &#64;&#64; struct path {<br /> static inline int __do_follow_link(struct path *path, struct nameidata *nd)<br /> {<br /> 	int error;<br />+	void *cookie;<br /> 	struct dentry *dentry = path-&gt;dentry;<br /> <br /> 	touch_atime(path-&gt;mnt, dentry);<br />&#64;&#64; -508,13 +509,15 &#64;&#64; static inline int __do_follow_link(struc<br /> <br /> 	if (path-&gt;mnt == nd-&gt;mnt)<br /> 		mntget(path-&gt;mnt);<br />-	error = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, nd);<br />-	if (!error) {<br />+	cookie = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, nd);<br />+	error = PTR_ERR(cookie);<br />+	if (!IS_ERR(cookie)) {<br /> 		char *s = nd_get_link(nd);<br />+		error = 0;<br /> 		if (s)<br /> 			error = __vfs_follow_link(nd, s);<br /> 		if (dentry-&gt;d_inode-&gt;i_op-&gt;put_link)<br />-			dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, nd);<br />+			dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, nd, cookie);<br /> 	}<br /> 	dput(dentry);<br /> 	mntput(path-&gt;mnt);<br />&#64;&#64; -2345,14 +2348,17 &#64;&#64; int generic_readlink(struct dentry *dent<br /> {<br /> 	struct nameidata nd;<br /> 	int res;<br />+	void *cookie;<br />+<br /> 	nd.depth = 0;<br />-	res = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, &amp;nd);<br />-	if (!res) {<br />+	cookie = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, &amp;nd);<br />+	if (!IS_ERR(cookie)) {<br /> 		res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&amp;nd));<br /> 		if (dentry-&gt;d_inode-&gt;i_op-&gt;put_link)<br />-			dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, &amp;nd);<br />+			dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, &amp;nd, cookie);<br />+		cookie = ERR_PTR(0);<br /> 	}<br />-	return res;<br />+	return PTR_ERR(cookie);<br /> }<br /> <br /> int vfs_follow_link(struct nameidata *nd, const char *link)<br />&#64;&#64; -2395,23 +2401,19 &#64;&#64; int page_readlink(struct dentry *dentry,<br /> 	return res;<br /> }<br /> <br />-int page_follow_link_light(struct dentry *dentry, struct nameidata *nd)<br />+void *page_follow_link_light(struct dentry *dentry, struct nameidata *nd)<br /> {<br /> 	struct page *page;<br /> 	nd_set_link(nd, page_getlink(dentry, &amp;page));<br />-	return 0;<br />+	return page;<br /> }<br /> <br />-void page_put_link(struct dentry *dentry, struct nameidata *nd)<br />+void page_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)<br /> {<br /> 	if (!IS_ERR(nd_get_link(nd))) {<br />-		struct page *page;<br />-		page = find_get_page(dentry-&gt;d_inode-&gt;i_mapping, 0);<br />-		if (!page)<br />-			BUG();<br />+		struct page *page = cookie;<br /> 		kunmap(page);<br /> 		page_cache_release(page);<br />-		page_cache_release(page);<br /> 	}<br /> }<br /> <br />diff --git a/include/linux/fs.h b/include/linux/fs.h<br />--- a/include/linux/fs.h<br />+++ b/include/linux/fs.h<br />&#64;&#64; -993,8 +993,8 &#64;&#64; struct inode_operations {<br /> 	int (*rename) (struct inode *, struct dentry *,<br /> 			struct inode *, struct dentry *);<br /> 	int (*readlink) (struct dentry *, char __user *,int);<br />-	int (*follow_link) (struct dentry *, struct nameidata *);<br />-	void (*put_link) (struct dentry *, struct nameidata *);<br />+	void * (*follow_link) (struct dentry *, struct nameidata *);<br />+	void (*put_link) (struct dentry *, struct nameidata *, void *);<br /> 	void (*truncate) (struct inode *);<br /> 	int (*permission) (struct inode *, int, struct nameidata *);<br /> 	int (*setattr) (struct dentry *, struct iattr *);<br />&#64;&#64; -1602,8 +1602,8 &#64;&#64; extern struct file_operations generic_ro<br /> extern int vfs_readlink(struct dentry *, char __user *, int, const char *);<br /> extern int vfs_follow_link(struct nameidata *, const char *);<br /> extern int page_readlink(struct dentry *, char __user *, int);<br />-extern int page_follow_link_light(struct dentry *, struct nameidata *);<br />-extern void page_put_link(struct dentry *, struct nameidata *);<br />+extern void *page_follow_link_light(struct dentry *, struct nameidata *);<br />+extern void page_put_link(struct dentry *, struct nameidata *, void *);<br /> extern int page_symlink(struct inode *inode, const char *symname, int len);<br /> extern struct inode_operations page_symlink_inode_operations;<br /> extern int generic_readlink(struct dentry *, char __user *, int);<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
