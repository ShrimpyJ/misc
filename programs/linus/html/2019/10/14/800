    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/10/9/1138">First message in thread</a></li><li><a href="/lkml/2019/10/14/729">Linus Torvalds</a><ul><li><a href="/lkml/2019/10/14/760">Vineet Gupta</a><ul><li class="origin"><a href="/lkml/2019/10/14/832">Linus Torvalds</a><ul><li><a href="/lkml/2019/10/14/832">Matthew Wilcox</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 14 Oct 2019 13:38:34 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC] asm-generic/tlb: stub out pmd_free_tlb() if __PAGETABLE_PMD_FOLDED</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Oct 14, 2019 at 12:08 PM Vineet Gupta &lt;vineetg76&#64;gmail.com&gt; wrote:<br />&gt;<br />&gt; &gt; And yes, pmd_clear_bad() should just go away. We have<br />&gt; &gt;<br />&gt; &gt;   static inline int pmd_none_or_clear_bad(pmd_t *pmd)<br />&gt; &gt;   {<br />&gt; &gt;         if (pmd_none(*pmd))<br />&gt; &gt;                 return 1;<br />&gt; &gt;         if (unlikely(pmd_bad(*pmd))) {<br />&gt; &gt;                 pmd_clear_bad(pmd);<br />&gt; &gt;                 return 1;<br />&gt; &gt;         }<br />&gt; &gt;         return 0;<br />&gt; &gt;   }<br /><br />That was a particularly bad example.<br /><br />The pmd always exists, even in a 2-level setup.<br /><br />It's the pgd/p4d/pud that end up containing a lower level, but<br />pmd_none() is never one of the fixed "doesn't exist" cases.<br /><br />&gt; &gt; Exactly what part isn't working for you?<br />&gt;<br />&gt; I haven't tested that patch but I suspect even if it was broken, it would not<br />&gt; necessarily show right away with a trivial test.<br />&gt;<br />&gt; Anyhow my worry/confusions starts at free_pgd_range() where<br />&gt; pgd_none_or_clear_bad(pgd) is no-op given pgd_none()/pgd_bad() are stubs for nopmd<br />&gt; case.<br /><br />Right. If you have a two-level setup, then p[g4u]d_none_or_clear_bad()<br />should end up being no-ops.<br /><br />Buit then:<br /><br />&gt; And the validation of pgd entry actually happens in pmd_none_or_clear_bad(pmd)<br />&gt; since there pmd actually ends up referencing pgd entry. Hence the ensuing<br />&gt; pmd_clear_bad() doesn't seem like if it could be stubbed out.<br /><br />Yes, you're correct, I was just "off by one" in my levels.<br /><br />Yeah, the folding is damn confusing. And it doesn't help that I think<br />some of the code talks about the lower level being folded into the<br />higher level for historical reasons, so we have those PMD_FOLDED<br />macros etc, which are really about pud() just going away because pmd<br />is folded inside the pud.<br /><br />So when the pud level is compiled away, we talk about the pmd level<br />being folded into it, and then we get confusion (like mine above)<br />where you end up being off by one level, because depending on how it's<br />being talked about, you talk about one or the other.<br /><br />And it shows in the header files too. We have "pgtable-nopmd.h", which<br />then defines the page table accessors not for the pmd level, but for<br />the pud level.<br /><br />Which is why I then spout nonsense like the above about pmd_none() -<br />because I was thinking of the nopmd case, but that makes the<br />p*u*d_none() be always 0, not p*m*d_none().<br /><br />So we have this whole "off-by-one" error in our naming and thus our<br />thinking, and it's really easy to just get really confused about it.<br /><br />We should probably get rid of the whole "PMD_FOLDED" logic, and<br />instead talk about "no PUD level".<br /><br />It actually shows in our types too. We do this:<br /><br />   typedef struct { pud_t pud; } pmd_t;<br />   #define PTRS_PER_PMD    1<br /><br />because some of the code thinks of the pmd as containing the pud.<br /><br />But it would probably be better to do it the other way around, and<br />just consistently think of it as "pud level doesn't exist, the pud<br />level just contains a pmd" instead.<br /><br />So we have these really odd "somethimes we think of pmd as part of a<br />pud entry" vs "sometimes we think of pud as just containing a single<br />pmd".<br /><br />And I think that latter model is the better mental model, but then we<br />should have<br /><br />   typedef struct { pmd_t pud; } pud_t;<br />   #define PTRS_PER_PUD    1<br /><br />instead, and we'd get<br /><br />   static inline pmd_t * pmd_offset(pud_t * pud, unsigned long address)<br />   { return &amp;pud-&gt;pmd; }<br /><br />and that would make more sense, wouldn't it?<br /><br />But trying to fix our odd "we seem to think about it wrong" model<br />would likely be too painful to be realistic., It would involve<br />renaming<br /><br />  nop4d.h -&gt; nopgd.h<br />  nopud.h -&gt; nop4d.h<br />  nopmd.h -&gt; nopud.h<br /><br />and turning those types around (so we'd have those<br /><br />   typedef struct { p4d_t p4d; } pgd_t;<br />   typedef struct { pud_t pud; | p4d_t;<br />   typedef struct { pmd_t pmd; } pud_t;<br /><br />for no-pgd/no-p4d/no-pud respectively.<br /><br />So then a 2-level machine would only define the pmd and pte levels,<br />and be done with it, because the upper levels would be defined in<br />terms of those.<br /><br />But that's not what we do, and we mix up levels in odd and confusing ways.<br /><br />And now I've said pgd/pud/p4d/pmd so many times that I've confused<br />myself and think I'm wrong again, and I think that historically -<br />originally - we always had a pgd, and then the pmd didn't exist<br />because it was folded into it. That makes sense from a x86 naming<br />standpoint. Then x86 _did_ get a pmd, and then we added more levels in<br />between, and other architectures did things differently.<br /><br />So I think the confusion is historical, and is because we've switched<br />between thinking that the the lower level that doesn't exist, but is<br />embedded in the upper level, and slowly converted to "it's the upper<br />level that doesn't exist, and just contains the lower level"<br /><br />The point stands: it's confusing, and we should probably pick one<br />model, and the model we pick should likely be "this level doesn't<br />exist, and just wraps the lower level", so it *should* be "no pgd"/"no<br />p4d"/"no pud".<br /><br />            Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
