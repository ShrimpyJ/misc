    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/10/9/1138">First message in thread</a></li><li><a href="/lkml/2019/10/14/701">Linus Torvalds</a><ul><li><a href="/lkml/2019/10/14/718">Vineet Gupta</a><ul><li class="origin"><a href="/lkml/2019/10/14/760">Linus Torvalds</a><ul><li><a href="/lkml/2019/10/14/760">Vineet Gupta</a><ul><li><a href="/lkml/2019/10/14/800">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 14 Oct 2019 11:25:08 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC] asm-generic/tlb: stub out pmd_free_tlb() if __PAGETABLE_PMD_FOLDED</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Oct 14, 2019 at 11:02 AM Vineet Gupta &lt;vineetg76&#64;gmail.com&gt; wrote:<br />&gt;<br />&gt; I suppose we could but<br />&gt;<br />&gt; (a) It would be asymmetric with the __p{u,4}d_free_tlb() changes in [1] and [2].<br /><br />Your patch is already assymmetric wrt those anyway - you had to add that<br /><br />  +#else<br />  +#define pmd_free_tlb(tlb, pmdp, address)        do { } while (0)<br />  +#endif<br /><br />that the other cases don't currently have, so then you point to<br />another patch that makes the code uglier instead.<br /><br />&gt; Do you  prefer [1] and [2] be repun along the same lines as you propose above ?<br /><br />In general, I absolutely detest how we have random<br /><br />   #ifndef ARCH_HAS_ONE_DEFINE<br />   #define another_define_entirely()<br />   ...<br /><br />which makes no sense and is ugly, and also wreaks havoc on simple<br />things like "git grep another_define_entirely"<br /><br />I've long tried to convince people to just do<br /><br />  #ifndef special_define<br />  #define special_define(xyz) ..<br />  #endif<br /><br />instead, which doesn't mix up two completely unrelated names, and when<br />you grep for that function name, you _see_ all the context.<br /><br />&gt; Also would you care to shed light on my other question about not being able to<br />&gt; fold away pmd_clear_bad() despite PMD_FOLDED given the pmd macros actually<br />&gt; checking for pgd. Of all the people you are likely to have most insight on how the<br />&gt; pmd folding actually evolved and works :-)<br /><br />I think some of it is just ugly and historical, and confused.<br /><br />In general, it should always be the "higher" level that folds away. So<br />I think the best example of this is<br /><br />  include/asm-generic/pgtable-nop4d.h<br /><br />where basically all the "pgd" functions become no-ops, and can never<br />not exist or be bad, because they are always just containers for the<br />lower level and don't have any data in them themselves:<br /><br />  static inline int pgd_none(pgd_t pgd)           { return 0; }<br />  static inline int pgd_bad(pgd_t pgd)            { return 0; }<br />  static inline int pgd_present(pgd_t pgd)        { return 1; }<br />  static inline void pgd_clear(pgd_t *pgd)        { }<br /><br />and walking from pgd to p4d is that nice folded op:<br /><br />  static inline p4d_t *p4d_offset(pgd_t *pgd, unsigned long address)<br />  { return (p4d_t *)pgd; }<br /><br />and this is how it should always work.See "nopud" and "nopmd"(which<br />are 3rd/2nd level respectively) doing the same thing exactly.<br /><br />And yes, pmd_clear_bad() should just go away. We have<br /><br />  static inline int pmd_none_or_clear_bad(pmd_t *pmd)<br />  {<br />        if (pmd_none(*pmd))<br />                return 1;<br />        if (unlikely(pmd_bad(*pmd))) {<br />                pmd_clear_bad(pmd);<br />                return 1;<br />        }<br />        return 0;<br />  }<br /><br />and if the pmd doesn't exist, then both pmd_none() and pmd_bad()<br />should just be zero (see above), and the pmd_none_or_clear_bad()<br />should just become "return 0";<br /><br />Exactly what part isn't working for you?<br /><br />I suspect part of the problem is exactly that we than have that stupid<br />confusion with some code checking "#ifdef __PAGETABLE_PMD_FOLDED" and<br />then making their own random decisions based on things like that<br />instead.<br /><br />When you do that, the code ends up relying on other magic than just<br />the natural folding.<br /><br />            Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
