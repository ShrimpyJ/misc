    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/8/20/1203">First message in thread</a></li><li><a href="/lkml/2019/8/22/1577">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/23/228">Ingo Molnar</a><ul><li class="origin"><a href="/lkml/2019/8/24/134">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/24/134">Ingo Molnar</a><ul><li><a href="/lkml/2019/8/24/146">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2019/8/23/379">Tetsuo Handa</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 23 Aug 2019 09:39:34 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] /dev/mem: Bail out upon SIGKILL when reading memory.</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Aug 23, 2019 at 2:16 AM Ingo Molnar &lt;mingo&#64;kernel.org&gt; wrote:<br />&gt;<br />&gt; &gt; +      */<br />&gt; &gt; +     if (fatal_signal_pending(current)) {<br />&gt; &gt; +             if (!(error_code &amp; X86_PF_USER))<br />&gt; &gt; +                     no_context(regs, error_code, address, 0, 0);<br />&gt;<br />&gt; Since the 'signal' parameter to no_context() is 0, will there be another<br />&gt; signal generated? I don't think so - so the comment looks wrong to me,<br />&gt; unless I'm missing something.<br /><br />The old case only handled the kernel case - which never added a signal<br />at all, it just failed the access (and results in EFAULT or similar,<br />but nobody cares since the whole point is that the process is going to<br />be killed).<br /><br />The *changed* case handles user space accesses too - by just returning<br />without any new signal being generated. The old case would fall<br />through to the "generate SIGSEGV", which seems pointless and wrong<br />(and also possibly generates misleading messages in the kernel logs).<br /><br />&gt; Other than that, what we are skipping here if a KILL signal is pending is<br />&gt; the printout of oops information if the fault is a kernel one.<br />&gt;<br />&gt; Not sure that's a good idea in general: carefully timing a KILL signal<br />&gt; would allow the 'stealth probing' of otherwise oops generating addresses?<br /><br />That sounds really like a non-issue to me. Plus the old code ALREADY<br />did that exact thing. The only _new_ case is that it does is silently<br />for user page faults.<br /><br />&gt; I.e. I'm not sure this hunk is necessary or even a good idea.<br /><br />As mentioned, the new code doesn't change the case you are talking about at all.<br /><br />The new code only changes the case of this happening from user space,<br />when it doesn't generate a pointless signal and a pointless possible<br />show_signal_msg() garbage for a user mode access that was denied due<br />to the new<br /><br />&gt; &gt; +     if (flags &amp; FAULT_FLAG_KILLABLE) {<br />&gt; &gt; +             if (fatal_signal_pending(current))<br />&gt; &gt; +                     return VM_FAULT_SIGSEGV;<br />&gt; &gt; +     }<br /><br />code in handle_mm_fault().<br /><br />And you said that new code looks fine to you, but you didn't seem to<br />realize that it causes stupid incorrect kernel messages to be printed<br />("segfault at xyz" etc) that are completely wrong.<br /><br />Because it's not a "real" SIGSEGV. It gets repressed by the fact that<br />there's a fatal signal pending.<br /><br />Otherwise we'd have to add a whole new case of VM_FAULT_xyz..<br /><br />             Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
