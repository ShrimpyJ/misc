    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2018/5/18/532">First message in thread</a></li><li><a href="/lkml/2019/8/16/884">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/16/981">Mathieu Desnoyers</a><ul><li><a href="/lkml/2019/8/16/986">Steven Rostedt</a><ul><li><a href="/lkml/2019/8/17/123">Mathieu Desnoyers</a><ul><li><a href="/lkml/2019/8/17/128">Steven Rostedt</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2019/8/20/658">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/20/658">Peter Zijlstra</a><ul><li><a href="/lkml/2019/8/20/1136">"Paul E. McKenney"</a></li><li><a href="/lkml/2019/9/9/24">Herbert Xu</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 17 Aug 2019 01:08:02 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 1/1] Fix: trace sched switch start/stop racy updates</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Aug 16, 2019, 18:36 Mathieu Desnoyers<br />&lt;mathieu.desnoyers&#64;efficios.com&gt; wrote:<br />&gt;<br />&gt; If WRITE_ONCE has any use at all (protecting against store tearing and<br />&gt; invented stores), it should be used even with a lock held in this<br />&gt; scenario, because the lock does not prevent READ_ONCE() from observing<br />&gt; transient states caused by lack of WRITE_ONCE() for the update.<br /><br />The thing is, we really haven't requred WRITE_ONCE() to protect<br />against store tearing.<br /><br />We have lots of traditional code that does stuff along the lines of<br /><br />   .. set of data structure ..<br />   smp_wmb();<br />   *ptr = newdata;<br /><br />and we simply *depend* on the compiler doing the "*ptr" as a single<br />write. We've simply always done that.  Even on UP we've had the<br />"interrupts will see old value or new value but not some random<br />half-way value", going all the way back to the original kernel<br />sources.<br /><br />The data tearing issue is almost a non-issue. We're not going to add<br />WRITE_ONCE() to these kinds of places for no good reason.<br /><br />&gt; So why does WRITE_ONCE exist in the first place ? Is it for documentation<br />&gt; purposes only or are there actual situations where omitting it can cause<br />&gt; bugs with real-life compilers ?<br /><br />WRITE_ONCE should be seen mainly as (a) documentation and (b) for new code.<br /><br />Although I suspect often you'd be better off using smb_load_acquire()<br />and smp_store_release() when you have code sequences where you have<br />unlocked READ_ONCE/WRITE_ONCE and memory ordering.<br /><br />WRITE_ONCE() doesn't even protect against data tearing. If you do a<br />"WRITE_ONCE()" on a type larger than 8 bytes, it will fall back to<br />__builtin_memcpy().<br /><br />So honestly, WRITE_ONCE() is often more documentation than protecting<br />against something, but overdoing it doesn't help document anything, it<br />just obscures the point.<br /><br />Yeah, yeah, it will use a "volatile" access for the proper normal<br />types, but even then that won't protect against data tearing on 64-bit<br />writes on a 32-bit machine, for example. It doesn't even give ordering<br />guarantees for the sub-words.<br /><br />So you still end up with the almost the same basic rule: a natural<br />byte/word write will be atomic. But really, it's going to be so even<br />without the WRITE_ONCE(), so...<br /><br />It does ostensibly protect against the compiler re-ordering the write<br />against other writes (note: *compiler*, not CPU), and it does make<br />sure the write only happens once. But it's really hard to see a valid<br />compiler optimization that wouldn't do that anyway.<br /><br />Because of the compiler ordering of WRITE_ONCE against other<br />WRITE_ONCE cases, it could be used for irq-safe ordering on the local<br />cpu, for example. If that matters. Although I suspect any such case is<br />practically going to use per-cpu variables anyway.<br /><br />End result: it's *mostly* about documentation.<br /><br />Just do a grep for WRITE_ONCE() vs READ_ONCE(). You'll find a lot more<br />users of the latter. And quite frankly, I looked at some of the<br />WRITE_ONCE() users and a lot of them were kind of pointless.<br /><br />Somebody tell me just exactly how they expect the WRITE_ONCE() cases<br />in net/tls/tls_sw.c to matter, for example (and that was literally a<br />random case I happened to look at). It's not clear what they do, since<br />they certainly don't imply any memory ordering. They do imply a<br />certain amount of compiler re-ordering due to the volatile, but that's<br />pretty limited too. Only wrt _other_ things with side effects, not the<br />normal code around them anyway.<br /><br />In contrast, READ_ONCE() has very practical examples of mattering,<br />because unlike writes, compilers really can reasonably split reads.<br />For example, if you're testing multiple bits in the same word, and you<br />want to make sure they are coherent, you should very much do<br /><br />   val = READ_ONCE(mem);<br />   .. test different bits in val ..<br /><br />because without the READ_ONCE(), the compiler could end up just doing<br />the read multiple times.<br /><br />Similarly, even if you only use a value once, this is actually<br />something a compiler can do:<br /><br />    if (a) {<br />         lock();<br />         B()<br />         unlock();<br />   } else<br />         B();<br /><br />and a compiler might end up generating that as<br /><br />   if (a) lock();<br />   B();<br />   if (a) unlock();<br /><br />instead. So doing "if (READ_ONCE(a))" actually makes a difference - it<br />guarantees that 'a' is only read once, even if that value was<br />_literally_ only used on a source level, the compiler really could<br />have decided "let's read it twice".<br /><br />See how duplicating a read is fundamentally different from duplicating<br />a write? Duplicating or splitting a read is not visible to other<br />threads. Notice how nothiing like the above is reasonable for a write.<br /><br />That said, the most common case really is none of the above half-way<br />subtle cases. It's literally the whole "write pointer once". Making<br />existing code that does that use WRITE_ONCE() is completely pointless.<br />It's not going to really change or fix anything at all.<br /><br />                 Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
