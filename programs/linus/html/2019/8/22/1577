    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/8/20/1203">First message in thread</a></li><li><a href="/lkml/2019/8/20/1203">Tetsuo Handa</a><ul><li><a href="/lkml/2019/8/20/1211">Greg Kroah-Hartman</a><ul><li><a href="/lkml/2019/8/20/1298">Tetsuo Handa</a></li><li><a href="/lkml/2019/8/22/322">Tetsuo Handa</a><ul><li><a href="/lkml/2019/8/22/557">Greg Kroah-Hartman</a><ul><li><a href="/lkml/2019/8/22/587">Tetsuo Handa</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2019/8/22/1560">Linus Torvalds</a></li><li class="origin"><a href="/lkml/2019/8/23/228">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/23/228">Ingo Molnar</a><ul><li><a href="/lkml/2019/8/23/683">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/24/134">Ingo Molnar</a></li></ul></li></ul></li><li><a href="/lkml/2019/8/23/379">Tetsuo Handa</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2019/8/22/1577/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 22 Aug 2019 15:08:03 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] /dev/mem: Bail out upon SIGKILL when reading memory.</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Aug 20, 2019 at 3:07 PM Tetsuo Handa<br />&lt;penguin-kernel&#64;i-love.sakura.ne.jp&gt; wrote:<br />&gt;<br />&gt; syzbot found that a thread can stall for minutes inside read_mem()<br />&gt; after that thread was killed by SIGKILL [1]. Reading 2GB at one read()<br />&gt; is legal, but delaying termination of killed thread for minutes is bad.<br /><br />Side note: we might even just allow regular signals to interrupt<br />/dev/mem reads. We already do that for /dev/zero, and the risk of<br />breaking something is likely fairly low since nothing should use that<br />thing anyway.<br /><br />Also, if it takes minutes to delay killing things, that implies that<br />we're probably still faulting in pages for the read_mem(). Which<br />points to another possible thing we could do in general: just don't<br />bother to handle page faults when a fatal signal is pending.<br /><br />That situation might happen for other random cases too, and is not<br />limited to /dev/mem. So maybe it's worth trying? Does that essentially<br />fix the /dev/mem read case too in practice?<br /><br />COMPLETELY untested patch attached, it may or may not make a<br />difference (and it may or may not work at all ;)<br /><br />                Linus<br /> arch/x86/mm/fault.c | 15 ++++++++++++---<br /> mm/memory.c         |  5 +++++<br /> 2 files changed, 17 insertions(+), 3 deletions(-)<br /><br />diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c<br />index 9ceacd1156db..d6c029a6cb90 100644<br />--- a/arch/x86/mm/fault.c<br />+++ b/arch/x86/mm/fault.c<br />&#64;&#64; -1033,8 +1033,15 &#64;&#64; static noinline void<br /> mm_fault_error(struct pt_regs *regs, unsigned long error_code,<br /> 	       unsigned long address, vm_fault_t fault)<br /> {<br />-	if (fatal_signal_pending(current) &amp;&amp; !(error_code &amp; X86_PF_USER)) {<br />-		no_context(regs, error_code, address, 0, 0);<br />+	/*<br />+	 * If we already have a fatal signal, don't bother adding<br />+	 * a new one. If it's a kernel access, just make it fail,<br />+	 * and if it's a user access just return to let the process<br />+	 * die.<br />+	 */<br />+	if (fatal_signal_pending(current)) {<br />+		if (!(error_code &amp; X86_PF_USER))<br />+			no_context(regs, error_code, address, 0, 0);<br /> 		return;<br /> 	}<br /> <br />&#64;&#64; -1389,7 +1396,8 &#64;&#64; void do_user_addr_fault(struct pt_regs *regs,<br /> 			return;<br /> 		}<br /> retry:<br />-		down_read(&amp;mm-&gt;mmap_sem);<br />+		if (down_read_killable(&amp;mm-&gt;mmap_sem))<br />+			goto fatal_signal;<br /> 	} else {<br /> 		/*<br /> 		 * The above down_read_trylock() might have succeeded in<br />&#64;&#64; -1455,6 +1463,7 &#64;&#64; void do_user_addr_fault(struct pt_regs *regs,<br /> 				goto retry;<br /> 		}<br /> <br />+fatal_signal:<br /> 		/* User mode? Just return to handle the fatal exception */<br /> 		if (flags &amp; FAULT_FLAG_USER)<br /> 			return;<br />diff --git a/mm/memory.c b/mm/memory.c<br />index e2bb51b6242e..7ad62f96b08e 100644<br />--- a/mm/memory.c<br />+++ b/mm/memory.c<br />&#64;&#64; -3988,6 +3988,11 &#64;&#64; vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,<br /> 					    flags &amp; FAULT_FLAG_REMOTE))<br /> 		return VM_FAULT_SIGSEGV;<br /> <br />+	if (flags &amp; FAULT_FLAG_KILLABLE) {<br />+		if (fatal_signal_pending(current))<br />+			return VM_FAULT_SIGSEGV;<br />+	}<br />+<br /> 	/*<br /> 	 * Enable the memcg OOM handling for faults triggered in user<br /> 	 * space.  Kernel faults are handled more gracefully.</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
