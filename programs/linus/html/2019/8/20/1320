    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/8/5/1351">First message in thread</a></li><li><a href="/lkml/2019/8/20/1286">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/20/1288">Joe Perches</a><ul><li class="origin"><a href="/lkml/2019/8/26/202">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/26/202">Geert Uytterhoeven</a></li></ul></li></ul></li><li><a href="/lkml/2019/8/20/1306">Joe Perches</a><ul><li><a href="/lkml/2019/8/20/1326">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/20/1334">Joe Perches</a></li><li><a href="/lkml/2019/8/21/1">Willy Tarreau</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 20 Aug 2019 17:39:01 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: rfc: treewide scripted patch mechanism? (was: Re: [PATCH] Makefile: Convert -Wimplicit-fallthrough=3 to just -Wimplicit-fallthrough for clang)QUILT</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Aug 20, 2019 at 4:37 PM Joe Perches &lt;joe&#64;perches.com&gt; wrote:<br />&gt;<br />&gt; &gt; So I'm putting my foot down on yet another broken string copy<br />&gt; &gt; interface from people who do not understand this fundamental issue.<br />&gt;<br />&gt; I think you are mistaken about the stracpy limits as<br />&gt; the only limit is not the source size but the dest.<br />&gt;<br />&gt; Why should the source be size limited?<br /><br />You just proved my point. You don't understand that sources can also<br />be limited, and the limit on a source can be *smaller* than the limit<br />of a destination.<br /><br />Did we learn *NOTHING* from the complete and utter disaster that was strlcpy()?<br /><br />Do you not understand why strlcpy() was unacceptably bad, and why the<br />people who converted strncpy() to it introduced real bugs?<br /><br />The fact is, it's not just the destination that has a size limit. The<br />source often has one too.<br /><br />And no, the source is not always guaranteed to be NUL-terminated, nor<br />is the source buffer guaranteed to be larger than the destination<br />buffer.<br /><br />Now, if you *know* that the source is smaller than the destination<br />size, you can do:<br /><br />    len = strnlen(src, srclen);<br />    memcpy(dst, len);<br />    dst[len] = 0;<br /><br />and that's not wrong, but that works only when<br /><br /> (a) you actually do the above<br /><br /> (b) you have no data races on src (or you at least only require that<br />'dst' is NUL-terminated, not that 'len' is necessarily the correct<br />length of the result<br /><br /> (c) you actually know as the programmer that yes, the source is<br />definitely smaller than the destination.<br /><br />and honestly, people don't get _any_ of that right.<br /><br />For one thing, the buffer sizes of the source and destination may be<br />two different things and some #define. It's hard to tell that one is<br />always smaller than the other (or that they are always the same size).<br />So then to get it right in the *general* case, you may need to do<br />something like<br /><br />     if (srcsize &lt; dstsize) {<br />          .. do the above ..<br />     } else {<br />          strlcpy(dst,src,dstsize);<br />     }<br /><br />do you see the reason?<br /><br />Do you see why strlcpy() is only safe to do when the allocation size<br />of the source buffer is at least as big as the allocation size of the<br />destination buffer?<br /><br />For example, I just grepped for some patterns, and I can find code<br />like this in the kernel<br /><br />     name_len = strnlen(fileName, PATH_MAX);<br />     name_len++;  /* trailing null */<br />     strncpy(pSMB-&gt;fileName, fileName, name_len);<br /><br />where pretty much everything is wrong. The comment is fundamentally<br />wrong, and even spells "nul" wrong. Christ.<br /><br />Here's another one:<br /><br />     /* will be less than a page size */<br />     len = strnlen(link, ocfs2_fast_symlink_chars(inode-&gt;i_sb));<br />     kaddr = kmap_atomic(page);<br />     memcpy(kaddr, link, len + 1);<br /><br />and notice how this time at least the comment is (hopefully) correct.<br />But the code is wrong once again, because it doesn't actually do the<br />correct pattern I showed above, it does a "memcpy(len+1)" instead.<br />Bzzt. WRONG!<br /><br />What I think the code *wants* to do is<br /><br />     kaddr = kmap_atomic(page);<br />     copy_string(<br />             // destination and destination size limit<br />             kaddr, PAGE_SIZE,<br />             // source and source size limit<br />             link, ocfs2_fast_symlink_chars(inode-&gt;i_sb)<br />     );<br /><br />ie the destination has one size, and the source has another size, and<br />the source may or may not be NUL-terminated.<br /><br />And then the programmer wouldn't have needed the comment, and wouldn't<br />have needed to make sure that yes, ocfs2_fast_symlink_chars() is<br />guaranteed to be less than PAGE_SIZE.<br /><br />Again, the code we actually _have_ in the kernel is not sensible. It<br />doesn't actually nul-terminate the destination, despite clearly<br />_trying_ to (note that "len+1" in the memcpy).<br /><br />Now, it's possible that it doesn't care about properly nul-terminating<br />things. And it's possible; that the source is always nul-terminated to<br />begin with unless the filesystem is corrupted. But the code clearly<br />_tries_ to do something, and fails.<br /><br />Because copying a string is complicated, particularly when the<br />allocations for source and destination may be entirely different.<br /><br />On a happier note, I actually found a correct code case too. Our<br />"kstrndup()" function seems to actually be at a first glance entirely<br />bug-free, and actually takes a limited source string size, and gives<br />you back a nul-terminated destination string of a different size. Of<br />course, that's a simple case, because the size of the destination is<br />something that that function actually controls, so getting it right is<br />actually somewhat simpler.<br /><br />                Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
