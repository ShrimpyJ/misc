    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/8/30/574">First message in thread</a></li><li><a href="/lkml/2019/8/30/683">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/30/726">Oleg Nesterov</a><ul><li class="origin"><a href="/lkml/2019/8/30/779">Linus Torvalds</a><ul><li><a href="/lkml/2019/8/30/779">Oleg Nesterov</a><ul><li><a href="/lkml/2019/8/30/799">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2019/8/30/908">(Eric W. Biederman)</a><ul><li><a href="/lkml/2019/9/2/539">Oleg Nesterov</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 30 Aug 2019 09:21:31 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [BUG] Use of probe_kernel_address() in task_rcu_dereference() without checking return value</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Aug 30, 2019 at 9:10 AM Oleg Nesterov &lt;oleg&#64;redhat.com&gt; wrote:<br />&gt;<br />&gt;<br />&gt; Yes, please see<br />&gt;<br />&gt;         [PATCH 2/3] introduce probe_slab_address()<br />&gt;         <a href="https://lore.kernel.org/lkml/20141027195425.GC11736&#64;redhat.com/">https://lore.kernel.org/lkml/20141027195425.GC11736&#64;redhat.com/</a><br />&gt;<br />&gt; I sent 5 years ago ;) Do you think<br />&gt;<br />&gt;         /*<br />&gt;          * Same as probe_kernel_address(), but &#64;addr must be the valid pointer<br />&gt;          * to a slab object, potentially freed/reused/unmapped.<br />&gt;          */<br />&gt;         #ifdef CONFIG_DEBUG_PAGEALLOC<br />&gt;         #define probe_slab_address(addr, retval)        \<br />&gt;                 probe_kernel_address(addr, retval)<br />&gt;         #else<br />&gt;         #define probe_slab_address(addr, retval)        \<br />&gt;                 ({                                                      \<br />&gt;                         (retval) = *(typeof(retval) *)(addr);           \<br />&gt;                         0;                                              \<br />&gt;                 })<br />&gt;         #endif<br />&gt;<br />&gt; can work?<br /><br />Ugh. I would much rather handle the general case, because honestly,<br />tracing has had a lot of issues with our hacky "probe_kernel_read()"<br />stuff that bases itself on user addresses.<br /><br />It's also one of the few remaining users of "set_fs()" in core code,<br />and we really should try to get rid of those.<br /><br />So your code would work for this particular case, but not for other<br />cases that can trap simply because the pointer isn't reliable (tracing<br />being the main case for that - but if the source of the pointer itself<br />might have been free'd, you would also have that situation).<br /><br />So I'd really prefer to have something a bit fancier. On most<br />architectures, doing a good exception fixup for kernel addresses is<br />really not that hard.<br /><br />On x86, for example, we actually have *exactly* that. The<br />"__get_user_asm()" macro is basically it. It purely does a load<br />instruction from an unchecked address.<br /><br />(It's a really odd syntax, but you could remove the __chk_user_ptr()<br />from the __get_user_size() macro, and now you'd have basically a "any<br />regular size kernel access with exception handlng").<br /><br />But yes, your hack is I guess optimal for this particular case where<br />you simply can depend on "we know the pointer was valid, we just don't<br />know if it was freed".<br /><br />Hmm. Don't we RCU-free the task struct? Because then we don't even<br />need to care about CONFIG_DEBUG_PAGEALLOC. We can just always access<br />the pointer as long as we have the RCU read lock. We do that in other<br />cases.<br /><br />                    Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
