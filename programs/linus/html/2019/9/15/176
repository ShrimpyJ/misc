    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/9/8/452">First message in thread</a></li><li><a href="/lkml/2019/9/14/91">"Alexander E. Patrakov"</a><ul><li><a href="/lkml/2019/9/15/4">"Theodore Y. Ts'o"</a><ul><li><a href="/lkml/2019/9/15/43">"Ahmed S. Darwish"</a><ul><li><a href="/lkml/2019/9/15/50">Lennart Poettering</a><ul><li><a href="/lkml/2019/9/15/53">Willy Tarreau</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2019/9/15/187">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/15/187">Willy Tarreau</a><ul><li><a href="/lkml/2019/9/15/190">Willy Tarreau</a></li><li><a href="/lkml/2019/9/15/197">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2019/9/16/591">Lennart Poettering</a><ul><li><a href="/lkml/2019/9/16/645">Willy Tarreau</a></li></ul></li><li><a href="/lkml/2019/9/18/1024">"Ahmed S. Darwish"</a><ul><li><a href="/lkml/2019/9/18/1025">"Ahmed S. Darwish"</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 15 Sep 2019 10:32:15 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH RFC v2] random: optionally block in getrandom(2) when the CRNG is uninitialized</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">[ Added Lennart, who was active in the other thread ]<br /><br />On Sat, Sep 14, 2019 at 10:22 PM Theodore Y. Ts'o &lt;tytso&#64;mit.edu&gt; wrote:<br />&gt;<br />&gt; Thus, add an optional configuration option which stops getrandom(2)<br />&gt; from blocking, but instead returns "best efforts" randomness, which<br />&gt; might not be random or secure at all.<br /><br />So I hate having a config option for something like this.<br /><br />How about this attached patch instead? It only changes the waiting<br />logic, and I'll quote the comment in full, because I think that<br />explains not only the rationale, it explains every part of the patch<br />(and is most of the patch anyway):<br /><br /> * We refuse to wait very long for a blocking getrandom().<br /> *<br /> * The crng may not be ready during boot, but if you ask for<br /> * blocking random numbers very early, there is no guarantee<br /> * that you'll ever get any timely entropy.<br /> *<br /> * If you are sure you need entropy and that you can generate<br /> * it, you need to ask for non-blocking random state, and then<br /> * if that fails you must actively _do_something_ that causes<br /> * enough system activity, perhaps asking the user to type<br /> * something on the keyboard.<br /> *<br /> * Just asking for blocking random numbers is completely and<br /> * fundamentally wrong, and the kernel will not play that game.<br /> *<br /> * We will block for at most 15 seconds at a time, and if called<br /> * sequentially will decrease the blocking amount so that we'll<br /> * block for at most 30s total - and if people continue to ask<br /> * for blocking, at that point we'll just return whatever random<br /> * state we have acquired.<br /> *<br /> * This will also complain loudly if the timeout happens, to let<br /> * the distribution or system admin know about the problem.<br /> *<br /> * The process that gets the -EAGAIN will hopefully also log the<br /> * error, to raise awareness that there may be use of random<br /> * numbers without sufficient entropy.<br /><br />Hmm? No strange behavior. No odd config variables. A bounded total<br />boot-time wait of 30s (which is a completely random number, but I<br />claimed it as the "big red button" time).<br /><br />And if you only do it once and fall back to something else it will<br />only wait for 15s, and you'll have your error value so that you can<br />log it properly.<br /><br />Yes, a single boot-time wait of 15s at boot is still "darn annoying",<br />but it likely<br /><br /> (a) isn't so long that people consider it a boot failure and give up<br />(but hopefully annoying enough that they'll report it)<br /><br /> (b) long enough that *if* the thing that is waiting is not actually<br />blocking the boot sequence, the non-blocked part of the boot sequence<br />should have time to do sufficient IO to get better randomness.<br /><br />So (a) is the "the system is still usable" part. While (b) is the<br />"give it a chance, and even if it fails and you fall back on urandom<br />or whatever, you'll actually be getting good randomness even if we<br />can't perhaps _guarantee_ entropy".<br /><br />Also, if you have some user that wants to do the old-timey ssh-keygen<br />thing with user input etc, we now have a documented way to do that:<br />just do the nonblocking thing, and then make really really sure that<br />you actually have something that generates more entropy if that<br />nonblocking thing returns EAGAIN. But it's also very clear that at<br />that point the program that wants this entropy guarantee has to _work_<br />for it.<br /><br />Because just being lazy and say "block" without any entropy will<br />return EAGAIN for a (continually decreasing) while, but then at some<br />point stop and say "you're broken", and just give you the urandom<br />data.<br /><br />Because if you really do nothing at all, and there is no activity<br />what-so-ever for 15s because you blocked the boot, then I claim that<br />it's better to return an error than to wait forever. And if you ignore<br />the error and just retry, eventually we'll do the fallback for you.<br /><br />Of course, if you have something like rdrand, and told us you trust<br />it, none of this matters at all, since we'll have initialized the pool<br />long before.<br /><br />So this is unconditional, but it's basically "unconditionally somewhat<br />flexibly reasonable". It should only ever trigger for the case where<br />the boot sequence was fundamentally broken. And it will complain<br />loudly (both at a kernel level, and hopefully at a systemd journal<br />level too) if it ever triggers.<br /><br />And hey, if some distro wants to then revert this because they feel<br />uncomfortable with this, that's now _their_ problem, not the problem<br />of the upstream kernel. The upstream kernel tries to do something that<br />I think is arguably fairly reasonable in all situations.<br /><br />                 Linus<br />[unhandled content-type:application/x-patch]</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
