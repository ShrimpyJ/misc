    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/9/8/452">First message in thread</a></li><li><a href="/lkml/2019/9/14/117">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/14/120">"Alexander E. Patrakov"</a><ul><li><a href="/lkml/2019/9/14/135">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2019/9/15/24">Lennart Poettering</a><ul><li><a href="/lkml/2019/9/15/26">Willy Tarreau</a><ul><li><a href="/lkml/2019/9/15/27">Lennart Poettering</a><ul><li><a href="/lkml/2019/9/15/28">Willy Tarreau</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2019/9/15/311">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/15/311">"Theodore Y. Ts'o"</a><ul><li><a href="/lkml/2019/9/15/316">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 15 Sep 2019 10:02:18 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Linux 5.3-rc8</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sat, Sep 14, 2019 at 11:56 PM Lennart Poettering<br />&lt;mzxreary&#64;0pointer.de&gt; wrote:<br />&gt;<br />&gt; I am not expecting the kernel to guarantee entropy. I just expecting<br />&gt; the kernel to not give me garbage knowingly. It's OK if it gives me<br />&gt; garbage unknowingly, but I have a problem if it gives me trash all the<br />&gt; time.<br /><br />So realistically, we never actually give you *garbage*.<br /><br />It's just that we try very hard to actually give you some entropy<br />guarantees, and that we can't always do in a timely manner -<br />particularly if you don't help.<br /><br />But on a PC, we can _almost_ guarantee entropy. Even with a golden<br />image, we do mix in:<br /><br /> - timestamp counter on every device interrupt (but "device interrupt"<br />doesn't include things like the local CPU timer, so it really needs<br />device activity)<br /><br /> - random boot and BIOS memory (dmi tables, the EFI RNG entry, etc)<br /><br /> - various device state (things like MAC addresses when registering<br />network devices, USB device numbers, etc)<br /><br /> - and obviously any CPU rdrand data<br /><br />and note the "mix in" part - it's all designed so that you don't trust<br />any of this for randomness on its own, but very much hopefully it<br />means that almost *any* differences in boot environment will add a<br />fair amount of unpredictable behavior.<br /><br />But also note the "on a PC" part.<br /><br />Also note that as far as the kernel is concerned, none of the above<br />counts as "entropy" for us, except to a very small degree the device<br />interrupt timing thing. But you need hundreds of interrupts for that<br />to be considered really sufficient.<br /><br />And that's why things broke. It turns out that making ext4 be more<br />efficient at boot caused fewer disk interrupts, and now we weren't<br />convinced we had sufficient entropy. And the systemd boot thing just<br />*stopped* waiting for entropy to magically appear, which is never will<br />if the machine is idle and not doing anything.<br /><br />So do we give you "garbage" in getrandom()? We try really really hard<br />not to, but it's exactly the "can we _guarantee_ that it has entropy"<br />that ends up being the problem.<br /><br />So if some silly early boot process comes along, and asks for "true<br />randomness", and just blocks for it without doing anything else,<br />that's broken from a kernel perspective.<br /><br />In practice, the only situation we have had really big problems with<br />not giving "garbage" isn't actually the "golden distro image" case you<br />talk about. It's the "embedded device golden _system_ image" case,<br />where the image isn't just the distribution, but the full bootloader<br />state.<br /><br />Some cheap embedded MIPS CPU without even a timestamp counter, with<br />identical flash contents for millions of devices, and doing a "on<br />first boot, generate a long-term key" without even connecting to the<br />network first.<br /><br />That's the thing Ted was pointing at:<br /><br />    <a href="https://factorable.net/weakkeys12.extended.pdf">https://factorable.net/weakkeys12.extended.pdf</a><br /><br />so yes, it can be "garbage", but it can be garbage only if you really<br />really do things entirely wrong.<br /><br />But basically, you should never *ever* try to generate some long-lived<br />key and then just wait for it without doing anything else. The<br />"without doing anything else" is key here.<br /><br />But every time we've had a blocking interface, that's exactly what<br />somebody has done. Which is why I consider that long blocking thing to<br />be completely unacceptable. There is no reason to believe that the<br />wait will ever end, partly exactly because we don't consider timer<br />interrupts to add any timer randomness. So if you are just waiting,<br />nothing necessarily ever happen.<br /><br />                 Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
