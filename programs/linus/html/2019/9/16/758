    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/9/13/45">First message in thread</a></li><li><a href="/lkml/2019/9/16/575">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/16/577">Andy Lutomirski</a><ul><li class="origin"><a href="/lkml/2019/9/16/835">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/16/835">Andy Lutomirski</a><ul><li><a href="/lkml/2019/9/16/838">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2019/9/17/126">Borislav Petkov</a></li><li><a href="/lkml/2019/9/17/327">David Laight</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 16 Sep 2019 14:29:52 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC] Improve memset</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Sep 16, 2019 at 10:41 AM Andy Lutomirski &lt;luto&#64;kernel.org&gt; wrote:<br />&gt;<br />&gt; After some experimentation, I think y'all are just doing it wrong.<br />&gt; GCC is very clever about this as long as it's given the chance.  This<br />&gt; test, for example, generates excellent code:<br />&gt;<br />&gt; #include &lt;string.h&gt;<br />&gt;<br />&gt; __THROW __nonnull ((1)) __attribute__((always_inline)) void<br />&gt; *memset(void *s, int c, size_t n)<br />&gt; {<br />&gt;     asm volatile ("nop");<br />&gt;     return s;<br />&gt; }<br />&gt;<br />&gt; /* generates 'nop' */<br />&gt; void zero(void *dest, size_t size)<br />&gt; {<br />&gt;     __builtin_memset(dest, 0, size);<br />&gt; }<br /><br />I think the point was that we'd like to get the default memset (for<br />when __builtin_memset() doesn't generate inline code) also inlined<br />into just "rep stosb", instead of that tail-call "jmp memset".<br /><br />&gt; So I'm thinking maybe compiler.h should actually do something like:<br />&gt;<br />&gt; #define memset __builtin_memset<br />&gt;<br />&gt; and we should have some appropriate magic so that the memset inline is<br />&gt; exempt from the macro.<br /><br />That "appropriate magic" is easy enough: make sure the memset inline<br />shows up before the macro definition.<br /><br />However, gcc never actually inlines the memset() for me, always doing<br />that "jmp memset"<br /><br />&gt; FWIW, this obviously wrong code:<br />&gt;<br />&gt; __THROW __nonnull ((1)) __attribute__((always_inline)) void<br />&gt; *memset(void *s, int c, size_t n)<br />&gt; {<br />&gt;     __builtin_memset(s, c, n);<br />&gt;     return s;<br />&gt; }<br />&gt;<br />&gt; generates 'jmp memset'.  It's not entirely clear to me exactly what's<br />&gt; happening here.<br /><br />I think calling memset() is always the default fallback for<br />__builtin_memset, and because it can't be recursiveyl inlined, it's<br />done as a call. Which is then turned into a tailcall because the<br />calling conventions match, thus the "jmp memset".<br /><br />But as mentioned, the example you claim generates excellent code<br />doesn't actually inline memset() at all for me, and they are all doing<br />"jmp memset" except for the cases that get turned into direct stores.<br /><br />Eg (removing the cfi annotations etc stuff):<br /><br />        zero:<br />                movq    %rsi, %rdx<br />                xorl    %esi, %esi<br />                jmp     memset<br /><br />rather than that "nop" showing up inside the zero function.<br /><br />But I agree that when __builtin_memset() generates manual inline code,<br />it does the right thing, ie<br /><br />        memset_a_bit:<br />                movl    $0, (%rdi)<br />                ret<br /><br />is clearly the right thing to do. We knew that.<br /><br />                  Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
