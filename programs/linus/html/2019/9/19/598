    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/9/8/452">First message in thread</a></li><li><a href="/lkml/2019/9/19/519">"Theodore Y. Ts'o"</a><ul><li><a href="/lkml/2019/9/19/579">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2019/9/20/331">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/20/331">"Theodore Y. Ts'o"</a></li></ul></li><li><a href="/lkml/2019/9/19/759">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/19/801">"Alexander E. Patrakov"</a><ul><li><a href="/lkml/2019/9/19/854">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2019/9/23/283">David Laight</a></li></ul></li><li><a href="/lkml/2019/9/20/330">"Theodore Y. Ts'o"</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2019/9/19/598/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 19 Sep 2019 08:50:15 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH RFC v4 1/1] random: WARN on large getrandom() waits and introduce getrandom2()</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Thu, Sep 19, 2019 at 8:20 AM Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; The silly "reset crng_init_cnt" does absolutely nothing to help that,<br />&gt; but in fact what it does is to basically give the attacker a way to<br />&gt; get an infinite stream of data without any reseeding (because that<br />&gt; only happens after crng_read()), and able to extend that "block at<br />&gt; boot" time indefinitely while doing so.<br /><br />.. btw, instead of bad workarounds for a theoretical attack, here's<br />something that should add actual *practical* real value: use the time<br />of day (whether from an RTC device, or from ntp) to add noise to the<br />random pool.<br /><br />If you let attackers in before you've set the clock on the device,<br />you're doing something seriously wrong.<br /><br />And while this doesn't add much "serious" entropy, it does mean that<br />the whole "let's look for identical state" which is a _real_ attack,<br />goes out the window.<br /><br />In other words, this is about real security, not academic papers.<br /><br />Of course, attackers can still see possible bad random values from<br />before the clock was set (possibly from things like TCP sequence<br />numbers etc, orfrom  that AT_RANDOM of a very early process, which was<br />part of the Android the attack). But doing things like delaying<br />reseeding sure isn't helping, which is what the crng_count reset does.<br /><br />                 Linus<br /> kernel/time/timekeeping.c | 3 +++<br /> 1 file changed, 3 insertions(+)<br /><br />diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c<br />index ca69290bee2a..67e74f7f4198 100644<br />--- a/kernel/time/timekeeping.c<br />+++ b/kernel/time/timekeeping.c<br />&#64;&#64; -22,6 +22,7 &#64;&#64;<br /> #include &lt;linux/pvclock_gtod.h&gt;<br /> #include &lt;linux/compiler.h&gt;<br /> #include &lt;linux/audit.h&gt;<br />+#include &lt;linux/random.h&gt;<br /> <br /> #include "tick-internal.h"<br /> #include "ntp_internal.h"<br />&#64;&#64; -1256,6 +1257,7 &#64;&#64; int do_settimeofday64(const struct timespec64 *ts)<br /> <br /> 	/* signal hrtimers about time change */<br /> 	clock_was_set();<br />+	add_device_randomness(ts, sizeof(*ts));<br /> <br /> 	if (!ret)<br /> 		audit_tk_injoffset(ts_delta);<br />&#64;&#64; -1304,6 +1306,7 &#64;&#64; static int timekeeping_inject_offset(const struct timespec64 *ts)<br /> <br /> 	/* signal hrtimers about time change */<br /> 	clock_was_set();<br />+	add_device_randomness(ts, sizeof(*ts));<br /> <br /> 	return ret;<br /> }</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
