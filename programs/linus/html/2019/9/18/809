    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/9/13/278">First message in thread</a></li><li><a href="/lkml/2019/9/17/473">David Howells</a><ul><li><a href="/lkml/2019/9/17/682">Will Deacon</a></li><li><a href="/lkml/2019/9/18/758">David Howells</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2019/9/19/440">David Howells</a><ul><li><a href="/lkml/2019/9/19/608">Linus Torvalds</a></li><li><a href="/lkml/2019/9/23/490">Peter Zijlstra</a><ul><li><a href="/lkml/2019/9/27/215">Andrea Parri</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 18 Sep 2019 09:48:37 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Do we need to correct barriering in circular-buffers.rst?</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Sep 18, 2019 at 8:43 AM David Howells &lt;dhowells&#64;redhat.com&gt; wrote:<br />&gt;<br />&gt; It mandates using smp_store_release() to update buffer-&gt;head in the producer<br />&gt; and buffer-&gt;tail in the consumer - but these need pairing with memory barriers<br />&gt; used when reading buffer-&gt;head and buffer-&gt;tail on the other side.<br /><br />No, the rule with smp_store_release() should be that it's paired with<br />"smp_load_acquire()". No other barriers needed.<br /><br />If you do that<br /><br />   thread #1            thread #2<br /><br />   ... add data to queue ..<br />   smp_store_release(x)<br /><br />                        smp_load_acquire(x)<br />                        ... read data from queue ..<br /><br />then you should need no other barriers.<br /><br />But yes, store_release(x) should always pair with the load_acquire(x),<br />and the guarantee is that if the load_acquire reads the value that the<br />store_release stored, then all subsequent reads in thread #2 will see<br />all preceding writes in thread #1.<br /><br />That's the optimal locking for a simple queue with a reader and a<br />writer and no other locking needed between the two.<br /><br />HOWEVER.<br /><br />I think this is all entirely pointless wrt the pipe buffer use. You<br />don't have a simple queue. You have multiple writers, and you have<br />multiple readers. As a result, you need real locking.<br /><br />So don't do the barriers. If you do the barriers, you're almost<br />certainly doing something buggy. You don't have the simple "consumer<br />-&gt; producer" thing. Or rather, you don't _only_ have that thing.<br /><br />A reader "produces" a new tail as far as the writer is concerned (so<br />the reader that has consumed an entry does a smp_store_release(tail)<br />-&gt; smp_load_acquire(tail) on the writer side when the writer looks for<br />a new entry it can fill).<br /><br />BUT! A writer also needs to make sure it's the *only* writer for that<br />new entry, and similarly a reader that is about to consume an entry<br />needs to make sure it's the only reader of that entry. So it is *not*<br />that kind of simple hand-off situation at all.<br /><br />End result: use a lock. Seriously. Anything else is going to be buggy,<br />or going to be incredibly subtle.<br /><br />Don't do those barriers. They are wrong. Barriers simply do not<br />protect against two concurrent readers, or two concurrent writers.<br />Barriers are useless.<br /><br />Now, it's possible that barriers together with very clever atomics<br />could do a lockless model, but then all the cleverness is going to be<br />in the lockless part of the code, not the barriers. So even if we<br />eventually do a lockless model, it's completely wrong to do the<br />barriers first.<br /><br />And no, lockless isn't as simple as "readers can do a<br />atomic_add_return_relaxed() to consume an entry, and writers can do a<br />atomic_cmpxchg() to produce one".<br /><br />I think the only possible lockless model is that readers have some<br />exclusion against other readers (so now you have only one reader at a<br />time), and then you fundamentally know that a reader can update the<br />tail pointer without worrying about any races (because a reader will<br />never race against another reader, and a writer will only ever _read_<br />the tail pointer). So then - once you have reader-reader exclusion,<br />the _tail_ update is simple:<br /><br />    smp_store_release(old_tail+1, &amp;tail);<br /><br />because while there are multiple writers, the reader doesn't care (the<br />above, btw, assumes that head/tail themselves aren't doing the "&amp;<br />bufsize" thing, and that that is done at use time - that also makes it<br />easy to see the difference between empty and full).<br /><br />But this still requires that lock around all readers. And we have<br />that: the pipe mutex.<br /><br />But writers have the same issue, and we don't want to use the pipe<br />mutex for writer exclusion, since we want to allow atomic writers.<br /><br />So writers do have to have a lock, or they need to do something clever<br />with a reservation system that uses cmpxchg. Honestly, just do the<br />lock.<br /><br />The way this should be done:<br /><br /> 1) do the head/tail conversion using the EXISTING locking. We have<br />the pipe_mutex, and it serializes everybody right now, and it makes<br />any barriers or atomics pointless. Just covert to a sane and simple<br />head/tail model.<br /><br />    NO BARRIERS!<br /><br />*after* you've done this, do the next phase:<br /><br /> 2) convert the writers to use an irq-safe spinlock, and either make<br />the readers look at it too, or do the above smp_store_release() for<br />the final tail update (and the writers need to use a<br />smp_load_acquire() to look at the tail, despite their lock).<br /><br />    NO BARRIERS (well, outside the tail thing above).<br /><br />and *after* you've done #2, you can now do writes from atomic context.<br /><br />At that point you are done. Consider youself happy, but also allow for<br />the possibility that some day you'll see lock contention with lots of<br />writers, and that *maybe* some day (unlikely) you'd want to look at<br />doing<br /><br /> 3) see if you can make the writers do some clever lockless reservation model.<br /><br />But that #3 really should be considered a "we are pretty sure it's<br />possible in theory, but it's questinably useful, and hopefully we'll<br />never even need to consider it".<br /><br />                Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
