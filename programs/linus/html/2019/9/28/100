    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/9/28/96">First message in thread</a></li><li><a href="/lkml/2019/9/28/96">Thomas Gleixner</a><ul><li class="origin"><a href="/lkml/2019/9/29/21">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/29/21">Thomas Gleixner</a></li><li><a href="/lkml/2019/9/29/27">"Alexander E. Patrakov"</a></li><li><a href="/lkml/2019/9/29/476">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/29/493">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/30/24">Borislav Petkov</a></li></ul></li><li><a href="/lkml/2019/9/29/501">"Theodore Y. Ts'o"</a><ul><li><a href="/lkml/2019/9/30/340">"Theodore Y. Ts'o"</a></li></ul></li></ul></li><li><a href="/lkml/2019/10/1/791">"Ahmed S. Darwish"</a><ul><li><a href="/lkml/2019/10/1/814">Kees Cook</a><ul><li><a href="/lkml/2019/10/1/1099">"Ahmed S. Darwish"</a></li></ul></li><li><a href="/lkml/2019/10/1/1103">Linus Torvalds</a><ul><li><a href="/lkml/2019/10/6/171">Pavel Machek</a></li></ul></li><li><a href="/lkml/2019/10/2/247">"Theodore Y. Ts'o"</a></li></ul></li><li><a href="/lkml/2019/10/6/169">Pavel Machek</a><ul><li><a href="/lkml/2019/10/6/341">Linus Torvalds</a><ul><li><a href="/lkml/2019/10/6/437">Pavel Machek</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2019/9/28/100/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 28 Sep 2019 16:53:52 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: x86/random: Speculation to the rescue</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sat, Sep 28, 2019 at 3:24 PM Thomas Gleixner &lt;tglx&#64;linutronix.de&gt; wrote:<br />&gt;<br />&gt; Nicholas presented the idea to (ab)use speculative execution for random<br />&gt; number generation years ago at the Real-Time Linux Workshop:<br /><br />What you describe is just a particularly simple version of the jitter<br />entropy. Not very reliable.<br /><br />But hey, here's a made-up patch. It basically does jitter entropy, but<br />it uses a more complex load than the fibonacci LFSR folding: it calls<br />"schedule()" in a loop, and it sets up a timer to fire.<br /><br />And then it mixes in the TSC in that loop.<br /><br />And to be fairly conservative, it then credits one bit of entropy for<br />every timer tick. Not because the timer itself would be all that<br />unpredictable, but because the interaction between the timer and the<br />loop is going to be pretty damn unpredictable.<br /><br />Ok, I'm handwaving. But I do claim it really is fairly conservative to<br />think that a cycle counter would give one bit of entropy when you time<br />over a timer actually happening. The way that loop is written, we do<br />guarantee that we'll mix in the TSC value both before and after the<br />timer actually happened. We never look at the difference of TSC<br />values, because the mixing makes that uninteresting, but the code does<br />start out with verifying that "yes, the TSC really is changing rapidly<br />enough to be meaningful".<br /><br />So if we want to do jitter entropy, I'd much rather do something like<br />this that actually has a known fairly complex load with timers and<br />scheduling.<br /><br />And even if absolutely no actual other process is running, the timer<br />itself is still going to cause perturbations. And the "schedule()"<br />call is more complicated than the LFSR is anyway.<br /><br />It does wait for one second the old way before it starts doing this.<br /><br />Whatever. I'm entirely convinced this won't make everybody happy<br />anyway, but it's _one_ approach to handle the issue.<br /><br />Ahmed - would you be willing to test this on your problem case (with<br />the ext4 optimization re-enabled, of course)?<br /><br />And Thomas - mind double-checking that I didn't do anything<br />questionable with the timer code..<br /><br />And this goes without saying - this patch is ENTIRELY untested.  Apart<br />from making people upset for the lack of rigor, it might do<br />unspeakable crimes against your pets. You have been warned.<br /><br />               Linus<br /> drivers/char/random.c | 62 ++++++++++++++++++++++++++++++++++++++++++++++++-<br /> 1 file changed, 61 insertions(+), 1 deletions(-)<br /><br />diff --git a/drivers/char/random.c b/drivers/char/random.c<br />index d3beed084c0a..de434feb873a 100644<br />--- a/drivers/char/random.c<br />+++ b/drivers/char/random.c<br />&#64;&#64; -1732,6 +1732,56 &#64;&#64; void get_random_bytes(void *buf, int nbytes)<br /> }<br /> EXPORT_SYMBOL(get_random_bytes);<br /> <br />+<br />+/*<br />+ * Each time the timer fires, we expect that we got an unpredictable<br />+ * jump in the cycle counter. Even if the timer is running on another<br />+ * CPU, the timer activity will be touching the stack of the CPU that is<br />+ * generating entropy..<br />+ *<br />+ * Note that we don't re-arm the timer in the timer itself - we are<br />+ * happy to be scheduled away, since that just makes the load more<br />+ * complex, but we do not want the timer to keep ticking unless the<br />+ * entropy loop is running.<br />+ *<br />+ * So the re-arming always happens in the entropy loop itself.<br />+ */<br />+static void entropy_timer(struct timer_list *t)<br />+{<br />+	credit_entropy_bits(&amp;input_pool, 1);<br />+}<br />+<br />+/*<br />+ * If we have an actual cycle counter, see if we can<br />+ * generate enough entropy with timing noise<br />+ */<br />+static void try_to_generate_entropy(void)<br />+{<br />+	struct {<br />+		unsigned long now;<br />+		struct timer_list timer;<br />+	} stack;<br />+<br />+	stack.now = random_get_entropy();<br />+<br />+	/* Slow counter - or none. Don't even bother */<br />+	if (stack.now == random_get_entropy())<br />+		return;<br />+<br />+	timer_setup_on_stack(&amp;stack.timer, entropy_timer, 0);<br />+	while (!crng_ready()) {<br />+		if (!timer_pending(&amp;stack.timer))<br />+			mod_timer(&amp;stack.timer, jiffies+1);<br />+		mix_pool_bytes(&amp;input_pool, &amp;stack.now, sizeof(stack.now));<br />+		schedule();<br />+		stack.now = random_get_entropy();<br />+	}<br />+<br />+	del_timer_sync(&amp;stack.timer);<br />+	destroy_timer_on_stack(&amp;stack.timer);<br />+	mix_pool_bytes(&amp;input_pool, &amp;stack.now, sizeof(stack.now));<br />+}<br />+<br /> /*<br />  * Wait for the urandom pool to be seeded and thus guaranteed to supply<br />  * cryptographically secure random numbers. This applies to: the /dev/urandom<br />&#64;&#64; -1746,7 +1796,17 &#64;&#64; int wait_for_random_bytes(void)<br /> {<br /> 	if (likely(crng_ready()))<br /> 		return 0;<br />-	return wait_event_interruptible(crng_init_wait, crng_ready());<br />+<br />+	do {<br />+		int ret;<br />+		ret = wait_event_interruptible_timeout(crng_init_wait, crng_ready(), HZ);<br />+		if (ret)<br />+			return ret &gt; 0 ? 0 : ret;<br />+<br />+		try_to_generate_entropy();<br />+	} while (!crng_ready());<br />+<br />+	return 0;<br /> }<br /> EXPORT_SYMBOL(wait_for_random_bytes);<br /> </pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
