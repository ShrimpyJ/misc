    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/9/8/452">First message in thread</a></li><li><a href="/lkml/2019/9/17/17">Willy Tarreau</a><ul><li><a href="/lkml/2019/9/17/86">Martin Steigerwald</a><ul><li><a href="/lkml/2019/9/17/168">Willy Tarreau</a><ul><li><a href="/lkml/2019/9/17/173">Martin Steigerwald</a></li></ul></li><li><a href="/lkml/2019/9/17/375">"Theodore Y. Ts'o"</a><ul><li><a href="/lkml/2019/9/17/389">"Ahmed S. Darwish"</a><ul><li><a href="/lkml/2019/9/17/414">"Alexander E. Patrakov"</a></li><li><a href="/lkml/2019/9/17/416">Willy Tarreau</a></li><li><a href="/lkml/2019/9/17/626">Lennart Poettering</a></li></ul></li><li><a href="/lkml/2019/9/17/435">"Alexander E. Patrakov"</a><ul><li><a href="/lkml/2019/9/17/461">"Alexander E. Patrakov"</a></li></ul></li><li><a href="/lkml/2019/9/17/619">Lennart Poettering</a><ul><li><a href="/lkml/2019/9/17/642">Willy Tarreau</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2019/9/17/671">Linus Torvalds</a><ul><li><a href="/lkml/2019/9/17/671">"Alexander E. Patrakov"</a><ul><li><a href="/lkml/2019/9/17/713">Lennart Poettering</a></li></ul></li><li><a href="/lkml/2019/9/17/677">Matthew Garrett</a><ul><li><a href="/lkml/2019/9/17/690">Willy Tarreau</a></li></ul></li><li><a href="/lkml/2019/9/17/711">Lennart Poettering</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2019/9/17/645/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 17 Sep 2019 09:27:44 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Linux 5.3-rc8</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Sep 17, 2019 at 12:33 AM Martin Steigerwald &lt;martin&#64;lichtvoll.de&gt; wrote:<br />&gt;<br />&gt; So yes, that would it make it harder to abuse the API, but not<br />&gt; impossible. Which may still be good, I don't know.<br /><br />So the real problem is not people abusing the ABI per se. Yes, I was a<br />bit worried about that too, but it's not the cause of the immediate<br />issue.<br /><br />The real problem is that "getrandom(0)" is really _convenient_ for<br />people who just want random numbers - and not at all the "secure"<br />kind.<br /><br />And it's convenient, and during development and testing, it always<br />"just works", because it doesn't ever block in any normal situation.<br /><br />And then you deploy it, and on some poor users machine it *does*<br />block, because the program now encounters the "oops, no entropy"<br />situation that it never ever encountered on the development machine,<br />because the testing there was mainly done not during booting, but the<br />developer also probably had a much more modern machine that had<br />rdrand, and that quite possibly also had more services enabled at<br />bootup etc so even without rdrand it got tons of entropy.<br /><br />That's why<br /><br /> (a) killing the process is _completely_ silly.  It misses the whole<br />point of the problem in the first place and only makes things much<br />worse.<br /><br /> (b) we should just change getrandom() and add that GRND_SECURE flag<br />instead. Because the current API is fundamentally confusing. If you<br />want secure random numbers, you should really deeply _know_ about it,<br />and think about it, rather than have it be the "oh, don't even bother<br />passing any flags, it's secure by default".<br /><br /> (c) the timeout approach isn't wonderful, but it at least helps with<br />the "this was never tested under those circumstances" kind of problem.<br /><br />Note that the people who actually *thought* about getrandom() and use<br />it correctly should already handle error returns (even for the<br />blocking version), because getrandom() can already return EINTR. So<br />the argument that we should cater primarily to the secure key people<br />is not all that strong. We should be able to return EINTR, and the<br />people who *thought* about blocking and about entropy should be fine.<br /><br />And gdm and other silly random users that never wanted entropy in the<br />first place, just "random" random numbers, wouldn't be in the<br />situation they are now.<br /><br />That said - looking at some of the problematic traces that Ahmed<br />posted for his bootup problem, I actually think we can use *another*<br />heuristic to solve the problem. Namely just looking at how much<br />randomness the caller wants.<br /><br />The processes that ask for randomness for an actual secure key have a<br />very fundamental constraint: they need enough randomness for the key<br />to be secure in the first place.<br /><br />But look at what gnome-shell and gnome-session-b does:<br /><br />    <a href="https://lore.kernel.org/linux-ext4/20190912034421.GA2085&#64;darwi-home-pc/">https://lore.kernel.org/linux-ext4/20190912034421.GA2085&#64;darwi-home-pc/</a><br /><br />and most of them already set GRND_NONBLOCK, but look at the<br />problematic one that actually causes the boot problem:<br /><br />    gnome-session-b-327   4.400620: getrandom(16 bytes, flags = 0)<br /><br />and here the big clue is: "Hey, it only asks for 128 bits of randomness".<br /><br />Does anybody believe that 128 bits of randomness is a good basis for a<br />long-term secure key? Even if the key itself contains than that, if<br />you are generating a long-term secure key in this day and age, you had<br />better be asking for more than 128 bits of actual unpredictable base<br />data. So just based on the size of the request we can determine that<br />this is not hugely important.<br /><br />Compare that to the case later on for something that seems to ask for<br />actual interesting randomness. and - just judging by the name -<br />probably even has a reason for it:<br /><br />      gsd-smartcard-388   51.433924: getrandom(110 bytes, flags = 0)<br />      gsd-smartcard-388   51.433936: getrandom(256 bytes, flags = 0)<br /><br />big difference.<br /><br />End result: I would propose the attached patch.<br /><br />Ahmed, can you just verify that it works for you (obviously with the<br />ext4 plugging reinstated)? It looks like it should "obviously" fix<br />things, but still...<br /><br />                    Linus<br /> drivers/char/random.c | 33 ++++++++++++++++++++++++++++++++-<br /> 1 file changed, 32 insertions(+), 1 deletion(-)<br /><br />diff --git a/drivers/char/random.c b/drivers/char/random.c<br />index 566922df4b7b..7be771eac969 100644<br />--- a/drivers/char/random.c<br />+++ b/drivers/char/random.c<br />&#64;&#64; -2118,6 +2118,37 &#64;&#64; const struct file_operations urandom_fops = {<br /> 	.llseek = noop_llseek,<br /> };<br /> <br />+/*<br />+ * Hacky workaround for the fact that some processes<br />+ * ask for truly secure random numbers and absolutely want<br />+ * to wait for the entropy pool to fill, and others just<br />+ * do "getrandom(0)" to get some ad-hoc random numbers.<br />+ *<br />+ * If you're generating a secure key, you'd better ask for<br />+ * more than 128 bits of randomness. Otherwise it's not<br />+ * really all that secure by definition.<br />+ *<br />+ * We should add a GRND_SECURE flag so that people can state<br />+ * this "I want secure random numbers" explicitly.<br />+ */<br />+static int wait_for_getrandom(size_t count)<br />+{<br />+	unsigned long timeout = MAX_SCHEDULE_TIMEOUT;<br />+	int ret;<br />+<br />+	/* We'll give even small requests _some_ time to get more entropy */<br />+	if (count &lt;= 16)<br />+		timeout = 5*HZ;<br />+<br />+	ret = wait_event_interruptible_timeout(crng_init_wait, crng_ready(), timeout);<br />+	if (likely(ret))<br />+		return ret &gt; 0 ? 0 : ret;<br />+<br />+	/* Timed out - we'll return urandom */<br />+	pr_notice("random: falling back to urandom for small request of %zu bytes", count);<br />+	return 0;<br />+}<br />+<br /> SYSCALL_DEFINE3(getrandom, char __user *, buf, size_t, count,<br /> 		unsigned int, flags)<br /> {<br />&#64;&#64; -2135,7 +2166,7 &#64;&#64; SYSCALL_DEFINE3(getrandom, char __user *, buf, size_t, count,<br /> 	if (!crng_ready()) {<br /> 		if (flags &amp; GRND_NONBLOCK)<br /> 			return -EAGAIN;<br />-		ret = wait_for_random_bytes();<br />+		ret = wait_for_getrandom(count);<br /> 		if (unlikely(ret))<br /> 			return ret;<br /> 	}</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
