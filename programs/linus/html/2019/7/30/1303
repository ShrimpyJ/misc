    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/7/28/194">First message in thread</a></li><li><a href="/lkml/2019/7/28/242">Kees Cook</a><ul><li><a href="/lkml/2019/7/30/610">Alexander Potapenko</a><ul><li class="origin"><a href="/lkml/2019/7/31/422">Linus Torvalds</a><ul><li><a href="/lkml/2019/7/31/422">Alexander Potapenko</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 30 Jul 2019 12:53:57 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [GIT PULL] meminit fix for v5.3-rc2</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Jul 30, 2019 at 6:53 AM Alexander Potapenko &lt;glider&#64;google.com&gt; wrote:<br />&gt;<br />&gt; I wonder how hard it should be to make a zero-filling GCC plugin?<br />&gt; I'm not a big fan of hacking GCC, but it shouldn't differ much from<br />&gt; the existing GCC plugins that initialize locals.<br /><br />The thing is, as long as it's a plugin, I don't think we can rely on<br />it. The gcc people will rightly just laugh at us if we were to report<br />a bug with some kernel plugin.<br /><br />So I'd like the zeroing of local variables to be a native compiler<br />option, so that we can (_eventually_ - these things take a long time)<br />just start saying "ok, we simply consider stack variables to be always<br />initialized".<br /><br />&gt; I've some stale data collected on an x86 QEMU instance.<br />&gt; For 0x00 stack initialization:<br />&gt;  - hackbench, netperf and parallel Linux build were virtually free<br />&gt; (slowdown within stdev)<br />&gt;  - for af_inet_loopback the slowdown was ~4%<br />&gt; For 0xAA stack initialization:<br />&gt;  - netperf and parallel Linux build were free<br />&gt;  - for hackbench the slowdown was ~1.5%<br />&gt;  - for af_inet_loopback the slowdown was ~7%<br /><br />So I would expect that we have some special cases where we end up<br />having arrays (or big structures) on the stack that end up being<br />critical, and where initializing them is clearly  abad idea.<br /><br />Then we can verify manually are very much initialized, and that we<br />could then mark and say "this is uninitialized".<br /><br />So when a compiler has an option to initialize stack variables, it<br />would probably _also_ be a very good idea for that compiler to then<br />support a variable attribute that says "don't initialize _this_<br />variable, I will do that manually".<br /><br />But if we in ten years had a kernel model where only allocations and<br />variables that were _explicitly_ uninitialized, that would be lovely.<br /><br />Then you can grep for those and verify that "yes, this is safe".<br /><br />We've historically had the reverse model - things are uninitialized by<br />default, and you have to explicitly initialize them. Turning that on<br />its head is what I would like to do long-term.<br /><br />(For normal allocations that wouldn't be too bad: get rid of<br />__GFP_ZERO and friends, and instead do __GFP_UNINITIALIZED).<br /><br />Again - I don't think we want a world where everything is<br />force-initialized. There _are_ going to be situations where that just<br />hurts too much. But if we get to a place where we are zero-initialized<br />by default, and have to explicitly mark the unsafe things (and we'll<br />have comments not just about how they get initialized, but also about<br />why that particular thing is so performance-critical), that would be a<br />good place to be.<br /><br />This, btw, is why I also think that the "initialize with poison" is<br />pointless and wrong. Yes, it can find bugs, but it doesn't really help<br />improve the general situation, and people see it as a debugging tool,<br />not a "improve code quality and improve the life of kernel developers"<br />tool.<br /><br />                Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
