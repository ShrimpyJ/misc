    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2019/7/13/52">First message in thread</a></li><li><a href="/lkml/2019/7/13/52">Alexey Dobriyan</a><ul><li><a href="/lkml/2019/7/13/139">Alexey Izbyshev</a></li><li><a href="/lkml/2019/7/14/5">(Eric W. Biederman)</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></li></ul><div class="threadlist">Patches in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2019/7/14/7/1">Get diff 1</a></li><li><a href="/lkml/diff/2019/7/14/7/2">Get diff 2</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 13 Jul 2019 22:02:15 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] proc: revert /proc/*/cmdline rewrite</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">[ Apparently this thread wasn't on the lists, and I didn't even<br />notice. So re-sending the patches ]<br /><br />On Sat, Jul 13, 2019 at 9:16 PM Eric W. Biederman &lt;ebiederm&#64;xmission.com&gt; wrote:<br />&gt; Given that this fixes a regression and a bug.<br />&gt;<br />&gt; Acked-by: "Eric W. Biederman" &lt;ebiederm&#64;xmission.com&gt;<br /><br />I'd much rather start from scratch. Like the attached.<br /><br />Alexey Izbyshev has a third patch that then limits the setproctitle()<br />case to only allow looking into the env[] area, which looks<br />reasonable.<br /><br />           Linus<br />From 5563a2fb39fe0ad42f239d2f583128d50155002b Mon Sep 17 00:00:00 2001<br />From: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />Date: Sat, 13 Jul 2019 13:40:13 -0700<br />Subject: [PATCH 1/2] /proc/&lt;pid&gt;/cmdline: remove all the special cases<br /><br />Start off with a clean slate that only reads exactly from arg_start to<br />arg_end, without any oddities.<br /><br />We'll add back the setproctitle() special case very differently in the<br />next commit.<br /><br />Signed-off-by: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />---<br /> fs/proc/base.c | 71 ++++++--------------------------------------------<br /> 1 file changed, 8 insertions(+), 63 deletions(-)<br /><br />diff --git a/fs/proc/base.c b/fs/proc/base.c<br />index 255f6754c70d..8040f9d1cf07 100644<br />--- a/fs/proc/base.c<br />+++ b/fs/proc/base.c<br />&#64;&#64; -212,7 +212,7 &#64;&#64; static int proc_root_link(struct dentry *dentry, struct path *path)<br /> static ssize_t get_mm_cmdline(struct mm_struct *mm, char __user *buf,<br /> 			      size_t count, loff_t *ppos)<br /> {<br />-	unsigned long arg_start, arg_end, env_start, env_end;<br />+	unsigned long arg_start, arg_end;<br /> 	unsigned long pos, len;<br /> 	char *page;<br /> <br />&#64;&#64; -223,36 +223,18 &#64;&#64; static ssize_t get_mm_cmdline(struct mm_struct *mm, char __user *buf,<br /> 	spin_lock(&amp;mm-&gt;arg_lock);<br /> 	arg_start = mm-&gt;arg_start;<br /> 	arg_end = mm-&gt;arg_end;<br />-	env_start = mm-&gt;env_start;<br />-	env_end = mm-&gt;env_end;<br /> 	spin_unlock(&amp;mm-&gt;arg_lock);<br /> <br /> 	if (arg_start &gt;= arg_end)<br /> 		return 0;<br /> <br />-	/*<br />-	 * We have traditionally allowed the user to re-write<br />-	 * the argument strings and overflow the end result<br />-	 * into the environment section. But only do that if<br />-	 * the environment area is contiguous to the arguments.<br />-	 */<br />-	if (env_start != arg_end || env_start &gt;= env_end)<br />-		env_start = env_end = arg_end;<br />-<br />-	/* .. and limit it to a maximum of one page of slop */<br />-	if (env_end &gt;= arg_end + PAGE_SIZE)<br />-		env_end = arg_end + PAGE_SIZE - 1;<br />-<br /> 	/* We're not going to care if "*ppos" has high bits set */<br />-	pos = arg_start + *ppos;<br />-<br /> 	/* .. but we do check the result is in the proper range */<br />-	if (pos &lt; arg_start || pos &gt;= env_end)<br />+	pos = arg_start + *ppos;<br />+	if (pos &lt; arg_start || pos &gt;= arg_end)<br /> 		return 0;<br />-<br />-	/* .. and we never go past env_end */<br />-	if (env_end - pos &lt; count)<br />-		count = env_end - pos;<br />+	if (count &gt; arg_end - pos)<br />+		count = arg_end - pos;<br /> <br /> 	page = (char *)__get_free_page(GFP_KERNEL);<br /> 	if (!page)<br />&#64;&#64; -262,48 +244,11 &#64;&#64; static ssize_t get_mm_cmdline(struct mm_struct *mm, char __user *buf,<br /> 	while (count) {<br /> 		int got;<br /> 		size_t size = min_t(size_t, PAGE_SIZE, count);<br />-		long offset;<br /> <br />-		/*<br />-		 * Are we already starting past the official end?<br />-		 * We always include the last byte that is *supposed*<br />-		 * to be NUL<br />-		 */<br />-		offset = (pos &gt;= arg_end) ? pos - arg_end + 1 : 0;<br />-<br />-		got = access_remote_vm(mm, pos - offset, page, size + offset, FOLL_ANON);<br />-		if (got &lt;= offset)<br />+		got = access_remote_vm(mm, pos, page, size, FOLL_ANON);<br />+		if (got &lt;= 0)<br /> 			break;<br />-		got -= offset;<br />-<br />-		/* Don't walk past a NUL character once you hit arg_end */<br />-		if (pos + got &gt;= arg_end) {<br />-			int n = 0;<br />-<br />-			/*<br />-			 * If we started before 'arg_end' but ended up<br />-			 * at or after it, we start the NUL character<br />-			 * check at arg_end-1 (where we expect the normal<br />-			 * EOF to be).<br />-			 *<br />-			 * NOTE! This is smaller than 'got', because<br />-			 * pos + got &gt;= arg_end<br />-			 */<br />-			if (pos &lt; arg_end)<br />-				n = arg_end - pos - 1;<br />-<br />-			/* Cut off at first NUL after 'n' */<br />-			got = n + strnlen(page+n, offset+got-n);<br />-			if (got &lt; offset)<br />-				break;<br />-			got -= offset;<br />-<br />-			/* Include the NUL if it existed */<br />-			if (got &lt; size)<br />-				got++;<br />-		}<br />-<br />-		got -= copy_to_user(buf, page+offset, got);<br />+		got -= copy_to_user(buf, page, got);<br /> 		if (unlikely(!got)) {<br /> 			if (!len)<br /> 				len = -EFAULT;<br />-- <br />2.22.0.193.g083935f9a2<br />From 63dd14999c6b210fbe33f780fec53faefa867d95 Mon Sep 17 00:00:00 2001<br />From: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />Date: Sat, 13 Jul 2019 14:27:14 -0700<br />Subject: [PATCH 2/2] /proc/&lt;pid&gt;/cmdline: add back the setproctitle() special<br /> case<br /><br />This makes the setproctitle() special case very explicit indeed, and<br />handles it with a separate helper function entirely.<br /><br />This makes the logic about when we use the string lengths etc much more<br />obvious, and makes it easy to see what we do.<br /><br />[ Fixed for missing 'count' check noted by Alexey Izbyshev ]<br />Signed-off-by: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />---<br /> fs/proc/base.c | 54 +++++++++++++++++++++++++++++++++++++++++++++++++-<br /> 1 file changed, 53 insertions(+), 1 deletion(-)<br /><br />diff --git a/fs/proc/base.c b/fs/proc/base.c<br />index 8040f9d1cf07..3ad3ff4cc12c 100644<br />--- a/fs/proc/base.c<br />+++ b/fs/proc/base.c<br />&#64;&#64; -209,12 +209,54 &#64;&#64; static int proc_root_link(struct dentry *dentry, struct path *path)<br /> 	return result;<br /> }<br /> <br />+/*<br />+ * If the user used setproctitle(), we just get the string from<br />+ * user space at arg_start, and limit it to a maximum of one page.<br />+ */<br />+static ssize_t get_mm_proctitle(struct mm_struct *mm, char __user *buf,<br />+				size_t count, loff_t *ppos,<br />+				unsigned long arg_start)<br />+{<br />+	unsigned long pos = *ppos;<br />+	char *page;<br />+	int ret, got;<br />+<br />+	if (pos &gt;= PAGE_SIZE)<br />+		return 0;<br />+<br />+	page = (char *)__get_free_page(GFP_KERNEL);<br />+	if (!page)<br />+		return -ENOMEM;<br />+<br />+	ret = 0;<br />+	got = access_remote_vm(mm, arg_start, page, PAGE_SIZE, FOLL_ANON);<br />+	if (got &gt; 0) {<br />+		int len = strnlen(page, got);<br />+<br />+		/* Include the NUL character if it was found */<br />+		if (len &lt; got)<br />+			len++;<br />+<br />+		if (len &gt; pos) {<br />+			len -= pos;<br />+			if (len &gt; count)<br />+				len = count;<br />+			len -= copy_to_user(buf, page+pos, len);<br />+			if (!len)<br />+				len = -EFAULT;<br />+			ret = len;<br />+		}<br />+	}<br />+	free_page((unsigned long)page);<br />+	return ret;<br />+}<br />+<br /> static ssize_t get_mm_cmdline(struct mm_struct *mm, char __user *buf,<br /> 			      size_t count, loff_t *ppos)<br /> {<br /> 	unsigned long arg_start, arg_end;<br /> 	unsigned long pos, len;<br />-	char *page;<br />+	char *page, c;<br /> <br /> 	/* Check if process spawned far enough to have cmdline. */<br /> 	if (!mm-&gt;env_end)<br />&#64;&#64; -228,6 +270,16 &#64;&#64; static ssize_t get_mm_cmdline(struct mm_struct *mm, char __user *buf,<br /> 	if (arg_start &gt;= arg_end)<br /> 		return 0;<br /> <br />+	/*<br />+	 * Magical special case: if the argv[] end byte is not<br />+	 * zero, the user has overwritten it with setproctitle(3).<br />+	 *<br />+	 * Possible future enhancement: do this only once when<br />+	 * pos is 0, and set a flag in the 'struct file'.<br />+	 */<br />+	if (access_remote_vm(mm, arg_end-1, &amp;c, 1, FOLL_ANON) == 1 &amp;&amp; c)<br />+		return get_mm_proctitle(mm, buf, count, ppos, arg_start);<br />+<br /> 	/* We're not going to care if "*ppos" has high bits set */<br /> 	/* .. but we do check the result is in the proper range */<br /> 	pos = arg_start + *ppos;<br />-- <br />2.22.0.193.g083935f9a2<br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
