    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/9/17/158">First message in thread</a></li><li><a href="/lkml/2006/9/18/137">Linus Torvalds</a><ul><li><a href="/lkml/2006/9/18/138">Ingo Molnar</a></li><li><a href="/lkml/2006/9/18/146">Andi Kleen</a><ul><li><a href="/lkml/2006/9/18/149">Ingo Molnar</a></li><li class="origin"><a href="/lkml/2006/9/18/164">Linus Torvalds</a><ul><li><a href="/lkml/2006/9/18/164">Linus Torvalds</a><ul><li><a href="/lkml/2006/9/18/171">Jeremy Fitzhardinge</a></li></ul></li></ul></li><li><a href="/lkml/2006/9/18/166">Benjamin LaHaise</a><ul><li><a href="/lkml/2006/9/18/178">Andi Kleen</a><ul><li><a href="/lkml/2006/9/18/201">Jeremy Fitzhardinge</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2006/9/18/161/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 18 Sep 2006 09:02:51 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Sysenter crash with Nested Task Bit set</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 18 Sep 2006, Andi Kleen wrote:<br />&gt; <br />&gt; &gt; If we fix it in the task-switch code, we shouldn't need any other changes <br />&gt; &gt; (ie Chuck's change is unnecessary too), because then the process that sets <br />&gt; &gt; NT will happily die (with NT set), but switch away to something else and <br />&gt; &gt; nobody else will be affected.<br />&gt; <br />&gt; Won't it die in the kernel with an oops on the next interrupt?<br /><br />No. As mentioned, "sysenter" is really special. It should really be the <br />_only_ entry into the kernel that doesn't change eflags. Everything else <br />clears NT (and most of them do other things too).<br /><br />So if a process already runs in kernel mode (or used mode, for that <br />matter) with NT set, and an interrupt happens, the act of taking the <br />interrupt will clear NT, and nothing bad happens at all. In fact, we very <br />much depend on this, exactly because otherwise user mode could just set NT <br />and just wait for an interrupt, and bad things would happen. They <br />obviously don't.<br /><br />So it's literally _only_ the path of<br /><br />	set NT<br />	sysenter<br />	...<br />	iret<br /><br />that causes problems, because all other paths will clear NT on entry into <br />the kernel.<br /><br />&gt; &gt; So if I'm right, then this patch _should_ fix it. UNTESTED (and the <br />&gt; &gt; "ref_from_fork" special case doesn't clear NT, so it's strictly incompete, <br />&gt; &gt; but maybe somebody can test this?)<br />&gt; <br />&gt; Are you sure this handles interrupts or nested syscalls <br />&gt; before the context switch correctly?<br /><br />Yeah, see above. And I have now even tested it slightly (ie I ran one of <br />my x86 machines with that patch).<br /><br />&gt; I think it really needs to be handled in the sysenter path.<br /><br />It really would be much more expensive there (well, the expense would be <br />the same, but any load that have any amount of either would tend to have <br />many more system calls than context switches).<br /><br />The only way to have more context switches than system calls is to run <br />entirely in user space all the time, and then we don't care - the context <br />switches will also be so rare that the extra cycles simply don't matter.<br /><br />&gt; &gt; Andi? I don't know if x86-64 honors NT in 64-bit mode, but if it does, it <br />&gt; &gt; needs something similar (assuming this works).<br />&gt; <br />&gt; It doesn't task switch, but you would get a #GP in IRET at least.<br />&gt; Leaking that to another process is definitely not good.<br /><br />Right. Then you need that exact same thing on x86-64 too.<br /><br />One final note: as I already mentioned, this isn't actually entirely <br />sufficient. There's the magic special case of "switch to a newly created <br />thread", which jumps to "ret_from_fork" rather than staying within that <br />small area. We'll need to add "clear NT" there.<br /><br />So this (UNTESTED - I tested the previous version, and it works, but this <br />extends on it) second patch should be more complete. It handles the case <br />where the NT-dirty task context switches to a newly created task, by just <br />forcing "eflags" to a known value in the newly created task, rather than <br />whatever value it had at the time of the context switch.<br /><br />The addition is fairly obvious, but maybe I screwed something up, so buyer <br />beware...<br /><br />		Linus<br /><br />---<br />diff --git a/arch/i386/kernel/entry.S b/arch/i386/kernel/entry.S<br />index 37a7d2e..87f9f60 100644<br />--- a/arch/i386/kernel/entry.S<br />+++ b/arch/i386/kernel/entry.S<br />&#64;&#64; -209,6 +209,10 &#64;&#64; ENTRY(ret_from_fork)<br /> 	GET_THREAD_INFO(%ebp)<br /> 	popl %eax<br /> 	CFI_ADJUST_CFA_OFFSET -4<br />+	pushl $0x0202			# Reset kernel eflags<br />+	CFI_ADJUST_CFA_OFFSET 4<br />+	popfl<br />+	CFI_ADJUST_CFA_OFFSET -4<br /> 	jmp syscall_exit<br /> 	CFI_ENDPROC<br /> <br />diff --git a/include/asm-i386/system.h b/include/asm-i386/system.h<br />index 49928eb..defbf12 100644<br />--- a/include/asm-i386/system.h<br />+++ b/include/asm-i386/system.h<br />&#64;&#64; -13,7 +13,8 &#64;&#64; extern struct task_struct * FASTCALL(__s<br /> <br /> #define switch_to(prev,next,last) do {					\<br /> 	unsigned long esi,edi;						\<br />-	asm volatile("pushl %%ebp\n\t"					\<br />+	asm volatile("pushfl\n\t"		/* Save flags */	\<br />+		     "pushl %%ebp\n\t"					\<br /> 		     "movl %%esp,%0\n\t"	/* save ESP */		\<br /> 		     "movl %5,%%esp\n\t"	/* restore ESP */	\<br /> 		     "movl $1f,%1\n\t"		/* save EIP */		\<br />&#64;&#64; -21,6 +22,7 &#64;&#64; #define switch_to(prev,next,last) do {		<br /> 		     "jmp __switch_to\n"				\<br /> 		     "1:\t"						\<br /> 		     "popl %%ebp\n\t"					\<br />+		     "popfl"						\<br /> 		     :"=m" (prev-&gt;thread.esp),"=m" (prev-&gt;thread.eip),	\<br /> 		      "=a" (last),"=S" (esi),"=D" (edi)			\<br /> 		     :"m" (next-&gt;thread.esp),"m" (next-&gt;thread.eip),	\<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
