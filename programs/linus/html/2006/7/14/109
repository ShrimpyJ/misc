    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/7/14/85">First message in thread</a></li><li><a href="/lkml/2006/7/14/85">Steven Rostedt</a><ul><li class="origin"><a href="/lkml/2006/7/14/133">Linus Torvalds</a><ul><li><a href="/lkml/2006/7/14/133">Chase Venters</a><ul><li><a href="/lkml/2006/7/14/142">Linus Torvalds</a><ul><li><a href="/lkml/2006/7/14/149">Steven Rostedt</a></li></ul></li></ul></li><li><a href="/lkml/2006/7/14/168">Linus Torvalds</a><ul><li><a href="/lkml/2006/7/14/171">Steven Rostedt</a><ul><li><a href="/lkml/2006/7/14/173">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2006/7/15/81">Nick Piggin</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2006/7/14/109/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 14 Jul 2006 08:23:55 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] remove volatile from nmi.c</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 14 Jul 2006, Steven Rostedt wrote:<br />&gt;<br />&gt; OK, I'm using this as something of an exercise to completely understand<br />&gt; memory barriers.  So if something is incorrect, please let me know.<br /><br />It's not an incorrect change, but perhaps more importantly, the old code <br />was buggy in other ways too. Which is sadly more-than-common with anything <br />that uses volatile - the issues that make people think using "volatile" is <br />a good idea also tend to cause other problems if the person in question <br />isn't careful (and using "volatile" obviously means that he/she/it wasn't <br />very careful when writing it).<br /><br />In particular, notice how "endflag" is on the _stack_ of the CPU that <br />wants to send out the NMI to another CPU?<br /><br />Now, think what that means for the case where we time out and return from <br />the function with an error.. In particular, think about the case of the <br />other CPU having been very busy, and now having a stale pointer that <br />points _where_ exactly?<br /><br />Also, when the caller sets "endflag", it doesn't (for barrier reasons, see <br />more below) actually need to use a write barrier in either of the two <br />cases, because of some _other_ issues. There are two cases of the caller <br />setting endflag, and neither of them needs "set_wmb()", but it's perhaps <br />instructive to show _why_.<br /><br />The first case is the initialization to zero. That one doesn't need a <br />write barrier, because it has _other_ serialization to any reader. In <br />order for another CPU to read that value, the other CPU needs to have <br />_gotten_ the pointer to it in the first place, and that implies that it <br />got the "smp_call_function()" thing.<br /><br />And "smp_call_function()" will better have a serialization in it, because <br />otherwise _any_ user of smp_call_function() would potentially set up data <br />structures that aren't then readable from other CPUs. So for the <br />particular case of x86, see the "mb()" in smp_call_function() just before <br />it does the "send_IPI_allbutself()".<br /><br />Now, the other case is the case where we set endflag to 1 because we're no <br />longer interested in the other CPU's. And the reason we don't need a <br />barrier there is that WE OBVIOUSLY NO LONGER CARE when the other side <br />sees the value - at that point, it's all moot, because there isn't any <br />serialization left, and it's just a flag to the other CPU's saying "don't <br />bother".<br /><br />So let's go back to the bigger problem..<br /><br />Now, there is a "reason" we'd want "endflag" to either be volatile, or <br />have the "set_wmb()", and that is that the code is incorrect in the first <br />place. <br /><br />Without the volatile, or the "set_wmb()", the compiler could decide to not <br />do the last "endflag = 1" write _at_all_, because<br /><br /> - endflag is an automatic variable<br /><br /> - we're going to return from the function RSN, which de-allocates it<br /><br />and as such, the "volatile" or "set_wmb()" actually forces that write to <br />happen at all. It so happens that because we have a printk() in there, and <br />gcc doesn't know that the printk() didn't get the address of the variable <br />through the "smp_call_function()" thing, gcc won't dare to remove the <br />write anyway, but let's say that the final 'printk("OK.\n");' wasn't <br />there, then the compiler could have removed it.<br /><br />So in that sense, "volatile" and "set_wmb()" superficially "remove a bug", <br />since optimizing out the write is wrong. However, the REAL bug was totally <br />elsewhere, and is the fact that "endflag" is an automatic variable in the <br />first place! The compiler would have been _correct_ to optimize the store <br />away, because the compiler (unlike the programmer) would have correctly <br />realized that it cannot matter.<br /><br />&gt; The first removal is trivial, since the barrier in the while loop makes<br />&gt; it unnecessary.<br /><br />Yes, and the first removal is also very much correct.<br /><br />&gt; The second is what I think is correct.<br /><br />See above. The second is "correct", in the sense that from a "volatile <br />removal" standpoint it does all the right things. But it's incorrect, <br />because it misses the bigger problem with the code.<br /><br />So I would suggest that the _real_ fix is actually something like the <br />appended, but I have to say that I didn't really look very closely into <br />it.<br /><br />I think that in _practice_ it probably doesn't really matter (in practice, <br />the other CPU's will either get the NMI or not, and in practice, the stack <br />location - even after it is released - will probably be overwritten by <br />something non-zero later anyway), but I think that my fix makes it more <br />obvious what is really going on, and it's easier to explain why it does <br />what it does because it no longer depends on insane code.<br /><br />But somebody like Ingo should probably double-check this.<br /><br />(The "Have we done this already" test is just covering my ass - I don't <br />think we should be calling that function more than once, but one of the <br />things that happens when the "endflag" semantics are fixed is that the <br />function now has history and the variable is no longer "per CPU". The <br />point is, that changes how initializations etc may need to be done: in <br />this case we only want to do it once, but in other cases this kind of <br />change may have more far-reaching implications).<br /><br />		Linus<br /><br />---<br />diff --git a/arch/i386/kernel/nmi.c b/arch/i386/kernel/nmi.c<br />index 2dd928a..eb8bbbb 100644<br />--- a/arch/i386/kernel/nmi.c<br />+++ b/arch/i386/kernel/nmi.c<br />&#64;&#64; -106,7 +106,7 &#64;&#64; #ifdef CONFIG_SMP<br />  */<br /> static __init void nmi_cpu_busy(void *data)<br /> {<br />-	volatile int *endflag = data;<br />+	int *endflag = data;<br /> 	local_irq_enable_in_hardirq();<br /> 	/* Intentionally don't use cpu_relax here. This is<br /> 	   to make sure that the performance counter really ticks,<br />&#64;&#64; -121,10 +121,14 &#64;&#64; #endif<br /> <br /> static int __init check_nmi_watchdog(void)<br /> {<br />-	volatile int endflag = 0;<br />+	static int endflag = 0;<br /> 	unsigned int *prev_nmi_count;<br /> 	int cpu;<br /> <br />+	/* Have we done this already? */<br />+	if (endflag)<br />+		return 0;<br />+<br /> 	if (nmi_watchdog == NMI_NONE)<br /> 		return 0;<br /> <br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
