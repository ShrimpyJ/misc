    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/7/22/88">First message in thread</a></li><li><a href="/lkml/2006/7/22/117">Linus Torvalds</a><ul><li><a href="/lkml/2006/7/23/1">Arjan van de Ven</a><ul><li class="origin"><a href="/lkml/2006/7/23/57">Linus Torvalds</a><ul><li><a href="/lkml/2006/7/23/57">Linus Torvalds</a><ul><li><a href="/lkml/2006/7/23/62">Patrick McFarland</a></li><li><a href="/lkml/2006/7/24/43">Arjan van de Ven</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2006/7/23/3">Andrew Morton</a><ul><li><a href="/lkml/2006/7/23/12">Arjan van de Ven</a></li><li><a href="/lkml/2006/7/23/46">Ingo Molnar</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2006/7/23/50/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 23 Jul 2006 10:20:47 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: remove cpu hotplug bustification in cpufreq.</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sun, 23 Jul 2006, Arjan van de Ven wrote:<br />&gt; <br />&gt; with rwsems being 100% fair... how is that going to make a difference?<br />&gt; Other than just making the deadlock harder to trigger because the writer<br />&gt; needs to come in just at the right time...<br /><br />Fair enough, I forgot about that particular braindamage. It would be _soo_ <br />nice to have a proper rwsem like we used to.<br /><br />Ok, here's a final try.<br /><br />Its actually simpler than either of the previous ones, and it just does <br />two different locks: a "cpu_add_remove_lock" which is entirely internal to <br />kernel/cpu.c, and is held over the entirety of a cpu_add()/cpu_down() <br />sequence, so that we will only ever add one CPU at a time.<br /><br />The other lock is the "cpu_bitmask_lock", and the only thing that protects <br />is the actual changing of the present bitmask. It's always nested inside <br />of the "cpu_add_remove_lock" (if that is taken at all, of course).<br /><br />The latter one is the one that "lock_cpu_hotplug()" actually takes, so <br />anybody who does "lock_cpu_hotplug()" will only protect against the bitmap <br />itself changing, not against the bigger issue of "cpu hotplug events are <br />happening".<br /><br />Does this work? Hey, it works for me once. It's pretty simple, and had <br />better not have any recursion issues. It guarantees that actual cpu <br />hotplug events are single-threaded wrt each other, and it does not allow <br />any recursive taking of "lock_cpu_hotplug()", but since cpu_add() and <br />cpu_down() no longer hold that particular lock when they to the call-outs <br />for the cpu events, it should hopefully not be needed any more either.<br /><br />Not very well tested, but it did suspend and resume twice for me.<br /><br />Does anybody see any problems with this?<br /><br />		Linus<br />---<br /> include/linux/cpu.h |    6 ------<br /> kernel/cpu.c        |   54 ++++++++++++---------------------------------------<br /> 2 files changed, 13 insertions(+), 47 deletions(-)<br /><br />diff --git a/include/linux/cpu.h b/include/linux/cpu.h<br />index 44a11f1..8fb344a 100644<br />--- a/include/linux/cpu.h<br />+++ b/include/linux/cpu.h<br />&#64;&#64; -48,7 +48,6 &#64;&#64; static inline void unregister_cpu_notifi<br /> {<br /> }<br /> #endif<br />-extern int current_in_cpu_hotplug(void);<br /> <br /> int cpu_up(unsigned int cpu);<br /> <br />&#64;&#64; -61,10 +60,6 &#64;&#64; static inline int register_cpu_notifier(<br /> static inline void unregister_cpu_notifier(struct notifier_block *nb)<br /> {<br /> }<br />-static inline int current_in_cpu_hotplug(void)<br />-{<br />-	return 0;<br />-}<br /> <br /> #endif /* CONFIG_SMP */<br /> extern struct sysdev_class cpu_sysdev_class;<br />&#64;&#64; -73,7 +68,6 &#64;&#64; #ifdef CONFIG_HOTPLUG_CPU<br /> /* Stop CPUs going up and down. */<br /> extern void lock_cpu_hotplug(void);<br /> extern void unlock_cpu_hotplug(void);<br />-extern int lock_cpu_hotplug_interruptible(void);<br /> #define hotcpu_notifier(fn, pri) {				\<br /> 	static struct notifier_block fn##_nb =			\<br /> 		{ .notifier_call = fn, .priority = pri };	\<br />diff --git a/kernel/cpu.c b/kernel/cpu.c<br />index 70fbf2e..4157055 100644<br />--- a/kernel/cpu.c<br />+++ b/kernel/cpu.c<br />&#64;&#64; -16,7 +16,8 &#64;&#64; #include &lt;linux/stop_machine.h&gt;<br /> #include &lt;linux/mutex.h&gt;<br /> <br /> /* This protects CPUs going up and down... */<br />-static DEFINE_MUTEX(cpucontrol);<br />+static DEFINE_MUTEX(cpu_add_remove_lock);<br />+static DEFINE_MUTEX(cpu_bitmask_lock);<br /> <br /> static __cpuinitdata BLOCKING_NOTIFIER_HEAD(cpu_chain);<br /> <br />&#64;&#64; -24,48 +25,18 &#64;&#64; #ifdef CONFIG_HOTPLUG_CPU<br /> static struct task_struct *lock_cpu_hotplug_owner;<br /> static int lock_cpu_hotplug_depth;<br /> <br />-static int __lock_cpu_hotplug(int interruptible)<br />-{<br />-	int ret = 0;<br />-<br />-	if (lock_cpu_hotplug_owner != current) {<br />-		if (interruptible)<br />-			ret = mutex_lock_interruptible(&amp;cpucontrol);<br />-		else<br />-			mutex_lock(&amp;cpucontrol);<br />-	}<br />-<br />-	/*<br />-	 * Set only if we succeed in locking<br />-	 */<br />-	if (!ret) {<br />-		lock_cpu_hotplug_depth++;<br />-		lock_cpu_hotplug_owner = current;<br />-	}<br />-<br />-	return ret;<br />-}<br />-<br /> void lock_cpu_hotplug(void)<br /> {<br />-	__lock_cpu_hotplug(0);<br />+	mutex_lock(&amp;cpu_bitmask_lock);<br /> }<br /> EXPORT_SYMBOL_GPL(lock_cpu_hotplug);<br /> <br /> void unlock_cpu_hotplug(void)<br /> {<br />-	if (--lock_cpu_hotplug_depth == 0) {<br />-		lock_cpu_hotplug_owner = NULL;<br />-		mutex_unlock(&amp;cpucontrol);<br />-	}<br />+	mutex_unlock(&amp;cpu_bitmask_lock);<br /> }<br /> EXPORT_SYMBOL_GPL(unlock_cpu_hotplug);<br /> <br />-int lock_cpu_hotplug_interruptible(void)<br />-{<br />-	return __lock_cpu_hotplug(1);<br />-}<br />-EXPORT_SYMBOL_GPL(lock_cpu_hotplug_interruptible);<br /> #endif	/* CONFIG_HOTPLUG_CPU */<br /> <br /> /* Need to know about CPUs going up/down? */<br />&#64;&#64; -122,9 +93,7 &#64;&#64; int cpu_down(unsigned int cpu)<br /> 	struct task_struct *p;<br /> 	cpumask_t old_allowed, tmp;<br /> <br />-	if ((err = lock_cpu_hotplug_interruptible()) != 0)<br />-		return err;<br />-<br />+	mutex_lock(&amp;cpu_add_remove_lock);<br /> 	if (num_online_cpus() == 1) {<br /> 		err = -EBUSY;<br /> 		goto out;<br />&#64;&#64; -150,7 +119,10 &#64;&#64; int cpu_down(unsigned int cpu)<br /> 	cpu_clear(cpu, tmp);<br /> 	set_cpus_allowed(current, tmp);<br /> <br />+	mutex_lock(&amp;cpu_bitmask_lock);<br /> 	p = __stop_machine_run(take_cpu_down, NULL, cpu);<br />+	mutex_unlock(&amp;cpu_bitmask_lock);<br />+<br /> 	if (IS_ERR(p)) {<br /> 		/* CPU didn't die: tell everyone.  Can't complain. */<br /> 		if (blocking_notifier_call_chain(&amp;cpu_chain, CPU_DOWN_FAILED,<br />&#64;&#64; -187,7 +159,7 &#64;&#64; out_thread:<br /> out_allowed:<br /> 	set_cpus_allowed(current, old_allowed);<br /> out:<br />-	unlock_cpu_hotplug();<br />+	mutex_unlock(&amp;cpu_add_remove_lock);<br /> 	return err;<br /> }<br /> #endif /*CONFIG_HOTPLUG_CPU*/<br />&#64;&#64; -197,9 +169,7 &#64;&#64; int __devinit cpu_up(unsigned int cpu)<br /> 	int ret;<br /> 	void *hcpu = (void *)(long)cpu;<br /> <br />-	if ((ret = lock_cpu_hotplug_interruptible()) != 0)<br />-		return ret;<br />-<br />+	mutex_lock(&amp;cpu_add_remove_lock);<br /> 	if (cpu_online(cpu) || !cpu_present(cpu)) {<br /> 		ret = -EINVAL;<br /> 		goto out;<br />&#64;&#64; -214,7 +184,9 &#64;&#64; int __devinit cpu_up(unsigned int cpu)<br /> 	}<br /> <br /> 	/* Arch-specific enabling code. */<br />+	mutex_lock(&amp;cpu_bitmask_lock);<br /> 	ret = __cpu_up(cpu);<br />+	mutex_unlock(&amp;cpu_bitmask_lock);<br /> 	if (ret != 0)<br /> 		goto out_notify;<br /> 	BUG_ON(!cpu_online(cpu));<br />&#64;&#64; -227,6 +199,6 &#64;&#64; out_notify:<br /> 		blocking_notifier_call_chain(&amp;cpu_chain,<br /> 				CPU_UP_CANCELED, hcpu);<br /> out:<br />-	unlock_cpu_hotplug();<br />+	mutex_unlock(&amp;cpu_add_remove_lock);<br /> 	return ret;<br /> }<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
