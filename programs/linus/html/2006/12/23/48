    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/22/106">First message in thread</a></li><li><a href="/lkml/2006/12/22/188">Jean Delvare</a><ul><li><a href="/lkml/2006/12/22/208">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2006/12/23/51">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/23/51">Randy Dunlap</a><ul><li><a href="/lkml/2006/12/23/54">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2006/12/23/48/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 23 Dec 2006 10:30:40 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: WARNING: "test_clear_page_dirty" [fs/cifs/cifs.ko] undefined!</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />[ Andrew - I'm cc'ing you, because you caused the requirement that people <br />  use "set_page_writeback()" in their writepage() routine that CIFS seems <br />  to have been ignoring all these years. That was introduced more than <br />two years ago, back in April 11, 2004:<br /><br />	[PATCH] fdatasync integrity fix<br /><br />	fdatasync can fail to wait on some pages due to a race.<br />	...<br /><br />  and as far as I can see, ever since then, any filesystem that didn't do <br />  a "set_page_writeback()" to sync up the TAG_DIRTY bit would have this <br />  CPU usage problem. Please double-check whether I'm right or barking up <br />  the wrong tree.<br /><br />  Afaik, the lack of doing the page writeback bit handling properly would <br />  seem to not cause any actual visible _semantic_ problems, it would just <br />  cause fdatasync to not necessarily be entirely reliable (which I guess <br />  is semantic, but very hard to see) and just wasted CPU cycles when we <br />  look up pages that are marked dirty in the radix tree, but aren't <br />  actually really dirty. <br /><br />  Correct? Who else is implicated in all of this? ]<br /><br />On Fri, 22 Dec 2006, Linus Torvalds wrote:<br />&gt; <br />&gt; CIFS _should_ be using "clear_page_dirty_for_io()" in that place, and that <br />&gt; will fix the build. However, the reason I didn't just do that myself is <br />&gt; that I can't test the end result, and for the life of me, I can't see <br />&gt; where CIFS does the "end_page_writeback()" that it needs to do at IO <br />&gt; completion time.<br /><br />Ok, I spent some more time looking at this.<br /><br />The reason cifs didn't do an "end_page_writeback()" was that it didn't <br />even do the "set_page_writeback()" to mark the page under writeback in the <br />first place.<br /><br />Now, you might think that since it didn't do a set_page_writeback(), it <br />doesn't need to do the matching end_page_writeback() at all, and instead <br />just continue to use the old (_really_ old) way of just unlocking the page <br />when it is done.<br /><br />However, you'd be wrong. The thing is, a "writepage()" function will be <br />called with the dirty bit cleared in the "struct page *", but the mapping <br />radix trees will still have the dirty bit set, exactly because the VM <br />_requires_ the filesystem to tell it what the h*ll it is doing with the <br />page. So a low-level filesystem must always do one of two things in it's <br />"writepage()" function. Either: <br /><br /> - "set_page_writeback()" (and then an "end_page_writeback()" when <br />   finished, of course)<br /><br />OR<br /><br /> - "redirty_page_for_writepage()" to tell the VM to move the page to the <br />   back of the LRU queues because it can't be cleaned (eg, some temporary <br />   problem with write ordering or similar, or something fundamental like <br />   "I'm ramfs, and I don't _have_ any backing store").<br /><br />and if the low-level filesystem doesn't do either of those, then the <br />status bits in the radix tree that contains the mapping information will <br />never be updated, so the page that got cleaned will continue to be marked <br />"dirty" in the radix tree (which admittedly will generally be invisible, <br />except for "sync()" and friends spending inordinate amounts of time <br />looking at pages that aren't even dirty any more - since they look things <br />up by the radix tree tags).<br /><br />So I think the old code happened to work, but it was definitely incorrect, <br />and would leave the dirty tags in the radix tree very confused indeed (it <br />so happened that "cifs_writepages()" - with an "s" at the end - because it <br />used "test_clear_page_dirty()" - would also clear the dirty tag, but any <br />page that went through the generic VM routines and the single-page <br />"cifs_writepage()" - without an "s" at the end - would then be forever <br />marked dirty in the radix tree even though it was clean.<br /><br />Somebody should check me, though.<br /><br />This fairly mindless patch adds the proper "set_page_writeback()" calls <br />(and the "clear_page_writeback()" ones I had already added before I looked <br />more closely at this). <br /><br />I added a comment in "cifs_writepage()" (the single-page case) for why <br />this all is the case,<br /><br />			Linus<br /><br />PS. To clarify: the old "test_clear_page_dirty()" would actually clear the <br />dirty bit in the radix tree too, so in that sense it was the RIGHT thing <br />to do for CIFS, since CIFS was mostly unaware of the need to clear the <br />radix tree dirty bit (even if cifs_writepages() actually used that bit to <br />look up pages).<br /><br />HOWEVER, since CIFS is called from the generic routines (which _are_ <br />radix-tree-aware and need the bit to be cleared explicitly), even the old <br />code was actually totally broken. It would clear - largely by mistake - <br />the radix tree dirty bit only for one case, not for _all_ the cases. A <br />filesystem really does need to know about these things now, although a <br />lot of filesystems can ignore them, since if they use all the generic <br />routines, they generic routines will handle it all for them.<br /><br />---<br />diff --git a/fs/cifs/file.c b/fs/cifs/file.c<br />index 0f05cab..8a49b2e 100644<br />--- a/fs/cifs/file.c<br />+++ b/fs/cifs/file.c<br />&#64;&#64; -1245,14 +1245,21 &#64;&#64; retry:<br /> 				wait_on_page_writeback(page);<br /> <br /> 			if (PageWriteback(page) ||<br />-					!test_clear_page_dirty(page)) {<br />+					!clear_page_dirty_for_io(page)) {<br /> 				unlock_page(page);<br /> 				break;<br /> 			}<br /> <br />+			/*<br />+			 * This actually clears the dirty bit in the radix tree.<br />+			 * See cifs_writepage() for more commentary.<br />+			 */<br />+			set_page_writeback(page);<br />+<br /> 			if (page_offset(page) &gt;= mapping-&gt;host-&gt;i_size) {<br /> 				done = 1;<br /> 				unlock_page(page);<br />+				end_page_writeback(page);<br /> 				break;<br /> 			}<br /> <br />&#64;&#64; -1316,6 +1323,7 &#64;&#64; retry:<br /> 					SetPageError(page);<br /> 				kunmap(page);<br /> 				unlock_page(page);<br />+				end_page_writeback(page);<br /> 				page_cache_release(page);<br /> 			}<br /> 			if ((wbc-&gt;nr_to_write -= n_iov) &lt;= 0)<br />&#64;&#64; -1352,11 +1360,23 &#64;&#64; static int cifs_writepage(struct page* page, struct writeback_control *wbc)<br />         if (!PageUptodate(page)) {<br /> 		cFYI(1, ("ppw - page not up to date"));<br /> 	}<br />-	<br />+<br />+	/*<br />+	 * Set the "writeback" flag, and clear "dirty" in the radix tree.<br />+	 *<br />+	 * A writepage() implementation always needs to do either this,<br />+	 * or re-dirty the page with "redirty_page_for_writepage()" in<br />+	 * the case of a failure.<br />+	 *<br />+	 * Just unlocking the page will cause the radix tree tag-bits<br />+	 * to fail to update with the state of the page correctly.<br />+	 */<br />+	set_page_writeback(page);		<br /> 	rc = cifs_partialpagewrite(page, 0, PAGE_CACHE_SIZE);<br /> 	SetPageUptodate(page); /* BB add check for error and Clearuptodate? */<br /> 	unlock_page(page);<br />-	page_cache_release(page);	<br />+	end_page_writeback(page);<br />+	page_cache_release(page);<br /> 	FreeXid(xid);<br /> 	return rc;<br /> }<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
