    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/16/164">First message in thread</a></li><li><a href="/lkml/2006/12/21/68">Martin Schwidefsky</a><ul><li><a href="/lkml/2006/12/21/74">Peter Zijlstra</a><ul><li><a href="/lkml/2006/12/21/75">Martin Schwidefsky</a></li><li class="origin"><a href="/lkml/2006/12/27/161">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/27/161">Martin Schwidefsky</a><ul><li><a href="/lkml/2006/12/27/168">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2006/12/21/231/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 21 Dec 2006 12:01:46 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] mm: fix page_mkclean_one (was: 2.6.19 file content corruption on ext3)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 21 Dec 2006, Peter Zijlstra wrote:<br />&gt; <br />&gt; Also, I'm dubious about the while thing and stuck a WARN_ON(ret) thing<br />&gt; at the beginning of the loop. flush_tlb_page() does IPI the other cpus<br />&gt; to flush their tlb too, so there should not be a SMP race, Arjan?<br /><br />Now, the reason I think the loop may be needed is:<br /><br />	CPU#0				CPU#1<br />	-----				-----<br />					load old PTE entry<br />	clear dirty and WP bits<br />					write to page using old PTE<br />					NOT CHECKING that the new one<br />					is write-protected, and just<br />					setting the dirty bit blindly<br />					(but atomically)<br />	flush_tlb_page()<br />					TLB flushed, but we now have a<br />					page that is marked dirty and<br />					unwritable in the page tables,<br />					and we will mark it clean in<br />					"struct page *"<br /><br />Now, the scary thing is, IF a CPU does this, then the way we do all this, <br />we may actually have the following sequence:<br /><br />	CPU#0				CPU#1<br />	-----				-----<br />					load old PTE entry<br />	ptep_clear_flush():<br />					atomic "set dirty bit" sequence<br />					PTEP now contains 0000040 !!!<br />	flush_tlb_page();<br />					TLB flushed, but PTEP is still <br />					"dirty zero"<br />	write the clear/readonly PTE<br />					THE DIRTY BIT WAS LOST!<br /><br />which might actually explain this bug.<br /><br />I personally _thought_ that Intel CPU's don't actually do an "set dirty <br />bit atomically" sequence, but more of a "set dirty bit but trap if the TLB <br />is nonpresent" thing, but I have absolutely no proof for that.<br /><br />Anyway, IF this is the case, then the following patch may or may not fix <br />things. It avoids things by never overwriting a PTE entry, not even the <br />"cleared" one. It always does an atomic "xchg()" with a valid new entry, <br />and looks at the old bits.<br /><br />What do you guys think? Does something like this work out for S/390 too? I <br />tried to make that "ptep_flush_dirty()" concept work for architectures <br />that hide the dirty bit somewhere else too, but..<br /><br />It actually simplifies the architecture-specific code (you just need to <br />implement a trivial "ptep_exchange()" and "ptep_flush_dirty()" macro), but <br />I only did x86-64 and i386, and while I've booted with this, I haven't <br />really given the thing a lot of really _deep_ thought.<br /><br />But I think this might be safer, as per above.. And it _might_ actually <br />explain the problem. Exactly because the "ptep_clear() + blindly assign to <br />ptep" might lose a dirty bit that was written by another CPU.<br /><br />But this really does depend on what a CPU does when it marks a page dirty. <br />Does it just blindly write the dirty bit? Or does it actually _validate_ <br />that the old page table entry was still present and writable?<br /><br />This patch makes no assumptions. It should work even if a CPU just writes <br />the dirty bit blindly, and the only expectation is that the page tables <br />can be accessed atomically (which had _better_ be true on any SMP <br />architecture)<br /><br />Arjan, can you please check within Intel, and ask what the "proper" <br />sequence for doing something like this is?<br /><br />			Linus<br /><br />----<br />commit 301d2d53ca0e5d2f61b1c1c259da410c7ee6d6a7<br />Author: Linus Torvalds &lt;torvalds&#64;woody.osdl.org&gt;<br />Date:   Thu Dec 21 11:11:05 2006 -0800<br /><br />    Rewrite the page table "clear dirty and writable" accesses<br />    <br />    This is much simpler for most architectures, and allows us to do the<br />    dirty and writable clear in a single operation without any races or any<br />    double flushes.<br />    <br />    It's also much more careful: we never overwrite the old dirty bits at<br />    any time, and always make sure to do atomic memory ops to exchange and<br />    see the old value.<br />    <br />    Signed-off-by: Linus Torvalds &lt;torvalds&#64;osdl.org&gt;<br /><br />diff --git a/include/asm-generic/pgtable.h b/include/asm-generic/pgtable.h<br />index 9d774d0..8879f1d 100644<br />--- a/include/asm-generic/pgtable.h<br />+++ b/include/asm-generic/pgtable.h<br />&#64;&#64; -61,31 +61,6 &#64;&#64; do {				  					  \<br /> })<br /> #endif<br /> <br />-#ifndef __HAVE_ARCH_PTEP_TEST_AND_CLEAR_DIRTY<br />-#define ptep_test_and_clear_dirty(__vma, __address, __ptep)		\<br />-({									\<br />-	pte_t __pte = *__ptep;						\<br />-	int r = 1;							\<br />-	if (!pte_dirty(__pte))						\<br />-		r = 0;							\<br />-	else								\<br />-		set_pte_at((__vma)-&gt;vm_mm, (__address), (__ptep),	\<br />-			   pte_mkclean(__pte));				\<br />-	r;								\<br />-})<br />-#endif<br />-<br />-#ifndef __HAVE_ARCH_PTEP_CLEAR_DIRTY_FLUSH<br />-#define ptep_clear_flush_dirty(__vma, __address, __ptep)		\<br />-({									\<br />-	int __dirty;							\<br />-	__dirty = ptep_test_and_clear_dirty(__vma, __address, __ptep);	\<br />-	if (__dirty)							\<br />-		flush_tlb_page(__vma, __address);			\<br />-	__dirty;							\<br />-})<br />-#endif<br />-<br /> #ifndef __HAVE_ARCH_PTEP_GET_AND_CLEAR<br /> #define ptep_get_and_clear(__mm, __address, __ptep)			\<br /> ({									\<br />diff --git a/include/asm-i386/pgtable.h b/include/asm-i386/pgtable.h<br />index e6a4723..b61d6f9 100644<br />--- a/include/asm-i386/pgtable.h<br />+++ b/include/asm-i386/pgtable.h<br />&#64;&#64; -300,18 +300,20 &#64;&#64; do {									\<br /> 	flush_tlb_page(vma, address);					\<br /> } while (0)<br /> <br />-#define __HAVE_ARCH_PTEP_CLEAR_DIRTY_FLUSH<br />-#define ptep_clear_flush_dirty(vma, address, ptep)			\<br />-({									\<br />-	int __dirty;							\<br />-	__dirty = pte_dirty(*(ptep));					\<br />-	if (__dirty) {							\<br />-		clear_bit(_PAGE_BIT_DIRTY, &amp;(ptep)-&gt;pte_low);		\<br />-		pte_update_defer((vma)-&gt;vm_mm, (address), (ptep));	\<br />-		flush_tlb_page(vma, address);				\<br />-	}								\<br />-	__dirty;							\<br />-})<br />+/*<br />+ * "ptep_exchange()" can be used to atomically change a set of<br />+ * page table protection bits, returning the old ones (the dirty<br />+ * and accessed bits in particular, since they are set by hw).<br />+ *<br />+ * "ptep_flush_dirty()" then returns the dirty status of the<br />+ * page (on x86-64, we just look at the dirty bit in the returned<br />+ * pte, but some other architectures have the dirty bits in<br />+ * other places than the page tables).<br />+ */<br />+#define ptep_exchange(vma, address, ptep, old, new) \<br />+	(old).pte_low = xchg(&amp;(ptep)-&gt;pte_low, (new).pte_low);<br />+#define ptep_flush_dirty(vma, address, ptep, old) \<br />+	pte_dirty(old)<br /> <br /> #define __HAVE_ARCH_PTEP_CLEAR_YOUNG_FLUSH<br /> #define ptep_clear_flush_young(vma, address, ptep)			\<br />diff --git a/include/asm-x86_64/pgtable.h b/include/asm-x86_64/pgtable.h<br />index 59901c6..07754b5 100644<br />--- a/include/asm-x86_64/pgtable.h<br />+++ b/include/asm-x86_64/pgtable.h<br />&#64;&#64; -283,12 +283,20 &#64;&#64; static inline pte_t pte_clrhuge(pte_t pte)	{ set_pte(&amp;pte, __pte(pte_val(pte) &amp;<br /> <br /> struct vm_area_struct;<br /> <br />-static inline int ptep_test_and_clear_dirty(struct vm_area_struct *vma, unsigned long addr, pte_t *ptep)<br />-{<br />-	if (!pte_dirty(*ptep))<br />-		return 0;<br />-	return test_and_clear_bit(_PAGE_BIT_DIRTY, &amp;ptep-&gt;pte);<br />-}<br />+/*<br />+ * "ptep_exchange()" can be used to atomically change a set of<br />+ * page table protection bits, returning the old ones (the dirty<br />+ * and accessed bits in particular, since they are set by hw).<br />+ *<br />+ * "ptep_flush_dirty()" then returns the dirty status of the<br />+ * page (on x86-64, we just look at the dirty bit in the returned<br />+ * pte, but some other architectures have the dirty bits in<br />+ * other places than the page tables).<br />+ */<br />+#define ptep_exchange(vma, address, ptep, old, new) \<br />+	(old).pte = xchg(&amp;(ptep)-&gt;pte, (new).pte);<br />+#define ptep_flush_dirty(vma, address, ptep, old) \<br />+	pte_dirty(old)<br /> <br /> static inline int ptep_test_and_clear_young(struct vm_area_struct *vma, unsigned long addr, pte_t *ptep)<br /> {<br />diff --git a/mm/rmap.c b/mm/rmap.c<br />index d8a842a..a028803 100644<br />--- a/mm/rmap.c<br />+++ b/mm/rmap.c<br />&#64;&#64; -432,7 +432,7 &#64;&#64; static int page_mkclean_one(struct page *page, struct vm_area_struct *vma)<br /> {<br /> 	struct mm_struct *mm = vma-&gt;vm_mm;<br /> 	unsigned long address;<br />-	pte_t *pte, entry;<br />+	pte_t *ptep;<br /> 	spinlock_t *ptl;<br /> 	int ret = 0;<br /> <br />&#64;&#64; -440,22 +440,24 &#64;&#64; static int page_mkclean_one(struct page *page, struct vm_area_struct *vma)<br /> 	if (address == -EFAULT)<br /> 		goto out;<br /> <br />-	pte = page_check_address(page, mm, address, &amp;ptl);<br />-	if (!pte)<br />-		goto out;<br />-<br />-	if (!pte_dirty(*pte) &amp;&amp; !pte_write(*pte))<br />-		goto unlock;<br />-<br />-	entry = ptep_get_and_clear(mm, address, pte);<br />-	entry = pte_mkclean(entry);<br />-	entry = pte_wrprotect(entry);<br />-	ptep_establish(vma, address, pte, entry);<br />-	lazy_mmu_prot_update(entry);<br />-	ret = 1;<br />-<br />-unlock:<br />-	pte_unmap_unlock(pte, ptl);<br />+	ptep = page_check_address(page, mm, address, &amp;ptl);<br />+	if (ptep) {<br />+		pte_t old, new;<br />+<br />+		old = *ptep;<br />+		new = pte_wrprotect(pte_mkclean(old));<br />+		if (!pte_same(old, new)) {<br />+			for (;;) {<br />+				flush_cache_page(vma, address, page_to_pfn(page));<br />+				ptep_exchange(vma, address, ptep, old, new);<br />+				if (pte_same(old, new))<br />+					break;<br />+				ret |= ptep_flush_dirty(vma, address, ptep, old);<br />+				flush_tlb_page(vma, address);<br />+			}<br />+		}<br />+		pte_unmap_unlock(pte, ptl);<br />+	}<br /> out:<br /> 	return ret;<br /> }<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
