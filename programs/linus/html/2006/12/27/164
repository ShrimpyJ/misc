    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/16/164">First message in thread</a></li><li><a href="/lkml/2006/12/26/58">Tobias Diedrich</a><ul><li><a href="/lkml/2006/12/26/125">David Miller</a><ul><li><a href="/lkml/2006/12/27/12">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/27/18">Andrei Popa</a></li></ul></li><li class="origin"><a href="/lkml/2006/12/27/167">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/27/167">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/27/170">David Miller</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 27 Dec 2006 16:16:12 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] mm: fix page_mkclean_one</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Tue, 26 Dec 2006, David Miller wrote:<br />&gt; <br />&gt; I've seen it on sparc64, UP kernel, no preempt.<br /><br />Ok, I still don't have a clue, but I think I at least have a new <br />test-case.<br /><br />It can probably be improved upon, but this would _seem_ to trigger the <br />problem. Can people check?<br /><br />You'd want to make sure you get page-put activity, by making TARGETSIZE be <br />big enough to cause memory pressure (and rather than making it bigger, you <br />might want to make your memory smaller instead, to make it run more <br />quickly. Either using "mem=128M" or big compiles or something...).<br /><br />If it finds corruption, you'll see something like<br /><br />	Writing chunk 183858/183859 (99%)<br />	Chunk ..<br />	Chunk 120887 corrupted<br />	Chunk 122372 corrupted<br />	Chunk ...<br />	Checking chunk 183858/183859 (99%)<br /><br />otherwise it will just say<br /><br />	Writing chunk 183858/183859 (99%)<br />	Checking chunk 183858/183859 (99%)<br /><br />and exit.<br /><br />I didn't spend a lot of time verifying this, but I _was_ able to cause <br />those "Chunk xxx corrupted" messages with this. There's probably a more <br />efficient better way to do it, but this is better than trying to use <br />rtorrent, and also makes any worries about what rtorrent does go away.<br /><br />Of course, maybe it's this test-program that is buggy now, although it <br />looks trivial enough that I don't think it is.<br /><br />I think my earlier stress-tester may not have triggered this, because it <br />just did all its writing in a linear order, so any LRU logic will happen <br />to write back old pages that we are no longer touching. The randomization <br />(and using a chunksize that isn't a multiple of a page-size) makes sure <br />that we're actually going to have lots of rewriting going on.<br /><br />I think the test-case could probably be improved by having a munmap() and <br />page-cache flush in between the writing and the checking, to see whether <br />that shows the corruption easier (and possibly without having to start <br />paging in order to throw the pages out, which would simplify testing a <br />lot). But I haven't tested. I decided to post this asap, now that I've <br />recreated the corruption with something else, and something that is <br />possibly easier to analyze..<br /><br />		Linus<br /><br />----<br />#include &lt;sys/mman.h&gt;<br />#include &lt;sys/fcntl.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;time.h&gt;<br /><br />#define TARGETSIZE (256 &lt;&lt; 20)<br />#define CHUNKSIZE (1460)<br />#define NRCHUNKS (TARGETSIZE / CHUNKSIZE)<br />#define SIZE (NRCHUNKS * CHUNKSIZE)<br /><br />static void fillmem(void *start, int nr)<br />{<br />	memset(start, nr, CHUNKSIZE);<br />}<br /><br />static void checkmem(void *start, int nr)<br />{<br />	unsigned char c = nr, *p = start;<br />	int i;<br />	for (i = 0; i &lt; CHUNKSIZE; i++) {<br />		if (*p++ != c) {<br />			printf("Chunk %d corrupted               \n", nr);<br />			return;<br />		}<br />	}<br />}<br /><br />int main(int argc, char **argv)<br />{<br />	char *mapping;<br />	int fd, i;<br />	static int chunkorder[NRCHUNKS];<br /><br />	/*<br />	 * Make some random ordering of writing the chunks to the<br />	 * memory map..<br />	 *<br />	 * Start with fully ordered..<br />	 */<br />	for (i = 0; i &lt; NRCHUNKS; i++)<br />		chunkorder[i] = i;<br /><br />	/* ..and then mix it up randomly */<br />	srandom(time(NULL));<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int index = (unsigned int) random() % NRCHUNKS;<br />		int nr = chunkorder[index];<br />		chunkorder[index] = chunkorder[i];<br />		chunkorder[i] = nr;<br />	}<br /><br />	fd = open("mapfile", O_RDWR | O_TRUNC | O_CREAT, 0666);<br />	if (fd &lt; 0)<br />		return -1;<br />	if (ftruncate(fd, SIZE) &lt; 0)<br />		return -1;<br />	mapping = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);<br />	if (-1 == (int)(long)mapping)<br />		return -1;<br /><br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = chunkorder[i];<br />		printf("Writing chunk %d/%d (%d%%)     \r", i, NRCHUNKS, 100*i/NRCHUNKS);<br />		fillmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = i;<br />		printf("Checking chunk %d/%d (%d%%)     \r", i, NRCHUNKS, 100*i/NRCHUNKS);<br />		checkmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br />	<br />	return 0;<br />}<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
