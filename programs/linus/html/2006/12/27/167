    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/16/164">First message in thread</a></li><li><a href="/lkml/2006/12/26/125">David Miller</a><ul><li><a href="/lkml/2006/12/27/12">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/27/18">Andrei Popa</a></li></ul></li><li><a href="/lkml/2006/12/27/164">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2006/12/27/170">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/27/170">David Miller</a><ul><li><a href="/lkml/2006/12/27/180">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 27 Dec 2006 16:39:43 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] mm: fix page_mkclean_one</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 27 Dec 2006, Linus Torvalds wrote:<br />&gt; <br />&gt; I think the test-case could probably be improved by having a munmap() and <br />&gt; page-cache flush in between the writing and the checking, to see whether <br />&gt; that shows the corruption easier (and possibly without having to start <br />&gt; paging in order to throw the pages out, which would simplify testing a <br />&gt; lot).<br /><br />I think the page-writeout is implicated, because I do seem to need it, but <br />the page-cache flush does seem to make corruption _easier_ to see. I now <br />seem about to trigger it with a 100MB file on a 256MB machine in a minute <br />or so, with this slight modification.<br /><br />I still don't see _why_, though. But maybe smarter people than me can see <br />it..<br /><br />		Linus<br /><br />---<br />#include &lt;sys/mman.h&gt;<br />#include &lt;sys/fcntl.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;time.h&gt;<br /><br />#define TARGETSIZE (100 &lt;&lt; 20)<br />#define CHUNKSIZE (1460)<br />#define NRCHUNKS (TARGETSIZE / CHUNKSIZE)<br />#define SIZE (NRCHUNKS * CHUNKSIZE)<br /><br />static void fillmem(void *start, int nr)<br />{<br />	memset(start, nr, CHUNKSIZE);<br />}<br /><br />static void checkmem(void *start, int nr)<br />{<br />	unsigned char c = nr, *p = start;<br />	int i;<br />	for (i = 0; i &lt; CHUNKSIZE; i++) {<br />		if (*p++ != c) {<br />			printf("Chunk %d corrupted           \n", nr);<br />			return;<br />		}<br />	}<br />}<br /><br />static char *remap(int fd, char *mapping)<br />{<br />	if (mapping) {<br />		munmap(mapping, SIZE);<br />		posix_fadvise(fd, 0, SIZE, POSIX_FADV_DONTNEED);<br />	}<br />	return mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);<br />}<br /><br />int main(int argc, char **argv)<br />{<br />	char *mapping;<br />	int fd, i;<br />	static int chunkorder[NRCHUNKS];<br /><br />	/*<br />	 * Make some random ordering of writing the chunks to the<br />	 * memory map..<br />	 *<br />	 * Start with fully ordered..<br />	 */<br />	for (i = 0; i &lt; NRCHUNKS; i++)<br />		chunkorder[i] = i;<br /><br />	/* ..and then mix it up randomly */<br />	srandom(time(NULL));<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int index = (unsigned int) random() % NRCHUNKS;<br />		int nr = chunkorder[index];<br />		chunkorder[index] = chunkorder[i];<br />		chunkorder[i] = nr;<br />	}<br /><br />	fd = open("mapfile", O_RDWR | O_TRUNC | O_CREAT, 0666);<br />	if (fd &lt; 0)<br />		return -1;<br />	if (ftruncate(fd, SIZE) &lt; 0)<br />		return -1;<br />	mapping = remap(fd, NULL);<br />	if (-1 == (int)(long)mapping)<br />		return -1;<br /><br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = chunkorder[i];<br />		printf("Writing chunk %d/%d (%d%%)     \r", i, NRCHUNKS, 100*i/NRCHUNKS);<br />		fillmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br /><br />	/* Unmap, drop, and remap.. */<br />	mapping = remap(fd, mapping);<br /><br />	/* .. and check */<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = i;<br />		printf("Checking chunk %d/%d (%d%%)     \r", i, NRCHUNKS, 100*i/NRCHUNKS);<br />		checkmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br />	<br />	return 0;<br />}<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
