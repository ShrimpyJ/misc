    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/16/164">First message in thread</a></li><li><a href="/lkml/2006/12/27/167">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/27/170">David Miller</a><ul><li class="origin"><a href="/lkml/2006/12/27/190">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/27/190">"Gordon Farquharson"</a><ul><li><a href="/lkml/2006/12/27/193">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2006/12/28/6">"Chen, Kenneth W"</a><ul><li><a href="/lkml/2006/12/28/8">"Chen, Kenneth W"</a></li></ul></li><li><a href="/lkml/2006/12/28/36">"Zhang, Yanmin"</a><ul><li><a href="/lkml/2006/12/28/133">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2006/12/28/77">Petri Kaukasoina</a></li><li><a href="/lkml/2006/12/28/110">Guillaume Chazarain</a><ul><li><a href="/lkml/2006/12/28/157">Guillaume Chazarain</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 27 Dec 2006 19:04:34 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] mm: fix page_mkclean_one</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 27 Dec 2006, David Miller wrote:<br />&gt; &gt; <br />&gt; &gt; I still don't see _why_, though. But maybe smarter people than me can see <br />&gt; &gt; it..<br />&gt; <br />&gt; FWIW this program definitely triggers the bug for me.<br /><br />Ok, now that I have something simple to do repeatable stuff with, I can <br />say what the pattern is.. It's not all that surprising, but it's still <br />worth just stating for the record.<br /><br />What happens is that when I do the "packetized writes" in random order, <br />the _last_ write to a page occasionally just goes missing. It's not always <br />at the end of a page, as shown by for example:<br /><br /> - A whole chunk got dropped:<br /><br />	Chunk 2094 corrupted (0-1459)  (1624-3083)<br />	Expected 46, got 0<br />	Written as (30912)55414(10000)<br /><br />   That "Written as (x)y(z)" line means that the corrupted chunk was <br />   written as chunk #y, and the preceding and following chunks (that were <br />   _not_ corrupt) on the page was written as #x and #z respectively.<br /><br />   In other words, the missing chunk (which is still zero) was written <br />   much later than the ones that were ok, and never hit the disk. It's a <br />   contiguous chunk in the middle of the page (chunks are 1460 bytes in <br />   size)<br /><br />   The first line means that all bytes of the chunk (0-1459) were <br />   corrupted, and the values in parenthesis are the offsets within a page. <br />   In other words, this was a chunk in the _middle_ of a page.<br /><br /> - The missing data can also be at the beginning or ends of pages:<br /><br />   Beginning of the chunk missing, it was at the end of a page (page <br />   offsets 3288-4095) and the _next_ page got written out fine:<br /><br />	Chunk 2126 corrupted (0-807)  (3288-4095)<br />	Expected 78, got 0<br />	Written as (32713)55573(14301)<br /><br />   End of a chunk missing, it was the beginning of a page (and the <br />   _previous_ page that contained the beginning of the chunk was written <br />   out fine)<br /><br />	Chunk 2179 corrupted (1252-1459)  (0-207)<br />	Expected 131, got 0<br />	Written as (45189)55489(15515)<br /><br />Now, the reason I say this isn't surprising is that this is entirely <br />consistent with the dirty bit being dropped on the floor somewhere, and <br />likely through some interaction with the previous changes being in the <br />process of being written out.<br /><br />Something (incorrectly) ends up deciding that it doesn't need to write the <br />page, since it's already written, or alternatively clears the dirty bit <br />too late (clears it because an _earlier_ write finished, never mind that <br />the new dirty data didn't make it).<br /><br />I also figured out that it's not the low-memory situation that does it, it <br />really must be the "page_mkclean()" triggering. Becuase I can do<br /><br />	echo 5 &gt; /proc/sys/vm/dirty_ratio<br />	echo 3 &gt; /proc/sys/vm/dirty_background_ratio<br /><br />to make it clean the pages much more aggressively than the default, and I <br />can see corruption on my 256MB machine with just a 40MB shared file, and <br />70MB of memory consistently free.<br /><br />So this thing is definitely giving some answers. It's NOT about low <br />memory, and it very much seems to be about the whole "balance_dirty_ratio" <br />thing. I don't think I triggered the actual low-memory stuff once in that <br />situation..<br /><br />So I have some more data on the behaviour, but I _still_ don't see the <br />reason behind it. It's probably something really obvious once it's pointed <br />out..<br /><br />[ Modified test-program that tells you where the corruption happens (and <br />  when the missing parts were supposed to be written out) appended, in <br />  case people care. ]<br /><br />			Linus<br /><br />---<br />#include &lt;sys/mman.h&gt;<br />#include &lt;sys/fcntl.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;time.h&gt;<br /><br />#define TARGETSIZE (100 &lt;&lt; 20)<br />#define CHUNKSIZE (1460)<br />#define NRCHUNKS (TARGETSIZE / CHUNKSIZE)<br />#define SIZE (NRCHUNKS * CHUNKSIZE)<br /><br />static void fillmem(void *start, int nr)<br />{<br />	memset(start, nr, CHUNKSIZE);<br />}<br /><br />#define page_offset(buf, off) (0xfff &amp; ((unsigned)(unsigned long)(buf)+(off)))<br /><br />static int chunkorder[NRCHUNKS];<br /><br />static int order(int nr)<br />{<br />	int i;<br />	if (nr &lt; 0 || nr &gt;= NRCHUNKS)<br />		return -1;<br />	for (i = 0; i &lt; NRCHUNKS; i++)<br />		if (chunkorder[i] == nr)<br />			return i;<br />	return -2;<br />}<br /><br />static void checkmem(void *buf, int nr)<br />{<br />	unsigned int start = ~0u, end = 0;<br />	unsigned char c = nr, *p = buf, differs = 0;<br />	int i;<br />	for (i = 0; i &lt; CHUNKSIZE; i++) {<br />		unsigned char got = *p++;<br />		if (got != c) {<br />			if (i &lt; start)<br />				start = i;<br />			if (i &gt; end)<br />				end = i;<br />			differs = got;<br />		}<br />	}<br />	if (start &lt; end) {<br />		printf("Chunk %d corrupted (%u-%u)  (%u-%u)            \n", nr, start, end,<br />			page_offset(buf, start), page_offset(buf, end));<br />		printf("Expected %u, got %u\n", c, differs);<br />		printf("Written as (%d)%d(%d)\n", order(nr-1), order(nr), order(nr+1));<br />	}<br />}<br /><br />static char *remap(int fd, char *mapping)<br />{<br />	if (mapping) {<br />		munmap(mapping, SIZE);<br />		posix_fadvise(fd, 0, SIZE, POSIX_FADV_DONTNEED);<br />	}<br />	return mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);<br />}<br /><br />int main(int argc, char **argv)<br />{<br />	char *mapping;<br />	int fd, i;<br /><br />	/*<br />	 * Make some random ordering of writing the chunks to the<br />	 * memory map..<br />	 *<br />	 * Start with fully ordered..<br />	 */<br />	for (i = 0; i &lt; NRCHUNKS; i++)<br />		chunkorder[i] = i;<br /><br />	/* ..and then mix it up randomly */<br />	srandom(time(NULL));<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int index = (unsigned int) random() % NRCHUNKS;<br />		int nr = chunkorder[index];<br />		chunkorder[index] = chunkorder[i];<br />		chunkorder[i] = nr;<br />	}<br /><br />	fd = open("mapfile", O_RDWR | O_TRUNC | O_CREAT, 0666);<br />	if (fd &lt; 0)<br />		return -1;<br />	if (ftruncate(fd, SIZE) &lt; 0)<br />		return -1;<br />	mapping = remap(fd, NULL);<br />	if (-1 == (int)(long)mapping)<br />		return -1;<br /><br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = chunkorder[i];<br />		printf("Writing chunk %d/%d (%d%%)     \r", i, NRCHUNKS, 100*i/NRCHUNKS);<br />		fillmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br /><br />	/* Unmap, drop, and remap.. */<br />	mapping = remap(fd, mapping);<br /><br />	/* .. and check */<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = i;<br />		printf("Checking chunk %d/%d (%d%%)     \r", i, NRCHUNKS, 100*i/NRCHUNKS);<br />		checkmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br />	<br />	return 0;<br />}<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
