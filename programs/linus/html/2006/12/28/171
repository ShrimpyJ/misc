    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/16/164">First message in thread</a></li><li><a href="/lkml/2006/12/28/159">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/28/161">Andrew Morton</a><ul><li class="origin"><a href="/lkml/2006/12/28/214">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/28/214">David Miller</a><ul><li><a href="/lkml/2006/12/28/251">Segher Boessenkool</a></li></ul></li></ul></li><li><a href="/lkml/2006/12/28/211">Mike Galbraith</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 28 Dec 2006 12:14:31 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] mm: fix page_mkclean_one</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 28 Dec 2006, Andrew Morton wrote:<br />&gt; <br />&gt; It would be interesting to convert your app to do fsync() before<br />&gt; FADV_DONTNEED.  That would take WB_SYNC_NONE out of the picture as well<br />&gt; (apart from pdflush activity).<br /><br />I get corruption - but the whole point is that it's very much pdflush that <br />should be writing these pages out.<br /><br />Andrew - give my test-program a try. It can run in about 1 minute if you <br />have a 256MB machine (I didn't, but "mem=256M" is my friend), and it seems <br />to very consistently cause corruption.<br /><br />What I do is:<br /><br />	# Make sure we write back aggressively<br />	echo 5 &gt; /proc/sys/vm/dirty_ratio<br /><br />as root, and then just run the thing. Tons of corruption. But the <br />corruption goes away if I just leave the default dirty ratio alone (but <br />then I can increse the file size to trigger it, of course - but that <br />also makes the test run a lot slower).<br /><br />Now, with a pre-2.6.19 kernel, I bet you won't get the corruption as <br />easily (at least with the "fsync()"), but that's less to do with anything <br />new, and probably just because then you simply won't have any pdflushing <br />going on - since the kernel won't even notice that you have tons of dirty <br />pages ;)<br /><br />It might also depend on the speed of your disk drive - the machine I test <br />this on has a slow 4200 rpm laptop drive in it, and that probably makes <br />things go south more easily. That's _especially_ true if this is related <br />to any "bdi_write_congested()" logic.<br /><br />Now, it could also be related to various code snippets like<br /><br />	...<br />	if (wbc-&gt;sync_mode != WB_SYNC_NONE)<br />		wait_on_page_writeback(page);<br /><br />	if (PageWriteback(page) ||<br />			!clear_page_dirty_for_io(page)) {<br />		unlock_page(page);<br />		continue;<br />	}<br />	...<br /><br />where the WB_SYNC_NONE case will hit the "PageWriteback()" and just not do <br />the writeback at all (but it also won't clear the dirty bit, so it's <br />certainly not an *OBVIOUS* bug).<br /><br />We also have code like this ("pageout()"):<br /><br />	if (clear_page_dirty_for_io(page)) {<br />		int res;<br />		struct writeback_control wbc = {<br />			.sync_mode = WB_SYNC_NONE,<br />			..<br />		}<br />		...<br />		res = mapping-&gt;a_ops-&gt;writepage(page, &amp;wbc);<br /><br />and in this case, if the "WB_SYNC_NONE" means that the "writepage()" call <br />won't do anything at all because of congestion, then that would be a _bad_ <br />thing, and would certainly explain how something didn't get written out.<br /><br />But that particular path should only trigger for the "shrink_page_list()" <br />case, and it's not the case I seem to be testing with my "low dirty_ratio" <br />testing.<br /><br />		Linus#include &lt;sys/mman.h&gt;<br />#include &lt;sys/fcntl.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;time.h&gt;<br /><br />#define TARGETSIZE (22 &lt;&lt; 20)<br />#define CHUNKSIZE (1460)<br />#define NRCHUNKS (TARGETSIZE / CHUNKSIZE)<br />#define SIZE (NRCHUNKS * CHUNKSIZE)<br /><br />static void fillmem(void *start, int nr)<br />{<br />	memset(start, nr, CHUNKSIZE);<br />}<br /><br />#define page_offset(buf, off) (unsigned)((unsigned long)(buf)+(off)-(unsigned long)(mapping))<br /><br />static int chunkorder[NRCHUNKS];<br />static char *mapping;<br /><br />static int order(int nr)<br />{<br />	int i;<br />	if (nr &lt; 0 || nr &gt;= NRCHUNKS)<br />		return -1;<br />	for (i = 0; i &lt; NRCHUNKS; i++)<br />		if (chunkorder[i] == nr)<br />			return i;<br />	return -2;<br />}<br /><br />static void checkmem(void *buf, int nr)<br />{<br />	unsigned int start = ~0u, end = 0;<br />	unsigned char c = nr, *p = buf, differs = 0;<br />	int i;<br />	for (i = 0; i &lt; CHUNKSIZE; i++) {<br />		unsigned char got = *p++;<br />		if (got != c) {<br />			if (i &lt; start)<br />				start = i;<br />			if (i &gt; end)<br />				end = i;<br />			differs = got;<br />		}<br />	}<br />	if (start &lt; end) {<br />		printf("Chunk %d corrupted (%u-%u)  (%x-%x)            \n", nr, start, end,<br />			page_offset(buf, start), page_offset(buf, end));<br />		printf("Expected %u, got %u\n", c, differs);<br />		printf("Written as (%d)%d(%d)\n", order(nr-1), order(nr), order(nr+1));<br />	}<br />}<br /><br />static char *remap(int fd, char *mapping)<br />{<br />	if (mapping) {<br />		munmap(mapping, SIZE);<br />//		fsync(fd);<br />		posix_fadvise(fd, 0, SIZE, POSIX_FADV_DONTNEED);<br />	}<br />	return mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);<br />}<br /><br />int main(int argc, char **argv)<br />{<br />	int fd, i;<br /><br />	/*<br />	 * Make some random ordering of writing the chunks to the<br />	 * memory map..<br />	 *<br />	 * Start with fully ordered..<br />	 */<br />	for (i = 0; i &lt; NRCHUNKS; i++)<br />		chunkorder[i] = i;<br /><br />	/* ..and then mix it up randomly */<br />	srandom(time(NULL));<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int index = (unsigned int) random() % NRCHUNKS;<br />		int nr = chunkorder[index];<br />		chunkorder[index] = chunkorder[i];<br />		chunkorder[i] = nr;<br />	}<br /><br />	fd = open("mapfile", O_RDWR | O_TRUNC | O_CREAT, 0666);<br />	if (fd &lt; 0)<br />		return -1;<br />	if (ftruncate(fd, SIZE) &lt; 0)<br />		return -1;<br />	mapping = remap(fd, NULL);<br />	if (-1 == (int)(long)mapping)<br />		return -1;<br /><br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = chunkorder[i];<br />		printf("Writing chunk %d/%d (%d%%)     \r", i, NRCHUNKS, 100*i/NRCHUNKS);<br />		fillmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br /><br />	/* Unmap, drop, and remap.. */<br />	mapping = remap(fd, mapping);<br /><br />	/* .. and check */<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = i;<br />		printf("Checking chunk %d/%d (%d%%)     \r", i, NRCHUNKS, 100*i/NRCHUNKS);<br />		checkmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br /><br />	/* Clean up for next time */<br />	sleep(5);<br />	sync();<br />	sleep(5);<br />	munmap(mapping, SIZE);<br />	close(fd);<br />	unlink("mapfile");<br />	<br />	return 0;<br />}<br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
