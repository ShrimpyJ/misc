    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/16/164">First message in thread</a></li><li><a href="/lkml/2006/12/28/215">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/28/220">David Miller</a><ul><li><a href="/lkml/2006/12/28/223">Linus Torvalds</a></li><li class="origin"><a href="/lkml/2006/12/28/245">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/28/245">Andrew Morton</a></li></ul></li></ul></li><li><a href="/lkml/2006/12/28/234">Anton Altaparmakov</a><ul><li><a href="/lkml/2006/12/28/232">Linus Torvalds</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2006/12/28/244/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 28 Dec 2006 17:38:38 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: 2.6.19 file content corruption on ext3</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />Btw, <br /> much cleaned-up page tracing patch here, in case anybody cares (and <br />"test.c" attached, although I don't think it changed since last time). <br /><br />The test.c output is a bit hard to read at times, since it will give <br />offsets in bytes as hex (ie "00a77664" means page frame 00000a77, and byte <br />664h within that page), while the kernel output is obvioiusly the page <br />indexes (but the page fault _addresses_ can contain information about the <br />exact byte in a page, so you can match them up when some kernel event is <br />related to a page fault).<br /><br />So both forms are necessary/logical, but it means that to match things up, <br />you often need to ignore the last three hex digits of the address that <br />"test.c" outputs.<br /><br />This one also adds traces for the tags and the writeback activity, but <br />since I'm going out for birthday dinner, I won't have time to try to <br />actually analyse the trace I have.. Which is why I'm sending it out, in <br />the hope that somebody else is working on this corruption issue and is <br />interested..<br /><br />		Linus<br /><br />----<br />diff --git a/fs/buffer.c b/fs/buffer.c<br />index 263f88e..f5e132a 100644<br />--- a/fs/buffer.c<br />+++ b/fs/buffer.c<br />&#64;&#64; -722,6 +722,7 &#64;&#64; int __set_page_dirty_buffers(struct page *page)<br /> 			set_buffer_dirty(bh);<br /> 			bh = bh-&gt;b_this_page;<br /> 		} while (bh != head);<br />+		PAGE_TRACE(page, "dirtied buffers");<br /> 	}<br /> 	spin_unlock(&amp;mapping-&gt;private_lock);<br /> <br />&#64;&#64; -734,6 +735,7 &#64;&#64; int __set_page_dirty_buffers(struct page *page)<br /> 			__inc_zone_page_state(page, NR_FILE_DIRTY);<br /> 			task_io_account_write(PAGE_CACHE_SIZE);<br /> 		}<br />+		PAGE_TRACE(page, "setting TAG_DIRTY");<br /> 		radix_tree_tag_set(&amp;mapping-&gt;page_tree,<br /> 				page_index(page), PAGECACHE_TAG_DIRTY);<br /> 	}<br />diff --git a/include/linux/page-flags.h b/include/linux/page-flags.h<br />index 350878a..0cf3dce 100644<br />--- a/include/linux/page-flags.h<br />+++ b/include/linux/page-flags.h<br />&#64;&#64; -91,6 +91,14 &#64;&#64;<br /> #define PG_nosave_free		18	/* Used for system suspend/resume */<br /> #define PG_buddy		19	/* Page is free, on buddy lists */<br /> <br />+#define SetPageInteresting(page) set_bit(PG_arch_1, &amp;(page)-&gt;flags)<br />+#define PageInteresting(page)	test_bit(PG_arch_1, &amp;(page)-&gt;flags)<br />+<br />+#define PAGE_TRACE(page, msg, arg...) do {	 				\<br />+	if (PageInteresting(page))	 					\<br />+		printk(KERN_DEBUG "PG %08lx: %s:%d " msg "\n", 			\<br />+			(page)-&gt;index, __FILE__, __LINE__ ,##arg );		\<br />+} while (0)<br /> <br /> #if (BITS_PER_LONG &gt; 32)<br /> /*<br />&#64;&#64; -183,32 +191,38 &#64;&#64; static inline void SetPageUptodate(struct page *page)<br /> #define PageWriteback(page)	test_bit(PG_writeback, &amp;(page)-&gt;flags)<br /> #define SetPageWriteback(page)						\<br /> 	do {								\<br />-		if (!test_and_set_bit(PG_writeback,			\<br />-				&amp;(page)-&gt;flags))			\<br />+		if (!test_and_set_bit(PG_writeback, &amp;(page)-&gt;flags)) {	\<br />+			PAGE_TRACE(page, "set writeback");		\<br /> 			inc_zone_page_state(page, NR_WRITEBACK);	\<br />+		}							\<br /> 	} while (0)<br /> #define TestSetPageWriteback(page)					\<br /> 	({								\<br /> 		int ret;						\<br /> 		ret = test_and_set_bit(PG_writeback,			\<br /> 					&amp;(page)-&gt;flags);		\<br />-		if (!ret)						\<br />+		if (!ret) {						\<br />+			PAGE_TRACE(page, "set writeback");		\<br /> 			inc_zone_page_state(page, NR_WRITEBACK);	\<br />+		}							\<br /> 		ret;							\<br /> 	})<br /> #define ClearPageWriteback(page)					\<br /> 	do {								\<br />-		if (test_and_clear_bit(PG_writeback,			\<br />-				&amp;(page)-&gt;flags))			\<br />+		if (test_and_clear_bit(PG_writeback, &amp;(page)-&gt;flags)) {	\<br />+			PAGE_TRACE(page, "end writeback");		\<br /> 			dec_zone_page_state(page, NR_WRITEBACK);	\<br />+		}							\<br /> 	} while (0)<br /> #define TestClearPageWriteback(page)					\<br /> 	({								\<br /> 		int ret;						\<br /> 		ret = test_and_clear_bit(PG_writeback,			\<br /> 				&amp;(page)-&gt;flags);			\<br />-		if (ret)						\<br />+		if (ret) {						\<br />+			PAGE_TRACE(page, "end writeback");		\<br /> 			dec_zone_page_state(page, NR_WRITEBACK);	\<br />+		}							\<br /> 		ret;							\<br /> 	})<br /> <br />diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug<br />index 5c26818..7735b83 100644<br />--- a/lib/Kconfig.debug<br />+++ b/lib/Kconfig.debug<br />&#64;&#64; -79,7 +79,7 &#64;&#64; config DEBUG_KERNEL<br /> <br /> config LOG_BUF_SHIFT<br /> 	int "Kernel log buffer size (16 =&gt; 64KB, 17 =&gt; 128KB)" if DEBUG_KERNEL<br />-	range 12 21<br />+	range 12 24<br /> 	default 17 if S390 || LOCKDEP<br /> 	default 16 if X86_NUMAQ || IA64<br /> 	default 15 if SMP<br />diff --git a/mm/filemap.c b/mm/filemap.c<br />index 8332c77..4df7d35 100644<br />--- a/mm/filemap.c<br />+++ b/mm/filemap.c<br />&#64;&#64; -116,6 +116,7 &#64;&#64; void __remove_from_page_cache(struct page *page)<br /> {<br /> 	struct address_space *mapping = page-&gt;mapping;<br /> <br />+	PAGE_TRACE(page, "Removing page cache");<br /> 	radix_tree_delete(&amp;mapping-&gt;page_tree, page-&gt;index);<br /> 	page-&gt;mapping = NULL;<br /> 	mapping-&gt;nrpages--;<br />&#64;&#64; -421,6 +422,23 &#64;&#64; int filemap_write_and_wait_range(struct address_space *mapping,<br /> 	return err;<br /> }<br /> <br />+static noinline int is_interesting(struct address_space *mapping)<br />+{<br />+	struct inode *inode = mapping-&gt;host;<br />+	struct dentry *dentry;<br />+	int retval = 0;<br />+<br />+	spin_lock(&amp;dcache_lock);<br />+	list_for_each_entry(dentry, &amp;inode-&gt;i_dentry, d_alias) {<br />+		if (strcmp(dentry-&gt;d_name.name, "mapfile"))<br />+			continue;<br />+		retval = 1;<br />+		break;<br />+	}<br />+	spin_unlock(&amp;dcache_lock);<br />+	return retval;<br />+}<br />+<br /> /**<br />  * add_to_page_cache - add newly allocated pagecache pages<br />  * &#64;page:	page to add<br />&#64;&#64; -439,6 +457,9 &#64;&#64; int add_to_page_cache(struct page *page, struct address_space *mapping,<br /> {<br /> 	int error = radix_tree_preload(gfp_mask &amp; ~__GFP_HIGHMEM);<br /> <br />+	if (is_interesting(mapping))<br />+		SetPageInteresting(page);<br />+<br /> 	if (error == 0) {<br /> 		write_lock_irq(&amp;mapping-&gt;tree_lock);<br /> 		error = radix_tree_insert(&amp;mapping-&gt;page_tree, offset, page);<br />diff --git a/mm/memory.c b/mm/memory.c<br />index 563792f..20af32f 100644<br />--- a/mm/memory.c<br />+++ b/mm/memory.c<br />&#64;&#64; -667,6 +667,7 &#64;&#64; static unsigned long zap_pte_range(struct mmu_gather *tlb,<br /> 			tlb_remove_tlb_entry(tlb, pte, addr);<br /> 			if (unlikely(!page))<br /> 				continue;<br />+			PAGE_TRACE(page, "unmapped at %08lx", addr);<br /> 			if (unlikely(details) &amp;&amp; details-&gt;nonlinear_vma<br /> 			    &amp;&amp; linear_page_index(details-&gt;nonlinear_vma,<br /> 						addr) != page-&gt;index)<br />&#64;&#64; -1605,6 +1606,7 &#64;&#64; gotten:<br /> 		 */<br /> 		ptep_clear_flush(vma, address, page_table);<br /> 		set_pte_at(mm, address, page_table, entry);<br />+		PAGE_TRACE(new_page, "write fault at %08lx", address);<br /> 		update_mmu_cache(vma, address, entry);<br /> 		lru_cache_add_active(new_page);<br /> 		page_add_new_anon_rmap(new_page, vma, address);<br />&#64;&#64; -2249,6 +2251,7 &#64;&#64; retry:<br /> 		entry = mk_pte(new_page, vma-&gt;vm_page_prot);<br /> 		if (write_access)<br /> 			entry = maybe_mkwrite(pte_mkdirty(entry), vma);<br />+		PAGE_TRACE(new_page, "mapping at %08lx (%s)", address, write_access ? "write" : "read");<br /> 		set_pte_at(mm, address, page_table, entry);<br /> 		if (anon) {<br /> 			inc_mm_counter(mm, anon_rss);<br />diff --git a/mm/page-writeback.c b/mm/page-writeback.c<br />index b3a198c..15f3aaf 100644<br />--- a/mm/page-writeback.c<br />+++ b/mm/page-writeback.c<br />&#64;&#64; -773,6 +773,7 &#64;&#64; int __set_page_dirty_nobuffers(struct page *page)<br /> 				__inc_zone_page_state(page, NR_FILE_DIRTY);<br /> 				task_io_account_write(PAGE_CACHE_SIZE);<br /> 			}<br />+			PAGE_TRACE(page, "setting TAG_DIRTY");<br /> 			radix_tree_tag_set(&amp;mapping-&gt;page_tree,<br /> 				page_index(page), PAGECACHE_TAG_DIRTY);<br /> 		}<br />&#64;&#64; -813,6 +814,7 &#64;&#64; int fastcall set_page_dirty(struct page *page)<br /> 		if (!spd)<br /> 			spd = __set_page_dirty_buffers;<br /> #endif<br />+		PAGE_TRACE(page, "setting dirty");<br /> 		return (*spd)(page);<br /> 	}<br /> 	if (!PageDirty(page)) {<br />&#64;&#64; -867,6 +869,7 &#64;&#64; int clear_page_dirty_for_io(struct page *page)<br /> <br /> 	if (TestClearPageDirty(page)) {<br /> 		if (mapping_cap_account_dirty(mapping)) {<br />+			PAGE_TRACE(page, "clean_for_io");<br /> 			page_mkclean(page);<br /> 			dec_zone_page_state(page, NR_FILE_DIRTY);<br /> 		}<br />&#64;&#64; -886,10 +889,12 &#64;&#64; int test_clear_page_writeback(struct page *page)<br /> <br /> 		write_lock_irqsave(&amp;mapping-&gt;tree_lock, flags);<br /> 		ret = TestClearPageWriteback(page);<br />-		if (ret)<br />+		if (ret) {<br />+			PAGE_TRACE(page, "clearing TAG_WRITEBACK");<br /> 			radix_tree_tag_clear(&amp;mapping-&gt;page_tree,<br /> 						page_index(page),<br /> 						PAGECACHE_TAG_WRITEBACK);<br />+		}<br /> 		write_unlock_irqrestore(&amp;mapping-&gt;tree_lock, flags);<br /> 	} else {<br /> 		ret = TestClearPageWriteback(page);<br />&#64;&#64; -907,14 +912,18 &#64;&#64; int test_set_page_writeback(struct page *page)<br /> <br /> 		write_lock_irqsave(&amp;mapping-&gt;tree_lock, flags);<br /> 		ret = TestSetPageWriteback(page);<br />-		if (!ret)<br />+		if (!ret) {<br />+			PAGE_TRACE(page, "setting TAG_WRITEBACK");<br /> 			radix_tree_tag_set(&amp;mapping-&gt;page_tree,<br /> 						page_index(page),<br /> 						PAGECACHE_TAG_WRITEBACK);<br />-		if (!PageDirty(page))<br />+		}<br />+		if (!PageDirty(page)) {<br />+			PAGE_TRACE(page, "clearing TAG_DIRTY");<br /> 			radix_tree_tag_clear(&amp;mapping-&gt;page_tree,<br /> 						page_index(page),<br /> 						PAGECACHE_TAG_DIRTY);<br />+		}<br /> 		write_unlock_irqrestore(&amp;mapping-&gt;tree_lock, flags);<br /> 	} else {<br /> 		ret = TestSetPageWriteback(page);<br />diff --git a/mm/rmap.c b/mm/rmap.c<br />index 57306fa..e6b4676 100644<br />--- a/mm/rmap.c<br />+++ b/mm/rmap.c<br />&#64;&#64; -448,6 +448,7 &#64;&#64; static int page_mkclean_one(struct page *page, struct vm_area_struct *vma)<br /> 	if (pte_dirty(*pte) || pte_write(*pte)) {<br /> 		pte_t entry;<br /> <br />+		PAGE_TRACE(page, "cleaning PTE %08lx", address);<br /> 		flush_cache_page(vma, address, pte_pfn(*pte));<br /> 		entry = ptep_clear_flush(vma, address, pte);<br /> 		entry = pte_wrprotect(entry);<br />&#64;&#64; -637,6 +638,7 &#64;&#64; static int try_to_unmap_one(struct page *page, struct vm_area_struct *vma,<br /> 		goto out_unmap;<br /> 	}<br /> <br />+	PAGE_TRACE(page, "unmapping from %08lx", address);<br /> 	/* Nuke the page table entry. */<br /> 	flush_cache_page(vma, address, page_to_pfn(page));<br /> 	pteval = ptep_clear_flush(vma, address, pte);<br />&#64;&#64; -767,6 +769,7 &#64;&#64; static void try_to_unmap_cluster(unsigned long cursor,<br /> 		if (ptep_clear_flush_young(vma, address, pte))<br /> 			continue;<br /> <br />+		PAGE_TRACE(page, "unmapping from %08lx", address);<br /> 		/* Nuke the page table entry. */<br /> 		flush_cache_page(vma, address, pte_pfn(*pte));<br /> 		pteval = ptep_clear_flush(vma, address, pte);#include &lt;sys/mman.h&gt;<br />#include &lt;sys/fcntl.h&gt;<br />#include &lt;unistd.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;time.h&gt;<br /><br />#define TARGETSIZE (22 &lt;&lt; 20)<br />#define CHUNKSIZE (1460)<br />#define NRCHUNKS (TARGETSIZE / CHUNKSIZE)<br />#define SIZE (NRCHUNKS * CHUNKSIZE)<br /><br />static void fillmem(void *start, int nr)<br />{<br />	memset(start, nr, CHUNKSIZE);<br />}<br /><br />#define page_offset(buf, off) (unsigned)((unsigned long)(buf)+(off)-(unsigned long)(mapping))<br /><br />static int chunkorder[NRCHUNKS];<br />static char *mapping;<br /><br />static int order(int nr)<br />{<br />	int i;<br />	if (nr &lt; 0 || nr &gt;= NRCHUNKS)<br />		return -1;<br />	for (i = 0; i &lt; NRCHUNKS; i++)<br />		if (chunkorder[i] == nr)<br />			return i;<br />	return -2;<br />}<br /><br />static void checkmem(void *buf, int nr)<br />{<br />	unsigned int start = ~0u, end = 0;<br />	unsigned char c = nr, *p = buf, differs = 0;<br />	int i;<br />	for (i = 0; i &lt; CHUNKSIZE; i++) {<br />		unsigned char got = *p++;<br />		if (got != c) {<br />			if (i &lt; start)<br />				start = i;<br />			if (i &gt; end)<br />				end = i;<br />			differs = got;<br />		}<br />	}<br />	if (start &lt; end) {<br />		printf("Chunk %d corrupted (%u-%u)  (%x-%x)            \n", nr, start, end,<br />			page_offset(buf, start), page_offset(buf, end));<br />		printf("Expected %u, got %u\n", c, differs);<br />		printf("Written as (%d)%d(%d)\n", order(nr-1), order(nr), order(nr+1));<br />	}<br />}<br /><br />static char *remap(int fd, char *mapping)<br />{<br />	if (mapping) {<br />		munmap(mapping, SIZE);<br />		posix_fadvise(fd, 0, SIZE, POSIX_FADV_DONTNEED);<br />	}<br />	return mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);<br />}<br /><br />int main(int argc, char **argv)<br />{<br />	int fd, i;<br /><br />	/*<br />	 * Make some random ordering of writing the chunks to the<br />	 * memory map..<br />	 *<br />	 * Start with fully ordered..<br />	 */<br />	for (i = 0; i &lt; NRCHUNKS; i++)<br />		chunkorder[i] = i;<br /><br />	/* ..and then mix it up randomly */<br />	srandom(time(NULL));<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int index = (unsigned int) random() % NRCHUNKS;<br />		int nr = chunkorder[index];<br />		chunkorder[index] = chunkorder[i];<br />		chunkorder[i] = nr;<br />	}<br /><br />	fd = open("mapfile", O_RDWR | O_TRUNC | O_CREAT, 0666);<br />	if (fd &lt; 0)<br />		return -1;<br />	if (ftruncate(fd, SIZE) &lt; 0)<br />		return -1;<br />	mapping = remap(fd, NULL);<br />	if (-1 == (int)(long)mapping)<br />		return -1;<br /><br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = chunkorder[i];<br />		printf("Writing chunk %d/%d (%d%%) (%08x)     \r",<br />			chunk, NRCHUNKS,<br />			100*i/NRCHUNKS,<br />			page_offset(mapping, chunk * CHUNKSIZE));<br />		fillmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br /><br />	/* Unmap, drop, and remap.. */<br />	mapping = remap(fd, mapping);<br /><br />	/* .. and check */<br />	for (i = 0; i &lt; NRCHUNKS; i++) {<br />		int chunk = i;<br />		printf("Checking chunk %d/%d (%d%%) (%08x)    \r",<br />			i, NRCHUNKS,<br />			100*i/NRCHUNKS,<br />			page_offset(mapping, i * CHUNKSIZE));<br />		checkmem(mapping + chunk * CHUNKSIZE, chunk);<br />	}<br />	printf("\n");<br /><br />	/* Clean up for next time */<br />	sleep(5);<br />	sync();<br />	sleep(5);<br />	munmap(mapping, SIZE);<br />	close(fd);<br />	unlink("mapfile");<br />	<br />	return 0;<br />}<br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
