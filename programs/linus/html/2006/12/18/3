    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/16/164">First message in thread</a></li><li><a href="/lkml/2006/12/17/135">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/18/1">Nick Piggin</a><ul><li><a href="/lkml/2006/12/18/2">Andrew Morton</a><ul><li><a href="/lkml/2006/12/18/29">Nick Piggin</a><ul><li><a href="/lkml/2006/12/18/34">Andrew Morton</a></li></ul></li><li><a href="/lkml/2006/12/19/61">Marc Haber</a><ul><li><a href="/lkml/2006/12/19/77">Martin Michlmayr</a></li><li><a href="/lkml/2006/12/28/139">Marc Haber</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2006/12/18/10">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/18/10">Andrew Morton</a><ul><li><a href="/lkml/2006/12/18/11">Andrew Morton</a></li><li><a href="/lkml/2006/12/18/59">Nick Piggin</a></li></ul></li><li><a href="/lkml/2006/12/18/24">Nick Piggin</a></li><li><a href="/lkml/2006/12/18/35">Andrei Popa</a><ul><li><a href="/lkml/2006/12/18/40">Andrew Morton</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2006/12/18/3/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 17 Dec 2006 21:50:43 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: 2.6.19 file content corruption on ext3</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 18 Dec 2006, Nick Piggin wrote:<br />&gt; <br />&gt; I can't see how that's exactly a problem -- so long as the page does not<br />&gt; get reclaimed (it won't, because we have a ref on it) then all that matters<br />&gt; is that the page eventually gets marked dirty.<br /><br />But the point being that "try_to_free_buffers()" marks it clean <br />AFTERWARDS.<br /><br />So yes, the page gets marked dirty in the pte's - the hardware generally <br />does that for us, so we don't have to worry about that part going on.<br /><br />But "try_to_free_buffers()" seems to clear those dirty bits without <br />serializing it really any way. It just says "ok, I will now clear them". <br />Without knowing whether the dirty bits got set before the IO that cleared <br />the buffer head dirty bits or not.<br /><br />What is _that_ serialization? As far as I can see, the only way to <br />guarantee that to happen (since the dirty bits in the page tables will get <br />set without us ever even being notified) is that the page tables <br />themselves must simply never contain that page in a writable form at all.<br /><br />And that seems to be lacking.<br /><br />Anyway, I have what I consider a much simpler solution: just don't DO all <br />that crap in try_to_free_buffers() at all. I sent it out to some people <br />already, not not very widely. <br /><br />I reproduce my suggestion here for you (and maybe others too who weren't <br />cc'd in that other discussion group) to comment on..<br /><br />		Linus<br /><br />---<br /><br />So I think your patch is really broken, how about this one instead?<br /><br />It's really my previous patch, BUT it also adds a <br /><br />	if (PageDirty(page) ..<br />		return 0;<br /><br />case, on the assumption that since PageDirty() measn that one of the <br />buffers should be dirty, there's no point in even _trying_ drop_buffers, <br />since that should just fail anyway.<br /><br />Now, that assumption is obviously wrong _if_ the buffers have been cleaned <br />by something else. So in that case, we now don't remove the buffer heads, <br />but who really cares? The page will remain on the dirty list, and <br />something should be trying to write it out, but since now all the buffers <br />are clean, once that happens, there is no actual IO to happen.<br /><br />Hmm? So this means that we simply don't remove the buffers early from such <br />pages, but there shouldn't be any real downside.<br /><br />Now, the only question would be if the page is marked dirty _while_ this <br />is running. We do hold the page lock, but page dirtying doesn't get the <br />lock, does it? But at least we won't mark the page _clean_ when it <br />shouldn't be.. And we still are atomic wrt the actual buffer lists <br />(mapping-&gt;private_lock), so I think this should all be ok, and <br />drop_buffers() will do the right thing.<br /><br />So no race possible either.<br /><br />At least as far as I can see. And the patch certainly is simple.<br /><br />Now the question whether this actually _fixes_ any problems does remain, <br />but I think this should be a pretty good solution if the bug really is <br />here. Andrew?<br /><br />		Linus<br /><br />----<br />diff --git a/fs/buffer.c b/fs/buffer.c<br />index d1f1b54..263f88e 100644<br />--- a/fs/buffer.c<br />+++ b/fs/buffer.c<br />&#64;&#64; -2834,7 +2834,7 &#64;&#64; int try_to_free_buffers(struct page *page)<br /> 	int ret = 0;<br /> <br /> 	BUG_ON(!PageLocked(page));<br />-	if (PageWriteback(page))<br />+	if (PageDirty(page) || PageWriteback(page))<br /> 		return 0;<br /> <br /> 	if (mapping == NULL) {		/* can this still happen? */<br />&#64;&#64; -2845,22 +2845,6 &#64;&#64; int try_to_free_buffers(struct page *page)<br /> 	spin_lock(&amp;mapping-&gt;private_lock);<br /> 	ret = drop_buffers(page, &amp;buffers_to_free);<br /> 	spin_unlock(&amp;mapping-&gt;private_lock);<br />-	if (ret) {<br />-		/*<br />-		 * If the filesystem writes its buffers by hand (eg ext3)<br />-		 * then we can have clean buffers against a dirty page.  We<br />-		 * clean the page here; otherwise later reattachment of buffers<br />-		 * could encounter a non-uptodate page, which is unresolvable.<br />-		 * This only applies in the rare case where try_to_free_buffers<br />-		 * succeeds but the page is not freed.<br />-		 *<br />-		 * Also, during truncate, discard_buffer will have marked all<br />-		 * the page's buffers clean.  We discover that here and clean<br />-		 * the page also.<br />-		 */<br />-		if (test_clear_page_dirty(page))<br />-			task_io_account_cancelled_write(PAGE_CACHE_SIZE);<br />-	}<br /> out:<br /> 	if (buffers_to_free) {<br /> 		struct buffer_head *bh = buffers_to_free;<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
