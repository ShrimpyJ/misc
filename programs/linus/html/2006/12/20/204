    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/16/164">First message in thread</a></li><li><a href="/lkml/2006/12/20/164">Martin Michlmayr</a><ul><li><a href="/lkml/2006/12/20/175">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2006/12/20/218">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/20/218">Peter Zijlstra</a></li><li><a href="/lkml/2006/12/20/252">Dave Kleikamp</a><ul><li><a href="/lkml/2006/12/20/274">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2006/12/20/263">Peter Zijlstra</a><ul><li><a href="/lkml/2006/12/20/267">Peter Zijlstra</a></li><li><a href="/lkml/2006/12/20/282">Linus Torvalds</a></li><li><a href="/lkml/2006/12/20/372">Trond Myklebust</a></li></ul></li><li><a href="/lkml/2006/12/20/295">David Chinner</a><ul><li><a href="/lkml/2006/12/20/310">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2006/12/20/300">Andrew Morton</a><ul><li><a href="/lkml/2006/12/20/308">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2006/12/21/33">"Gordon Farquharson"</a><ul><li><a href="/lkml/2006/12/21/37">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2006/12/21/109">Martin Michlmayr</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2006/12/20/204/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 20 Dec 2006 11:50:50 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] mm: fix page_mkclean_one (was: 2.6.19 file content corruption on ext3)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 20 Dec 2006, Linus Torvalds wrote:<br />&gt; <br />&gt; So that's why I've been harping on the fact that I think we simply do <br />&gt; really wrong things with PG_dirty at times [ ... ]<br /><br />Ok, I'll just put my money where my mouth is, and suggest a patch like <br />THIS instead.<br /><br />This one clears up all the issues I find irritating:<br /><br /> - "test_clear_page_dirty()" is insane, both conceptually and as an <br />   implementation. "Give me a 'C', give me an 'R', give me an 'A', give me <br />   a 'P'".<br /><br />   So rip out that mindfart entirely.<br /><br /> - "clear_page_dirty()" is badly named, and should be about CANCELLING the <br />   dirty bit, and must never be called with pages mapped anyway. So throw <br />   that out too, and replace it with a new function:<br /><br />	void cancel_dirty_page(struct page *page, unsigned int accounting_size);<br /><br /> - "clear_page_dirty_for_io()" is fine.<br /><br />And with that, I then either rip out any old users of <br />"test_clear_page_dirty()" or "clear_page_dirty()", and if appropriate (and <br />it's realy lonly appropriate for "truncate()", I replace them with the new <br />"cancel_dirty_page()". Most of the time, they should just be deleted <br />entirely.<br /><br />NOTE NOTE NOTE! I _only_ did enough to make things compile for my <br />particular configuration. That means that right now the following <br />filesystems are broken with this patch (because they use the totally <br />broken old crap):<br /><br />	CIFS, FUSE, JFS, ReiserFS, XFS<br /><br />and I don't know exactly what they need to be fixed. But most likely their <br />usage was insane and pointless anyway (looking at the ReiserFS case, for <br />example, that was DEFINITELY the case. I can't even imagine what the heck <br />it thinks it is doing).<br /><br />Anyway, I'm not at all guaranteeing that this solves anything at all. I <br />_do_ guarantee that this is a h*ll of a lot saner than what we had before.<br /><br />[ This also includes a few of my older patches, I didn't bother to sort <br />  them out, and the fs/buffer.c patch is required because it got rid of <br />  one of the insane uses of test_clear_page_dirty().<br /><br />  So this goes directly on top of current -git, with no other changes in <br />  the tree. ]<br /><br />Nick, Hugh, Peter, Andrew? Comments? <br /><br />Martin, Andrei, does this make any difference for your corruption cases?<br /><br />		Linus<br /><br />---<br />diff --git a/fs/buffer.c b/fs/buffer.c<br />index d1f1b54..263f88e 100644<br />--- a/fs/buffer.c<br />+++ b/fs/buffer.c<br />&#64;&#64; -2834,7 +2834,7 &#64;&#64; int try_to_free_buffers(struct page *page)<br /> 	int ret = 0;<br /> <br /> 	BUG_ON(!PageLocked(page));<br />-	if (PageWriteback(page))<br />+	if (PageDirty(page) || PageWriteback(page))<br /> 		return 0;<br /> <br /> 	if (mapping == NULL) {		/* can this still happen? */<br />&#64;&#64; -2845,22 +2845,6 &#64;&#64; int try_to_free_buffers(struct page *page)<br /> 	spin_lock(&amp;mapping-&gt;private_lock);<br /> 	ret = drop_buffers(page, &amp;buffers_to_free);<br /> 	spin_unlock(&amp;mapping-&gt;private_lock);<br />-	if (ret) {<br />-		/*<br />-		 * If the filesystem writes its buffers by hand (eg ext3)<br />-		 * then we can have clean buffers against a dirty page.  We<br />-		 * clean the page here; otherwise later reattachment of buffers<br />-		 * could encounter a non-uptodate page, which is unresolvable.<br />-		 * This only applies in the rare case where try_to_free_buffers<br />-		 * succeeds but the page is not freed.<br />-		 *<br />-		 * Also, during truncate, discard_buffer will have marked all<br />-		 * the page's buffers clean.  We discover that here and clean<br />-		 * the page also.<br />-		 */<br />-		if (test_clear_page_dirty(page))<br />-			task_io_account_cancelled_write(PAGE_CACHE_SIZE);<br />-	}<br /> out:<br /> 	if (buffers_to_free) {<br /> 		struct buffer_head *bh = buffers_to_free;<br />diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c<br />index ed2c223..4f4cd13 100644<br />--- a/fs/hugetlbfs/inode.c<br />+++ b/fs/hugetlbfs/inode.c<br />&#64;&#64; -176,7 +176,7 &#64;&#64; static int hugetlbfs_commit_write(struct file *file,<br /> <br /> static void truncate_huge_page(struct page *page)<br /> {<br />-	clear_page_dirty(page);<br />+	cancel_dirty_page(page, /* No IO accounting for huge pages? */0);<br /> 	ClearPageUptodate(page);<br /> 	remove_from_page_cache(page);<br /> 	put_page(page);<br />diff --git a/include/linux/page-flags.h b/include/linux/page-flags.h<br />index 4830a3b..350878a 100644<br />--- a/include/linux/page-flags.h<br />+++ b/include/linux/page-flags.h<br />&#64;&#64; -253,15 +253,11 &#64;&#64; static inline void SetPageUptodate(struct page *page)<br /> <br /> struct page;	/* forward declaration */<br /> <br />-int test_clear_page_dirty(struct page *page);<br />+extern void cancel_dirty_page(struct page *page, unsigned int account_size);<br />+<br /> int test_clear_page_writeback(struct page *page);<br /> int test_set_page_writeback(struct page *page);<br /> <br />-static inline void clear_page_dirty(struct page *page)<br />-{<br />-	test_clear_page_dirty(page);<br />-}<br />-<br /> static inline void set_page_writeback(struct page *page)<br /> {<br /> 	test_set_page_writeback(page);<br />diff --git a/mm/memory.c b/mm/memory.c<br />index c00bac6..79cecab 100644<br />--- a/mm/memory.c<br />+++ b/mm/memory.c<br />&#64;&#64; -1842,6 +1842,33 &#64;&#64; void unmap_mapping_range(struct address_space *mapping,<br /> }<br /> EXPORT_SYMBOL(unmap_mapping_range);<br /> <br />+static void check_last_page(struct address_space *mapping, loff_t size)<br />+{<br />+	pgoff_t index;<br />+	unsigned int offset;<br />+	struct page *page;<br />+<br />+	if (!mapping)<br />+		return;<br />+	offset = size &amp; ~PAGE_MASK;<br />+	if (!offset)<br />+		return;<br />+	index = size &gt;&gt; PAGE_SHIFT;<br />+	page = find_lock_page(mapping, index);<br />+	if (page) {<br />+		unsigned int check = 0;<br />+		unsigned char *kaddr = kmap_atomic(page, KM_USER0);<br />+		do {<br />+			check += kaddr[offset++];<br />+		} while (offset &lt; PAGE_SIZE);<br />+		kunmap_atomic(kaddr,KM_USER0);<br />+		unlock_page(page);<br />+		page_cache_release(page);<br />+		if (check)<br />+			printk("%s: BADNESS: truncate check %u\n", current-&gt;comm, check);<br />+	}<br />+}<br />+<br /> /**<br />  * vmtruncate - unmap mappings "freed" by truncate() syscall<br />  * &#64;inode: inode of the file used<br />&#64;&#64; -1875,6 +1902,7 &#64;&#64; do_expand:<br /> 		goto out_sig;<br /> 	if (offset &gt; inode-&gt;i_sb-&gt;s_maxbytes)<br /> 		goto out_big;<br />+	check_last_page(mapping, inode-&gt;i_size);<br /> 	i_size_write(inode, offset);<br /> <br /> out_truncate:<br />diff --git a/mm/page-writeback.c b/mm/page-writeback.c<br />index 237107c..b3a198c 100644<br />--- a/mm/page-writeback.c<br />+++ b/mm/page-writeback.c<br />&#64;&#64; -845,38 +845,6 &#64;&#64; int set_page_dirty_lock(struct page *page)<br /> EXPORT_SYMBOL(set_page_dirty_lock);<br /> <br /> /*<br />- * Clear a page's dirty flag, while caring for dirty memory accounting. <br />- * Returns true if the page was previously dirty.<br />- */<br />-int test_clear_page_dirty(struct page *page)<br />-{<br />-	struct address_space *mapping = page_mapping(page);<br />-	unsigned long flags;<br />-<br />-	if (!mapping)<br />-		return TestClearPageDirty(page);<br />-<br />-	write_lock_irqsave(&amp;mapping-&gt;tree_lock, flags);<br />-	if (TestClearPageDirty(page)) {<br />-		radix_tree_tag_clear(&amp;mapping-&gt;page_tree,<br />-				page_index(page), PAGECACHE_TAG_DIRTY);<br />-		write_unlock_irqrestore(&amp;mapping-&gt;tree_lock, flags);<br />-		/*<br />-		 * We can continue to use `mapping' here because the<br />-		 * page is locked, which pins the address_space<br />-		 */<br />-		if (mapping_cap_account_dirty(mapping)) {<br />-			page_mkclean(page);<br />-			dec_zone_page_state(page, NR_FILE_DIRTY);<br />-		}<br />-		return 1;<br />-	}<br />-	write_unlock_irqrestore(&amp;mapping-&gt;tree_lock, flags);<br />-	return 0;<br />-}<br />-EXPORT_SYMBOL(test_clear_page_dirty);<br />-<br />-/*<br />  * Clear a page's dirty flag, while caring for dirty memory accounting.<br />  * Returns true if the page was previously dirty.<br />  *<br />diff --git a/mm/truncate.c b/mm/truncate.c<br />index 9bfb8e8..bf9e296 100644<br />--- a/mm/truncate.c<br />+++ b/mm/truncate.c<br />&#64;&#64; -51,6 +51,20 &#64;&#64; static inline void truncate_partial_page(struct page *page, unsigned partial)<br /> 		do_invalidatepage(page, partial);<br /> }<br /> <br />+void cancel_dirty_page(struct page *page, unsigned int account_size)<br />+{<br />+	/* If we're cancelling the page, it had better not be mapped any more */<br />+	if (page_mapped(page)) {<br />+		static unsigned int warncount;<br />+<br />+		WARN_ON(++warncount &lt; 5);<br />+	}<br />+		<br />+	if (TestClearPageDirty(page) &amp;&amp; account_size)<br />+		task_io_account_cancelled_write(account_size);<br />+}<br />+<br />+<br /> /*<br />  * If truncate cannot remove the fs-private metadata from the page, the page<br />  * becomes anonymous.  It will be left on the LRU and may even be mapped into<br />&#64;&#64; -70,8 +84,8 &#64;&#64; truncate_complete_page(struct address_space *mapping, struct page *page)<br /> 	if (PagePrivate(page))<br /> 		do_invalidatepage(page, 0);<br /> <br />-	if (test_clear_page_dirty(page))<br />-		task_io_account_cancelled_write(PAGE_CACHE_SIZE);<br />+	cancel_dirty_page(page, PAGE_CACHE_SIZE);<br />+<br /> 	ClearPageUptodate(page);<br /> 	ClearPageMappedToDisk(page);<br /> 	remove_from_page_cache(page);<br />&#64;&#64; -350,7 +364,6 &#64;&#64; int invalidate_inode_pages2_range(struct address_space *mapping,<br /> 		for (i = 0; !ret &amp;&amp; i &lt; pagevec_count(&amp;pvec); i++) {<br /> 			struct page *page = pvec.pages[i];<br /> 			pgoff_t page_index;<br />-			int was_dirty;<br /> <br /> 			lock_page(page);<br /> 			if (page-&gt;mapping != mapping) {<br />&#64;&#64; -386,12 +399,8 &#64;&#64; int invalidate_inode_pages2_range(struct address_space *mapping,<br /> 					  PAGE_CACHE_SIZE, 0);<br /> 				}<br /> 			}<br />-			was_dirty = test_clear_page_dirty(page);<br />-			if (!invalidate_complete_page2(mapping, page)) {<br />-				if (was_dirty)<br />-					set_page_dirty(page);<br />+			if (!invalidate_complete_page2(mapping, page))<br /> 				ret = -EIO;<br />-			}<br /> 			unlock_page(page);<br /> 		}<br /> 		pagevec_release(&amp;pvec);<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
