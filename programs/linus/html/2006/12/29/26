    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/16/164">First message in thread</a></li><li><a href="/lkml/2006/12/28/251">Segher Boessenkool</a><ul><li><a href="/lkml/2006/12/29/18">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2006/12/29/44">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/29/44">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/29/47">Andrei Popa</a></li><li><a href="/lkml/2006/12/29/51">Nick Piggin</a></li><li><a href="/lkml/2006/12/29/63">Ingo Molnar</a></li><li><a href="/lkml/2006/12/29/70">Martin Johansson</a></li><li><a href="/lkml/2006/12/29/76">Martin Michlmayr</a></li><li><a href="/lkml/2006/12/29/145">Andrew Morton</a></li></ul></li><li><a href="/lkml/2006/12/29/85">Theodore Tso</a><ul><li><a href="/lkml/2006/12/29/103">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2006/12/29/52">Ingo Molnar</a><ul><li><a href="/lkml/2007/1/2/52">Christoph Hellwig</a><ul><li><a href="/lkml/2007/1/2/74">Ingo Molnar</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 29 Dec 2006 00:58:12 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Ok, explained.. (was Re: [PATCH] mm: fix page_mkclean_one)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 28 Dec 2006, Linus Torvalds wrote:<br />&gt; <br />&gt; So everything I have ever seen says that the VM layer is actually doing <br />&gt; everything right.<br /><br />That was true, but at the same time, it's not. Let me explain.<br /><br />&gt; That to me says: "somebody didn't actually write out out". The VM layer <br />&gt; asked the filesystem to do the write, but the filesystem just didn't do <br />&gt; it. I personally think it's because some buffer-head BH_dirty bit got <br />&gt; scrogged<br /><br />Ok, I have proof of this now.<br /><br />Here's a trace (with cycle counts), and with a new trace event added: this <br />is for another corrupted page. I have:<br /><br /> 49105  PG 000015d8 (14800): mm/page-writeback.c:872 clean_for_io<br /> 49106  PG 000015d8 (6900): mm/rmap.c:451 cleaning PTE b7fa6000<br /> 49107  PG 000015d8 (9900): mm/page-writeback.c:914 set writeback<br /> 49108  PG 000015d8 (6480): mm/page-writeback.c:916 setting TAG_WRITEBACK<br /> 49109  PG 000015d8 (7110): mm/page-writeback.c:922 clearing TAG_DIRTY<br /> 49110  PG 000015d8 (7190): fs/buffer.c:1713 no IO underway<br /> 49111  PG 000015d8 (6180): mm/page-writeback.c:891 end writeback<br /> 49112  PG 000015d8 (6460): mm/page-writeback.c:893 clearing TAG_WRITEBACK<br /><br />where that first column is the trace event number again, and the "PG <br />000015d8" is that corrupted page. The thing in the parenthesis is "CPU <br />cycles since last event), and the important part to note is that this is <br />indeed all one single thing with no actual IO anywhere (~7000 CPU cycles <br />may sound like a lot, but (a) it's not that many cache misses and (b) a <br />lot of it is the logging overhead - back-to-back log events will take <br />about 3500 cycles) just because it does the actual ASCII printk() etc.<br /><br />Also, the new event is:<br /><br />	fs/buffer.c:1713 no IO underway<br /><br />which is just the <br /><br />	if (nr_underway == 0)<br /><br />case in fs/buffer.c<br /><br />And I now finally really believe that I fully understand the corruption, <br />but I don't have a simple solution, much less a patch.<br /><br />What the problem basically boils down to is that "set_page_dirty()" is <br />supposed to be a mark for dirtying THE WHOLE PAGE, but it really is not <br />"the whole page when the 'set_page_dirty()' itself happens", but more of a <br />"the next writepage() needs to write back the whole page" thing.<br /><br />And that's not what "__set_page_dirty_buffers()" really does.<br /><br />Because what "__set_page_dirty_buffers()" does is that AT THE TIME THE <br />"set_page_dirty()" IS CALLED, it will mark all the buffers on that page as <br />dirty. That may _sound_ like what we want, but it really isn't. Because by <br />the time "writepage()" is actually called (which can be MUCH MUCH later), <br />some internal filesystem activity may actually have cleaned one or more of <br />those buffers in the meantime, and now we call "writepage()" (which really <br />wants to write them _all_), and it will write only part of them, or none <br />at all.<br /><br />So the VM thought that since it did a "writepage()", all the dirty state <br />at that point got written back. But it didn't - the filesystem could have <br />written back part or all of the page much earlier, and the writepage() <br />actually does nothing at all.<br /><br />Both filesystem and VM actually _think_ they do the right thing, because <br />they simply have totally different expectations. The filesystem thinks <br />that it should care about dirty buffers (that got marked dirty _after_ <br />they were dirtied), while the filesystem thinks that it cares about dirty <br />_pages_ (that got dirted at any time _before_ "writepage()" was called).<br /><br />Neither is really "wrong", per se, it's just that the two parts have <br />different expectations, and the _combination_ just doesn't work. <br />"set_page_dirty()" at some point meant "the writes have been done", but <br />these days it really means something else.<br /><br />Now, the reason there is no trivial patch is not that this is conceptually <br />really hard to fix. I can see several different approaches to fixing it, <br />but they all really boil down to two alternatives:<br /><br /> (a) splitting the one "PG_dirty" bit up into two bits: the <br />     "PG_writescheduled" bit and the "PG_alldirty" bit.<br /><br />     The "PG_write_scheduled" bit would be the bit that the filesystem <br />     would set when it has pending dirty data that it wrote itself (and <br />     that may not cover the whole page), and is the part of PG_dirty that <br />     sets the PAGECACHE_TAG_DIRTY. It's also what forces "writepage()" to <br />     be called.<br /><br />     The "PG_alldirty" bit is just an additional "somebody else dirtied <br />     random parts of this page, and we don't know what" flag, which is set <br />     by "set_page_dirty()" in addition to doing the PG_write_scheduled <br />     stuff. We would test-and-clear it at "writepage()" time, and pass it <br />     in to "writepages()" to tell the writepage() function that it can't <br />     just write out its own small limited notion of what is dirty.<br /><br />     (There are various variations on this whole theme: instead of having <br />     a flag to "writepage()", we could split the "whole page" case out as <br />     a separate callback or similar)<br /><br /> (b) making sure that all "set_page_dirty()" calls are _after_ the page <br />     has been marked dirty (which in the case of memory mapped pages would <br />     mean that we would _not_ call it when we mark the page writable at <br />     all, we would call it when we _remove_ the dirty bit and mark it <br />     unwritable). That would have the nice fearture that it wouldn't <br />     require any FS-level changes, which would be a nice thing - it would <br />     basically make the VM dirty accounting work the way the FS layer now <br />     already expects it to.<br /><br />I think (b) is conceptually simpler, and I think I'll try it tomorrow <br />after I've slept on it. The reason I mention (a) at all is that I like the <br />conceptual notion of telling he filesystem ahead of time that "you're <br />going to get a full dirty page", because what (b) will inevitably lead to <br />is that the filesystem will maintain its own partial state, and then <br />effectively just before it gets the writepage() notification, it will be <br />told it was all pointless, because we just dirtied the whole thing. <br /><br />IOW, the advantage of (a) is also it's disadvantage: it tells the <br />filesystem more. The disadvantage is that it would require VFS interface <br />changes exactly to do that (ie the "mapping-&gt;set_page_dirty()" semantics <br />would also be split up into two, and it would now be a "prepare to write <br />the whole page during the next 'writepage()'" thing).<br /><br />So to recap: the VM layer really expected "writepage()" to act as if it <br />wrote out the whole page. It doesn't. Not in the presense of the buffer <br />layer and the filesystem having written out some buffers independently of <br />the VM layer earlier.<br /><br />I think this also explains why "data=ordered" broke, and "data=writeback" <br />didn't. When ext3 does "ordered" writebacks, it will do file data <br />writebacks on its own, in _its_ order. In contrast, when it does <br />"data=writeback", it will do the writebacks exactly as the VM presents <br />them, and won't write any buffers on its own - which makes the bug go <br />away, because now VM and FS end up agreeing about the semantics of <br />"writepage()".<br /><br />Andrew, do you see anything wrong in my thinking?<br /><br />Peter - on a VM level, the fix would be:<br /><br /> - remove the "set_page_dirty()" from the page fault path, and just set <br />   the PAGECACHE_TAG_DIRTY instead.<br /><br /> - clear_page_dirty_for_io() would now need to check the mappings of the <br />   page even if it wasn't marked PG_dirty (or we'd have another page flag <br />   for the "page is dirty in page tables"), which is kind of a mixture of <br />   (a) and (b) cases above, except we don't expose it to the FS.<br /><br /> - if it was dirty in the page tables, we do a "set_page_dirty()" after <br />   cleaning the page tables, and then the rest of <br />   "clear_page_dirty_for_io()" really boils down to a simple <br />   "TestAndClearDirty(page)"<br /><br />Hmm? I'd love it if somebody else wrote the patch and tested it, because <br />I'm getting sick and tired of this bug ;)<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
