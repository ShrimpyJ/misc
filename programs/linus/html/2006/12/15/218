    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/12/12/271">First message in thread</a></li><li><a href="/lkml/2006/12/12/338">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/12/342">Nick Piggin</a><ul><li><a href="/lkml/2006/12/12/345">Linus Torvalds</a></li><li class="origin"><a href="/lkml/2006/12/18/27">Linus Torvalds</a><ul><li><a href="/lkml/2006/12/18/27">David Woodhouse</a><ul><li><a href="/lkml/2006/12/18/32">Evgeniy Polyakov</a></li><li><a href="/lkml/2006/12/18/33">David Miller</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2006/12/15/218/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 15 Dec 2006 14:45:25 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 1/2] WorkStruct: Add assign_bits() to give an atomic-bitops safe assignment</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 13 Dec 2006, Nick Piggin wrote:<br />&gt; Linus Torvalds wrote:<br />&gt; &gt; <br />&gt; &gt; On Tue, 12 Dec 2006, Russell King wrote:<br />&gt; &gt; &gt; <br />&gt; &gt; &gt; Why can't we just use atomic_t for this?<br />&gt; &gt; <br />&gt; &gt; <br />&gt; &gt; Well, others have answered that ("wrong sizes"), but I'm wavering on using<br />&gt; &gt; atomic_long_t. I have to admit that I'd rather not add a new accessor<br />&gt; &gt; function, when it _should_ be easier to use the current ones.<br />&gt; <br />&gt; I agree.<br /><br />Ok, nobody ever did anything about this, so here's my try.<br /><br />This uses "atomic_long_t" for the workstruct "data" field, which shares <br />the per-cpu pointer and the workstruct flag bits in one field.<br /><br />This ONLY works if "atomic_set()" is actually atomic wrt the atomic bit <br />operations too, which is generally true on any architecture that does <br />atomics natively (or on UP when done by disabling interrupts), but may not <br />be true on architectures where atomic operations are faked with spinlocks, <br />and the two different kinds of atomic ops use different spinlocks.<br /><br />Right now sparc32 is one such architecture, possibly the only one. It <br />would need to be fixed. Davem?<br /><br />NOTE! This patch also depends on an unrealted fix that I already pushed <br />out, which fixes "delayed_work_pending()" which was totally broken before <br />(macro expansion would replace "work" whether it was used as a variable <br />_or_ as a struct member name). If that hasn't mirrored out yet, you should <br />just fix the "delayed_work_pending()" macro to look like<br /><br />	#define delayed_work_pending(w) \<br />		work_pending(&amp;(w)-&gt;work)<br /><br />(ie use the "work_pending()" macro to do the heavy lifting, and do NOT use <br />the name "work" for the macro argument).<br /><br />This is untested, other than to see that it compiles. It all looks very <br />obvious, but then, all my code always does, yet somehow bugs still creep <br />in occasionally. I personally suspect it's some really subtle SMTP bug <br />that corrupts my patches, but I've never caught it outright. <br /><br />Anyway. It's bug-free-by-definition, since it's written by yours truly, <br />but people should probably test it and comment on it, in the unlikely <br />event that the evil gnomes lurking in the intarnet tubes corrupt it.<br /><br />Comments?<br /><br />			Linus<br />---<br />diff --git a/include/linux/workqueue.h b/include/linux/workqueue.h<br />index 5b13dcf..2a7b38d 100644<br />--- a/include/linux/workqueue.h<br />+++ b/include/linux/workqueue.h<br />&#64;&#64; -8,16 +8,21 &#64;&#64;<br /> #include &lt;linux/timer.h&gt;<br /> #include &lt;linux/linkage.h&gt;<br /> #include &lt;linux/bitops.h&gt;<br />+#include &lt;asm/atomic.h&gt;<br /> <br /> struct workqueue_struct;<br /> <br /> struct work_struct;<br /> typedef void (*work_func_t)(struct work_struct *work);<br /> <br />+/*<br />+ * The first word is the work queue pointer and the flags rolled into<br />+ * one<br />+ */<br />+#define work_data_bits(work) ((unsigned long *)(&amp;(work)-&gt;data))<br />+<br /> struct work_struct {<br />-	/* the first word is the work queue pointer and the flags rolled into<br />-	 * one */<br />-	unsigned long management;<br />+	atomic_long_t data;<br /> #define WORK_STRUCT_PENDING 0		/* T if work item pending execution */<br /> #define WORK_STRUCT_NOAUTOREL 1		/* F if work item automatically released on exec */<br /> #define WORK_STRUCT_FLAG_MASK (3UL)<br />&#64;&#64; -26,6 +31,9 &#64;&#64; struct work_struct {<br /> 	work_func_t func;<br /> };<br /> <br />+#define WORK_DATA_INIT(autorelease) \<br />+	ATOMIC_LONG_INIT((autorelease) &lt;&lt; WORK_STRUCT_NOAUTOREL)<br />+<br /> struct delayed_work {<br /> 	struct work_struct work;<br /> 	struct timer_list timer;<br />&#64;&#64; -36,13 +44,13 &#64;&#64; struct execute_work {<br /> };<br /> <br /> #define __WORK_INITIALIZER(n, f) {				\<br />-	.management = 0,					\<br />+	.data = WORK_DATA_INIT(0),				\<br />         .entry	= { &amp;(n).entry, &amp;(n).entry },			\<br /> 	.func = (f),						\<br /> 	}<br /> <br /> #define __WORK_INITIALIZER_NAR(n, f) {				\<br />-	.management = (1 &lt;&lt; WORK_STRUCT_NOAUTOREL),		\<br />+	.data = WORK_DATA_INIT(1),				\<br />         .entry	= { &amp;(n).entry, &amp;(n).entry },			\<br /> 	.func = (f),						\<br /> 	}<br />&#64;&#64; -82,17 +90,21 &#64;&#64; struct execute_work {<br /> <br /> /*<br />  * initialize all of a work item in one go<br />+ *<br />+ * NOTE! No point in using "atomic_long_set()": useing a direct<br />+ * assignment of the work data initializer allows the compiler<br />+ * to generate better code.<br />  */<br /> #define INIT_WORK(_work, _func)					\<br /> 	do {							\<br />-		(_work)-&gt;management = 0;			\<br />+		(_work)-&gt;data = (atomic_long_t) WORK_DATA_INIT(0);	\<br /> 		INIT_LIST_HEAD(&amp;(_work)-&gt;entry);		\<br /> 		PREPARE_WORK((_work), (_func));			\<br /> 	} while (0)<br /> <br /> #define INIT_WORK_NAR(_work, _func)					\<br /> 	do {								\<br />-		(_work)-&gt;management = (1 &lt;&lt; WORK_STRUCT_NOAUTOREL);	\<br />+		(_work)-&gt;data = (atomic_long_t) WORK_DATA_INIT(1);	\<br /> 		INIT_LIST_HEAD(&amp;(_work)-&gt;entry);			\<br /> 		PREPARE_WORK((_work), (_func));				\<br /> 	} while (0)<br />&#64;&#64; -114,7 +126,7 &#64;&#64; struct execute_work {<br />  * &#64;work: The work item in question<br />  */<br /> #define work_pending(work) \<br />-	test_bit(WORK_STRUCT_PENDING, &amp;(work)-&gt;management)<br />+	test_bit(WORK_STRUCT_PENDING, work_data_bits(work))<br /> <br /> /**<br />  * delayed_work_pending - Find out whether a delayable work item is currently<br />&#64;&#64; -143,7 +155,7 &#64;&#64; struct execute_work {<br />  * This should also be used to release a delayed work item.<br />  */<br /> #define work_release(work) \<br />-	clear_bit(WORK_STRUCT_PENDING, &amp;(work)-&gt;management)<br />+	clear_bit(WORK_STRUCT_PENDING, work_data_bits(work))<br /> <br /> <br /> extern struct workqueue_struct *__create_workqueue(const char *name,<br />&#64;&#64; -188,7 +200,7 &#64;&#64; static inline int cancel_delayed_work(struct delayed_work *work)<br /> <br /> 	ret = del_timer_sync(&amp;work-&gt;timer);<br /> 	if (ret)<br />-		clear_bit(WORK_STRUCT_PENDING, &amp;work-&gt;work.management);<br />+		work_release(&amp;work-&gt;work);<br /> 	return ret;<br /> }<br /> <br />diff --git a/kernel/workqueue.c b/kernel/workqueue.c<br />index db49886..742cbbe 100644<br />--- a/kernel/workqueue.c<br />+++ b/kernel/workqueue.c<br />&#64;&#64; -96,13 +96,13 &#64;&#64; static inline void set_wq_data(struct work_struct *work, void *wq)<br /> 	BUG_ON(!work_pending(work));<br /> <br /> 	new = (unsigned long) wq | (1UL &lt;&lt; WORK_STRUCT_PENDING);<br />-	new |= work-&gt;management &amp; WORK_STRUCT_FLAG_MASK;<br />-	work-&gt;management = new;<br />+	new |= WORK_STRUCT_FLAG_MASK &amp; *work_data_bits(work);<br />+	atomic_long_set(&amp;work-&gt;data, new);<br /> }<br /> <br /> static inline void *get_wq_data(struct work_struct *work)<br /> {<br />-	return (void *) (work-&gt;management &amp; WORK_STRUCT_WQ_DATA_MASK);<br />+	return (void *) (atomic_long_read(&amp;work-&gt;data) &amp; WORK_STRUCT_WQ_DATA_MASK);<br /> }<br /> <br /> static int __run_work(struct cpu_workqueue_struct *cwq, struct work_struct *work)<br />&#64;&#64; -133,7 +133,7 &#64;&#64; static int __run_work(struct cpu_workqueue_struct *cwq, struct work_struct *work<br /> 		list_del_init(&amp;work-&gt;entry);<br /> 		spin_unlock_irqrestore(&amp;cwq-&gt;lock, flags);<br /> <br />-		if (!test_bit(WORK_STRUCT_NOAUTOREL, &amp;work-&gt;management))<br />+		if (!test_bit(WORK_STRUCT_NOAUTOREL, work_data_bits(work)))<br /> 			work_release(work);<br /> 		f(work);<br /> <br />&#64;&#64; -206,7 +206,7 &#64;&#64; int fastcall queue_work(struct workqueue_struct *wq, struct work_struct *work)<br /> {<br /> 	int ret = 0, cpu = get_cpu();<br /> <br />-	if (!test_and_set_bit(WORK_STRUCT_PENDING, &amp;work-&gt;management)) {<br />+	if (!test_and_set_bit(WORK_STRUCT_PENDING, work_data_bits(work))) {<br /> 		if (unlikely(is_single_threaded(wq)))<br /> 			cpu = singlethread_cpu;<br /> 		BUG_ON(!list_empty(&amp;work-&gt;entry));<br />&#64;&#64; -248,7 +248,7 &#64;&#64; int fastcall queue_delayed_work(struct workqueue_struct *wq,<br /> 	if (delay == 0)<br /> 		return queue_work(wq, work);<br /> <br />-	if (!test_and_set_bit(WORK_STRUCT_PENDING, &amp;work-&gt;management)) {<br />+	if (!test_and_set_bit(WORK_STRUCT_PENDING, work_data_bits(work))) {<br /> 		BUG_ON(timer_pending(timer));<br /> 		BUG_ON(!list_empty(&amp;work-&gt;entry));<br /> <br />&#64;&#64; -280,7 +280,7 &#64;&#64; int queue_delayed_work_on(int cpu, struct workqueue_struct *wq,<br /> 	struct timer_list *timer = &amp;dwork-&gt;timer;<br /> 	struct work_struct *work = &amp;dwork-&gt;work;<br /> <br />-	if (!test_and_set_bit(WORK_STRUCT_PENDING, &amp;work-&gt;management)) {<br />+	if (!test_and_set_bit(WORK_STRUCT_PENDING, work_data_bits(work))) {<br /> 		BUG_ON(timer_pending(timer));<br /> 		BUG_ON(!list_empty(&amp;work-&gt;entry));<br /> <br />&#64;&#64; -321,7 +321,7 &#64;&#64; static void run_workqueue(struct cpu_workqueue_struct *cwq)<br /> 		spin_unlock_irqrestore(&amp;cwq-&gt;lock, flags);<br /> <br /> 		BUG_ON(get_wq_data(work) != cwq);<br />-		if (!test_bit(WORK_STRUCT_NOAUTOREL, &amp;work-&gt;management))<br />+		if (!test_bit(WORK_STRUCT_NOAUTOREL, work_data_bits(work)))<br /> 			work_release(work);<br /> 		f(work);<br /> <br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
