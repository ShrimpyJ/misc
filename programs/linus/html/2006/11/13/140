    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2006/11/7/345">First message in thread</a></li><li><a href="/lkml/2006/11/8/176">Linus Torvalds</a><ul><li><a href="/lkml/2006/11/10/142">Komuro</a><ul><li class="origin"><a href="/lkml/2006/11/13/190">Linus Torvalds</a><ul><li><a href="/lkml/2006/11/13/190">(Eric W. Biederman)</a><ul><li><a href="/lkml/2006/11/13/277">Ingo Molnar</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 13 Nov 2006 08:02:28 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Re: Re: 2.6.19-rc5: known regressions :SMP kernel can not generate ISA irq</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Fri, 10 Nov 2006, Komuro wrote:<br />&gt; <br />&gt; I tried the 2.6.19-rc5,  the problem still happens.<br /><br />Ok, that's good data, and especially:<br /><br />&gt; But,<br />&gt; I remove the disable_irq_nosync() , enable_irq()<br />&gt; from the linux/drivers/net/pcmcia/axnet_cs.c<br />&gt; the interrupt is generated properly.<br /><br />All RIGHT. That's a very good clue. The major difference between PCI and <br />ISA irq's is that they have different trigger types (they also have <br />different polarity, but that tends to be just a small detail). In <br />particular, ISA IRQ's are edge-triggered, and PCI IRQ's are level- <br />triggered.<br /><br />Now, edge-triggered interrupts are a _lot_ harder to mask, because the <br />Intel APIC is an unbelievable piece of sh*t, and has the edge-detect logic <br />_before_ the mask logic, so if a edge happens _while_ the device is <br />masked, you'll never ever see the edge ever again (unmasking will not <br />cause a new edge, so you simply lost the interrupt).<br /><br />So when you "mask" an edge-triggered IRQ, you can't really mask it at all, <br />because if you did that, you'd lose it forever if the IRQ comes in while <br />you masked it. Instead, we're supposed to leave it active, and set a flag, <br />and IF the IRQ comes in, we just remember it, and mask it at that point <br />instead, and then on unmasking, we have to replay it by sending a <br />self-IPI.<br /><br />Maybe that part got broken by some of the IRQ changes by Eric. <br /><br />Eric, can you please double-check this all? I suspect you disable <br />edge-triggered interrupts when moving them, or something, and maybe you <br />didn't realize that if you disable them on the IO-APIC level, they can be <br />gone forever.<br /><br />[ Note: this is true EVEN IF we are in the interrupt handler right then - <br />  if we get another edge while in the interrupt handler, the interrupt <br />  will normally be _delayed_ until we've ACK'ed it, but if we have <br />  _masked_ it, it will simply be lost entirely. So a simple "mask" <br />  operation is always incorrect for edge-triggered interrupts.<br /><br />  One option might be to do a simple mask, and on unmask, turn the edge <br />  trigger into a level trigger at the same time. Then, the first time you <br />  get the interrupt, you turn it back into an edge trigger _before_ you <br />  call the interrupt handlers. That might actually be simpler than doing <br />  the "irq replay" dance with self-IPI, because we can't actually just <br />  fake the IRQ handling - when enable_irq() is called, irq's are normally <br />  disabled on the CPU, so we can't just call the irq handler at that <br />  point: we really do need to "replay" the dang thing.<br /><br />  Did I mention that the Intel APIC's are a piece of cr*p already? ]<br /><br />&gt; So I think enable_irq does not enable the irq.<br /><br />It probably does enable it (that's the easy part), but see above: if any <br />of the support structure for the APIC crapola is subtly broken, we'll have <br />lost the IRQ anyway.<br /><br />(Many other IRQ controllers get this right: the "old and broken" Intel <br />i8259 interrupt controller was a much better IRQ controller than the APIC <br />in this regard, because it simply had the edge-detect logic after the <br />masking logic, so if you unmasked an active interrupt that had been <br />masked, you would always see it as an edge, and the i8259 controller needs <br />none of the subtle code at _all_. It just works.)<br /><br />Anyway, if you _can_ bisect the exact point where this started happening, <br />that would be good. But I would not be surprised in the least if this is <br />all introduced by Eric Biedermans dynamic IRQ handling.<br /><br />Eric?<br /><br />			Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
