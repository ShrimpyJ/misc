    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1998/9/13/19">First message in thread</a></li><li><a href="/lkml/1998/9/19/178">(Alan Cox)</a><ul><li><a href="/lkml/1998/9/20/42">Geert Uytterhoeven</a><ul><li class="origin"><a href="/lkml/1998/9/20/122">Linus Torvalds</a><ul><li><a href="/lkml/1998/9/20/122">(Alan Cox)</a><ul><li><a href="/lkml/1998/9/20/147">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 20 Sep 1998 10:10:23 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Today Linus redesigns the networking driver interface (was Re: tulip driver in ...)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sun, 20 Sep 1998, Geert Uytterhoeven wrote:<br />&gt; &gt; Almost every cli in the kernel is in fact really<br />&gt; &gt; <br />&gt; &gt; 	block_interrupt(dev-&gt;irq)<br />&gt; &gt; 	something<br />&gt; &gt; 	unblock_interrupt(dev-&gt;irq)<br />&gt; &gt; <br />&gt; &gt; Where dev-&gt;irq is the device irq.<br />&gt; <br />&gt; #ifdef __i386__<br />&gt; #define block_interrupt(irq)	save_flags(flags); cli();<br />&gt; #define unblock_interrupt(irq)	restore_flags();<br />&gt; #else<br />&gt; #define block_interrupt(irq)	sane_block_interrupt(irq);<br />&gt; #define unblock_interrupt(irq)	sane_unblock_interrupt(irq);<br />&gt; #endif<br /><br />No, this really is basically broken. It's broken for two major reasons:<br /><br /> - a lot of code wants to block _multiple_ interrupts. And they really<br />   shouldn't know about that. For example, the networking code would have<br />   to block interrupts from all network devices that could be implicated,<br />   in addition to blocking the timers. <br /><br />   And trust me, it's too easy to get wrong.<br /><br />   Linux very obviously already supports the "disable_irq(irq)" notion,<br />   and it should work correctly these days now that we understand better<br />   how the silly IO-APIC works (and most other architectures have much<br />   saner interrupt controllers that are better documented). So the above<br />   feature really does exist already.<br /><br />   However, that feature is really meant more to be used by device drivers<br />   etc for their internal use, rather than for "generic" code.<br /><br /> - generic code really shouldn't care about issues like what interrupts<br />   handle networking. More importantly, as Donald Becker pointed out,<br />   there really _is_ no sense of "one interrupt, one device". That's a<br />   notion from the 70s, we've gone past that. And I don't want to have<br />   Linux to have a broken architecture that doesn't match reality.<br /><br />So how to do this? The only sane answer is, and has always been, to just<br />minimize the critical regions. People who want "[un]block_interrupt()"<br />just want to write bad code. The real solution is to just make sure that<br />you do 99% of all your work using completely "local" resources, and then<br />there is a very small and well-defined critical section where global<br />resources are handled. And then you use spinlocks or similar<br />synchronization means. <br /><br />The Linux netowkring use of a bottom half handler is extremely efficient: <br />it allows for very simple locking constraints, and the only problems I see<br />are really (a) SMP scalability (and quite frankly, I suspect people talk<br />more about this than is true - I doubt it's really an issue for us right<br />now, and won't be until we scale better in other areas) and (b) suboptimal<br />implementation.<br /><br />		Linus<br /><br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.rutgers.edu<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
