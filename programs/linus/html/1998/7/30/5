    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1998/7/29/107">First message in thread</a></li><li><a href="/lkml/1998/7/29/107">Gadi Oxman</a><ul><li><a href="/lkml/1998/7/29/118">MOLNAR Ingo</a><ul><li class="origin"><a href="/lkml/1998/7/30/9">Linus Torvalds</a><ul><li><a href="/lkml/1998/7/30/9">MOLNAR Ingo</a><ul><li><a href="/lkml/1998/7/30/10">Linus Torvalds</a></li></ul></li><li><a href="/lkml/1998/7/30/26">MOLNAR Ingo</a><ul><li><a href="/lkml/1998/7/30/74">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/1998/7/29/143">Linus Torvalds</a><ul><li><a href="/lkml/1998/7/29/146">MOLNAR Ingo</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 29 Jul 1998 22:57:42 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [patch] IDE problems on SMP, fixed? (fwd)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 29 Jul 1998, MOLNAR Ingo wrote:<br />&gt; <br />&gt; the lockup happens somewhere after we enter smp_apic_timer_interrupt(). I<br />&gt; suspect it's the irq_enter() within smp_local_timer_interrupt().<br /><br />irq_enter() would certainly be a top suspect, yes. It's one of the few<br />things that can easily wait forever if something goes wrong.<br /><br />[ This btw shows a layering thing - we _should_ do the irq_enter()  inside<br />  the smp_apic_timer_interrupt() function before actually calling the<br />  smp_local_timer_interrupt() thing - because smp_local_timer_interrupt()<br />  is also called from the "old-fashioned" timer irq handler when we didn't<br />  get the SMP IO-APIC stuff set up correctly, and in that case we'd do an<br />  "irq_enter()" twice - which is harmless but still not the right thing to<br />  do conceptually ]<br /><br />Hanging in irq_enter() _tends_ to mean that the local CPU has done a<br />global interrupt disable, and then enabled interrupts locally. BOOM. That<br />would certainly cause lockups, although I don't see why this would be new<br />behaviour: that would have been a lock-up problem since fairly long ago. <br /><br />This is fairly easy to check on: you can make "__sti" check that we don't<br />have the global IRQ-lock enabled by doing something like<br /><br />        #define GETEIP() ({ unsigned long eip; \<br />                asm volatile("movl $1f,%0\n1:":"=g" (eip)); \<br />                eip; })<br /><br />        #define __sti() do { \<br />                if (global_irq_holder == smp_processor_id()) \<br />                        printk("__sti at %08lx\n", GETEIP()); \<br />                asm volatile("sti": : :"memory"); \<br />        } while (0)<br /><br />which should catch any cases where we illegally enable interrupts while<br />still holding the interrupt lock. <br /><br />  [ And on to other things ]<br /><br />Ingo: wrt the new locking code.. If you (or somebody else) can shoot any<br />holes in this, holler.<br /><br />[ Btw, I added code to the big kernel lock that checks that the lock is<br />  always aquired with interrupts enabled (locally or globally). I've run a<br />  kernel that would panic if interrupts were ever disabled upon trying to<br />  access the global kernel lock, and it's been up so far, under both heavy<br />  load and me trying to find some other way to crash it. My sanity tests<br />  have not found a single place where we try to aquire the lock in an<br />  interrupt context (irq or bh) or with interrupts disabled, so everything<br />  looks fine and checks out so far. ]<br /><br />The other new thing with the new kernel lock code is that the "lock_depth" <br />variable is no longer accessed atomically. The old code used to do atomic<br />increment and decrement operations, but as the lock_depth is entirely<br />local to one specific thread, it is never accessed from multiple CPU's at<br />the same time, and the only way the process can move from one CPU to<br />another is by doing a context switch (two of them, in fact), and the<br />context switch will force a synchronization point through using the<br />spinlocks. As such, doing an atomic access looked like a waste of time to<br />me.. <br /><br />So as far as I can tell, the new code is not only a lot simpler and more<br />elegant, it's also "obviously correct". But if you see hangs with 2.1.112<br />that you didn't see earlier, it's still one of the few things that<br />changed, so I'd appreciate another pair of eyes looking at the "obviously<br />correct" code ;) <br /><br />		Linus<br /><br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.rutgers.edu<br />Please read the FAQ at <a href="http://www.altern.org/andrebalsa/doc/lkml-faq.html">http://www.altern.org/andrebalsa/doc/lkml-faq.html</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
