    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/9/21/1969">First message in thread</a></li><li><a href="/lkml/2020/9/28/811">Linus Torvalds</a><ul><li><a href="/lkml/2020/9/28/920">Peter Xu</a><ul><li class="origin"><a href="/lkml/2020/9/28/1033">Linus Torvalds</a><ul><li><a href="/lkml/2020/9/28/1033">Jason Gunthorpe</a><ul><li><a href="/lkml/2020/9/28/1073">Linus Torvalds</a></li><li><a href="/lkml/2020/9/28/1092">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 28 Sep 2020 10:54:28 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 1/5] mm: Introduce mm_struct.has_pinned</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Sep 28, 2020 at 10:23 AM Peter Xu &lt;peterx&#64;redhat.com&gt; wrote:<br />&gt;<br />&gt; Yes...  Actually I am also thinking about the complete solution to cover<br />&gt; read-only fast-gups too, but now I start to doubt this, at least for the fork()<br />&gt; path.  E.g. if we'd finally like to use pte_protnone() to replace the current<br />&gt; pte_wrprotect(), we'll be able to also block the read gups, but we'll suffer<br />&gt; the same degradation on normal fork()s, or even more.  Seems unacceptable.<br /><br />So I think the real question about pinned read gups is what semantics<br />they should have.<br /><br />Because honestly, I think we have two options:<br /><br /> - the current "it gets a shared copy from the page tables"<br /><br /> - the "this is an exclusive pin, and it _will_ follow the source VM<br />changes, and never break"<br /><br />because honestly, if we get a shared copy at the time of the pinning<br />(like we do now), then "fork()" is entirely immaterial. The fork() can<br />have happened ages ago, that page is shared with other processes, and<br />anybody process writing to it - including very much the pinning one -<br />will cause a copy-on-write and get a copy of the page.<br /><br />IOW, the current - and past - semantics for read pinning is that you<br />get a copy of the page, but any changes made by the pinning process<br />may OR MAY NOT show up in your pinned copy.<br /><br />Again: doing a concurrent fork() is entirely immaterial, because the<br />page can have been made a read-only COW page by _previous_ fork()<br />calls (or KSM logic or whatever).<br /><br />In other words: read pinning gets a page efficiently, but there is<br />zero guarantee of any future coherence with the process doing<br />subsequent writes.<br /><br />That has always been the semantics, and FOLL_PIN didn't change that at<br />all. You may have had things that worked almost by accident (ie you<br />had made the page private by writing to it after the fork, so the read<br />pinning _effectively_ gave you a page that was coherent), but even<br />that was always accidental rather than anything else. Afaik it could<br />easily be broken by KSM, for example.<br /><br />In other words, a read pin isn't really any different from a read GUP.<br />You get a reference to a page that is valid at the time of the page<br />lookup, and absolutely nothing more.<br /><br />Now, the alternative is to make a read pin have the same guarantees as<br />a write pin, and say "this will stay attached to this MM until unmap<br />or unpin".<br /><br />But honestly, that is largely going to _be_ the same as a write pin,<br />because it absolutely needs to do a page COW at the time of the<br />pinning to get that initial exclusive guarantee in the first place.<br />Without that initial exclusivity, you cannot avoid future COW events<br />breaking the wrong way.<br /><br />So I think the "you get a reference to the page at the time of the<br />pin, and the page _may_ or may not change under you if the original<br />process writes to it" are really the only relevant semantics. Because<br />if you need those exclusive semantics, you might as well just use a<br />write pin.<br /><br />The downside of a write pin is that it not only makes that page<br />exclusive, it also (a) marks it dirty and (b) requires write access.<br />That can matter particularly for shared mappings. So if you know<br />you're doing the pin on a shared mmap, then a read pin is the right<br />thing, because the page will stay around - not because of the VM it<br />happens in, but because of the underlying file mapping!<br /><br />See the difference?<br /><br />&gt; The other question is, whether we should emphasize and document somewhere that<br />&gt; MADV_DONTFORK is still (and should always be) the preferred way, because<br />&gt; changes like this series can potentially encourage the other way.<br /><br />I really suspect that the concurrent fork() case is fundamentally hard<br />to handle.<br /><br />Is it impossible? No. Even without any real locking, we could change<br />the code to do a seqcount_t, for example. The fastgup code wouldn't<br />take a lock, but it would just fail and fall back to the slow code if<br />the sequence count fails.<br /><br />So the copy_page_range() code would do a write count around the copy:<br /><br />    write_seqcount_begin(&amp;mm-&gt;seq);<br />    .. do the copy ..<br />    write_seqcount_end(&amp;mm-&gt;seq);<br /><br />and the fast-gup code would do a<br /><br />    seq = raw_read_seqcount(&amp;mm-&gt;seq);<br />    if (seq &amp; 1)<br />        return -EAGAIN;<br /><br />at the top, and do a<br /><br />    if (__read_seqcount_t_retry(&amp;mm-&gt;seq, seq) {<br />       .. Uhhuh, that failed, drop the ref to the page again ..<br />        return -EAGAIN;<br />    }<br /><br />after getting the pin reference.<br /><br />We could make this conditional on FOLL_PIN, or maybe even a new flag<br />("FOLL_FORK_CONSISTENT").<br /><br />So I think we can serialize with fork() without serializing each and every PTE.<br /><br />If we want to and really need to.<br /><br />Hmm?<br /><br />               Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
