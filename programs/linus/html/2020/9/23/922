    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/9/12/316">First message in thread</a></li><li><a href="/lkml/2020/9/22/810">Gerald Schaefer</a><ul><li><a href="/lkml/2020/9/23/414">Gerald Schaefer</a><ul><li class="origin"><a href="/lkml/2020/9/23/1028">Linus Torvalds</a><ul><li><a href="/lkml/2020/9/23/1028">Gerald Schaefer</a><ul><li><a href="/lkml/2020/9/23/1037">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2020/9/23/1217">Qian Cai</a><ul><li><a href="/lkml/2020/9/24/785">Alex Shi</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 23 Sep 2020 13:00:45 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: BUG: Bad page state in process dirtyc0w_child</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Sep 23, 2020 at 6:39 AM Gerald Schaefer<br />&lt;gerald.schaefer&#64;linux.ibm.com&gt; wrote:<br />&gt;<br />&gt; OK, I can now reproduce this, and unfortunately also with the gup_fast<br />&gt; fix, so it is something different. Bisecting is a bit hard, as it will<br />&gt; not always show immediately, sometimes takes up to an hour.<br />&gt;<br />&gt; Still, I think I found the culprit, merge commit b25d1dc9474e "Merge<br />&gt; branch 'simplify-do_wp_page'". Without those 4 patches, it works fine,<br />&gt; running over night.<br /><br />Odd, but I have a strong suspicion that the "do_wp_page()<br />simplification" only ends up removing serialization that then hides<br />some existing thing.<br /><br />&gt; Not sure why this only shows on s390, should not be architecture-specific,<br />&gt; but we do often see subtle races earlier than others due to hypervisor<br />&gt; impact.<br /><br />Yeah, so if it needs very particular timing, maybe the s390 page table<br />handling together with the hypervisor interfaces ends up being more<br />likely to trigger this, and thus the different timings at do_wp_page()<br />then ends up showing it.<br /><br />&gt; One thing that seems strange to me is that the page flags from the<br />&gt; bad page state output are (uptodate|swapbacked), see below, or<br />&gt; (referenced|uptodate|dirty|swapbacked) in the original report. But IIUC,<br />&gt; that should not qualify for the "PAGE_FLAGS_CHECK_AT_FREE flag(s) set"<br />&gt; reason. So it seems that the flags have changed between check_free_page()<br />&gt; and __dump_page(), which would be very odd. Or maybe some issue with<br />&gt; compound pages, because __dump_page() looks at head-&gt;flags.<br /><br />The odd thing is that all of this _should_ be serialized by the page<br />table lock, as far as I can tell.<br /><br />From your trace, it looks very much like it's do_madvise() -&gt;<br />zap_pte_range() (your stack trace only has zap_p4d_range mentioned,<br />but all the lower levels are inlined) that races with presumably<br />fast-gup.<br /><br />But zap_pte_range() has the pte lock, and fast-gup is - by design -<br />not allowed to change the page state other than taking a reference to<br />it, and should do that with a "try_get" operation, so even taking the<br />reference should never ever race with somebody doing the final free.<br /><br />IOW, the fast-GUP code does that<br /><br />                page = pte_page(pte);<br /><br />                head = try_grab_compound_head(page, 1, flags);<br />                if (!head)<br />                        goto pte_unmap;<br /><br />                if (unlikely(pte_val(pte) != pte_val(*ptep))) {<br />                        put_compound_head(head, 1, flags);<br />                        goto pte_unmap;<br />                }<br /><br />where the important part is that "try_grab_compound_head()" which does<br />the whole careful atomic "increase page count only if it wasn't zero".<br />See page_cache_add_speculative().<br /><br />So the rule is<br /><br /> - if you hold the page table lock, you can just do<br />"get_page(pte_page())" directly, because you know the pte cannot go<br />away from under you<br /><br /> - if you are fast-gup, the pte *can* go away from under you, so you<br />need to do that very careful "get page unless it's gone" dance<br /><br />but I don't see us violating that.<br /><br />There's maybe some interesting memory ordering in the above case, but<br />it does atomic_add_unless() which is ordered, and s390 is strongly<br />ordered anyway, isn't it?<br /><br />(Yes, and it doesn't do the atomic stuff at all if TINY_RCU is set,<br />but that's only set for non-preemptible UP kernels, so that doesn't<br />matter).<br /><br />So if zap_page_range() races with fast-gup, then either<br />zap_page_range() wins the race and puts the page - but then fast-gup<br />won't touch it, or fast-gup wins and gets a reference to the page, and<br />then zap_page_range() will clear it and drop the ref to it, but it<br />won't be the final ref.<br /><br />Your dump seems to show that zap_page_range() *did* drop the final<br />ref, but something is racing with it to the point of actually<br />modifying the page flags.<br /><br />Odd.<br /><br />And the do_wp_page() change itself shouldn't be directly involved,<br />because that's all done under the page table lock. But it obviously<br />does change the page locking a lot, and changes timing a lot.<br /><br />And in fact, the zap_pte_range() code itself doesn't take the page<br />lock (and cannot, because it's all under the page table spinlock).<br /><br />So it does smell like timing to me. But possibly with some<br />s390-specific twist to it.<br /><br />Ooh. One thing that is *very* different about s390 is that it frees<br />the page directly, and doesn't batch things up to happen after the TLB<br />flush.<br /><br />Maybe THAT is the difference? Not that I can tell why it should<br />matter, for all the reasons outlines above. But on x86-64, the<br />__tlb_remove_page() function just adds the page to the "free this<br />later" TLB flush structure, and if it fills up it does the TLB flush<br />and then does the actual batched page freeing outside the page table<br />lock.<br /><br />And that *has* been one of the things that the fast-gup code depended<br />on. We even have a big comment about it:<br /><br />        /*<br />         * Disable interrupts. The nested form is used, in order to allow<br />         * full, general purpose use of this routine.<br />         *<br />         * With interrupts disabled, we block page table pages from being<br />         * freed from under us. See struct mmu_table_batch comments in<br />         * include/asm-generic/tlb.h for more details.<br />         *<br />         * We do not adopt an rcu_read_lock(.) here as we also want to<br />         * block IPIs that come from THPs splitting.<br />         */<br /><br />and maybe that whole thing doesn't hold true for s390 at all.<br /><br />            Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
