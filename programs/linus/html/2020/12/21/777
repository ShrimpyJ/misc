    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/12/18/753">First message in thread</a></li><li><a href="/lkml/2020/12/21/660">Linus Torvalds</a><ul><li><a href="/lkml/2020/12/21/756">Andy Lutomirski</a><ul><li class="origin"><a href="/lkml/2020/12/22/608">Linus Torvalds</a><ul><li><a href="/lkml/2020/12/22/608">Andy Lutomirski</a></li><li><a href="/lkml/2021/1/5/632">Peter Zijlstra</a><ul><li><a href="/lkml/2021/1/5/769">Andrea Arcangeli</a></li><li><a href="/lkml/2021/1/12/427">Vinayak Menon</a></li></ul></li></ul></li><li><a href="/lkml/2020/12/22/163">Nadav Amit</a></li><li><a href="/lkml/2020/12/22/586">Andrea Arcangeli</a><ul><li><a href="/lkml/2020/12/22/605">Matthew Wilcox</a><ul><li><a href="/lkml/2020/12/22/611">Andrea Arcangeli</a></li></ul></li><li><a href="/lkml/2020/12/22/640">Yu Zhao</a><ul><li><a href="/lkml/2020/12/22/656">Andrea Arcangeli</a></li></ul></li><li><a href="/lkml/2020/12/22/641">Nadav Amit</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 21 Dec 2020 20:16:11 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] mm/userfaultfd: fix memory corruption due to writeprotect</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Dec 21, 2020 at 7:19 PM Andy Lutomirski &lt;luto&#64;kernel.org&gt; wrote:<br />&gt;<br />&gt; Ugh, this is unpleasantly complicated.<br /><br />I probably should have phrased it differently, because the case you<br />quote is actually a good one:<br /><br />&gt;  I will admit that any API that<br />&gt; takes an address and more-or-less-blindly marks it RO makes me quite<br />&gt; nervous even assuming all the relevant locks are held.  At least<br />&gt; userfaultfd refuses to operate on VM_SHARED VMAs, but we have another<br />&gt; instance of this (with mmap_sem held for write) in x86:<br />&gt; mark_screen_rdonly().  Dare I ask how broken this is?  We could likely<br />&gt; get away with deleting it entirely.<br /><br />So I think the basic rule is that "if you hold mmap_sem for writing,<br />you're always safe". And that really should be considered the<br />"default" locking.<br /><br />ANY time you make a modification to the VM layer, you should basically<br />always treat it as a write operation, and get the mmap_sem for<br />writing.<br /><br />Yeah, yeah, that's a bit simplified, and it ignores various special<br />cases (and the hardware page table walkers that obviously take no<br />locks at all), but if you hold the mmap_sem for writing you won't<br />really race with anything else - not page faults, and not other<br />"modify this VM".<br /><br />So mark_screen_rdonly() looks trivially fine to me. I don't think it<br />really necessarily matters any more, and it's a legacy thing for a<br />legacy hardware issue, but I don't think there's any reason at all to<br />remove it either.<br /><br />To a first approximation, everybody that changes the VM should take<br />the mmap_sem for writing, and the readers should just be just about<br />page fault handling (and I count GUP as "page fault handling" too -<br />it's kind of the same "look up page" rather than "modify vm" kind of<br />operation).<br /><br />And there are just a _lot_ more page faults than there are things that<br />modify the page tables and the vma's.<br /><br />So having that mental model of "lookup of pages in a VM take mmap_semn<br />for reading, any modification of the VM uses it for writing" makes<br />sense both from a performance angle and a logical standpoint. It's the<br />correct model.<br /><br />And it's worth noting that COW is still "lookup of pages", even though<br />it might modify the page tables in the process. The same way lookup<br />can modify the page tables to mark things accessed or dirty.<br /><br />So COW is still a lookup operation, in ways that "change the<br />writabiility of this range" very much is not. COW is "lookup for<br />write", and the magic we do to copy to make that write valid is still<br />all about the lookup of the page.<br /><br />Which brings up another mental mistake I saw earlier in this thread:<br />you should not think "mmap_sem is for vma, and the page table lock is<br />for the page table changes".<br /><br />mmap_sem is the primary lock for any modifications to the VM layout,<br />whether it be in the vma's or in the page tables.<br /><br />Now, the page table lock does exist _in_addition_to_ the mmap_sem, but<br />it is partly because<br /><br /> (a) we have things that historically walked the page tables _without_<br />walking the vma's (notably the virtual memory scanning)<br /><br /> (b) we do allow concurrent page faults, so we then need a lower-level<br />lock to serialize the parallelism we _do_ have.<br /><br />And yes, we have ended up allowing some of those "modify the VM state"<br />to then take the mmap_sem for reading, just because their<br />modifications are slight enough that we can then say "ok, this is a<br />write modification, but the writes it does are protected by the page<br />table lock, we'll just get the mmap_sem for reading". It's an<br />optimization, but it should be considered exactly that: not<br />fundamental, but just a clever trick and an optimization.<br /><br />It's why I went "userfaultfd is buggy" immediately when I noticed. It<br />basically became clear that "oh, that's an optimization, but it's an<br />*invalid* one", in that it didn't actually work and give the same end<br />result.<br /><br />So when I said:<br /><br />&gt; Anything that changes RW-&gt;RO - like fork(), for example - needs to<br />&gt; take the mmap_lock.<br /><br />I didn't mean that we should consider that RW-&gt;RO change to be this<br />complex semantic marker that we should honor and say "ok, because it's<br />a RW-&gt;RO change, we need to hold the mmap_sem".<br /><br />I phrased it really badly, in other words.<br /><br />What I *should* have said is that *because* userfaultfd is changing<br />the VM layout, it should always act as if it had to take the mmap_sem<br />for writing, and that the RW-&gt;RO change is an example of when<br />downgrading that write-lock to a read lock is simply not valid -<br />because it basically breaks the rules about what a lookup (ie a read)<br />can do.<br /><br />A lookup can never turn a writable page non-writable. A lookup -<br />through COW - _can_ turn a read-only page writable. So that's why<br />"RO-&gt;RW" can be ok under the read lock, but RW-&gt;RO is not.<br /><br />Does that clarify the situation when I phrase it that way instead?<br /><br />             Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
