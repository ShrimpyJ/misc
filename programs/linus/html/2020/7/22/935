    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/7/21/76">First message in thread</a></li><li><a href="/lkml/2020/7/21/76">Michal Hocko</a><ul><li><a href="/lkml/2020/7/21/429">Qian Cai</a><ul><li><a href="/lkml/2020/7/21/456">Michal Hocko</a><ul><li><a href="/lkml/2020/7/21/503">Qian Cai</a><ul><li><a href="/lkml/2020/7/21/545">Michal Hocko</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2020/7/21/655">Chris Down</a><ul><li><a href="/lkml/2020/7/21/733">Michal Hocko</a></li></ul></li><li><a href="/lkml/2020/7/21/778">Linus Torvalds</a><ul><li><a href="/lkml/2020/7/21/797">Michal Hocko</a></li><li class="origin"><a href="/lkml/2020/7/22/1085">Linus Torvalds</a><ul><li><a href="/lkml/2020/7/22/1085">Hugh Dickins</a><ul><li><a href="/lkml/2020/7/22/1112">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2020/7/23/176">Michal Hocko</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 22 Jul 2020 11:29:20 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC PATCH] mm: silence soft lockups from unlock_page</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Jul 21, 2020 at 8:33 AM Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; More likely, it's actually *caused* by that commit 11a19c7b099f, and<br />&gt; what might be happening is that other CPU's are just adding new<br />&gt; waiters to the list *while* we're waking things up, because somebody<br />&gt; else already got the page lock again.<br />&gt;<br />&gt; Humor me.. Does something like this work instead?<br /><br />I went back and looked at this, because it bothered me.<br /><br />And I'm no longer convinced it can possibly make a difference.<br /><br />Why?<br /><br />Because __wake_up_locked_key_bookmark() just calls __wake_up_common(),<br />and that one checks the return value of the wakeup function:<br /><br />                ret = curr-&gt;func(curr, mode, wake_flags, key);<br />                if (ret &lt; 0)<br />                        break;<br /><br />and will not add the bookmark back to the list if this triggers.<br /><br />And the wakeup function does that same "stop walking" thing:<br /><br />        if (test_bit(key-&gt;bit_nr, &amp;key-&gt;page-&gt;flags))<br />                return -1;<br /><br />So if somebody else took the page lock, I think we should already have<br />stopped walking the list.<br /><br />Of course, the page table lock hash table is very small. It's only 256<br />entries. So maybe the list is basically all aliases for another page<br />entirely that is being hammered by that load, and we're just unlucky.<br /><br />Because the wakeup function only does that "stop walking" if the page<br />key matched. So wait queue entries for another page that just hashes<br />to the same bucket (or even the same page, but a different bit in the<br />page) will confuse that logic.<br /><br />Hmm.<br /><br />I still can't see how you'd get so many entries (without re-adding<br />them) that you'd hit the softlockup timer.<br /><br />So I wonder if maybe we really do hit the "aliasing with a really hot<br />page that gets re-added in the page wait table" case, but it seems a<br />bit contrived.<br /><br />So I think that patch is still worth testing, but I'm not quite as<br />hopeful about it as I was originally.<br /><br />I do wonder if we should make that PAGE_WAIT_TABLE_SIZE be larger. 256<br />entries seems potentially ridiculously small, and aliasing not only<br />increases the waitqueue length, it also potentially causes more<br />contention on the waitqueue spinlock (which is already likely seeing<br />some false sharing on a cacheline basis due to the fairly dense array<br />of waitqueue entries: wait_queue_head is intentionally fairly small<br />and dense unless you have lots of spinlock debugging options enabled).<br /><br />That hashed wait-queue size is an independent issue, though. But it<br />might be part of "some loads can get into some really nasty behavior<br />in corner cases"<br /><br />               Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
