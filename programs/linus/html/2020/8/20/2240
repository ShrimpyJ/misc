    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/8/17/2466">First message in thread</a></li><li><a href="/lkml/2020/8/20/1816">Rasmus Villemoes</a><ul><li><a href="/lkml/2020/8/20/2030">Arvind Sankar</a><ul><li><a href="/lkml/2020/8/20/2040">=?utf-8?Q?D=C3=A1vid_Bolvansk=C3=BD?=</a></li><li class="origin"><a href="/lkml/2020/8/21/1191">Linus Torvalds</a><ul><li><a href="/lkml/2020/8/21/1191">Arvind Sankar</a><ul><li><a href="/lkml/2020/8/21/1215">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2020/8/21/110">Rasmus Villemoes</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 20 Aug 2020 16:33:03 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 0/4] -ffreestanding/-fno-builtin-* patches</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Thu, Aug 20, 2020 at 10:56 AM Arvind Sankar &lt;nivedita&#64;alum.mit.edu&gt; wrote:<br />&gt;<br />&gt; Clang's interpretation is more useful for embedded, since you can use<br />&gt; -fno-builtin-foo and avoid calling __builtin_foo directly, and be<br />&gt; guaranteed that there will be no calls to foo that you didn't write<br />&gt; explicitly (outside of memcpy/memset/memcmp). In this case you are free<br />&gt; to implement foo with non-standard semantics, or avoid implementing it<br />&gt; altogether, and be reasonably confident that it will all work.<br /><br />Honestly, I think concentrating on whether __builtin_foo() works or<br />not misses the point entirely.<br /><br />That has never _ever_ been a problem for us, and I doubt it has been a<br />problem for anybody else either.<br /><br />If you use __builtin_memcpy() in your source tree, then why would you<br />possibly ever want to disable it? And if you _don't_ use it, then<br />again - why would you ever want to disable it?<br /><br />No, the real (and only) problem has always been about the compilers<br />magically and silently "recognizing" certain source patterns, and<br />turning them into function calls behind the users back.<br /><br />And that has nothing to do with __builtin_foo(). At least it<br />_shouldn't_ have anything to do with it.<br /><br />So this is things like the compiler silently seeing "oh, you called<br />your function 'free()', so we know that the stores you did to it are<br />dead and we'll remove them".<br /><br />Or this is the compiler doing "Oh, you did four stores of zero in a<br />row, and and you asked for size optimizations, so we'll turn those<br />into a 'bzero()' call".<br /><br />Or the compiler doing completely broken things, and turning a<br />"!memcmp()" expression into a "!bcmp()" because the compilier<br />incorrectly assumes it's faster.<br /><br />Notice? Not a single one of those had any __builtin_xyz() pattern in<br />them. Quite the reverse. The compiler took something completely<br />different, and assumed builtin semantics without us having told it to.<br /><br />So I think "-fno-builtin-xyz" is barking *completely* up the wrong<br />tree. It's missing the problem. The problem is not "I have some<br />builtin patterns, here, you can use them".<br /><br />It's the same as all the vector intrinsics. Those don't hurt anybody -<br />as long as they only get used when people use the intrinsics. If the<br />compiler starts to suddenly use vector intrinsics without being told<br />to, *THAT* can be a problem. But there is never any reson to turn off<br />any particular intrinsic otherwise.<br /><br />If you don't want it used, don't use it. And if you do use it, the<br />compiler generates the vector code sequence. It's that simple.<br /><br />So to me, a compiler flag like "-fno-builtin-memcpy" is completely<br />insane. The flag adds absolutely no value.<br /><br />The real value would be "-fno-magic-bcmp" which turns off stupid<br />optimizations that magically turn non-bcmp things into bcmp. But it<br />should not turn off *actual* __builtin_bcmp() if such a thing exists<br />and people want to explicitly use it.<br /><br />             Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
