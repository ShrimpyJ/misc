    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/8/26/1445">First message in thread</a></li><li><a href="/lkml/2020/11/24/1282">Hugh Dickins</a><ul><li><a href="/lkml/2020/11/24/1336">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2020/11/25/975">Linus Torvalds</a><ul><li><a href="/lkml/2020/11/25/975">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 25 Nov 2020 13:30:20 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: kernel BUG at fs/ext4/inode.c:LINE!</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Nov 24, 2020 at 3:24 PM Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; I've applied your second patch (the smaller one that just takes a ref<br />&gt; around the critical section). If somebody comes up with some great<br />&gt; alternative, we can always revisit this.<br /><br />Hmm.<br /><br />I'm not sure about "great alternative", but it strikes me that we<br />*could* move the clearing of the PG_writeback bit _into_<br />wake_up_page_bit(), under the page waitqueue lock.<br /><br />IOW, we could make the rule be that the bit isn't actually cleared<br />before calling wake_up_page() at all, and we'd clear it with something<br />like<br /><br />    unsigned long flags = READ_ONCE(page-&gt;flags);<br /><br />    // We can clear PG_writeback directly if PG_waiters isn't set<br />    while (!(flags &amp; (1ul &lt;&lt; PG_waiters))) {<br />        unsigned long new = flags &amp; ~(1ul &lt;&lt; PG_writeback);<br />        // PG_writeback was already clear??!!?<br />        if (WARN_ON_ONCE(new == flags))<br />            return;<br />        new = cmpxchg(&amp;page-&gt;flags, flags, new);<br />        if (likely(flags == new))<br />            return;<br />        flags = new;<br />    }<br /><br />    // Otherwise, clear the bit at the end - but under the<br />    // page waitqueue lock - inside wake_up_page_bit()<br />    return wake_up_page_bit(..);<br /><br />instead.<br /><br />That would basically make the bit clearing atomic wrt the PG_waiters<br />flags - either using that atomic cmpxchg, or by doing it under the<br />page queue lock so that it's atomic wrt any new waiters.<br /><br />This seems conceptually like the right thing to do - and if would also<br />make the (fair) exclusive lock hand-off case atomic too, because the<br />bit we're waking up on would never be cleared if it gets handed off<br />directly.<br /><br />The above is entirely untested crap written in my MUA, and obviously<br />requires that all callers of wake_up_page() be moved to that new world<br />order, but I think we only have two cases: unlock_page() and<br />end_page_writeback().<br /><br />And unlock_page() already has that<br />"clear_bit_unlock_is_negative_byte()" special case that is an ugly<br />special case of PG_waiters atomicity. So we'd get rid of that, because<br />the cmpxchg loop would be the better model.<br /><br />I'm not sure I'm willing to write and test the real patch, but it<br />doesn't look _too_ nasty from just looking at the code. The bookmark<br />thing makes it important to only actually clear the bit at the end (as<br />does the handoff case anyway), but the way wake_up_page_bit() is<br />written, that's actually very straightforward - just after the<br />while-loop. That's when we've woken up everybody.<br /><br />So I'm sending this idea out to see if somebody can shoot it down, or<br />even wants to possibly even try to do it..<br /><br />                Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
