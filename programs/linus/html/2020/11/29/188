    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/11/29/85">First message in thread</a></li><li><a href="/lkml/2020/11/29/85">Thomas Gleixner</a><ul><li><a href="/lkml/2020/11/29/86">Thomas Gleixner</a><ul><li class="origin"><a href="/lkml/2020/11/29/240">Linus Torvalds</a><ul><li><a href="/lkml/2020/11/29/240">"Paul E. McKenney"</a></li><li><a href="/lkml/2020/11/30/77">Peter Zijlstra</a><ul><li><a href="/lkml/2020/11/30/90">Sven Schnelle</a></li><li><a href="/lkml/2020/11/30/116">Peter Zijlstra</a></li><li><a href="/lkml/2020/11/30/920">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2020/11/29/201">   pr-tracker-bot&#64;kernel ...</a></li></ul></li><li><a href="/lkml/2020/11/29/202">   pr-tracker-bot&#64;kernel ...</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 29 Nov 2020 11:31:41 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [GIT pull] locking/urgent for v5.10-rc6</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Nov 29, 2020 at 5:38 AM Thomas Gleixner &lt;tglx&#64;linutronix.de&gt; wrote:<br />&gt;<br />&gt; Yet two more places which invoke tracing from RCU disabled regions in the<br />&gt; idle path. Similar to the entry path the low level idle functions have to<br />&gt; be non-instrumentable.<br /><br />This really seems less than optimal.<br /><br />In particular, lookie here:<br /><br />&gt; &#64;&#64; -94,9 +94,35 &#64;&#64; void __cpuidle default_idle_call(void)<br />&gt;<br />&gt;                 trace_cpu_idle(1, smp_processor_id());<br />&gt;                 stop_critical_timings();<br />&gt; +<br />&gt; +               /*<br />&gt; +                * arch_cpu_idle() is supposed to enable IRQs, however<br />&gt; +                * we can't do that because of RCU and tracing.<br />&gt; +                *<br />&gt; +                * Trace IRQs enable here, then switch off RCU, and have<br />&gt; +                * arch_cpu_idle() use raw_local_irq_enable(). Note that<br />&gt; +                * rcu_idle_enter() relies on lockdep IRQ state, so switch that<br />&gt; +                * last -- this is very similar to the entry code.<br />&gt; +                */<br />&gt; +               trace_hardirqs_on_prepare();<br />&gt; +               lockdep_hardirqs_on_prepare(_THIS_IP_);<br />&gt;                 rcu_idle_enter();<br />&gt; +               lockdep_hardirqs_on(_THIS_IP_);<br />&gt; +<br />&gt;                 arch_cpu_idle();<br />&gt; +<br />&gt; +               /*<br />&gt; +                * OK, so IRQs are enabled here, but RCU needs them disabled to<br />&gt; +                * turn itself back on.. funny thing is that disabling IRQs<br />&gt; +                * will cause tracing, which needs RCU. Jump through hoops to<br />&gt; +                * make it 'work'.<br />&gt; +                */<br />&gt; +               raw_local_irq_disable();<br />&gt; +               lockdep_hardirqs_off(_THIS_IP_);<br />&gt;                 rcu_idle_exit();<br />&gt; +               lockdep_hardirqs_on(_THIS_IP_);<br />&gt; +               raw_local_irq_enable();<br />&gt; +<br />&gt;                 start_critical_timings();<br />&gt;                 trace_cpu_idle(PWR_EVENT_EXIT, smp_processor_id());<br />&gt;         }<br /><br />And look at what the code generation for the idle exit path is when<br />lockdep isn't even on.<br /><br />It's *literally*<br /><br />        cli<br />        call rcu_idle_exit<br />        sti<br /><br />and guess what rcu_idle_exit does?<br /><br />Yeah, that one does "pushf; cli; call rcu_eqs_exit; popf".<br /><br />So here we are, in the somewhat critical "an interrupt woke us up"<br />section, and we're doing just ridiculously stupid things.<br /><br />I've pulled this, because it solves a problem, but there's a deeper<br />problem here in how all this is done.<br /><br />The idle path is actually quite important. I can point to real loads<br />where this is a big part of the CPU profile, because you end up having<br />lots of "go to sleep for very short times, because the thing we were<br />waiting for takes almost no time at all".<br /><br />                 Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
