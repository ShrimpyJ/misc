    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/11/11/1308">First message in thread</a></li><li><a href="/lkml/2020/11/13/903">Linus Torvalds</a><ul><li><a href="/lkml/2020/11/13/961">Alexei Starovoitov</a><ul><li><a href="/lkml/2020/11/13/972">Linus Torvalds</a></li><li><a href="/lkml/2020/11/13/995">Linus Torvalds</a></li><li class="origin"><a href="/lkml/2020/11/13/1059">Linus Torvalds</a><ul><li><a href="/lkml/2020/11/13/1059">Alexei Starovoitov</a><ul><li><a href="/lkml/2020/11/13/1073">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 13 Nov 2020 12:10:57 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH bpf v5 1/2] lib/strncpy_from_user.c: Don't overcopy bytes after NUL terminator</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Nov 13, 2020 at 11:17 AM Alexei Starovoitov<br />&lt;alexei.starovoitov&#64;gmail.com&gt; wrote:<br />&gt;<br />&gt; The v4 approach preserves performance. It wasn't switching to byte_at_a_time:<br /><br />That v4 looks better, but still pointless.<br /><br />But it might be acceptable, with that final<br /><br />        *out = (*out &amp; ~mask) | (c &amp; mask);<br /><br />just replaced with<br /><br />        *out = c &amp; mask;<br /><br />which still writes past the end, but now it only writes zeroes.<br /><br />But the only reason for that to be done is if you have exposed the<br />destination buffer to another thread before (and you zeroed it before<br />exposing it), and you want to make sure that any concurrent reader can<br />never see anything past the end of the string.<br /><br />Again - the *only* case that could possibly matter is when you<br />pre-zeroed the buffer, because if you didn't, then a concurrent reader<br />would see random garbage *anyway*, particularly since there is no SMP<br />memory ordering imposed with the strncpy. So nothing but "pre-zeroed"<br />makes any possible sense, which means that the whole "(*out &amp; ~mask)"<br />in that v4 patch is completely and utterly meaningless. There's<br />absolutely zero reason to try to preserve any old data.<br /><br />In other words, you have two cases:<br /><br /> (a) no threaded and unlocked accesses to the resulting string<br /><br /> (b) you _do_ have concurrent threaded accesses to the string and no<br />locking (really? That's seriously questionable),<br /><br />If you have case (a), then the only correct thing to do is to<br />explicitly pad afterwards. It's optimal, and doesn't make any<br />assumptions about implementation of strncpy_from_user().<br /><br />If you really have that case (b), and you absolutely require that the<br />filling be done without exposing any temporary garbage, and thus the<br />"pad afterwards" doesn't work, then you are doing something seriously<br />odd.<br /><br />But in that seriously odd (b) case, the _only_ possibly valid thing<br />you can do is to pre-zero the buffer, since strncpy_from_user()<br />doesn't even imply any memory ordering in its accesses, so any<br />concurrent reader by definition will see a randomly ordered partial<br />string being copied. That strikes me as completely insane, but at<br />least a careful reader could see a valid partial string being possibly<br />in the process of being built up. But again, that use-case is only<br />possible if the buffer is pre-zeroed, so doing that "(*out &amp; ~mask)"<br />cannot be relevant or sane.<br /><br />If you really do have that (b) case, then I'd accept that modified v4<br />patch, together with an absolutely *huge* comment both in<br />strncpy_from_user() and very much at the call-site, talking about that<br />non-locked concurrent access to the destination buffer.<br /><br />            Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
