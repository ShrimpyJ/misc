    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/11/16/1404">First message in thread</a></li><li><a href="/lkml/2020/11/16/1404">Daniel Xu</a><ul><li><a href="/lkml/2020/11/16/1403">Daniel Xu</a><ul><li class="origin"><a href="/lkml/2020/11/16/1454">Linus Torvalds</a><ul><li><a href="/lkml/2020/11/16/1454">Linus Torvalds</a><ul><li><a href="/lkml/2020/11/17/1777">Ivan Kokshaysky</a></li></ul></li><li><a href="/lkml/2020/11/16/1801">Daniel Xu</a></li></ul></li></ul></li><li><a href="/lkml/2020/11/16/1405">Daniel Xu</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 16 Nov 2020 14:15:52 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH bpf v6 1/2] lib/strncpy_from_user.c: Don't overcopy bytes after NUL terminator</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Nov 16, 2020 at 1:17 PM Daniel Xu &lt;dxu&#64;dxuuu.xyz&gt; wrote:<br />&gt;<br />&gt; Based on on-list discussion and some off-list discussion with Alexei,<br />&gt; I'd like to propose the v4-style patch without the `(*out &amp; ~mask)`<br />&gt; bit.<br /><br />So I've verified that at least on x86-64, this doesn't really make<br />code generation any worse, and I'm ok with the patch from that<br />standpoint.<br /><br />However, this was not what the discussion actually amended at as far<br />as I'm concerned.<br /><br />I mentioned that if BPF cares about the bytes past the end of the<br />string, I want a *BIG COMMENT* about it. Yes, in strncpy_from_user()<br />itself, but even more in the place that cares.<br /><br />And no, that does not mean bpf_probe_read_user_str().  That function<br />clearly doesn't care at all, and doesn't access anything past the end<br />of the string. I want a comment in whatever code that accesses past<br />the end of the string.<br /><br />And your ABI point is actively misleading:<br /><br />&gt; We can't really zero out the rest of the buffer due to ABI issues.<br />&gt; The bpf docs state for bpf_probe_read_user_str():<br />&gt;<br />&gt; &gt; In case the string length is smaller than *size*, the target is not<br />&gt; &gt; padded with further NUL bytes.<br /><br />This comment is actively wrong and misleading.<br /><br />The code (after the patch) clearly *does* pad a bit with "further NUL<br />bytes". It's just that it doesn't pad all the way to the end.<br /><br />Where is the actual buffer zeroing done?<br /><br />Because without the buffer zeroing, this whole patch is completely<br />pointless. Which is why I want that comment, and I want a pointer to<br />where that zeroing is done.<br /><br />Really. You have two cases:<br /><br /> (a) the buffer isn't zeroed before the strncpy_from_user()<br /><br /> (b) the buffer is guaranteed to be zero before that<br /><br />and in case (a), this patch is pointless, since the data after the<br />string is already undefined.<br /><br />And in case (b), I want to see a comment and a pointer to the code<br />that actually does the zeroing.<br /><br />HOWEVER. Look at bpf_probe_read_user_str_common(), and notice how it<br />ALREADY does the zeroing of the buffer past the end, it's just that it<br />only does it in the error case.<br /><br />Why do you send this patch, instead of<br /><br /> (a) get rid of the pointless pre-zeroing<br /><br /> (b) change bpf_probe_read_user_str_common() to do<br /><br />        int ret;<br />        u32 offset;<br /><br />        ret = strncpy_from_user_nofault(dst, unsafe_ptr, size);<br />        offset = ret &lt; 0 ? 0 : ret;<br />        memset(dst+offset, 0, size-offset);<br />        return ret;<br /><br />which seems to be much simpler anyway. The comment you quote about<br />"target is not padded with further NUL bytes" is clearly wrong anyway,<br />since that error case *does* pad the target with NUL bytes, and always<br />has.<br /><br />So honestly, in this whole discussion, it seems rather clear to me<br />that the bug has always been in bpf, not in strncpy_from_user(). The<br />ABI comment you quote is clearly not true, and I can point to that<br />existing bpf_probe_read_user_str_common() code itself:<br /><br />        ret = strncpy_from_user_nofault(dst, unsafe_ptr, size);<br />        if (unlikely(ret &lt; 0))<br />                memset(dst, 0, size);<br /><br />as to why that is.<br /><br />But guys, as mentioned, I'm willing to apply this patch, but only if<br />you add some actually *correct* comments about the odd bpf use of this<br />string, and point to where the pre-zeroing is done.<br /><br />               Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
