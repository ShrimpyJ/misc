    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2020/8/26/1445">First message in thread</a></li><li><a href="/lkml/2020/11/24/924">Hugh Dickins</a><ul><li><a href="/lkml/2020/11/24/1084">Matthew Wilcox</a><ul><li class="origin"><a href="/lkml/2020/11/24/1208">Linus Torvalds</a><ul><li><a href="/lkml/2020/11/24/1208">Matthew Wilcox</a><ul><li><a href="/lkml/2020/11/24/1221">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 24 Nov 2020 11:00:42 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: kernel BUG at fs/ext4/inode.c:LINE!</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Nov 24, 2020 at 10:33 AM Matthew Wilcox &lt;willy&#64;infradead.org&gt; wrote:<br />&gt;<br />&gt; We could fix this by turning that 'if' into a 'while' in<br />&gt; write_cache_pages().<br /><br />That might be the simplest patch indeed.<br /><br />At the same time, I do worry about other cases like this: while<br />spurious wakeup events are normal and happen in other places, this is<br />a bit different.<br /><br />This is literally a wakeup that leaks from a previous use of a page,<br />and makes us think that something could have happened to the new use.<br /><br />The unlock_page() case presumably never hits that, because even if we<br />have some unlock without a page ref (which I don't think can happen,<br />but whatever..), the exclusive nature of "lock_page()" means that no<br />locker can care - once you get the lock, you own the page./<br /><br />The writeback code is special in that the writeback bit isn't some<br />kind of exclusive bit, but this code kind of expected it to be that.<br /><br />So I'd _like_ to have something like<br /><br />        WARN_ON_ONCE(!page_count(page));<br /><br />in the wake_up_page_bit() function, to catch things that wake up a<br />page that has already been released and might be reused..<br /><br />And that would require the "get_page()" to be done when we set the<br />writeback bit and queue the page up for IO (so that then<br />end_page_writeback() would clear the bit, do the wakeup, and then drop<br />the ref).<br /><br />Hugh's second patch isn't pretty - I think the "get_page()" is<br />conceptually in the wrong place - but it "works" in that it keeps that<br />"implicit page reference" being kept by the PG_writeback bit, and then<br />it takes an explicit page reference before it clears the bit.<br /><br />So while I don't love the whole "PG_writeback is an implicit reference<br />to the page" model, Hugh's patch at least makes that model much more<br />straightforward: we really either have that PG_writeback, _or_ we have<br />a real ref to the page, and we never have that odd "we could actually<br />lose the page" situation.<br /><br />So I think I prefer Hugh's two-liner over your one-liner suggestion.<br /><br />But your one-liner is technically not just smaller, it obviously also<br />avoids the whole mucking with the atomic page ref.<br /><br />I don't _think_ that the extra get/put overhead could possibly really<br />matter: doing the writeback is going to be a lot more expensive<br />anyway. And an atomic access to a 'struct page' sounds expensive, but<br />that cacheline is already likely dirty in the L1 cache because we've<br />touch page-&gt;flags and done other things to it).<br /><br />So I'd personally be inclined to go with Hugh's patch. Comments?<br /><br />                 Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
