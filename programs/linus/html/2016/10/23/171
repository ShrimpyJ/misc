    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/10/22/130">First message in thread</a></li><li><a href="/lkml/2016/10/22/130">Thomas Gleixner</a><ul><li class="origin"><a href="/lkml/2016/10/23/178">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/23/178">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/24/184">Thomas Gleixner</a><ul><li><a href="/lkml/2016/10/24/424">Thomas Gleixner</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 23 Oct 2016 15:39:50 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [GIT pull] timer updates for 4.9</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sat, Oct 22, 2016 at 5:02 AM, Thomas Gleixner &lt;tglx&#64;linutronix.de&gt; wrote:<br />&gt;<br />&gt; please pull the latest timers-urgent-for-linus git tree from:<br />&gt;<br />&gt;    git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git timers-urgent-for-linus<br /><br />Hmm. I just hit something that looks very much like a timer bug.<br /><br />I'm working on cleaning up the KERN_CONT handling of printk.c, and in<br />the process I'm adding a timer that flushes incomplete lines to the<br />logs. The code is pretty simple, and it basically just does<br /><br />  static void deferred_cont_flush(void)<br />  {<br />        static DEFINE_TIMER(timer, flush_timer, 0, 0);<br /><br />        if (!cont.len)<br />                return;<br />        mod_timer(&amp;timer, jiffies + HZ/10);<br />  }<br /><br />which is then called whenever we have a incomplete line (the<br />"flush_timer()" function will just flush the pending line to the<br />console and to the logs.<br /><br />It worked fine in testing, but at shutdown I just got this:<br /><br />    do_trap: 165 callbacks suppressed<br />    traps: gnome-shell[1339] trap int3 ip:7f465aace15b sp:7fffc54f1670 error:0<br /><br />followed by<br /><br />    general protection fault: 0000 [#1] SMP<br />    Modules linked in: fuse xt_CHECKSUM ipt_MASQUERADE<br />nf_nat_masquerade_ipv4 tun nf_conntrack_netbios_ns<br />nf_conntrack_broadcast ip6t_rpfilter ip6t_REJECT nf_reject_ipv6<br />xt_conntrack ebtable_broute bridge stp llc ebtable_nat ip6tabl$<br />     wmi pinctrl_intel acpi_als kfifo_buf tpm_tis tpm_tis_core<br />industrialio acpi_pad tpm nfsd auth_rpcgss nfs_acl lockd grace sunrpc<br />dm_crypt i915 crct10dif_pclmul crc32_pclmul crc32c_intel i2c_algo_bit<br />drm_kms_helper syscopyarea se$<br />    CPU: 7 PID: 1339 Comm: gnome-shell Tainted: G           O<br />4.9.0-rc1-00244-g0c2b6dc4fd4f-dirty #6<br />    Hardware name: System manufacturer System Product Name/Z170-K,<br />BIOS 1803 05/06/2016<br />    task: ffff95c443bcd940 task.stack: ffffa6ce82d6c000<br />    RIP: 0010:[&lt;ffffffffb10f9df1&gt;]  [&lt;ffffffffb10f9df1&gt;]<br />detach_if_pending+0x41/0xd0<br />    RSP: 0000:ffffa6ce82d6fd08  EFLAGS: 00010086<br />    RAX: dead000000000200 RBX: 0000000100089285 RCX: 0000000000000000<br />    RDX: ffffffffb1c99580 RSI: ffff95c476ccf140 RDI: ffffffffb1c50920<br />    RBP: ffffa6ce82d6fd20 R08: 000000000000004a R09: 0000000000000000<br />    R10: 000000000000000f R11: ffffffffb1f0912c R12: ffffffffb1c50920<br />    R13: 0000000000000000 R14: ffff95c476ccf140 R15: ffffffffb1c50920<br />    FS:  00007f46639adac0(0000) GS:ffff95c476dc0000(0000) knlGS:0000000000000000<br />    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033<br />    CR2: 00007fea54725010 CR3: 0000000410fa3000 CR4: 00000000003406e0<br />    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000<br />    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400<br />    Stack:<br />     0000000100089285 0000000000000052 0000000000000051 ffffa6ce82d6fd90<br />     ffffffffb10fc4e0 ffffffffb1c50948 0000000100089222 00000000cbeae39b<br />     ffffffffb1f0912b 0000000000000246 00000000cbeae39b ffffffffb1a074af<br />    Call Trace:<br />     [&lt;ffffffffb10fc4e0&gt;] mod_timer+0xd0/0x3b0<br />     [&lt;ffffffffb10e6670&gt;] deferred_cont_flush.part.12+0x20/0x30<br />     [&lt;ffffffffb10e7139&gt;] console_unlock+0x489/0x4a0<br />     [&lt;ffffffffb10e092e&gt;] ? down_trylock+0x2e/0x40<br />     [&lt;ffffffffb10e7443&gt;] vprintk_emit+0x2f3/0x480<br />     [&lt;ffffffffb10e77a9&gt;] vprintk_default+0x29/0x40<br />     [&lt;ffffffffb11a1a3b&gt;] printk+0x57/0x73<br />     [&lt;ffffffffb13c7521&gt;] ? ___ratelimit+0x91/0xd0<br />     [&lt;ffffffffb101ed76&gt;] do_trap+0x116/0x140<br />     [&lt;ffffffffb101f2bf&gt;] do_int3+0xdf/0x110<br />     [&lt;ffffffffb17a17cb&gt;] int3+0x5b/0x60<br />    Code: 41 55 41 54 53 48 83 3f 00 0f 84 81 00 00 00 41 89 d5 49 89<br />fc 0f 1f 44 00 00 49 8b 04 24 49 8b 54 24 08 48 85 c0 48 89 02 74 04<br />&lt;48&gt; 89 50 08 45 84 ed 74 09 49 c7 44 24 08 00 00 00 00 48 b8 00<br />    RIP  [&lt;ffffffffb10f9df1&gt;] detach_if_pending+0x41/0xd0<br />     RSP &lt;ffffa6ce82d6fd08&gt;<br />    ---[ end trace e4a7055c685d5e1e ]---<br /><br />(there was another GP fault at the same address immediately<br />afterwards, and then the machine was dead).<br /><br />The code disassembly at the faulting instruction is<br /><br />   0: 48 89 50 08           mov    %rdx,0x8(%rax)<br />   4: 45 84 ed             test   %r13b,%r13b<br />   7: 74 09                 je     0x12<br /><br />and obviously %rax is bogus. In fact, %rax has the value<br />"dead000000000200", which is just LIST_POISON2.<br /><br />Now, normally, I'd just say "my code is obviously buggy crap", and I<br />did spend a bit of time on that theory. But quite frankly, that timer<br />really _is_ local to that one function, and the absolutely only thing<br />that is ever done on that timer is that "mod_timer()" call.<br /><br />So I don't think it's my new code. What triggers this is do_trap() doing two<br /><br />                pr_info("%s[%d] trap %s ip:%lx sp:%lx error:%lx",<br />                        tsk-&gt;comm, tsk-&gt;pid, str,<br />                        regs-&gt;ip, regs-&gt;sp, error_code);<br />                print_vma_addr(" in ", regs-&gt;ip);<br />                pr_cont("\n");<br /><br />which does two printk's without '\n' in close succession, so the first<br />one will turn on the timer, and then the second one will update it<br />again very soon afterwards.<br /><br />So I started looking at mod_timer() and detach_if_pending(), but I<br />don't see anything obvious. I can certainly find the code: the oops<br />clearly happens in detach_timer():<br /><br />        __hlist_del(entry);<br />        if (clear_pending)<br />                entry-&gt;pprev = NULL;<br />        entry-&gt;next = LIST_POISON2;<br /><br />and the "test   %r13b,%r13b" instruction that follows the GP<br />insutrction is the test of "clear_pending", and the access that faults<br />is the<br /><br />        if (next)<br />                next-&gt;pprev = pprev;<br /><br />in __hlist_del(), where "next" is that %rax LIST_POISON2 value.<br /><br />So it smells like "entry" was simply detached _twice_. The second time<br />it hit that LIST_POISON2 poisoning and died.<br /><br />Some locking problem in the timer handling?<br /><br />Without knowing anythign at all, I'd be inclined to blame f00c0afdfa62<br />("timers: Implement optimization for same expiry time in mod_timer()")<br />which seems to do unlocked games with mod_timer().<br /><br />But I may be full of crap. I literally just looked at "what has<br />changed recently in this area", on the assumption that timers have<br />historically been robust.<br /><br />The fact that this happened not during my testing (I had test cases<br />that did similar things), but at shutdown, makes me also wonder if<br />maybe some CPU hot-unplug thing might have been involved. Concurrent<br />timer migration from a CPU that was going down? Although  honestly, it<br />doesn't seem like that, this happens when gnome-shell is exiting, and<br />it's simply not that late in the shutdown process yet.<br /><br />I don't know. It still bothers me that this happens with new code that<br />I was just testing out, and my gut feel is that "timers are so core<br />and tested from other code that it can't *possibly* be bug in<br />mod_timer()". But the code really is *so* simple: literally a single<br />static timer that is only _ever_ touched by "mod_timer()" and<br />absolutely nothing else. So even if everything else in my KERN_CONT<br />cleanup was completely buggy crap, I'm not seeing how it could screw<br />up the timer.<br /><br />Ideas?<br /><br />               Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
