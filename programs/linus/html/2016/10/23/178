    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/10/22/130">First message in thread</a></li><li><a href="/lkml/2016/10/22/130">Thomas Gleixner</a><ul><li><a href="/lkml/2016/10/23/171">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2016/10/24/184">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/24/184">Thomas Gleixner</a><ul><li><a href="/lkml/2016/10/24/424">Thomas Gleixner</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 23 Oct 2016 16:20:22 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [GIT pull] timer updates for 4.9</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Oct 23, 2016 at 3:39 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; Some locking problem in the timer handling?<br /><br />So I found what looks like a bug in lock_timer_base() wrt migration.<br /><br />This code:<br /><br />        for (;;) {<br />                struct timer_base *base;<br />                u32 tf = timer-&gt;flags;<br /><br />                if (!(tf &amp; TIMER_MIGRATING)) {<br />                        base = get_timer_base(tf);<br />                        spin_lock_irqsave(&amp;base-&gt;lock, *flags);<br />                        if (timer-&gt;flags == tf)<br />                                return base;<br />                        spin_unlock_irqrestore(&amp;base-&gt;lock, *flags);<br />                }<br />                cpu_relax();<br />        }<br /><br />looks subtly buggy. I think that load of "tf" needs a READ_ONCE() to<br />make sure that gcc doesn't simply reload the valid of "timer-&gt;flags"<br />at random points.<br /><br />Yes, the spin_lock_irqsave() is a barrier, but that's the only one.<br />Afaik, gcc could decide that "I need to spill tf, so I'll just reload<br />it" after looking up get_timer_base().<br /><br />And no, I don't think this is the cause of my problem, but I suspect<br />that something _like_ fragility in lock_timer_base() could cause this.<br />Looking at "timer-&gt;flags" *before* you hold the lock that actually<br />locks down the value sounds very very fragile.<br /><br />Another example of the exact same problem is in __mod_timer() itself:<br /><br />                base = get_timer_base(timer-&gt;flags);<br />    ...<br />                if (idx == timer_get_idx(timer)) {<br /><br />and since "timer_get_idx()" depends on timer-&gt;flags, doing this all<br />without holding the base lock smells really really bad.<br /><br />Again, _if_ that whole "let's check timer_pending without holding the<br />lock" is valid, I'd suggest doing<br /><br />                u32 flags = READ_ONCE(timer-&gt;flags);<br />                base = get_timer_base(flags);<br />    ...<br />                if (idx == timer_flags_get_idx(flags)) {<br /><br /><br />or something similar, so that at least we know that even if the<br />"flags" value changes, we use the *same* flag values to look up the<br />base and to then checking the index of the wheel of that base.<br /><br />I dunno. That whole thing looks very fragile to begin with: is it<br />really ok to change the expiry time of a timer without holding any<br />locks what-so-ever? The timer may just be firing on another CPU, and<br />you may be setting the expiry time on a timer that isn't ever going to<br />fire again.<br /><br />Anyway, the timer locking (and lack of it) makes me nervous.<br /><br />And there may well be valid reasons why I'm full of crap, and there's<br />some reason why this is all safe. Maybe the GP fault I saw was my<br />fault after all, in some way that I can't for the life of me figure<br />out right now..<br /><br />                Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
