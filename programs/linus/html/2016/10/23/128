    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/10/12/363">First message in thread</a></li><li><a href="/lkml/2016/10/23/121">Joe Perches</a><ul><li><a href="/lkml/2016/10/23/125">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2016/10/24/248">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/24/248">Geert Uytterhoeven</a></li><li><a href="/lkml/2016/10/24/379">Sergey Senozhatsky</a><ul><li><a href="/lkml/2016/10/24/389">Sergey Senozhatsky</a></li><li><a href="/lkml/2016/10/24/657">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2016/10/23/139">Joe Perches</a><ul><li><a href="/lkml/2016/10/23/152">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2016/10/23/128/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 23 Oct 2016 12:46:15 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: linux.git: printk() problem</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Oct 23, 2016 at 12:32 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; No, the real complexity comes from that interaction with the console<br />&gt; output, which is done outside the core log locks, and which currently<br />&gt; has the added thing where we have a "has this line fragment been<br />&gt; flushed or not".<br /><br />Ok, so here's the stupid patch that removes all the partial line flushing.<br /><br />NOTE! It still leaves all the games with LOG_NEWLINE and LOG_NOCONS<br />that are pretty much pointless with it. So there's room for more<br />simplification here.<br /><br />In particular, the games with LOG_NEWLINE is what Geert's "console and<br />dmesg output looks different" at least partially comes from. What<br />happens is that "dmesg" always shows the records as one line (so it<br />effectively ignores LOG_NEWLINE), but the console output (in<br />msg_print_text() still has that LOG_NEWLINE logic.<br /><br />In particular, msg_print_text() looks at the *previous* logged line to<br />decide whether it should do newlines etc, which is why Geert gets that<br />odd "two continuations per line" pattern on the console, but "one<br />continuation per line" in dmesg. That comes from the interaction with<br />flushing to the console and LOG_NEWLINE and just general complexity.<br /><br />All of that LOG_NEWLINE code could be removed. But again, this patch<br />doesn't do that removal. It just removes the partial console flushing<br />and simplifies that part of the code.<br /><br />(This patch removes way more lines than it adds, but the *real*<br />advantage is that it removes complexity. The rules for<br />console_cont_flush() really were _very_ hard to grok, it has subtle<br />interactions with cont_add() and cont_flush() through that "cont.cons"<br />and "cont.flushed" logic that is all removed by this patch).<br /><br />                Linus<br /> kernel/printk/printk.c | 132 +++++++++++--------------------------------------<br /> 1 file changed, 28 insertions(+), 104 deletions(-)<br /><br />diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c<br />index de08fc90baaf..ed1bfa774427 100644<br />--- a/kernel/printk/printk.c<br />+++ b/kernel/printk/printk.c<br />&#64;&#64; -794,7 +794,7 &#64;&#64; static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)<br /> 	return ret;<br /> }<br /> <br />-static void cont_flush(void);<br />+static void deferred_cont_flush(void);<br /> <br /> static ssize_t devkmsg_read(struct file *file, char __user *buf,<br /> 			    size_t count, loff_t *ppos)<br />&#64;&#64; -811,7 +811,6 &#64;&#64; static ssize_t devkmsg_read(struct file *file, char __user *buf,<br /> 	if (ret)<br /> 		return ret;<br /> 	raw_spin_lock_irq(&amp;logbuf_lock);<br />-	cont_flush();<br /> 	while (user-&gt;seq == log_next_seq) {<br /> 		if (file-&gt;f_flags &amp; O_NONBLOCK) {<br /> 			ret = -EAGAIN;<br />&#64;&#64; -860,6 +859,7 &#64;&#64; static ssize_t devkmsg_read(struct file *file, char __user *buf,<br /> 	ret = len;<br /> out:<br /> 	mutex_unlock(&amp;user-&gt;lock);<br />+	deferred_cont_flush();<br /> 	return ret;<br /> }<br /> <br />&#64;&#64; -874,7 +874,6 &#64;&#64; static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)<br /> 		return -ESPIPE;<br /> <br /> 	raw_spin_lock_irq(&amp;logbuf_lock);<br />-	cont_flush();<br /> 	switch (whence) {<br /> 	case SEEK_SET:<br /> 		/* the first record */<br />&#64;&#64; -913,7 +912,6 &#64;&#64; static unsigned int devkmsg_poll(struct file *file, poll_table *wait)<br /> 	poll_wait(file, &amp;log_wait, wait);<br /> <br /> 	raw_spin_lock_irq(&amp;logbuf_lock);<br />-	cont_flush();<br /> 	if (user-&gt;seq &lt; log_next_seq) {<br /> 		/* return error when data has vanished underneath us */<br /> 		if (user-&gt;seq &lt; log_first_seq)<br />&#64;&#64; -922,6 +920,7 &#64;&#64; static unsigned int devkmsg_poll(struct file *file, poll_table *wait)<br /> 			ret = POLLIN|POLLRDNORM;<br /> 	}<br /> 	raw_spin_unlock_irq(&amp;logbuf_lock);<br />+	deferred_cont_flush();<br /> <br /> 	return ret;<br /> }<br />&#64;&#64; -1300,7 +1299,6 &#64;&#64; static int syslog_print(char __user *buf, int size)<br /> 		size_t skip;<br /> <br /> 		raw_spin_lock_irq(&amp;logbuf_lock);<br />-		cont_flush();<br /> 		if (syslog_seq &lt; log_first_seq) {<br /> 			/* messages are gone, move to first one */<br /> 			syslog_seq = log_first_seq;<br />&#64;&#64; -1360,7 +1358,6 &#64;&#64; static int syslog_print_all(char __user *buf, int size, bool clear)<br /> 		return -ENOMEM;<br /> <br /> 	raw_spin_lock_irq(&amp;logbuf_lock);<br />-	cont_flush();<br /> 	if (buf) {<br /> 		u64 next_seq;<br /> 		u64 seq;<br />&#64;&#64; -1522,7 +1519,6 &#64;&#64; int do_syslog(int type, char __user *buf, int len, int source)<br /> 	/* Number of chars in the log buffer */<br /> 	case SYSLOG_ACTION_SIZE_UNREAD:<br /> 		raw_spin_lock_irq(&amp;logbuf_lock);<br />-		cont_flush();<br /> 		if (syslog_seq &lt; log_first_seq) {<br /> 			/* messages are gone, move to first one */<br /> 			syslog_seq = log_first_seq;<br />&#64;&#64; -1563,6 +1559,7 &#64;&#64; int do_syslog(int type, char __user *buf, int len, int source)<br /> 		error = -EINVAL;<br /> 		break;<br /> 	}<br />+	deferred_cont_flush();<br /> out:<br /> 	return error;<br /> }<br />&#64;&#64; -1650,46 +1647,41 &#64;&#64; static inline void printk_delay(void)<br /> static struct cont {<br /> 	char buf[LOG_LINE_MAX];<br /> 	size_t len;			/* length == 0 means unused buffer */<br />-	size_t cons;			/* bytes written to console */<br /> 	struct task_struct *owner;	/* task of first print*/<br /> 	u64 ts_nsec;			/* time of first print */<br /> 	u8 level;			/* log level of first message */<br /> 	u8 facility;			/* log facility of first message */<br /> 	enum log_flags flags;		/* prefix, newline flags */<br />-	bool flushed:1;			/* buffer sealed and committed */<br /> } cont;<br /> <br />-static void cont_flush(void)<br />+static bool cont_flush(void)<br /> {<br />-	if (cont.flushed)<br />-		return;<br />-	if (cont.len == 0)<br />+	if (!cont.len)<br />+		return false;<br />+<br />+	log_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,<br />+		  NULL, 0, cont.buf, cont.len);<br />+	cont.len = 0;<br />+	return true;<br />+}<br />+<br />+static void flush_timer(unsigned long data)<br />+{<br />+	if (cont_flush())<br />+		wake_up_klogd();<br />+}<br />+<br />+static void deferred_cont_flush(void)<br />+{<br />+	static DEFINE_TIMER(timer, flush_timer, 0, 0);<br />+<br />+	if (!cont.len)<br /> 		return;<br />-	if (cont.cons) {<br />-		/*<br />-		 * If a fragment of this line was directly flushed to the<br />-		 * console; wait for the console to pick up the rest of the<br />-		 * line. LOG_NOCONS suppresses a duplicated output.<br />-		 */<br />-		log_store(cont.facility, cont.level, cont.flags | LOG_NOCONS,<br />-			  cont.ts_nsec, NULL, 0, cont.buf, cont.len);<br />-		cont.flushed = true;<br />-	} else {<br />-		/*<br />-		 * If no fragment of this line ever reached the console,<br />-		 * just submit it to the store and free the buffer.<br />-		 */<br />-		log_store(cont.facility, cont.level, cont.flags, 0,<br />-			  NULL, 0, cont.buf, cont.len);<br />-		cont.len = 0;<br />-	}<br />+	mod_timer(&amp;timer, jiffies + HZ/10);<br /> }<br /> <br /> static bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)<br /> {<br />-	if (cont.len &amp;&amp; cont.flushed)<br />-		return false;<br />-<br /> 	/*<br /> 	 * If ext consoles are present, flush and skip in-kernel<br /> 	 * continuation.  See nr_ext_console_drivers definition.  Also, if<br />&#64;&#64; -1706,8 +1698,6 &#64;&#64; static bool cont_add(int facility, int level, enum log_flags flags, const char *<br /> 		cont.owner = current;<br /> 		cont.ts_nsec = local_clock();<br /> 		cont.flags = flags;<br />-		cont.cons = 0;<br />-		cont.flushed = false;<br /> 	}<br /> <br /> 	memcpy(cont.buf + cont.len, text, len);<br />&#64;&#64; -1726,34 +1716,6 &#64;&#64; static bool cont_add(int facility, int level, enum log_flags flags, const char *<br /> 	return true;<br /> }<br /> <br />-static size_t cont_print_text(char *text, size_t size)<br />-{<br />-	size_t textlen = 0;<br />-	size_t len;<br />-<br />-	if (cont.cons == 0 &amp;&amp; (console_prev &amp; LOG_NEWLINE)) {<br />-		textlen += print_time(cont.ts_nsec, text);<br />-		size -= textlen;<br />-	}<br />-<br />-	len = cont.len - cont.cons;<br />-	if (len &gt; 0) {<br />-		if (len+1 &gt; size)<br />-			len = size-1;<br />-		memcpy(text + textlen, cont.buf + cont.cons, len);<br />-		textlen += len;<br />-		cont.cons = cont.len;<br />-	}<br />-<br />-	if (cont.flushed) {<br />-		if (cont.flags &amp; LOG_NEWLINE)<br />-			text[textlen++] = '\n';<br />-		/* got everything, release buffer */<br />-		cont.len = 0;<br />-	}<br />-	return textlen;<br />-}<br />-<br /> static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)<br /> {<br /> 	/*<br />&#64;&#64; -2025,7 +1987,6 &#64;&#64; static void call_console_drivers(int level,<br /> 				 const char *text, size_t len) {}<br /> static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,<br /> 			     bool syslog, char *buf, size_t size) { return 0; }<br />-static size_t cont_print_text(char *text, size_t size) { return 0; }<br /> static bool suppress_message_printing(int level) { return false; }<br /> <br /> /* Still needs to be defined for users */<br />&#64;&#64; -2296,42 +2257,6 &#64;&#64; static inline int can_use_console(void)<br /> 	return cpu_online(raw_smp_processor_id()) || have_callable_console();<br /> }<br /> <br />-static void console_cont_flush(char *text, size_t size)<br />-{<br />-	unsigned long flags;<br />-	size_t len;<br />-<br />-	raw_spin_lock_irqsave(&amp;logbuf_lock, flags);<br />-<br />-	if (!cont.len)<br />-		goto out;<br />-<br />-	if (suppress_message_printing(cont.level)) {<br />-		cont.cons = cont.len;<br />-		if (cont.flushed)<br />-			cont.len = 0;<br />-		goto out;<br />-	}<br />-<br />-	/*<br />-	 * We still queue earlier records, likely because the console was<br />-	 * busy. The earlier ones need to be printed before this one, we<br />-	 * did not flush any fragment so far, so just let it queue up.<br />-	 */<br />-	if (console_seq &lt; log_next_seq &amp;&amp; !cont.cons)<br />-		goto out;<br />-<br />-	len = cont_print_text(text, size);<br />-	raw_spin_unlock(&amp;logbuf_lock);<br />-	stop_critical_timings();<br />-	call_console_drivers(cont.level, NULL, 0, text, len);<br />-	start_critical_timings();<br />-	local_irq_restore(flags);<br />-	return;<br />-out:<br />-	raw_spin_unlock_irqrestore(&amp;logbuf_lock, flags);<br />-}<br />-<br /> /**<br />  * console_unlock - unlock the console system<br />  *<br />&#64;&#64; -2360,6 +2285,8 &#64;&#64; void console_unlock(void)<br /> 		return;<br /> 	}<br /> <br />+	deferred_cont_flush();<br />+<br /> 	/*<br /> 	 * Console drivers are called under logbuf_lock, so<br /> 	 * &#64;console_may_schedule should be cleared before; however, we may<br />&#64;&#64; -2385,9 +2312,6 &#64;&#64; void console_unlock(void)<br /> 		return;<br /> 	}<br /> <br />-	/* flush buffered message fragment immediately to console */<br />-	console_cont_flush(text, sizeof(text));<br />-<br /> 	for (;;) {<br /> 		struct printk_log *msg;<br /> 		size_t ext_len = 0;</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
