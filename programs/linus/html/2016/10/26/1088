    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/10/26/494">First message in thread</a></li><li><a href="/lkml/2016/10/26/863">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/26/911">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/26/922">Bob Peterson</a><ul><li><a href="/lkml/2016/10/26/927">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/26/960">Bob Peterson</a></li><li><a href="/lkml/2016/10/26/1072">Bob Peterson</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2016/10/26/1047">Mel Gorman</a><ul><li class="origin"><a href="/lkml/2016/10/26/1141">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/26/1141">Mel Gorman</a><ul><li><a href="/lkml/2016/10/26/1146">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 26 Oct 2016 14:26:57 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: CONFIG_VMAP_STACK, on-stack struct, and wake_up_bit</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Oct 26, 2016 at 1:31 PM, Mel Gorman &lt;mgorman&#64;techsingularity.net&gt; wrote:<br />&gt;<br />&gt; IO wait activity is not all that matters. We hit the lock/unlock paths<br />&gt; during a lot of operations like reclaim.<br /><br />I doubt we do.<br /><br />Yes, we hit the lock/unlock itself, but do we hit the *contention*?<br /><br />The current code is nasty, and always ends up touching the wait-queue<br />regardless of whether it needs to or not, but we have a fix for that.<br /><br />With that fixed, do we actually get contention on a per-page basis?<br />Because without contention, we'd never actually look up the wait-queue<br />at all.<br /><br />I suspect that without IO, it's really really hard to actually get<br />that contention, because things like reclaim end up looking at the LRU<br />queue etc wioth their own locking, so it should look at various<br />individual pages one at a time, not have multiple queues look at the<br />same page.<br /><br />&gt;&gt; diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h<br />&gt;&gt; index 7f2ae99e5daf..0f088f3a2fed 100644<br />&gt;&gt; --- a/include/linux/mmzone.h<br />&gt;&gt; +++ b/include/linux/mmzone.h<br />&gt;&gt; &#64;&#64; -440,33 +440,7 &#64;&#64; struct zone {<br />&gt;&gt; +     int initialized;<br />&gt;&gt;<br />&gt;&gt;       /* Write-intensive fields used from the page allocator */<br />&gt;&gt;       ZONE_PADDING(_pad1_)<br />&gt;<br />&gt; zone_is_initialized is mostly the domain of hotplug. A potential cleanup<br />&gt; is to use a page flag and shrink the size of zone slightly. Nothing to<br />&gt; panic over.<br /><br />I really did that to make it very obvious that there was no semantic<br />change. I just set the "initialized" flag in the same place where it<br />used to initialize the wait_table, so that this:<br /><br />&gt;&gt;  static inline bool zone_is_initialized(struct zone *zone)<br />&gt;&gt;  {<br />&gt;&gt; -     return !!zone-&gt;wait_table;<br />&gt;&gt; +     return zone-&gt;initialized;<br />&gt;&gt;  }<br /><br />ends up being obviously equivalent.<br /><br />Admittedly I didn't clear it when the code cleared the wait_table<br />pointer, because that _seemed_ a non-issue - the zone will remain<br />initialized until it can't be reached any more, so there didn't seem<br />to be an actual problem there.<br /><br />&gt;&gt; +#define WAIT_TABLE_BITS 8<br />&gt;&gt; +#define WAIT_TABLE_SIZE (1 &lt;&lt; WAIT_TABLE_BITS)<br />&gt;&gt; +static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE] __cacheline_aligned;<br />&gt;&gt; +<br />&gt;&gt; +wait_queue_head_t *bit_waitqueue(void *word, int bit)<br />&gt;&gt; +{<br />&gt;&gt; +     const int shift = BITS_PER_LONG == 32 ? 5 : 6;<br />&gt;&gt; +     unsigned long val = (unsigned long)word &lt;&lt; shift | bit;<br />&gt;&gt; +<br />&gt;&gt; +     return bit_wait_table + hash_long(val, WAIT_TABLE_BITS);<br />&gt;&gt; +}<br />&gt;&gt; +EXPORT_SYMBOL(bit_waitqueue);<br />&gt;&gt; +<br />&gt;<br />&gt; Minor nit that it's unfortunate this moved to the scheduler core. It<br />&gt; wouldn't have been a complete disaster to add a page_waitqueue_init() or<br />&gt; something similar after sched_init.<br /><br />I considered that, but decided that "minimal patch" was better. Plus,<br />with that bit_waitqueue() actually also being used for the page<br />locking queues (which act _kind of_ but not quite, like a bitlock),<br />the bit_wait_table is actually more core than just the bit-wait code.<br /><br />In fact, I considered just renaming it to "hashed_wait_queue", because<br />that's effectively how we use it now, rather than being particularly<br />specific to the bit-waiting. But again, that would have made the patch<br />bigger, which I wanted to avoid since this is a post-rc2 thing due to<br />the gfs2 breakage.<br /><br />            Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
