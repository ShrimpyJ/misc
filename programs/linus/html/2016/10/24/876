    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/10/11/389">First message in thread</a></li><li><a href="/lkml/2016/10/24/21">Dave Jones</a><ul><li><a href="/lkml/2016/10/24/362">Chris Mason</a><ul><li><a href="/lkml/2016/10/25/822">Dave Jones</a><ul><li><a href="/lkml/2016/10/25/843">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/25/847">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2016/10/27/15">Dave Chinner</a><ul><li><a href="/lkml/2016/10/27/483">Dave Jones</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2016/10/24/843">Andy Lutomirski</a><ul><li class="origin"><a href="/lkml/2016/10/24/900">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/24/900">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/24/921">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2016/10/24/969">Andy Lutomirski</a><ul><li><a href="/lkml/2016/10/24/999">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 24 Oct 2016 13:46:42 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: bio linked list corruption.</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Oct 24, 2016 at 1:06 PM, Andy Lutomirski &lt;luto&#64;amacapital.net&gt; wrote:<br />&gt;&gt;<br />&gt;&gt; [69943.450108] Oops: 0003 [#1] PREEMPT SMP DEBUG_PAGEALLOC<br />&gt;<br />&gt; This is an unhandled kernel page fault.  The string "Oops" is so helpful :-/<br /><br />I think there was a line above it that DaveJ just didn't include.<br /><br />&gt;<br />&gt;&gt; [69943.454452] CPU: 1 PID: 21558 Comm: trinity-c60 Not tainted 4.9.0-rc1-think+ #11<br />&gt;&gt; [69943.463510] task: ffff8804f8dd3740 task.stack: ffffc9000b108000<br />&gt;&gt; [69943.468077] RIP: 0010:[&lt;ffffffff810c3f6b&gt;]<br />&gt;&gt; [69943.472704]  [&lt;ffffffff810c3f6b&gt;] __lock_acquire.isra.32+0x6b/0x8c0<br />&gt;&gt; [69943.477489] RSP: 0018:ffffc9000b10b9e8  EFLAGS: 00010086<br />&gt;&gt; [69943.482368] RAX: ffffffff81789b90 RBX: ffff8804f8dd3740 RCX: 0000000000000000<br />&gt;&gt; [69943.487410] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000<br />&gt;&gt; [69943.492515] RBP: ffffc9000b10ba18 R08: 0000000000000001 R09: 0000000000000000<br />&gt;&gt; [69943.497666] R10: 0000000000000001 R11: 00003f9cfa7f4e73 R12: 0000000000000000<br />&gt;&gt; [69943.502880] R13: 0000000000000000 R14: ffffc9000af7bd48 R15: ffff8804f8dd3740<br />&gt;&gt; [69943.508163] FS:  00007f64904a2b40(0000) GS:ffff880507a00000(0000) knlGS:0000000000000000<br />&gt;&gt; [69943.513591] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033<br />&gt;&gt; [69943.518917] CR2: ffffffff81789d28 CR3: 00000004a8f16000 CR4: 00000000001406e0<br />&gt;&gt; [69943.524253] DR0: 00007f5b97fd4000 DR1: 0000000000000000 DR2: 0000000000000000<br />&gt;&gt; [69943.529488] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000600<br />&gt;&gt; [69943.534771] Stack:<br />&gt;&gt; [69943.540023]  ffff880507bd74c0<br />&gt;&gt; [69943.545317]  ffff8804f8dd3740 0000000000000046 0000000000000286[69943.545456]  ffffc9000af7bd08<br />&gt;&gt; [69943.550930]  0000000000000100 ffffc9000b10ba50 ffffffff810c4b68[69943.551069]  ffffffff810ba40c<br />&gt;&gt; [69943.556657]  ffff880400000000 0000000000000000 ffffc9000af7bd48[69943.556796] Call Trace:<br />&gt;&gt; [69943.562465]  [&lt;ffffffff810c4b68&gt;] lock_acquire+0x58/0x70<br />&gt;&gt; [69943.568354]  [&lt;ffffffff810ba40c&gt;] ? finish_wait+0x3c/0x70<br />&gt;&gt; [69943.574306]  [&lt;ffffffff8178fef2&gt;] _raw_spin_lock_irqsave+0x42/0x80<br />&gt;&gt; [69943.580335]  [&lt;ffffffff810ba40c&gt;] ? finish_wait+0x3c/0x70<br />&gt;&gt; [69943.586237]  [&lt;ffffffff810ba40c&gt;] finish_wait+0x3c/0x70<br />&gt;&gt; [69943.591992]  [&lt;ffffffff81169727&gt;] shmem_fault+0x167/0x1b0<br />&gt;&gt; [69943.597807]  [&lt;ffffffff810ba6c0&gt;] ? prepare_to_wait_event+0x100/0x100<br />&gt;&gt; [69943.603741]  [&lt;ffffffff8117b46d&gt;] __do_fault+0x6d/0x1b0<br />&gt;&gt; [69943.609743]  [&lt;ffffffff8117f168&gt;] handle_mm_fault+0xc58/0x1170<br />&gt;&gt; [69943.615822]  [&lt;ffffffff8117e553&gt;] ? handle_mm_fault+0x43/0x1170<br />&gt;&gt; [69943.621971]  [&lt;ffffffff81044982&gt;] __do_page_fault+0x172/0x4e0<br />&gt;&gt; [69943.628184]  [&lt;ffffffff81044d10&gt;] do_page_fault+0x20/0x70<br />&gt;&gt; [69943.634449]  [&lt;ffffffff8132a897&gt;] ? debug_smp_processor_id+0x17/0x20<br />&gt;&gt; [69943.640784]  [&lt;ffffffff81791f3f&gt;] page_fault+0x1f/0x30<br />&gt;&gt; [69943.647170]  [&lt;ffffffff8133d69c&gt;] ? strncpy_from_user+0x5c/0x170<br />&gt;&gt; [69943.653480]  [&lt;ffffffff8133d686&gt;] ? strncpy_from_user+0x46/0x170<br />&gt;&gt; [69943.659632]  [&lt;ffffffff811f22a7&gt;] setxattr+0x57/0x170<br />&gt;&gt; [69943.665846]  [&lt;ffffffff8132a897&gt;] ? debug_smp_processor_id+0x17/0x20<br />&gt;&gt; [69943.672172]  [&lt;ffffffff810c1f09&gt;] ? get_lock_stats+0x19/0x50<br />&gt;&gt; [69943.678558]  [&lt;ffffffff810a58f6&gt;] ? sched_clock_cpu+0xb6/0xd0<br />&gt;&gt; [69943.685007]  [&lt;ffffffff810c40cf&gt;] ? __lock_acquire.isra.32+0x1cf/0x8c0<br />&gt;&gt; [69943.691542]  [&lt;ffffffff8132a8b3&gt;] ? __this_cpu_preempt_check+0x13/0x20<br />&gt;&gt; [69943.698130]  [&lt;ffffffff8109b9bc&gt;] ? preempt_count_add+0x7c/0xc0<br />&gt;&gt; [69943.704791]  [&lt;ffffffff811ecda1&gt;] ? __mnt_want_write+0x61/0x90<br />&gt;&gt; [69943.711519]  [&lt;ffffffff811f2638&gt;] SyS_fsetxattr+0x78/0xa0<br />&gt;&gt; [69943.718300]  [&lt;ffffffff8100255c&gt;] do_syscall_64+0x5c/0x170<br />&gt;&gt; [69943.724949]  [&lt;ffffffff81790a4b&gt;] entry_SYSCALL64_slow_path+0x25/0x25<br />&gt;&gt; [69943.731521] Code:<br />&gt;&gt; [69943.738124] 00 83 fe 01 0f 86 0e 03 00 00 31 d2 4c 89 f7 44 89 45 d0 89 4d d4 e8 75 e7 ff ff 8b 4d d4 48 85 c0 44 8b 45 d0 0f 84 d8 02 00 00 &lt;f0&gt; ff 80 98 01 00 00 8b 15 e0 21 8f 01 45 8b 8f 50 08 00 00 85<br />&gt;<br />&gt; That's lock incl 0x198(%rax).  I think this is:<br />&gt;<br />&gt;     atomic_inc((atomic_t *)&amp;class-&gt;ops);<br />&gt;<br />&gt; I suppose this could be stack corruption at work, but after a fair<br />&gt; amount of staring, I still haven't found anything in the vmap_stack<br />&gt; code that would cause stack corruption.<br /><br />Well, it is intriguing that what faults is this:<br /><br />                        finish_wait(shmem_falloc_waitq, &amp;shmem_fault_wait);<br /><br />where 'shmem_fault_wait' is a on-stack wait queue. So it really looks<br />very much like stack corruption.<br /><br />What strikes me is that "finish_wait()" does this optimistic "has my<br />entry been removed" without holding the waitqueue lock (and uses<br />list_empty_careful() to make sure it does that "safely").<br /><br />It has that big comment too:<br /><br />                        /*<br />                         * shmem_falloc_waitq points into the shmem_fallocate()<br />                         * stack of the hole-punching task: shmem_falloc_waitq<br />                         * is usually invalid by the time we reach here, but<br />                         * finish_wait() does not dereference it in that case;<br />                         * though i_lock needed lest racing with wake_up_all().<br />                         */<br /><br />the stack it comes from is the wait queue head from shmem_fallocate(),<br />which will do "wake_up_all()" under the inode lock.<br /><br />On the face of it, the inode lock should make that safe and serialize<br />everything. And yes, finish_wait() does not touch the unsafe stuff if<br />the wait-queue (in the local stack) is empty, which wake_up_all()<br />*should* have guaranteed. It's just a regular wait-queue entry (that<br />DEFINE_WAIT() does that), so it uses the normal<br />autoremove_wake_function() that removes things on successful wakeup:<br /><br />int autoremove_wake_function(wait_queue_t *wait, unsigned mode, int<br />sync, void *key)<br />{<br />        int ret = default_wake_function(wait, mode, sync, key);<br /><br />        if (ret)<br />                list_del_init(&amp;wait-&gt;task_list);<br />        return ret;<br />}<br /><br />So the only issue is "did default_wake_function() return true"? That's<br />try_to_wake_up(TASK_NORMAL, 0), and I note that it can return zero<br />(and thus *not* remove the entry - leavign the invalid entry tghere)<br />if<br /><br />        if (!(p-&gt;state &amp; state))<br />                goto out;<br /><br />but "prepare_to_wait()" (which also ran with the inode-&gt;i_lock held,<br />and also takes the wait-queue lock) did set p-&gt;state to<br />TASK_UNINTERRUPTIBLE.<br /><br />So this is all some really subtle code, but I'm not seeing that it<br />would be wrong.<br /><br />            Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
