    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/10/12/363">First message in thread</a></li><li><a href="/lkml/2016/10/24/1082">Sergey Senozhatsky</a><ul><li><a href="/lkml/2016/10/24/1086">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2016/10/25/2">Linus Torvalds</a><ul><li><a href="/lkml/2016/10/25/2">Sergey Senozhatsky</a><ul><li><a href="/lkml/2016/10/25/4">Joe Perches</a></li><li><a href="/lkml/2016/10/25/6">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2016/10/25/408">Petr Mladek</a></li><li><a href="/lkml/2016/11/9/507">Petr Mladek</a></li></ul></li></ul></li><li><a href="/lkml/2016/10/24/1089">Sergey Senozhatsky</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2016/10/24/1088/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 24 Oct 2016 19:22:59 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: linux.git: printk() problem</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Oct 24, 2016 at 7:06 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt; On Mon, Oct 24, 2016 at 6:55 PM, Sergey Senozhatsky<br />&gt; &lt;sergey.senozhatsky.work&#64;gmail.com&gt; wrote:<br />&gt;&gt;<br />&gt;&gt; I think cont_flush() should grab the logbuf_lock lock, because<br />&gt;&gt; it does log_store() and touches the cont.len. so something like<br />&gt;&gt; this perhaps<br />&gt;<br />&gt; Absolutely. Good catch.<br /><br />Actually, you can't do it the way you did (inside cont_flush), because<br />"cont_flush()" is already called with logbuf_lock held in most cases<br />(see "cont_add()").<br /><br />So it's really just the timer function that needs to take the<br />logbuf_lock before it calls cont_flush().<br /><br />So here's a new version. How does this look to you?<br /><br />Again, this still tests "cont.len" outside the lock (not just in<br />console_unlock(), but also in deferred_cont_flush()). And it's fine:<br />even if it sees the "wrong" value due to some race, it does so either<br />because cont.len was just set to non-zero (and whoever set it will<br />force the re-check anyway), or it got cleared just as it was tested<br />(and at worst you end up with an extra timer invocation).<br /><br />              Linus<br /> kernel/printk/printk.c | 255 +++++++++++--------------------------------------<br /> 1 file changed, 58 insertions(+), 197 deletions(-)<br /><br />diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c<br />index de08fc90baaf..e63aa679614e 100644<br />--- a/kernel/printk/printk.c<br />+++ b/kernel/printk/printk.c<br />&#64;&#64; -367,7 +367,6 &#64;&#64; DECLARE_WAIT_QUEUE_HEAD(log_wait);<br /> /* the next printk record to read by syslog(READ) or /proc/kmsg */<br /> static u64 syslog_seq;<br /> static u32 syslog_idx;<br />-static enum log_flags syslog_prev;<br /> static size_t syslog_partial;<br /> <br /> /* index and sequence number of the first record stored in the buffer */<br />&#64;&#64; -381,7 +380,6 &#64;&#64; static u32 log_next_idx;<br /> /* the next printk record to write to the console */<br /> static u64 console_seq;<br /> static u32 console_idx;<br />-static enum log_flags console_prev;<br /> <br /> /* the next printk record to read after the last 'clear' command */<br /> static u64 clear_seq;<br />&#64;&#64; -650,27 +648,15 &#64;&#64; static void append_char(char **pp, char *e, char c)<br /> }<br /> <br /> static ssize_t msg_print_ext_header(char *buf, size_t size,<br />-				    struct printk_log *msg, u64 seq,<br />-				    enum log_flags prev_flags)<br />+				    struct printk_log *msg, u64 seq)<br /> {<br /> 	u64 ts_usec = msg-&gt;ts_nsec;<br />-	char cont = '-';<br /> <br /> 	do_div(ts_usec, 1000);<br /> <br />-	/*<br />-	 * If we couldn't merge continuation line fragments during the print,<br />-	 * export the stored flags to allow an optional external merge of the<br />-	 * records. Merging the records isn't always neccessarily correct, like<br />-	 * when we hit a race during printing. In most cases though, it produces<br />-	 * better readable output. 'c' in the record flags mark the first<br />-	 * fragment of a line, '+' the following.<br />-	 */<br />-	if (msg-&gt;flags &amp; LOG_CONT)<br />-		cont = (prev_flags &amp; LOG_CONT) ? '+' : 'c';<br />-<br /> 	return scnprintf(buf, size, "%u,%llu,%llu,%c;",<br />-		       (msg-&gt;facility &lt;&lt; 3) | msg-&gt;level, seq, ts_usec, cont);<br />+		       (msg-&gt;facility &lt;&lt; 3) | msg-&gt;level, seq, ts_usec,<br />+		       msg-&gt;flags &amp; LOG_CONT ? 'c' : '-');<br /> }<br /> <br /> static ssize_t msg_print_ext_body(char *buf, size_t size,<br />&#64;&#64; -725,7 +711,6 &#64;&#64; static ssize_t msg_print_ext_body(char *buf, size_t size,<br /> struct devkmsg_user {<br /> 	u64 seq;<br /> 	u32 idx;<br />-	enum log_flags prev;<br /> 	struct ratelimit_state rs;<br /> 	struct mutex lock;<br /> 	char buf[CONSOLE_EXT_LOG_MAX];<br />&#64;&#64; -794,7 +779,7 &#64;&#64; static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)<br /> 	return ret;<br /> }<br /> <br />-static void cont_flush(void);<br />+static void deferred_cont_flush(void);<br /> <br /> static ssize_t devkmsg_read(struct file *file, char __user *buf,<br /> 			    size_t count, loff_t *ppos)<br />&#64;&#64; -811,7 +796,6 &#64;&#64; static ssize_t devkmsg_read(struct file *file, char __user *buf,<br /> 	if (ret)<br /> 		return ret;<br /> 	raw_spin_lock_irq(&amp;logbuf_lock);<br />-	cont_flush();<br /> 	while (user-&gt;seq == log_next_seq) {<br /> 		if (file-&gt;f_flags &amp; O_NONBLOCK) {<br /> 			ret = -EAGAIN;<br />&#64;&#64; -838,12 +822,11 &#64;&#64; static ssize_t devkmsg_read(struct file *file, char __user *buf,<br /> <br /> 	msg = log_from_idx(user-&gt;idx);<br /> 	len = msg_print_ext_header(user-&gt;buf, sizeof(user-&gt;buf),<br />-				   msg, user-&gt;seq, user-&gt;prev);<br />+				   msg, user-&gt;seq);<br /> 	len += msg_print_ext_body(user-&gt;buf + len, sizeof(user-&gt;buf) - len,<br /> 				  log_dict(msg), msg-&gt;dict_len,<br /> 				  log_text(msg), msg-&gt;text_len);<br /> <br />-	user-&gt;prev = msg-&gt;flags;<br /> 	user-&gt;idx = log_next(user-&gt;idx);<br /> 	user-&gt;seq++;<br /> 	raw_spin_unlock_irq(&amp;logbuf_lock);<br />&#64;&#64; -860,6 +843,7 &#64;&#64; static ssize_t devkmsg_read(struct file *file, char __user *buf,<br /> 	ret = len;<br /> out:<br /> 	mutex_unlock(&amp;user-&gt;lock);<br />+	deferred_cont_flush();<br /> 	return ret;<br /> }<br /> <br />&#64;&#64; -874,7 +858,6 &#64;&#64; static loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)<br /> 		return -ESPIPE;<br /> <br /> 	raw_spin_lock_irq(&amp;logbuf_lock);<br />-	cont_flush();<br /> 	switch (whence) {<br /> 	case SEEK_SET:<br /> 		/* the first record */<br />&#64;&#64; -913,7 +896,6 &#64;&#64; static unsigned int devkmsg_poll(struct file *file, poll_table *wait)<br /> 	poll_wait(file, &amp;log_wait, wait);<br /> <br /> 	raw_spin_lock_irq(&amp;logbuf_lock);<br />-	cont_flush();<br /> 	if (user-&gt;seq &lt; log_next_seq) {<br /> 		/* return error when data has vanished underneath us */<br /> 		if (user-&gt;seq &lt; log_first_seq)<br />&#64;&#64; -922,6 +904,7 &#64;&#64; static unsigned int devkmsg_poll(struct file *file, poll_table *wait)<br /> 			ret = POLLIN|POLLRDNORM;<br /> 	}<br /> 	raw_spin_unlock_irq(&amp;logbuf_lock);<br />+	deferred_cont_flush();<br /> <br /> 	return ret;<br /> }<br />&#64;&#64; -1226,26 +1209,12 &#64;&#64; static size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)<br /> 	return len;<br /> }<br /> <br />-static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,<br />-			     bool syslog, char *buf, size_t size)<br />+static size_t msg_print_text(const struct printk_log *msg, bool syslog, char *buf, size_t size)<br /> {<br /> 	const char *text = log_text(msg);<br /> 	size_t text_size = msg-&gt;text_len;<br />-	bool prefix = true;<br />-	bool newline = true;<br /> 	size_t len = 0;<br /> <br />-	if ((prev &amp; LOG_CONT) &amp;&amp; !(msg-&gt;flags &amp; LOG_PREFIX))<br />-		prefix = false;<br />-<br />-	if (msg-&gt;flags &amp; LOG_CONT) {<br />-		if ((prev &amp; LOG_CONT) &amp;&amp; !(prev &amp; LOG_NEWLINE))<br />-			prefix = false;<br />-<br />-		if (!(msg-&gt;flags &amp; LOG_NEWLINE))<br />-			newline = false;<br />-	}<br />-<br /> 	do {<br /> 		const char *next = memchr(text, '\n', text_size);<br /> 		size_t text_len;<br />&#64;&#64; -1263,22 +1232,17 &#64;&#64; static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,<br /> 			    text_len + 1 &gt;= size - len)<br /> 				break;<br /> <br />-			if (prefix)<br />-				len += print_prefix(msg, syslog, buf + len);<br />+			len += print_prefix(msg, syslog, buf + len);<br /> 			memcpy(buf + len, text, text_len);<br /> 			len += text_len;<br />-			if (next || newline)<br />-				buf[len++] = '\n';<br />+			buf[len++] = '\n';<br /> 		} else {<br /> 			/* SYSLOG_ACTION_* buffer size only calculation */<br />-			if (prefix)<br />-				len += print_prefix(msg, syslog, NULL);<br />+			len += print_prefix(msg, syslog, NULL);<br /> 			len += text_len;<br />-			if (next || newline)<br />-				len++;<br />+			len++;<br /> 		}<br /> <br />-		prefix = true;<br /> 		text = next;<br /> 	} while (text);<br /> <br />&#64;&#64; -1300,12 +1264,10 &#64;&#64; static int syslog_print(char __user *buf, int size)<br /> 		size_t skip;<br /> <br /> 		raw_spin_lock_irq(&amp;logbuf_lock);<br />-		cont_flush();<br /> 		if (syslog_seq &lt; log_first_seq) {<br /> 			/* messages are gone, move to first one */<br /> 			syslog_seq = log_first_seq;<br /> 			syslog_idx = log_first_idx;<br />-			syslog_prev = 0;<br /> 			syslog_partial = 0;<br /> 		}<br /> 		if (syslog_seq == log_next_seq) {<br />&#64;&#64; -1315,13 +1277,11 &#64;&#64; static int syslog_print(char __user *buf, int size)<br /> <br /> 		skip = syslog_partial;<br /> 		msg = log_from_idx(syslog_idx);<br />-		n = msg_print_text(msg, syslog_prev, true, text,<br />-				   LOG_LINE_MAX + PREFIX_MAX);<br />+		n = msg_print_text(msg, true, text, LOG_LINE_MAX + PREFIX_MAX);<br /> 		if (n - syslog_partial &lt;= size) {<br /> 			/* message fits into buffer, move forward */<br /> 			syslog_idx = log_next(syslog_idx);<br /> 			syslog_seq++;<br />-			syslog_prev = msg-&gt;flags;<br /> 			n -= syslog_partial;<br /> 			syslog_partial = 0;<br /> 		} else if (!len){<br />&#64;&#64; -1360,12 +1320,10 &#64;&#64; static int syslog_print_all(char __user *buf, int size, bool clear)<br /> 		return -ENOMEM;<br /> <br /> 	raw_spin_lock_irq(&amp;logbuf_lock);<br />-	cont_flush();<br /> 	if (buf) {<br /> 		u64 next_seq;<br /> 		u64 seq;<br /> 		u32 idx;<br />-		enum log_flags prev;<br /> <br /> 		/*<br /> 		 * Find first record that fits, including all following records,<br />&#64;&#64; -1373,12 +1331,10 &#64;&#64; static int syslog_print_all(char __user *buf, int size, bool clear)<br /> 		 */<br /> 		seq = clear_seq;<br /> 		idx = clear_idx;<br />-		prev = 0;<br /> 		while (seq &lt; log_next_seq) {<br /> 			struct printk_log *msg = log_from_idx(idx);<br /> <br />-			len += msg_print_text(msg, prev, true, NULL, 0);<br />-			prev = msg-&gt;flags;<br />+			len += msg_print_text(msg, true, NULL, 0);<br /> 			idx = log_next(idx);<br /> 			seq++;<br /> 		}<br />&#64;&#64; -1386,12 +1342,10 &#64;&#64; static int syslog_print_all(char __user *buf, int size, bool clear)<br /> 		/* move first record forward until length fits into the buffer */<br /> 		seq = clear_seq;<br /> 		idx = clear_idx;<br />-		prev = 0;<br /> 		while (len &gt; size &amp;&amp; seq &lt; log_next_seq) {<br /> 			struct printk_log *msg = log_from_idx(idx);<br /> <br />-			len -= msg_print_text(msg, prev, true, NULL, 0);<br />-			prev = msg-&gt;flags;<br />+			len -= msg_print_text(msg, true, NULL, 0);<br /> 			idx = log_next(idx);<br /> 			seq++;<br /> 		}<br />&#64;&#64; -1404,7 +1358,7 &#64;&#64; static int syslog_print_all(char __user *buf, int size, bool clear)<br /> 			struct printk_log *msg = log_from_idx(idx);<br /> 			int textlen;<br /> <br />-			textlen = msg_print_text(msg, prev, true, text,<br />+			textlen = msg_print_text(msg, true, text,<br /> 						 LOG_LINE_MAX + PREFIX_MAX);<br /> 			if (textlen &lt; 0) {<br /> 				len = textlen;<br />&#64;&#64; -1412,7 +1366,6 &#64;&#64; static int syslog_print_all(char __user *buf, int size, bool clear)<br /> 			}<br /> 			idx = log_next(idx);<br /> 			seq++;<br />-			prev = msg-&gt;flags;<br /> <br /> 			raw_spin_unlock_irq(&amp;logbuf_lock);<br /> 			if (copy_to_user(buf + len, text, textlen))<br />&#64;&#64; -1425,7 +1378,6 &#64;&#64; static int syslog_print_all(char __user *buf, int size, bool clear)<br /> 				/* messages are gone, move to next one */<br /> 				seq = log_first_seq;<br /> 				idx = log_first_idx;<br />-				prev = 0;<br /> 			}<br /> 		}<br /> 	}<br />&#64;&#64; -1522,12 +1474,10 &#64;&#64; int do_syslog(int type, char __user *buf, int len, int source)<br /> 	/* Number of chars in the log buffer */<br /> 	case SYSLOG_ACTION_SIZE_UNREAD:<br /> 		raw_spin_lock_irq(&amp;logbuf_lock);<br />-		cont_flush();<br /> 		if (syslog_seq &lt; log_first_seq) {<br /> 			/* messages are gone, move to first one */<br /> 			syslog_seq = log_first_seq;<br /> 			syslog_idx = log_first_idx;<br />-			syslog_prev = 0;<br /> 			syslog_partial = 0;<br /> 		}<br /> 		if (source == SYSLOG_FROM_PROC) {<br />&#64;&#64; -1540,16 +1490,14 &#64;&#64; int do_syslog(int type, char __user *buf, int len, int source)<br /> 		} else {<br /> 			u64 seq = syslog_seq;<br /> 			u32 idx = syslog_idx;<br />-			enum log_flags prev = syslog_prev;<br /> <br /> 			error = 0;<br /> 			while (seq &lt; log_next_seq) {<br /> 				struct printk_log *msg = log_from_idx(idx);<br /> <br />-				error += msg_print_text(msg, prev, true, NULL, 0);<br />+				error += msg_print_text(msg, true, NULL, 0);<br /> 				idx = log_next(idx);<br /> 				seq++;<br />-				prev = msg-&gt;flags;<br /> 			}<br /> 			error -= syslog_partial;<br /> 		}<br />&#64;&#64; -1563,6 +1511,7 &#64;&#64; int do_syslog(int type, char __user *buf, int len, int source)<br /> 		error = -EINVAL;<br /> 		break;<br /> 	}<br />+	deferred_cont_flush();<br /> out:<br /> 	return error;<br /> }<br />&#64;&#64; -1650,46 +1599,47 &#64;&#64; static inline void printk_delay(void)<br /> static struct cont {<br /> 	char buf[LOG_LINE_MAX];<br /> 	size_t len;			/* length == 0 means unused buffer */<br />-	size_t cons;			/* bytes written to console */<br /> 	struct task_struct *owner;	/* task of first print*/<br /> 	u64 ts_nsec;			/* time of first print */<br /> 	u8 level;			/* log level of first message */<br /> 	u8 facility;			/* log facility of first message */<br /> 	enum log_flags flags;		/* prefix, newline flags */<br />-	bool flushed:1;			/* buffer sealed and committed */<br /> } cont;<br /> <br />-static void cont_flush(void)<br />+static bool cont_flush(void)<br /> {<br />-	if (cont.flushed)<br />-		return;<br />-	if (cont.len == 0)<br />+	if (!cont.len)<br />+		return false;<br />+<br />+	log_store(cont.facility, cont.level, cont.flags, cont.ts_nsec,<br />+		  NULL, 0, cont.buf, cont.len);<br />+	cont.len = 0;<br />+	return true;<br />+}<br />+<br />+static void flush_timer(unsigned long data)<br />+{<br />+	unsigned long flags;<br />+	bool did_flush;<br />+<br />+	raw_spin_lock_irqsave(&amp;logbuf_lock, flags);<br />+	did_flush = cont_flush();<br />+	raw_spin_unlock_irqrestore(&amp;logbuf_lock, flags);<br />+	if (did_flush)<br />+		wake_up_klogd();<br />+}<br />+<br />+static void deferred_cont_flush(void)<br />+{<br />+	static DEFINE_TIMER(timer, flush_timer, 0, 0);<br />+<br />+	if (!cont.len)<br /> 		return;<br />-	if (cont.cons) {<br />-		/*<br />-		 * If a fragment of this line was directly flushed to the<br />-		 * console; wait for the console to pick up the rest of the<br />-		 * line. LOG_NOCONS suppresses a duplicated output.<br />-		 */<br />-		log_store(cont.facility, cont.level, cont.flags | LOG_NOCONS,<br />-			  cont.ts_nsec, NULL, 0, cont.buf, cont.len);<br />-		cont.flushed = true;<br />-	} else {<br />-		/*<br />-		 * If no fragment of this line ever reached the console,<br />-		 * just submit it to the store and free the buffer.<br />-		 */<br />-		log_store(cont.facility, cont.level, cont.flags, 0,<br />-			  NULL, 0, cont.buf, cont.len);<br />-		cont.len = 0;<br />-	}<br />+	mod_timer(&amp;timer, jiffies + HZ/10);<br /> }<br /> <br /> static bool cont_add(int facility, int level, enum log_flags flags, const char *text, size_t len)<br /> {<br />-	if (cont.len &amp;&amp; cont.flushed)<br />-		return false;<br />-<br /> 	/*<br /> 	 * If ext consoles are present, flush and skip in-kernel<br /> 	 * continuation.  See nr_ext_console_drivers definition.  Also, if<br />&#64;&#64; -1706,8 +1656,6 &#64;&#64; static bool cont_add(int facility, int level, enum log_flags flags, const char *<br /> 		cont.owner = current;<br /> 		cont.ts_nsec = local_clock();<br /> 		cont.flags = flags;<br />-		cont.cons = 0;<br />-		cont.flushed = false;<br /> 	}<br /> <br /> 	memcpy(cont.buf + cont.len, text, len);<br />&#64;&#64; -1726,34 +1674,6 &#64;&#64; static bool cont_add(int facility, int level, enum log_flags flags, const char *<br /> 	return true;<br /> }<br /> <br />-static size_t cont_print_text(char *text, size_t size)<br />-{<br />-	size_t textlen = 0;<br />-	size_t len;<br />-<br />-	if (cont.cons == 0 &amp;&amp; (console_prev &amp; LOG_NEWLINE)) {<br />-		textlen += print_time(cont.ts_nsec, text);<br />-		size -= textlen;<br />-	}<br />-<br />-	len = cont.len - cont.cons;<br />-	if (len &gt; 0) {<br />-		if (len+1 &gt; size)<br />-			len = size-1;<br />-		memcpy(text + textlen, cont.buf + cont.cons, len);<br />-		textlen += len;<br />-		cont.cons = cont.len;<br />-	}<br />-<br />-	if (cont.flushed) {<br />-		if (cont.flags &amp; LOG_NEWLINE)<br />-			text[textlen++] = '\n';<br />-		/* got everything, release buffer */<br />-		cont.len = 0;<br />-	}<br />-	return textlen;<br />-}<br />-<br /> static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)<br /> {<br /> 	/*<br />&#64;&#64; -1999,11 +1919,9 &#64;&#64; static u64 syslog_seq;<br /> static u32 syslog_idx;<br /> static u64 console_seq;<br /> static u32 console_idx;<br />-static enum log_flags syslog_prev;<br /> static u64 log_first_seq;<br /> static u32 log_first_idx;<br /> static u64 log_next_seq;<br />-static enum log_flags console_prev;<br /> static struct cont {<br /> 	size_t len;<br /> 	size_t cons;<br />&#64;&#64; -2015,17 +1933,16 &#64;&#64; static char *log_dict(const struct printk_log *msg) { return NULL; }<br /> static struct printk_log *log_from_idx(u32 idx) { return NULL; }<br /> static u32 log_next(u32 idx) { return 0; }<br /> static ssize_t msg_print_ext_header(char *buf, size_t size,<br />-				    struct printk_log *msg, u64 seq,<br />-				    enum log_flags prev_flags) { return 0; }<br />+				    struct printk_log *msg,<br />+				    u64 seq) { return 0; }<br /> static ssize_t msg_print_ext_body(char *buf, size_t size,<br /> 				  char *dict, size_t dict_len,<br /> 				  char *text, size_t text_len) { return 0; }<br /> static void call_console_drivers(int level,<br /> 				 const char *ext_text, size_t ext_len,<br /> 				 const char *text, size_t len) {}<br />-static size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,<br />+static size_t msg_print_text(const struct printk_log *msg,<br /> 			     bool syslog, char *buf, size_t size) { return 0; }<br />-static size_t cont_print_text(char *text, size_t size) { return 0; }<br /> static bool suppress_message_printing(int level) { return false; }<br /> <br /> /* Still needs to be defined for users */<br />&#64;&#64; -2296,42 +2213,6 &#64;&#64; static inline int can_use_console(void)<br /> 	return cpu_online(raw_smp_processor_id()) || have_callable_console();<br /> }<br /> <br />-static void console_cont_flush(char *text, size_t size)<br />-{<br />-	unsigned long flags;<br />-	size_t len;<br />-<br />-	raw_spin_lock_irqsave(&amp;logbuf_lock, flags);<br />-<br />-	if (!cont.len)<br />-		goto out;<br />-<br />-	if (suppress_message_printing(cont.level)) {<br />-		cont.cons = cont.len;<br />-		if (cont.flushed)<br />-			cont.len = 0;<br />-		goto out;<br />-	}<br />-<br />-	/*<br />-	 * We still queue earlier records, likely because the console was<br />-	 * busy. The earlier ones need to be printed before this one, we<br />-	 * did not flush any fragment so far, so just let it queue up.<br />-	 */<br />-	if (console_seq &lt; log_next_seq &amp;&amp; !cont.cons)<br />-		goto out;<br />-<br />-	len = cont_print_text(text, size);<br />-	raw_spin_unlock(&amp;logbuf_lock);<br />-	stop_critical_timings();<br />-	call_console_drivers(cont.level, NULL, 0, text, len);<br />-	start_critical_timings();<br />-	local_irq_restore(flags);<br />-	return;<br />-out:<br />-	raw_spin_unlock_irqrestore(&amp;logbuf_lock, flags);<br />-}<br />-<br /> /**<br />  * console_unlock - unlock the console system<br />  *<br />&#64;&#64; -2385,9 +2266,6 &#64;&#64; void console_unlock(void)<br /> 		return;<br /> 	}<br /> <br />-	/* flush buffered message fragment immediately to console */<br />-	console_cont_flush(text, sizeof(text));<br />-<br /> 	for (;;) {<br /> 		struct printk_log *msg;<br /> 		size_t ext_len = 0;<br />&#64;&#64; -2407,7 +2285,6 &#64;&#64; void console_unlock(void)<br /> 			/* messages are gone, move to first one */<br /> 			console_seq = log_first_seq;<br /> 			console_idx = log_first_idx;<br />-			console_prev = 0;<br /> 		} else {<br /> 			len = 0;<br /> 		}<br />&#64;&#64; -2417,8 +2294,7 &#64;&#64; void console_unlock(void)<br /> <br /> 		msg = log_from_idx(console_idx);<br /> 		level = msg-&gt;level;<br />-		if ((msg-&gt;flags &amp; LOG_NOCONS) ||<br />-				suppress_message_printing(level)) {<br />+		if (suppress_message_printing(level)) {<br /> 			/*<br /> 			 * Skip record we have buffered and already printed<br /> 			 * directly to the console when we received it, and<br />&#64;&#64; -2426,22 +2302,14 &#64;&#64; void console_unlock(void)<br /> 			 */<br /> 			console_idx = log_next(console_idx);<br /> 			console_seq++;<br />-			/*<br />-			 * We will get here again when we register a new<br />-			 * CON_PRINTBUFFER console. Clear the flag so we<br />-			 * will properly dump everything later.<br />-			 */<br />-			msg-&gt;flags &amp;= ~LOG_NOCONS;<br />-			console_prev = msg-&gt;flags;<br /> 			goto skip;<br /> 		}<br /> <br />-		len += msg_print_text(msg, console_prev, false,<br />-				      text + len, sizeof(text) - len);<br />+		len += msg_print_text(msg, false, text + len, sizeof(text) - len);<br /> 		if (nr_ext_console_drivers) {<br /> 			ext_len = msg_print_ext_header(ext_text,<br /> 						sizeof(ext_text),<br />-						msg, console_seq, console_prev);<br />+						msg, console_seq);<br /> 			ext_len += msg_print_ext_body(ext_text + ext_len,<br /> 						sizeof(ext_text) - ext_len,<br /> 						log_dict(msg), msg-&gt;dict_len,<br />&#64;&#64; -2449,7 +2317,6 &#64;&#64; void console_unlock(void)<br /> 		}<br /> 		console_idx = log_next(console_idx);<br /> 		console_seq++;<br />-		console_prev = msg-&gt;flags;<br /> 		raw_spin_unlock(&amp;logbuf_lock);<br /> <br /> 		stop_critical_timings();	/* don't trace print latency */<br />&#64;&#64; -2483,7 +2350,7 &#64;&#64; void console_unlock(void)<br /> 	if (retry &amp;&amp; console_trylock())<br /> 		goto again;<br /> <br />-	if (wake_klogd)<br />+	if (wake_klogd || cont.len)<br /> 		wake_up_klogd();<br /> }<br /> EXPORT_SYMBOL(console_unlock);<br />&#64;&#64; -2744,7 +2611,6 &#64;&#64; void register_console(struct console *newcon)<br /> 		raw_spin_lock_irqsave(&amp;logbuf_lock, flags);<br /> 		console_seq = syslog_seq;<br /> 		console_idx = syslog_idx;<br />-		console_prev = syslog_prev;<br /> 		raw_spin_unlock_irqrestore(&amp;logbuf_lock, flags);<br /> 		/*<br /> 		 * We're about to replay the log buffer.  Only do this to the<br />&#64;&#64; -2883,6 +2749,7 &#64;&#64; static void wake_up_klogd_work_func(struct irq_work *irq_work)<br /> <br /> 	if (pending &amp; PRINTK_PENDING_WAKEUP)<br /> 		wake_up_interruptible(&amp;log_wait);<br />+	deferred_cont_flush();<br /> }<br /> <br /> static DEFINE_PER_CPU(struct irq_work, wake_up_klogd_work) = {<br />&#64;&#64; -3095,7 +2962,7 &#64;&#64; bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,<br /> 		goto out;<br /> <br /> 	msg = log_from_idx(dumper-&gt;cur_idx);<br />-	l = msg_print_text(msg, 0, syslog, line, size);<br />+	l = msg_print_text(msg, syslog, line, size);<br /> <br /> 	dumper-&gt;cur_idx = log_next(dumper-&gt;cur_idx);<br /> 	dumper-&gt;cur_seq++;<br />&#64;&#64; -3165,7 +3032,6 &#64;&#64; bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,<br /> 	u32 idx;<br /> 	u64 next_seq;<br /> 	u32 next_idx;<br />-	enum log_flags prev;<br /> 	size_t l = 0;<br /> 	bool ret = false;<br /> <br />&#64;&#64; -3189,27 +3055,23 &#64;&#64; bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,<br /> 	/* calculate length of entire buffer */<br /> 	seq = dumper-&gt;cur_seq;<br /> 	idx = dumper-&gt;cur_idx;<br />-	prev = 0;<br /> 	while (seq &lt; dumper-&gt;next_seq) {<br /> 		struct printk_log *msg = log_from_idx(idx);<br /> <br />-		l += msg_print_text(msg, prev, true, NULL, 0);<br />+		l += msg_print_text(msg, true, NULL, 0);<br /> 		idx = log_next(idx);<br /> 		seq++;<br />-		prev = msg-&gt;flags;<br /> 	}<br /> <br /> 	/* move first record forward until length fits into the buffer */<br /> 	seq = dumper-&gt;cur_seq;<br /> 	idx = dumper-&gt;cur_idx;<br />-	prev = 0;<br /> 	while (l &gt; size &amp;&amp; seq &lt; dumper-&gt;next_seq) {<br /> 		struct printk_log *msg = log_from_idx(idx);<br /> <br />-		l -= msg_print_text(msg, prev, true, NULL, 0);<br />+		l -= msg_print_text(msg, true, NULL, 0);<br /> 		idx = log_next(idx);<br /> 		seq++;<br />-		prev = msg-&gt;flags;<br /> 	}<br /> <br /> 	/* last message in next interation */<br />&#64;&#64; -3220,10 +3082,9 &#64;&#64; bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,<br /> 	while (seq &lt; dumper-&gt;next_seq) {<br /> 		struct printk_log *msg = log_from_idx(idx);<br /> <br />-		l += msg_print_text(msg, prev, syslog, buf + l, size - l);<br />+		l += msg_print_text(msg, syslog, buf + l, size - l);<br /> 		idx = log_next(idx);<br /> 		seq++;<br />-		prev = msg-&gt;flags;<br /> 	}<br /> <br /> 	dumper-&gt;next_seq = next_seq;</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
