    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/9/22/597">First message in thread</a></li><li><a href="/lkml/2016/9/23/711">Matthew Wilcox</a><ul><li><a href="/lkml/2016/9/24/211">Linus Torvalds</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2016/9/24/219">"Kirill A. Shutemov"</a><ul><li><a href="/lkml/2016/9/24/225">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2016/9/24/217/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 24 Sep 2016 13:47:38 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 2/2] radix-tree: Fix optimisation problem</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sat, Sep 24, 2016 at 1:21 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; That said, if this code isn't even used, as Konstantin says (THP<br />&gt; selects it - doesn't THP use it?), then the fix really should be to<br />&gt; just remove the odd code instead of adding to it.<br />&gt;<br />&gt; Looking around for uses that set "order" to anything but zero, I<br />&gt; really don't see it. So maybe we should just do *that* trivial thing<br />&gt; instead, and remove CONFIG_RADIX_TREE_MULTIORDER, since it's appears<br />&gt; to be buggy and always has been.<br /><br />IOW, a patch something like this?<br /><br />NOTE! This is entirely untested. Things still seem to compile with it,<br />at least with some configurations. That's all I can say.<br /><br />I do like this part:<br /><br />   11 files changed, 29 insertions(+), 518 deletions(-)<br /><br />although admittedly 2/3rds of the deletions were for the multiorder<br />tests. But even if you ignore the test side, it's just fairly clean<br />removal of code that is apparently not used, and that was buggy.<br /><br />               Linus<br /> include/linux/radix-tree.h                    |  48 +---<br /> lib/Kconfig                                   |   3 -<br /> lib/radix-tree.c                              | 100 +-------<br /> mm/Kconfig                                    |   1 -<br /> mm/filemap.c                                  |   2 +-<br /> tools/testing/radix-tree/Makefile             |   2 +-<br /> tools/testing/radix-tree/generated/autoconf.h |   1 -<br /> tools/testing/radix-tree/main.c               |  34 +--<br /> tools/testing/radix-tree/multiorder.c         | 337 --------------------------<br /> tools/testing/radix-tree/test.c               |  14 +-<br /> tools/testing/radix-tree/test.h               |   5 -<br /> 11 files changed, 29 insertions(+), 518 deletions(-)<br /><br />diff --git a/include/linux/radix-tree.h b/include/linux/radix-tree.h<br />index 4c45105dece3..ac546baa604c 100644<br />--- a/include/linux/radix-tree.h<br />+++ b/include/linux/radix-tree.h<br />&#64;&#64; -263,15 +263,9 &#64;&#64; static inline void radix_tree_replace_slot(void **pslot, void *item)<br /> }<br /> <br /> int __radix_tree_create(struct radix_tree_root *root, unsigned long index,<br />-			unsigned order, struct radix_tree_node **nodep,<br />+			struct radix_tree_node **nodep,<br /> 			void ***slotp);<br />-int __radix_tree_insert(struct radix_tree_root *, unsigned long index,<br />-			unsigned order, void *);<br />-static inline int radix_tree_insert(struct radix_tree_root *root,<br />-			unsigned long index, void *entry)<br />-{<br />-	return __radix_tree_insert(root, index, 0, entry);<br />-}<br />+int radix_tree_insert(struct radix_tree_root *, unsigned long index, void *);<br /> void *__radix_tree_lookup(struct radix_tree_root *root, unsigned long index,<br /> 			  struct radix_tree_node **nodep, void ***slotp);<br /> void *radix_tree_lookup(struct radix_tree_root *, unsigned long);<br />&#64;&#64; -338,20 +332,8 &#64;&#64; struct radix_tree_iter {<br /> 	unsigned long	index;<br /> 	unsigned long	next_index;<br /> 	unsigned long	tags;<br />-#ifdef CONFIG_RADIX_TREE_MULTIORDER<br />-	unsigned int	shift;<br />-#endif<br /> };<br /> <br />-static inline unsigned int iter_shift(struct radix_tree_iter *iter)<br />-{<br />-#ifdef CONFIG_RADIX_TREE_MULTIORDER<br />-	return iter-&gt;shift;<br />-#else<br />-	return 0;<br />-#endif<br />-}<br />-<br /> #define RADIX_TREE_ITER_TAG_MASK	0x00FF	/* tag index in lower byte */<br /> #define RADIX_TREE_ITER_TAGGED		0x0100	/* lookup tagged slots */<br /> #define RADIX_TREE_ITER_CONTIG		0x0200	/* stop at first hole */<br />&#64;&#64; -415,7 +397,7 &#64;&#64; void **radix_tree_iter_retry(struct radix_tree_iter *iter)<br /> static inline unsigned long<br /> __radix_tree_iter_add(struct radix_tree_iter *iter, unsigned long slots)<br /> {<br />-	return iter-&gt;index + (slots &lt;&lt; iter_shift(iter));<br />+	return iter-&gt;index + slots;<br /> }<br /> <br /> /**<br />&#64;&#64; -443,7 +425,7 &#64;&#64; void **radix_tree_iter_next(struct radix_tree_iter *iter)<br /> static __always_inline long<br /> radix_tree_chunk_size(struct radix_tree_iter *iter)<br /> {<br />-	return (iter-&gt;next_index - iter-&gt;index) &gt;&gt; iter_shift(iter);<br />+	return iter-&gt;next_index - iter-&gt;index;<br /> }<br /> <br /> static inline struct radix_tree_node *entry_to_node(void *ptr)<br />&#64;&#64; -466,22 +448,9 &#64;&#64; static __always_inline void **<br /> radix_tree_next_slot(void **slot, struct radix_tree_iter *iter, unsigned flags)<br /> {<br /> 	if (flags &amp; RADIX_TREE_ITER_TAGGED) {<br />-		void *canon = slot;<br />-<br /> 		iter-&gt;tags &gt;&gt;= 1;<br /> 		if (unlikely(!iter-&gt;tags))<br /> 			return NULL;<br />-		while (IS_ENABLED(CONFIG_RADIX_TREE_MULTIORDER) &amp;&amp;<br />-					radix_tree_is_internal_node(slot[1])) {<br />-			if (entry_to_node(slot[1]) == canon) {<br />-				iter-&gt;tags &gt;&gt;= 1;<br />-				iter-&gt;index = __radix_tree_iter_add(iter, 1);<br />-				slot++;<br />-				continue;<br />-			}<br />-			iter-&gt;next_index = __radix_tree_iter_add(iter, 1);<br />-			return NULL;<br />-		}<br /> 		if (likely(iter-&gt;tags &amp; 1ul)) {<br /> 			iter-&gt;index = __radix_tree_iter_add(iter, 1);<br /> 			return slot + 1;<br />&#64;&#64; -495,20 +464,11 &#64;&#64; radix_tree_next_slot(void **slot, struct radix_tree_iter *iter, unsigned flags)<br /> 		}<br /> 	} else {<br /> 		long count = radix_tree_chunk_size(iter);<br />-		void *canon = slot;<br /> <br /> 		while (--count &gt; 0) {<br /> 			slot++;<br /> 			iter-&gt;index = __radix_tree_iter_add(iter, 1);<br /> <br />-			if (IS_ENABLED(CONFIG_RADIX_TREE_MULTIORDER) &amp;&amp;<br />-			    radix_tree_is_internal_node(*slot)) {<br />-				if (entry_to_node(*slot) == canon)<br />-					continue;<br />-				iter-&gt;next_index = iter-&gt;index;<br />-				break;<br />-			}<br />-<br /> 			if (likely(*slot))<br /> 				return slot;<br /> 			if (flags &amp; RADIX_TREE_ITER_CONTIG) {<br />diff --git a/lib/Kconfig b/lib/Kconfig<br />index d79909dc01ec..61d55bd0ed89 100644<br />--- a/lib/Kconfig<br />+++ b/lib/Kconfig<br />&#64;&#64; -362,9 +362,6 &#64;&#64; config INTERVAL_TREE<br /> <br /> 	  for more information.<br /> <br />-config RADIX_TREE_MULTIORDER<br />-	bool<br />-<br /> config ASSOCIATIVE_ARRAY<br /> 	bool<br /> 	help<br />diff --git a/lib/radix-tree.c b/lib/radix-tree.c<br />index 1b7bf7314141..b8b12172bb60 100644<br />--- a/lib/radix-tree.c<br />+++ b/lib/radix-tree.c<br />&#64;&#64; -76,21 +76,6 &#64;&#64; static inline void *node_to_entry(void *ptr)<br /> <br /> #define RADIX_TREE_RETRY	node_to_entry(NULL)<br /> <br />-#ifdef CONFIG_RADIX_TREE_MULTIORDER<br />-/* Sibling slots point directly to another slot in the same node */<br />-static inline bool is_sibling_entry(struct radix_tree_node *parent, void *node)<br />-{<br />-	void **ptr = node;<br />-	return (parent-&gt;slots &lt;= ptr) &amp;&amp;<br />-			(ptr &lt; parent-&gt;slots + RADIX_TREE_MAP_SIZE);<br />-}<br />-#else<br />-static inline bool is_sibling_entry(struct radix_tree_node *parent, void *node)<br />-{<br />-	return false;<br />-}<br />-#endif<br />-<br /> static inline unsigned long get_slot_offset(struct radix_tree_node *parent,<br /> 						 void **slot)<br /> {<br />&#64;&#64; -103,16 +88,6 &#64;&#64; static unsigned int radix_tree_descend(struct radix_tree_node *parent,<br /> 	unsigned int offset = (index &gt;&gt; parent-&gt;shift) &amp; RADIX_TREE_MAP_MASK;<br /> 	void **entry = rcu_dereference_raw(parent-&gt;slots[offset]);<br /> <br />-#ifdef CONFIG_RADIX_TREE_MULTIORDER<br />-	if (radix_tree_is_internal_node(entry)) {<br />-		unsigned long siboff = get_slot_offset(parent, entry);<br />-		if (siboff &lt; RADIX_TREE_MAP_SIZE) {<br />-			offset = siboff;<br />-			entry = rcu_dereference_raw(parent-&gt;slots[offset]);<br />-		}<br />-	}<br />-#endif<br />-<br /> 	*nodep = (void *)entry;<br /> 	return offset;<br /> }<br />&#64;&#64; -231,12 +206,7 &#64;&#64; static void dump_node(struct radix_tree_node *node, unsigned long index)<br /> 		void *entry = node-&gt;slots[i];<br /> 		if (!entry)<br /> 			continue;<br />-		if (is_sibling_entry(node, entry)) {<br />-			pr_debug("radix sblng %p offset %ld val %p indices %ld-%ld\n",<br />-					entry, i,<br />-					*(void **)entry_to_node(entry),<br />-					first, last);<br />-		} else if (!radix_tree_is_internal_node(entry)) {<br />+		if (!radix_tree_is_internal_node(entry)) {<br /> 			pr_debug("radix entry %p offset %ld indices %ld-%ld\n",<br /> 					entry, i, first, last);<br /> 		} else {<br />&#64;&#64; -551,29 +521,28 &#64;&#64; out:<br />  *	Returns -ENOMEM, or 0 for success.<br />  */<br /> int __radix_tree_create(struct radix_tree_root *root, unsigned long index,<br />-			unsigned order, struct radix_tree_node **nodep,<br />+			struct radix_tree_node **nodep,<br /> 			void ***slotp)<br /> {<br /> 	struct radix_tree_node *node = NULL, *child;<br /> 	void **slot = (void **)&amp;root-&gt;rnode;<br /> 	unsigned long maxindex;<br /> 	unsigned int shift, offset = 0;<br />-	unsigned long max = index | ((1UL &lt;&lt; order) - 1);<br /> <br /> 	shift = radix_tree_load_root(root, &amp;child, &amp;maxindex);<br /> <br /> 	/* Make sure the tree is high enough.  */<br />-	if (max &gt; maxindex) {<br />-		int error = radix_tree_extend(root, max, shift);<br />+	if (index &gt; maxindex) {<br />+		int error = radix_tree_extend(root, index, shift);<br /> 		if (error &lt; 0)<br /> 			return error;<br /> 		shift = error;<br /> 		child = root-&gt;rnode;<br />-		if (order == shift)<br />+		if (!shift)<br /> 			shift += RADIX_TREE_MAP_SHIFT;<br /> 	}<br /> <br />-	while (shift &gt; order) {<br />+	while (shift &gt; 0) {<br /> 		shift -= RADIX_TREE_MAP_SHIFT;<br /> 		if (child == NULL) {<br /> 			/* Have to add a child node.  */<br />&#64;&#64; -595,25 +564,6 &#64;&#64; int __radix_tree_create(struct radix_tree_root *root, unsigned long index,<br /> 		slot = &amp;node-&gt;slots[offset];<br /> 	}<br /> <br />-#ifdef CONFIG_RADIX_TREE_MULTIORDER<br />-	/* Insert pointers to the canonical entry */<br />-	if (order &gt; shift) {<br />-		unsigned i, n = 1 &lt;&lt; (order - shift);<br />-		offset = offset &amp; ~(n - 1);<br />-		slot = &amp;node-&gt;slots[offset];<br />-		child = node_to_entry(slot);<br />-		for (i = 0; i &lt; n; i++) {<br />-			if (slot[i])<br />-				return -EEXIST;<br />-		}<br />-<br />-		for (i = 1; i &lt; n; i++) {<br />-			rcu_assign_pointer(slot[i], child);<br />-			node-&gt;count++;<br />-		}<br />-	}<br />-#endif<br />-<br /> 	if (nodep)<br /> 		*nodep = node;<br /> 	if (slotp)<br />&#64;&#64; -630,8 +580,7 &#64;&#64; int __radix_tree_create(struct radix_tree_root *root, unsigned long index,<br />  *<br />  *	Insert an item into the radix tree at position &#64;index.<br />  */<br />-int __radix_tree_insert(struct radix_tree_root *root, unsigned long index,<br />-			unsigned order, void *item)<br />+int radix_tree_insert(struct radix_tree_root *root, unsigned long index, void *item)<br /> {<br /> 	struct radix_tree_node *node;<br /> 	void **slot;<br />&#64;&#64; -639,7 +588,7 &#64;&#64; int __radix_tree_insert(struct radix_tree_root *root, unsigned long index,<br /> <br /> 	BUG_ON(radix_tree_is_internal_node(item));<br /> <br />-	error = __radix_tree_create(root, index, order, &amp;node, &amp;slot);<br />+	error = __radix_tree_create(root, index, &amp;node, &amp;slot);<br /> 	if (error)<br /> 		return error;<br /> 	if (*slot != NULL)<br />&#64;&#64; -658,7 +607,7 &#64;&#64; int __radix_tree_insert(struct radix_tree_root *root, unsigned long index,<br /> <br /> 	return 0;<br /> }<br />-EXPORT_SYMBOL(__radix_tree_insert);<br />+EXPORT_SYMBOL(radix_tree_insert);<br /> <br /> /**<br />  *	__radix_tree_lookup	-	lookup an item in a radix tree<br />&#64;&#64; -894,14 +843,6 &#64;&#64; int radix_tree_tag_get(struct radix_tree_root *root,<br /> }<br /> EXPORT_SYMBOL(radix_tree_tag_get);<br /> <br />-static inline void __set_iter_shift(struct radix_tree_iter *iter,<br />-					unsigned int shift)<br />-{<br />-#ifdef CONFIG_RADIX_TREE_MULTIORDER<br />-	iter-&gt;shift = shift;<br />-#endif<br />-}<br />-<br /> /**<br />  * radix_tree_next_chunk - find next chunk of slots for iteration<br />  *<br />&#64;&#64; -945,7 +886,6 &#64;&#64; void **radix_tree_next_chunk(struct radix_tree_root *root,<br /> 		iter-&gt;index = index;<br /> 		iter-&gt;next_index = maxindex + 1;<br /> 		iter-&gt;tags = 1;<br />-		__set_iter_shift(iter, 0);<br /> 		return (void **)&amp;root-&gt;rnode;<br /> 	}<br /> <br />&#64;&#64; -967,8 +907,6 &#64;&#64; void **radix_tree_next_chunk(struct radix_tree_root *root,<br /> 			else<br /> 				while (++offset	&lt; RADIX_TREE_MAP_SIZE) {<br /> 					void *slot = node-&gt;slots[offset];<br />-					if (is_sibling_entry(node, slot))<br />-						continue;<br /> 					if (slot)<br /> 						break;<br /> 				}<br />&#64;&#64; -989,7 +927,6 &#64;&#64; void **radix_tree_next_chunk(struct radix_tree_root *root,<br /> 	/* Update the iterator state */<br /> 	iter-&gt;index = (index &amp;~ node_maxindex(node)) | (offset &lt;&lt; node-&gt;shift);<br /> 	iter-&gt;next_index = (index | node_maxindex(node)) + 1;<br />-	__set_iter_shift(iter, node-&gt;shift);<br /> <br /> 	/* Construct iter-&gt;tags bit-mask from node-&gt;tags[tag] array */<br /> 	if (flags &amp; RADIX_TREE_ITER_TAGGED) {<br />&#64;&#64; -1112,8 +1049,6 &#64;&#64; unsigned long radix_tree_range_tag_if_tagged(struct radix_tree_root *root,<br /> 			node = node-&gt;parent;<br /> 			offset = (index &gt;&gt; node-&gt;shift) &amp; RADIX_TREE_MAP_MASK;<br /> 		}<br />-		if (is_sibling_entry(node, node-&gt;slots[offset]))<br />-			goto next;<br /> 		if (tagged &gt;= nr_to_tag)<br /> 			break;<br /> 	}<br />&#64;&#64; -1329,8 +1264,6 &#64;&#64; static unsigned long __locate(struct radix_tree_node *slot, void *item,<br /> 				continue;<br /> 			}<br /> 			node = entry_to_node(node);<br />-			if (is_sibling_entry(slot, node))<br />-				continue;<br /> 			slot = node;<br /> 			break;<br /> 		}<br />&#64;&#64; -1505,20 +1438,6 &#64;&#64; bool __radix_tree_delete_node(struct radix_tree_root *root,<br /> 	return deleted;<br /> }<br /> <br />-static inline void delete_sibling_entries(struct radix_tree_node *node,<br />-					void *ptr, unsigned offset)<br />-{<br />-#ifdef CONFIG_RADIX_TREE_MULTIORDER<br />-	int i;<br />-	for (i = 1; offset + i &lt; RADIX_TREE_MAP_SIZE; i++) {<br />-		if (node-&gt;slots[offset + i] != ptr)<br />-			break;<br />-		node-&gt;slots[offset + i] = NULL;<br />-		node-&gt;count--;<br />-	}<br />-#endif<br />-}<br />-<br /> /**<br />  *	radix_tree_delete_item    -    delete an item from a radix tree<br />  *	&#64;root:		radix tree root<br />&#64;&#64; -1558,7 +1477,6 &#64;&#64; void *radix_tree_delete_item(struct radix_tree_root *root,<br /> 	for (tag = 0; tag &lt; RADIX_TREE_MAX_TAGS; tag++)<br /> 		node_tag_clear(root, node, tag, offset);<br /> <br />-	delete_sibling_entries(node, node_to_entry(slot), offset);<br /> 	node-&gt;slots[offset] = NULL;<br /> 	node-&gt;count--;<br /> <br />diff --git a/mm/Kconfig b/mm/Kconfig<br />index be0ee11fa0d9..57fad7262c42 100644<br />--- a/mm/Kconfig<br />+++ b/mm/Kconfig<br />&#64;&#64; -412,7 +412,6 &#64;&#64; config TRANSPARENT_HUGEPAGE<br /> 	bool "Transparent Hugepage Support"<br /> 	depends on HAVE_ARCH_TRANSPARENT_HUGEPAGE<br /> 	select COMPACTION<br />-	select RADIX_TREE_MULTIORDER<br /> 	help<br /> 	  Transparent Hugepages allows the kernel to use huge pages and<br /> 	  huge tlb transparently to the applications whenever possible.<br />diff --git a/mm/filemap.c b/mm/filemap.c<br />index 8a287dfc5372..3046d7583267 100644<br />--- a/mm/filemap.c<br />+++ b/mm/filemap.c<br />&#64;&#64; -591,7 +591,7 &#64;&#64; static int page_cache_tree_insert(struct address_space *mapping,<br /> 	void **slot;<br /> 	int error;<br /> <br />-	error = __radix_tree_create(&amp;mapping-&gt;page_tree, page-&gt;index, 0,<br />+	error = __radix_tree_create(&amp;mapping-&gt;page_tree, page-&gt;index,<br /> 				    &amp;node, &amp;slot);<br /> 	if (error)<br /> 		return error;<br />diff --git a/tools/testing/radix-tree/Makefile b/tools/testing/radix-tree/Makefile<br />index 3b530467148e..43febba864bd 100644<br />--- a/tools/testing/radix-tree/Makefile<br />+++ b/tools/testing/radix-tree/Makefile<br />&#64;&#64; -3,7 +3,7 &#64;&#64; CFLAGS += -I. -g -Wall -D_LGPL_SOURCE<br /> LDFLAGS += -lpthread -lurcu<br /> TARGETS = main<br /> OFILES = main.o radix-tree.o linux.o test.o tag_check.o find_next_bit.o \<br />-	 regression1.o regression2.o regression3.o multiorder.o<br />+	 regression1.o regression2.o regression3.o<br /> <br /> targets: $(TARGETS)<br /> <br />diff --git a/tools/testing/radix-tree/generated/autoconf.h b/tools/testing/radix-tree/generated/autoconf.h<br />index ad18cf5a2a3a..a6b5fba4c3e0 100644<br />--- a/tools/testing/radix-tree/generated/autoconf.h<br />+++ b/tools/testing/radix-tree/generated/autoconf.h<br />&#64;&#64; -1,3 +1,2 &#64;&#64;<br />-#define CONFIG_RADIX_TREE_MULTIORDER 1<br /> #define CONFIG_SHMEM 1<br /> #define CONFIG_SWAP 1<br />diff --git a/tools/testing/radix-tree/main.c b/tools/testing/radix-tree/main.c<br />index b7619ff3b552..bdee099410f0 100644<br />--- a/tools/testing/radix-tree/main.c<br />+++ b/tools/testing/radix-tree/main.c<br />&#64;&#64; -232,18 +232,17 &#64;&#64; void copy_tag_check(void)<br /> 	item_kill_tree(&amp;tree);<br /> }<br /> <br />-static void __locate_check(struct radix_tree_root *tree, unsigned long index,<br />-			unsigned order)<br />+static void __locate_check(struct radix_tree_root *tree, unsigned long index)<br /> {<br /> 	struct item *item;<br /> 	unsigned long index2;<br /> <br />-	item_insert_order(tree, index, order);<br />+	item_insert(tree, index);<br /> 	item = item_lookup(tree, index);<br /> 	index2 = radix_tree_locate_item(tree, item);<br /> 	if (index != index2) {<br />-		printf("index %ld order %d inserted; found %ld\n",<br />-			index, order, index2);<br />+		printf("index %ld inserted; found %ld\n",<br />+			index, index2);<br /> 		abort();<br /> 	}<br /> }<br />&#64;&#64; -254,7 +253,7 &#64;&#64; static void __order_0_locate_check(void)<br /> 	int i;<br /> <br /> 	for (i = 0; i &lt; 50; i++)<br />-		__locate_check(&amp;tree, rand() % INT_MAX, 0);<br />+		__locate_check(&amp;tree, rand() % INT_MAX);<br /> <br /> 	item_kill_tree(&amp;tree);<br /> }<br />&#64;&#64; -262,28 +261,23 &#64;&#64; static void __order_0_locate_check(void)<br /> static void locate_check(void)<br /> {<br /> 	RADIX_TREE(tree, GFP_KERNEL);<br />-	unsigned order;<br /> 	unsigned long offset, index;<br /> <br /> 	__order_0_locate_check();<br /> <br />-	for (order = 0; order &lt; 20; order++) {<br />-		for (offset = 0; offset &lt; (1 &lt;&lt; (order + 3));<br />-		     offset += (1UL &lt;&lt; order)) {<br />-			for (index = 0; index &lt; (1UL &lt;&lt; (order + 5));<br />-			     index += (1UL &lt;&lt; order)) {<br />-				__locate_check(&amp;tree, index + offset, order);<br />-			}<br />-			if (radix_tree_locate_item(&amp;tree, &amp;tree) != -1)<br />-				abort();<br />-<br />-			item_kill_tree(&amp;tree);<br />+	for (offset = 0; offset &lt; (1 &lt;&lt; 3); offset++) {<br />+		for (index = 0; index &lt; (1UL &lt;&lt; 5); index++) {<br />+			__locate_check(&amp;tree, index + offset);<br /> 		}<br />+		if (radix_tree_locate_item(&amp;tree, &amp;tree) != -1)<br />+			abort();<br />+<br />+		item_kill_tree(&amp;tree);<br /> 	}<br /> <br /> 	if (radix_tree_locate_item(&amp;tree, &amp;tree) != -1)<br /> 		abort();<br />-	__locate_check(&amp;tree, -1, 0);<br />+	__locate_check(&amp;tree, -1);<br /> 	if (radix_tree_locate_item(&amp;tree, &amp;tree) != -1)<br /> 		abort();<br /> 	item_kill_tree(&amp;tree);<br />&#64;&#64; -294,8 +288,6 &#64;&#64; static void single_thread_tests(bool long_run)<br /> 	int i;<br /> <br /> 	printf("starting single_thread_tests: %d allocated\n", nr_allocated);<br />-	multiorder_checks();<br />-	printf("after multiorder_check: %d allocated\n", nr_allocated);<br /> 	locate_check();<br /> 	printf("after locate_check: %d allocated\n", nr_allocated);<br /> 	tag_check();<br />diff --git a/tools/testing/radix-tree/multiorder.c b/tools/testing/radix-tree/multiorder.c<br />deleted file mode 100644<br />index 39d9b9568fe2..000000000000<br />--- a/tools/testing/radix-tree/multiorder.c<br />+++ /dev/null<br />&#64;&#64; -1,337 +0,0 &#64;&#64;<br />-/*<br />- * multiorder.c: Multi-order radix tree entry testing<br />- * Copyright (c) 2016 Intel Corporation<br />- * Author: Ross Zwisler &lt;ross.zwisler&#64;linux.intel.com&gt;<br />- * Author: Matthew Wilcox &lt;matthew.r.wilcox&#64;intel.com&gt;<br />- *<br />- * This program is free software; you can redistribute it and/or modify it<br />- * under the terms and conditions of the GNU General Public License,<br />- * version 2, as published by the Free Software Foundation.<br />- *<br />- * This program is distributed in the hope it will be useful, but WITHOUT<br />- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or<br />- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for<br />- * more details.<br />- */<br />-#include &lt;linux/radix-tree.h&gt;<br />-#include &lt;linux/slab.h&gt;<br />-#include &lt;linux/errno.h&gt;<br />-<br />-#include "test.h"<br />-<br />-#define for_each_index(i, base, order) \<br />-	for (i = base; i &lt; base + (1 &lt;&lt; order); i++)<br />-<br />-static void __multiorder_tag_test(int index, int order)<br />-{<br />-	RADIX_TREE(tree, GFP_KERNEL);<br />-	int base, err, i;<br />-	unsigned long first = 0;<br />-<br />-	/* our canonical entry */<br />-	base = index &amp; ~((1 &lt;&lt; order) - 1);<br />-<br />-	printf("Multiorder tag test with index %d, canonical entry %d\n",<br />-			index, base);<br />-<br />-	err = item_insert_order(&amp;tree, index, order);<br />-	assert(!err);<br />-<br />-	/*<br />-	 * Verify we get collisions for covered indices.  We try and fail to<br />-	 * insert an exceptional entry so we don't leak memory via<br />-	 * item_insert_order().<br />-	 */<br />-	for_each_index(i, base, order) {<br />-		err = __radix_tree_insert(&amp;tree, i, order,<br />-				(void *)(0xA0 | RADIX_TREE_EXCEPTIONAL_ENTRY));<br />-		assert(err == -EEXIST);<br />-	}<br />-<br />-	for_each_index(i, base, order) {<br />-		assert(!radix_tree_tag_get(&amp;tree, i, 0));<br />-		assert(!radix_tree_tag_get(&amp;tree, i, 1));<br />-	}<br />-<br />-	assert(radix_tree_tag_set(&amp;tree, index, 0));<br />-<br />-	for_each_index(i, base, order) {<br />-		assert(radix_tree_tag_get(&amp;tree, i, 0));<br />-		assert(!radix_tree_tag_get(&amp;tree, i, 1));<br />-	}<br />-<br />-	assert(radix_tree_range_tag_if_tagged(&amp;tree, &amp;first, ~0UL, 10, 0, 1) == 1);<br />-	assert(radix_tree_tag_clear(&amp;tree, index, 0));<br />-<br />-	for_each_index(i, base, order) {<br />-		assert(!radix_tree_tag_get(&amp;tree, i, 0));<br />-		assert(radix_tree_tag_get(&amp;tree, i, 1));<br />-	}<br />-<br />-	assert(radix_tree_tag_clear(&amp;tree, index, 1));<br />-<br />-	assert(!radix_tree_tagged(&amp;tree, 0));<br />-	assert(!radix_tree_tagged(&amp;tree, 1));<br />-<br />-	item_kill_tree(&amp;tree);<br />-}<br />-<br />-static void multiorder_tag_tests(void)<br />-{<br />-	/* test multi-order entry for indices 0-7 with no sibling pointers */<br />-	__multiorder_tag_test(0, 3);<br />-	__multiorder_tag_test(5, 3);<br />-<br />-	/* test multi-order entry for indices 8-15 with no sibling pointers */<br />-	__multiorder_tag_test(8, 3);<br />-	__multiorder_tag_test(15, 3);<br />-<br />-	/*<br />-	 * Our order 5 entry covers indices 0-31 in a tree with height=2.<br />-	 * This is broken up as follows:<br />-	 * 0-7:		canonical entry<br />-	 * 8-15:	sibling 1<br />-	 * 16-23:	sibling 2<br />-	 * 24-31:	sibling 3<br />-	 */<br />-	__multiorder_tag_test(0, 5);<br />-	__multiorder_tag_test(29, 5);<br />-<br />-	/* same test, but with indices 32-63 */<br />-	__multiorder_tag_test(32, 5);<br />-	__multiorder_tag_test(44, 5);<br />-<br />-	/*<br />-	 * Our order 8 entry covers indices 0-255 in a tree with height=3.<br />-	 * This is broken up as follows:<br />-	 * 0-63:	canonical entry<br />-	 * 64-127:	sibling 1<br />-	 * 128-191:	sibling 2<br />-	 * 192-255:	sibling 3<br />-	 */<br />-	__multiorder_tag_test(0, 8);<br />-	__multiorder_tag_test(190, 8);<br />-<br />-	/* same test, but with indices 256-511 */<br />-	__multiorder_tag_test(256, 8);<br />-	__multiorder_tag_test(300, 8);<br />-<br />-	__multiorder_tag_test(0x12345678UL, 8);<br />-}<br />-<br />-static void multiorder_check(unsigned long index, int order)<br />-{<br />-	unsigned long i;<br />-	unsigned long min = index &amp; ~((1UL &lt;&lt; order) - 1);<br />-	unsigned long max = min + (1UL &lt;&lt; order);<br />-	RADIX_TREE(tree, GFP_KERNEL);<br />-<br />-	printf("Multiorder index %ld, order %d\n", index, order);<br />-<br />-	assert(item_insert_order(&amp;tree, index, order) == 0);<br />-<br />-	for (i = min; i &lt; max; i++) {<br />-		struct item *item = item_lookup(&amp;tree, i);<br />-		assert(item != 0);<br />-		assert(item-&gt;index == index);<br />-	}<br />-	for (i = 0; i &lt; min; i++)<br />-		item_check_absent(&amp;tree, i);<br />-	for (i = max; i &lt; 2*max; i++)<br />-		item_check_absent(&amp;tree, i);<br />-	for (i = min; i &lt; max; i++) {<br />-		static void *entry = (void *)<br />-					(0xA0 | RADIX_TREE_EXCEPTIONAL_ENTRY);<br />-		assert(radix_tree_insert(&amp;tree, i, entry) == -EEXIST);<br />-	}<br />-<br />-	assert(item_delete(&amp;tree, index) != 0);<br />-<br />-	for (i = 0; i &lt; 2*max; i++)<br />-		item_check_absent(&amp;tree, i);<br />-}<br />-<br />-static void multiorder_shrink(unsigned long index, int order)<br />-{<br />-	unsigned long i;<br />-	unsigned long max = 1 &lt;&lt; order;<br />-	RADIX_TREE(tree, GFP_KERNEL);<br />-	struct radix_tree_node *node;<br />-<br />-	printf("Multiorder shrink index %ld, order %d\n", index, order);<br />-<br />-	assert(item_insert_order(&amp;tree, 0, order) == 0);<br />-<br />-	node = tree.rnode;<br />-<br />-	assert(item_insert(&amp;tree, index) == 0);<br />-	assert(node != tree.rnode);<br />-<br />-	assert(item_delete(&amp;tree, index) != 0);<br />-	assert(node == tree.rnode);<br />-<br />-	for (i = 0; i &lt; max; i++) {<br />-		struct item *item = item_lookup(&amp;tree, i);<br />-		assert(item != 0);<br />-		assert(item-&gt;index == 0);<br />-	}<br />-	for (i = max; i &lt; 2*max; i++)<br />-		item_check_absent(&amp;tree, i);<br />-<br />-	if (!item_delete(&amp;tree, 0)) {<br />-		printf("failed to delete index %ld (order %d)\n", index, order);		abort();<br />-	}<br />-<br />-	for (i = 0; i &lt; 2*max; i++)<br />-		item_check_absent(&amp;tree, i);<br />-}<br />-<br />-static void multiorder_insert_bug(void)<br />-{<br />-	RADIX_TREE(tree, GFP_KERNEL);<br />-<br />-	item_insert(&amp;tree, 0);<br />-	radix_tree_tag_set(&amp;tree, 0, 0);<br />-	item_insert_order(&amp;tree, 3 &lt;&lt; 6, 6);<br />-<br />-	item_kill_tree(&amp;tree);<br />-}<br />-<br />-void multiorder_iteration(void)<br />-{<br />-	RADIX_TREE(tree, GFP_KERNEL);<br />-	struct radix_tree_iter iter;<br />-	void **slot;<br />-	int i, j, err;<br />-<br />-	printf("Multiorder iteration test\n");<br />-<br />-#define NUM_ENTRIES 11<br />-	int index[NUM_ENTRIES] = {0, 2, 4, 8, 16, 32, 34, 36, 64, 72, 128};<br />-	int order[NUM_ENTRIES] = {1, 1, 2, 3,  4,  1,  0,  1,  3,  0, 7};<br />-<br />-	for (i = 0; i &lt; NUM_ENTRIES; i++) {<br />-		err = item_insert_order(&amp;tree, index[i], order[i]);<br />-		assert(!err);<br />-	}<br />-<br />-	for (j = 0; j &lt; 256; j++) {<br />-		for (i = 0; i &lt; NUM_ENTRIES; i++)<br />-			if (j &lt;= (index[i] | ((1 &lt;&lt; order[i]) - 1)))<br />-				break;<br />-<br />-		radix_tree_for_each_slot(slot, &amp;tree, &amp;iter, j) {<br />-			int height = order[i] / RADIX_TREE_MAP_SHIFT;<br />-			int shift = height * RADIX_TREE_MAP_SHIFT;<br />-			int mask = (1 &lt;&lt; order[i]) - 1;<br />-<br />-			assert(iter.index &gt;= (index[i] &amp;~ mask));<br />-			assert(iter.index &lt;= (index[i] | mask));<br />-			assert(iter.shift == shift);<br />-			i++;<br />-		}<br />-	}<br />-<br />-	item_kill_tree(&amp;tree);<br />-}<br />-<br />-void multiorder_tagged_iteration(void)<br />-{<br />-	RADIX_TREE(tree, GFP_KERNEL);<br />-	struct radix_tree_iter iter;<br />-	void **slot;<br />-	unsigned long first = 0;<br />-	int i, j;<br />-<br />-	printf("Multiorder tagged iteration test\n");<br />-<br />-#define MT_NUM_ENTRIES 9<br />-	int index[MT_NUM_ENTRIES] = {0, 2, 4, 16, 32, 40, 64, 72, 128};<br />-	int order[MT_NUM_ENTRIES] = {1, 0, 2, 4,  3,  1,  3,  0,   7};<br />-<br />-#define TAG_ENTRIES 7<br />-	int tag_index[TAG_ENTRIES] = {0, 4, 16, 40, 64, 72, 128};<br />-<br />-	for (i = 0; i &lt; MT_NUM_ENTRIES; i++)<br />-		assert(!item_insert_order(&amp;tree, index[i], order[i]));<br />-<br />-	assert(!radix_tree_tagged(&amp;tree, 1));<br />-<br />-	for (i = 0; i &lt; TAG_ENTRIES; i++)<br />-		assert(radix_tree_tag_set(&amp;tree, tag_index[i], 1));<br />-<br />-	for (j = 0; j &lt; 256; j++) {<br />-		int mask, k;<br />-<br />-		for (i = 0; i &lt; TAG_ENTRIES; i++) {<br />-			for (k = i; index[k] &lt; tag_index[i]; k++)<br />-				;<br />-			if (j &lt;= (index[k] | ((1 &lt;&lt; order[k]) - 1)))<br />-				break;<br />-		}<br />-<br />-		radix_tree_for_each_tagged(slot, &amp;tree, &amp;iter, j, 1) {<br />-			for (k = i; index[k] &lt; tag_index[i]; k++)<br />-				;<br />-			mask = (1 &lt;&lt; order[k]) - 1;<br />-<br />-			assert(iter.index &gt;= (tag_index[i] &amp;~ mask));<br />-			assert(iter.index &lt;= (tag_index[i] | mask));<br />-			i++;<br />-		}<br />-	}<br />-<br />-	radix_tree_range_tag_if_tagged(&amp;tree, &amp;first, ~0UL,<br />-					MT_NUM_ENTRIES, 1, 2);<br />-<br />-	for (j = 0; j &lt; 256; j++) {<br />-		int mask, k;<br />-<br />-		for (i = 0; i &lt; TAG_ENTRIES; i++) {<br />-			for (k = i; index[k] &lt; tag_index[i]; k++)<br />-				;<br />-			if (j &lt;= (index[k] | ((1 &lt;&lt; order[k]) - 1)))<br />-				break;<br />-		}<br />-<br />-		radix_tree_for_each_tagged(slot, &amp;tree, &amp;iter, j, 2) {<br />-			for (k = i; index[k] &lt; tag_index[i]; k++)<br />-				;<br />-			mask = (1 &lt;&lt; order[k]) - 1;<br />-<br />-			assert(iter.index &gt;= (tag_index[i] &amp;~ mask));<br />-			assert(iter.index &lt;= (tag_index[i] | mask));<br />-			i++;<br />-		}<br />-	}<br />-<br />-	first = 1;<br />-	radix_tree_range_tag_if_tagged(&amp;tree, &amp;first, ~0UL,<br />-					MT_NUM_ENTRIES, 1, 0);<br />-	i = 0;<br />-	radix_tree_for_each_tagged(slot, &amp;tree, &amp;iter, 0, 0) {<br />-		assert(iter.index == tag_index[i]);<br />-		i++;<br />-	}<br />-<br />-	item_kill_tree(&amp;tree);<br />-}<br />-<br />-void multiorder_checks(void)<br />-{<br />-	int i;<br />-<br />-	for (i = 0; i &lt; 20; i++) {<br />-		multiorder_check(200, i);<br />-		multiorder_check(0, i);<br />-		multiorder_check((1UL &lt;&lt; i) + 1, i);<br />-	}<br />-<br />-	for (i = 0; i &lt; 15; i++)<br />-		multiorder_shrink((1UL &lt;&lt; (i + RADIX_TREE_MAP_SHIFT)), i);<br />-<br />-	multiorder_insert_bug();<br />-	multiorder_tag_tests();<br />-	multiorder_iteration();<br />-	multiorder_tagged_iteration();<br />-}<br />diff --git a/tools/testing/radix-tree/test.c b/tools/testing/radix-tree/test.c<br />index a6e8099eaf4f..81377b40af79 100644<br />--- a/tools/testing/radix-tree/test.c<br />+++ b/tools/testing/radix-tree/test.c<br />&#64;&#64; -24,21 +24,9 &#64;&#64; int item_tag_get(struct radix_tree_root *root, unsigned long index, int tag)<br /> 	return radix_tree_tag_get(root, index, tag);<br /> }<br /> <br />-int __item_insert(struct radix_tree_root *root, struct item *item,<br />-			unsigned order)<br />-{<br />-	return __radix_tree_insert(root, item-&gt;index, order, item);<br />-}<br />-<br /> int item_insert(struct radix_tree_root *root, unsigned long index)<br /> {<br />-	return __item_insert(root, item_create(index), 0);<br />-}<br />-<br />-int item_insert_order(struct radix_tree_root *root, unsigned long index,<br />-			unsigned order)<br />-{<br />-	return __item_insert(root, item_create(index), order);<br />+	return radix_tree_insert(root, index, item_create(index));<br /> }<br /> <br /> int item_delete(struct radix_tree_root *root, unsigned long index)<br />diff --git a/tools/testing/radix-tree/test.h b/tools/testing/radix-tree/test.h<br />index e85131369723..7c2e290e4c3e 100644<br />--- a/tools/testing/radix-tree/test.h<br />+++ b/tools/testing/radix-tree/test.h<br />&#64;&#64; -8,11 +8,7 &#64;&#64; struct item {<br /> };<br /> <br /> struct item *item_create(unsigned long index);<br />-int __item_insert(struct radix_tree_root *root, struct item *item,<br />-			unsigned order);<br /> int item_insert(struct radix_tree_root *root, unsigned long index);<br />-int item_insert_order(struct radix_tree_root *root, unsigned long index,<br />-			unsigned order);<br /> int item_delete(struct radix_tree_root *root, unsigned long index);<br /> struct item *item_lookup(struct radix_tree_root *root, unsigned long index);<br /> <br />&#64;&#64; -26,7 +22,6 &#64;&#64; void item_full_scan(struct radix_tree_root *root, unsigned long start,<br /> void item_kill_tree(struct radix_tree_root *root);<br /> <br /> void tag_check(void);<br />-void multiorder_checks(void);<br /> <br /> struct item *<br /> item_tag_set(struct radix_tree_root *root, unsigned long index, int tag);</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
