    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/8/19/671">First message in thread</a></li><li><a href="/lkml/2016/8/21/9">Al Viro</a><ul><li><a href="/lkml/2016/8/21/277">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2016/8/22/881">Linus Torvalds</a><ul><li><a href="/lkml/2016/8/22/881">"H. Peter Anvin"</a><ul><li><a href="/lkml/2016/8/22/946">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2016/8/22/888">"H. Peter Anvin"</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2016/8/22/828/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 22 Aug 2016 15:23:06 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] ARC: uaccess: get_user to zero out dest in cause of fault</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Aug 21, 2016 at 10:52 AM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt; On Sat, Aug 20, 2016 at 11:42 PM, Al Viro &lt;viro&#64;zeniv.linux.org.uk&gt; wrote:<br />&gt;&gt;<br />&gt;&gt; It's not exactly setjmp/longjmp; what I had in mind was along the lines of<br />&gt;<br />&gt; That ends up having all the exact same issues as setjmp, and generally<br />&gt; you *do* want the compiler to know about it.<br /><br />So just in case you wanted to play around with it, here's a kernel<br />implementation of 'setjmp/longjmp' for x86.<br /><br />It's very lightly tested (and I'll admit to editing it for some<br />cleanups after that light testing), but it does look largely sane.<br /><br />The whole interface choice may be debatable: maybe it would be better<br />to allocate the register buffer on the stack, and just hide a pointer<br />to it in the task struct. Things like that could be changed fairly<br />easily. But if you want to play around with this, this patch should<br />get you started.<br /><br />Of course, you'd want to wrap things up somehow, and I would *not*<br />want to see naked setjmp() calls in the kernel.<br /><br />And we'd need this for all other architectures too, but it's usually<br />not hard to do. It needs to save all the callee-saved registers and<br />the stack pointer and return address. That should generally be it.<br /><br />The 32-bit version has not been tested at all, but it compiled at some<br />point, and the code looks mostly sane. The 64-bit code I actually had<br />a stupid non-user-access test-case for.<br /><br />                Linus<br />commit a8062ecb780bed81eaec10bd9fea60bf595a9c40<br />Author: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />Date:   Mon Aug 22 13:15:51 2016 -0700<br /><br />    x86: add basic setjmp/longjmp implementation<br /><br />    To make the compiler happy, we have to actually call it setjmp/longjmp<br />    too.  Even if the exact semantics aren't the same - we keep the register<br />    buffer in the thread structure, for example, rather than pass it in as<br />    an argument.<br /><br />    Signed-off-by: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />---<br /> arch/x86/include/asm/processor.h |  2 ++<br /> arch/x86/include/asm/setjmp.h    | 31 ++++++++++++++++++++++++++++++<br /> arch/x86/kernel/asm-offsets.c    |  1 +<br /> arch/x86/lib/Makefile            |  1 +<br /> arch/x86/lib/setjmp_32.S         | 37 ++++++++++++++++++++++++++++++++++++<br /> arch/x86/lib/setjmp_64.S         | 41 ++++++++++++++++++++++++++++++++++++++++<br /> include/linux/setjmp.h           | 19 +++++++++++++++++++<br /> 7 files changed, 132 insertions(+)<br /><br />diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h<br />index 63def9537a2d..1af2c7025d51 100644<br />--- a/arch/x86/include/asm/processor.h<br />+++ b/arch/x86/include/asm/processor.h<br />&#64;&#64; -22,6 +22,7 &#64;&#64; struct vm86;<br /> #include &lt;asm/nops.h&gt;<br /> #include &lt;asm/special_insns.h&gt;<br /> #include &lt;asm/fpu/types.h&gt;<br />+#include &lt;asm/setjmp.h&gt;<br /> <br /> #include &lt;linux/personality.h&gt;<br /> #include &lt;linux/cache.h&gt;<br />&#64;&#64; -425,6 +426,7 &#64;&#64; struct thread_struct {<br /> 	unsigned		io_bitmap_max;<br /> <br /> 	mm_segment_t		addr_limit;<br />+	struct setjmp		setjmp;<br /> <br /> 	unsigned int		sig_on_uaccess_err:1;<br /> 	unsigned int		uaccess_err:1;	/* uaccess failed */<br />diff --git a/arch/x86/include/asm/setjmp.h b/arch/x86/include/asm/setjmp.h<br />new file mode 100644<br />index 000000000000..6cda8608ce04<br />--- /dev/null<br />+++ b/arch/x86/include/asm/setjmp.h<br />&#64;&#64; -0,0 +1,31 &#64;&#64;<br />+#ifndef _ASM_SETJMP_H<br />+#define _ASM_SETJMP_H<br />+<br />+/*<br />+ * setjmp needs to save the callee-saved registers and<br />+ * the stack setup, so that it looks like a normal call.<br />+ *<br />+ * In addition, gcc needs to know that it's setjmp, but<br />+ * that seems to literally just trigger on the name.<br />+ *<br />+ * Unlike the legacy C implementation, we just have the<br />+ * save area in the task structure.<br />+ */<br />+<br />+#ifdef CONFIG_X86_64<br />+<br />+struct setjmp {<br />+	unsigned long rbx, r12, r13, r14, r15;<br />+	unsigned long rbp, rsp, rip;<br />+};<br />+<br />+#else<br />+<br />+struct setjmp {<br />+	unsigned long ebx, esi, edi;<br />+	unsigned long ebp, esp, eip;<br />+};<br />+<br />+#endif<br />+<br />+#endif // _ASM_SETJMP_H<br />diff --git a/arch/x86/kernel/asm-offsets.c b/arch/x86/kernel/asm-offsets.c<br />index 2bd5c6ff7ee7..78a10eb048e8 100644<br />--- a/arch/x86/kernel/asm-offsets.c<br />+++ b/arch/x86/kernel/asm-offsets.c<br />&#64;&#64; -34,6 +34,7 &#64;&#64; void common(void) {<br /> <br /> 	BLANK();<br /> 	OFFSET(TASK_addr_limit, task_struct, thread.addr_limit);<br />+	OFFSET(TASK_setjmp, task_struct, thread.setjmp);<br /> <br /> 	BLANK();<br /> 	OFFSET(crypto_tfm_ctx_offset, crypto_tfm, __crt_ctx);<br />diff --git a/arch/x86/lib/Makefile b/arch/x86/lib/Makefile<br />index 34a74131a12c..bb7a34648c2c 100644<br />--- a/arch/x86/lib/Makefile<br />+++ b/arch/x86/lib/Makefile<br />&#64;&#64; -22,6 +22,7 &#64;&#64; obj-$(CONFIG_SMP) += msr-smp.o cache-smp.o<br /> lib-y := delay.o misc.o cmdline.o cpu.o<br /> lib-y += usercopy_$(BITS).o usercopy.o getuser.o putuser.o<br /> lib-y += memcpy_$(BITS).o<br />+lib-y += setjmp_$(BITS).o<br /> lib-$(CONFIG_RWSEM_XCHGADD_ALGORITHM) += rwsem.o<br /> lib-$(CONFIG_INSTRUCTION_DECODER) += insn.o inat.o<br /> lib-$(CONFIG_RANDOMIZE_BASE) += kaslr.o<br />diff --git a/arch/x86/lib/setjmp_32.S b/arch/x86/lib/setjmp_32.S<br />new file mode 100644<br />index 000000000000..44f3d52ee40c<br />--- /dev/null<br />+++ b/arch/x86/lib/setjmp_32.S<br />&#64;&#64; -0,0 +1,37 &#64;&#64;<br />+#include &lt;linux/linkage.h&gt;<br />+#include &lt;asm/asm-offsets.h&gt;<br />+#include &lt;asm/asm.h&gt;<br />+#include &lt;asm/percpu.h&gt;<br />+<br />+// The explicit add of TASK_setjmp keeps the<br />+// following offset 8-bit values, and shrinks<br />+// the modrm bytes in the instructions that<br />+// follow.<br />+<br />+ENTRY(setjmp)<br />+	movl PER_CPU_VAR(current_task),%eax<br />+	addl $TASK_setjmp,%eax<br />+<br />+	movl %ebx,(%eax)<br />+	movl %esi,4(%eax)<br />+	movl %edi,8(%eax)<br />+	movl %ebp,12(%eax)<br />+	lea 4(%esp),%edx<br />+	movl %edx,16(%eax)<br />+	movl (%esp),%edx<br />+	movl %edx,20(%eax)<br />+	xorl %eax,%eax<br />+	ret<br />+<br />+ENTRY(longjmp)<br />+	movl PER_CPU_VAR(current_task),%eax<br />+	addl $TASK_setjmp,%eax<br />+<br />+	movl (%eax),%ebx<br />+	movl 4(%eax),%esi<br />+	movl 8(%eax),%edi<br />+	movl 12(%eax),%ebp<br />+	movl 16(%eax),%esp<br />+	movl 20(%eax),%edx<br />+	movl $1,%eax<br />+	jmp *%edx<br />diff --git a/arch/x86/lib/setjmp_64.S b/arch/x86/lib/setjmp_64.S<br />new file mode 100644<br />index 000000000000..c113e132e4d8<br />--- /dev/null<br />+++ b/arch/x86/lib/setjmp_64.S<br />&#64;&#64; -0,0 +1,41 &#64;&#64;<br />+#include &lt;linux/linkage.h&gt;<br />+#include &lt;asm/asm-offsets.h&gt;<br />+#include &lt;asm/asm.h&gt;<br />+#include &lt;asm/percpu.h&gt;<br />+<br />+// The explicit add of TASK_setjmp keeps the<br />+// following offset 8-bit values, and shrinks<br />+// the modrm bytes in the instructions that<br />+// follow.<br />+<br />+ENTRY(setjmp)<br />+	movq PER_CPU_VAR(current_task),%rax<br />+	addq $TASK_setjmp,%rax<br />+<br />+	movq %rbx,(%rax)<br />+	movq %r12,8(%rax)<br />+	movq %r13,16(%rax)<br />+	movq %r14,24(%rax)<br />+	movq %r15,32(%rax)<br />+	movq %rbp,40(%rax)<br />+	lea 8(%rsp),%rdx<br />+	movq %rdx,48(%rax)<br />+	movq (%rsp),%rdx<br />+	movq %rdx,56(%rax)<br />+	xorl %eax,%eax<br />+	ret<br />+<br />+ENTRY(longjmp)<br />+	movq PER_CPU_VAR(current_task),%rax<br />+	addq $TASK_setjmp,%rax<br />+<br />+	movq (%rax),%rbx<br />+	movq 8(%rax),%r12<br />+	movq 16(%rax),%r13<br />+	movq 24(%rax),%r14<br />+	movq 32(%rax),%r15<br />+	movq 40(%rax),%rbp<br />+	movq 48(%rax),%rsp<br />+	movq 56(%rax),%rdx<br />+	movl $1,%eax<br />+	jmp *%rdx<br />diff --git a/include/linux/setjmp.h b/include/linux/setjmp.h<br />new file mode 100644<br />index 000000000000..42d4674791e8<br />--- /dev/null<br />+++ b/include/linux/setjmp.h<br />&#64;&#64; -0,0 +1,19 &#64;&#64;<br />+#ifndef _LINUX_SETJMP_H<br />+#define _LINUX_SETJMP_H<br />+<br />+#include &lt;linux/compiler.h&gt;<br />+<br />+//<br />+// NOTE! We call it 'setjmp' to make gcc treat it specially,<br />+// but the calling conventions are different from the regular<br />+// user-space setjmp.<br />+//<br />+// So setjmp() always returns 0/1, and the  register buffer<br />+// is always in the task struct rather than being passed in<br />+// as an argument.<br />+//<br />+<br />+extern int setjmp(void);<br />+extern void __noreturn longjmp(void);<br />+<br />+#endif // _LINUX_SETJMP_H</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
