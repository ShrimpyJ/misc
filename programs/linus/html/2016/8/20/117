    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/8/19/671">First message in thread</a></li><li><a href="/lkml/2016/8/19/757">Linus Torvalds</a><ul><li><a href="/lkml/2016/8/19/759">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2016/8/20/118">Linus Torvalds</a><ul><li><a href="/lkml/2016/8/20/118">Al Viro</a><ul><li><a href="/lkml/2016/8/20/121">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2016/8/20/117/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 20 Aug 2016 16:32:57 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] ARC: uaccess: get_user to zero out dest in cause of fault</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Aug 19, 2016 at 3:11 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;&gt;<br />&gt;&gt; (I have some experimental patches that actually use "asm goto" in<br />&gt;&gt; "unsafe_put_user()" to get that nice code generation, but they only<br />&gt;&gt; work if your gcc version supports "asm goto", which some older<br />&gt;&gt; versions of gcc does not)<br />&gt;<br />&gt; Since you actually are looking at the user access stuff, I'll just put<br />&gt; them here.<br /><br />Here's an updated patch that applies on current git and that actually<br />uses this for filldir() (but not signal handling).<br /><br />It turns out that on Skylake, which supports SMAP, the clac/stac<br />instructions are quite slow, and doing them for each access makes<br />things insanely much slower than it could be. And "filldir" does the<br />user accesses one by one (except for the name copying), and is<br />actually somewhat common under some loads (ie the "find . -name XYZ"<br />kind of thing).<br /><br />Anyway, the asm coming out of gcc looks nasty, because it has all the<br />ugly section stuiff and fixups for SMAP not existing on some CPU's<br />etc. So the resulting fs/readdir.s file is hard to read. But if you<br />look at the disassembly at the object file that hides all that (and<br />shows what the end result actually is), the actual filldir user<br />accesses end up looking beautiful, with no extra code anywhere. An<br />exception just goes to the EFAULT handling directly.<br /><br />Sadly, unsafe_get_user() looking as good does require gcc improvements<br />that aren't imminent.<br /><br />This patch is untested, although the earlier original pre-rebased<br />version of it actually got a fair amount of testing on my machine<br />(including the filldir use)<br /><br />                    Linus<br /> arch/x86/include/asm/uaccess.h | 80 ++++++++++++++++++++----------------------<br /> fs/readdir.c                   | 22 ++++++------<br /> 2 files changed, 51 insertions(+), 51 deletions(-)<br /><br />diff --git a/arch/x86/include/asm/uaccess.h b/arch/x86/include/asm/uaccess.h<br />index a0ae610b9280..8d6b299522f1 100644<br />--- a/arch/x86/include/asm/uaccess.h<br />+++ b/arch/x86/include/asm/uaccess.h<br />&#64;&#64; -204,19 +204,14 &#64;&#64; __typeof__(__builtin_choose_expr(sizeof(x) &gt; sizeof(0UL), 0ULL, 0UL))<br /> <br /> <br /> #ifdef CONFIG_X86_32<br />-#define __put_user_asm_u64(x, addr, err, errret)			\<br />-	asm volatile("\n"						\<br />-		     "1:	movl %%eax,0(%2)\n"			\<br />-		     "2:	movl %%edx,4(%2)\n"			\<br />-		     "3:"						\<br />-		     ".section .fixup,\"ax\"\n"				\<br />-		     "4:	movl %3,%0\n"				\<br />-		     "	jmp 3b\n"					\<br />-		     ".previous\n"					\<br />-		     _ASM_EXTABLE(1b, 4b)				\<br />-		     _ASM_EXTABLE(2b, 4b)				\<br />-		     : "=r" (err)					\<br />-		     : "A" (x), "r" (addr), "i" (errret), "0" (err))<br />+#define __put_user_goto_u64(x, addr, label)			\<br />+	asm volatile("\n"					\<br />+		     "1:	movl %%eax,0(%2)\n"		\<br />+		     "2:	movl %%edx,4(%2)\n"		\<br />+		     _ASM_EXTABLE(1b, %2l)			\<br />+		     _ASM_EXTABLE(2b, %2l)			\<br />+		     : : "A" (x), "r" (addr)			\<br />+		     : : label)<br /> <br /> #define __put_user_asm_ex_u64(x, addr)					\<br /> 	asm volatile("\n"						\<br />&#64;&#64; -231,8 +226,8 &#64;&#64; __typeof__(__builtin_choose_expr(sizeof(x) &gt; sizeof(0UL), 0ULL, 0UL))<br /> 	asm volatile("call __put_user_8" : "=a" (__ret_pu)	\<br /> 		     : "A" ((typeof(*(ptr)))(x)), "c" (ptr) : "ebx")<br /> #else<br />-#define __put_user_asm_u64(x, ptr, retval, errret) \<br />-	__put_user_asm(x, ptr, retval, "q", "", "er", errret)<br />+#define __put_user_goto_u64(x, ptr, label) \<br />+	__put_user_goto(x, ptr, "q", "", "er", label)<br /> #define __put_user_asm_ex_u64(x, addr)	\<br /> 	__put_user_asm_ex(x, addr, "q", "", "er")<br /> #define __put_user_x8(x, ptr, __ret_pu) __put_user_x(8, x, ptr, __ret_pu)<br />&#64;&#64; -293,23 +288,21 &#64;&#64; extern void __put_user_8(void);<br /> 	__builtin_expect(__ret_pu, 0);				\<br /> })<br /> <br />-#define __put_user_size(x, ptr, size, retval, errret)			\<br />+#define __put_user_size(x, ptr, size, label)				\<br /> do {									\<br />-	retval = 0;							\<br /> 	__chk_user_ptr(ptr);						\<br /> 	switch (size) {							\<br /> 	case 1:								\<br />-		__put_user_asm(x, ptr, retval, "b", "b", "iq", errret);	\<br />+		__put_user_goto(x, ptr, "b", "b", "iq", label);	\<br /> 		break;							\<br /> 	case 2:								\<br />-		__put_user_asm(x, ptr, retval, "w", "w", "ir", errret);	\<br />+		__put_user_goto(x, ptr, "w", "w", "ir", label);		\<br /> 		break;							\<br /> 	case 4:								\<br />-		__put_user_asm(x, ptr, retval, "l", "k", "ir", errret);	\<br />+		__put_user_goto(x, ptr, "l", "k", "ir", label);		\<br /> 		break;							\<br /> 	case 8:								\<br />-		__put_user_asm_u64((__typeof__(*ptr))(x), ptr, retval,	\<br />-				   errret);				\<br />+		__put_user_goto_u64((__typeof__(*ptr))(x), ptr, label);	\<br /> 		break;							\<br /> 	default:							\<br /> 		__put_user_bad();					\<br />&#64;&#64; -438,9 +431,12 &#64;&#64; do {									\<br /> <br /> #define __put_user_nocheck(x, ptr, size)			\<br /> ({								\<br />-	int __pu_err;						\<br />+	__label__ __pu_label;					\<br />+	int __pu_err = -EFAULT;					\<br /> 	__uaccess_begin();					\<br />-	__put_user_size((x), (ptr), (size), __pu_err, -EFAULT);	\<br />+	__put_user_size((x), (ptr), (size), __pu_label);	\<br />+	__pu_err = 0;						\<br />+__pu_label:							\<br /> 	__uaccess_end();					\<br /> 	__builtin_expect(__pu_err, 0);				\<br /> })<br />&#64;&#64; -465,17 +461,23 &#64;&#64; struct __large_struct { unsigned long buf[100]; };<br />  * we do not write to any memory gcc knows about, so there are no<br />  * aliasing issues.<br />  */<br />-#define __put_user_asm(x, addr, err, itype, rtype, ltype, errret)	\<br />-	asm volatile("\n"						\<br />-		     "1:	mov"itype" %"rtype"1,%2\n"		\<br />-		     "2:\n"						\<br />-		     ".section .fixup,\"ax\"\n"				\<br />-		     "3:	mov %3,%0\n"				\<br />-		     "	jmp 2b\n"					\<br />-		     ".previous\n"					\<br />-		     _ASM_EXTABLE(1b, 3b)				\<br />-		     : "=r"(err)					\<br />-		     : ltype(x), "m" (__m(addr)), "i" (errret), "0" (err))<br />+#define __put_user_goto(x, addr, itype, rtype, ltype, label)	\<br />+	asm volatile goto("\n"						\<br />+		"1:	mov"itype" %"rtype"0,%1\n"			\<br />+		_ASM_EXTABLE(1b, %l2)					\<br />+		: : ltype(x), "m" (__m(addr))				\<br />+		: : label)<br />+<br />+#define __put_user_failed(x, addr, itype, rtype, ltype, errret)		\<br />+	({	__label__ __puflab;					\<br />+		int __pufret = errret;					\<br />+		__put_user_goto(x,addr,itype,rtype,ltype,__puflab);	\<br />+		__pufret = 0;						\<br />+	__puflab: __pufret; })<br />+<br />+#define __put_user_asm(x, addr, retval, itype, rtype, ltype, errret)	do {	\<br />+	retval = __put_user_failed(x, addr, itype, rtype, ltype, errret);	\<br />+} while (0)<br /> <br /> #define __put_user_asm_ex(x, addr, itype, rtype, ltype)			\<br /> 	asm volatile("1:	mov"itype" %"rtype"0,%1\n"		\<br />&#64;&#64; -814,12 +816,8 &#64;&#64; copy_to_user(void __user *to, const void *from, unsigned long n)<br /> #define user_access_begin()	__uaccess_begin()<br /> #define user_access_end()	__uaccess_end()<br /> <br />-#define unsafe_put_user(x, ptr, err_label)					\<br />-do {										\<br />-	int __pu_err;								\<br />-	__put_user_size((x), (ptr), sizeof(*(ptr)), __pu_err, -EFAULT);		\<br />-	if (unlikely(__pu_err)) goto err_label;					\<br />-} while (0)<br />+#define unsafe_put_user(x, ptr, label)	\<br />+	__put_user_size((x), (ptr), sizeof(*(ptr)), label)<br /> <br /> #define unsafe_get_user(x, ptr, err_label)					\<br /> do {										\<br />diff --git a/fs/readdir.c b/fs/readdir.c<br />index 9d0212c374d6..03324f54c0e9 100644<br />--- a/fs/readdir.c<br />+++ b/fs/readdir.c<br />&#64;&#64; -184,25 +184,27 &#64;&#64; static int filldir(struct dir_context *ctx, const char *name, int namlen,<br /> 	if (dirent) {<br /> 		if (signal_pending(current))<br /> 			return -EINTR;<br />-		if (__put_user(offset, &amp;dirent-&gt;d_off))<br />-			goto efault;<br /> 	}<br />+<br />+	user_access_begin();<br />+	if (dirent)<br />+		unsafe_put_user(offset, &amp;dirent-&gt;d_off, efault_end);<br /> 	dirent = buf-&gt;current_dir;<br />-	if (__put_user(d_ino, &amp;dirent-&gt;d_ino))<br />-		goto efault;<br />-	if (__put_user(reclen, &amp;dirent-&gt;d_reclen))<br />-		goto efault;<br />+	unsafe_put_user(d_ino, &amp;dirent-&gt;d_ino, efault_end);<br />+	unsafe_put_user(reclen, &amp;dirent-&gt;d_reclen, efault_end);<br />+	unsafe_put_user(0, dirent-&gt;d_name + namlen, efault_end);<br />+	unsafe_put_user(d_type, (char __user *) dirent + reclen - 1, efault_end);<br />+	user_access_end();<br />+<br /> 	if (copy_to_user(dirent-&gt;d_name, name, namlen))<br /> 		goto efault;<br />-	if (__put_user(0, dirent-&gt;d_name + namlen))<br />-		goto efault;<br />-	if (__put_user(d_type, (char __user *) dirent + reclen - 1))<br />-		goto efault;<br /> 	buf-&gt;previous = dirent;<br /> 	dirent = (void __user *)dirent + reclen;<br /> 	buf-&gt;current_dir = dirent;<br /> 	buf-&gt;count -= reclen;<br /> 	return 0;<br />+efault_end:<br />+	user_access_end();<br /> efault:<br /> 	buf-&gt;error = -EFAULT;<br /> 	return -EFAULT;</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
