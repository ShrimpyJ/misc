    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/8/18/393">First message in thread</a></li><li><a href="/lkml/2016/8/22/822">Linus Torvalds</a><ul><li><a href="/lkml/2016/8/22/997">Kees Cook</a><ul><li><a href="/lkml/2016/8/23/455">Josh Poimboeuf</a></li><li><a href="/lkml/2016/8/23/778">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2016/8/23/436">Josh Poimboeuf</a><ul><li><a href="/lkml/2016/8/23/568">Josh Poimboeuf</a><ul><li><a href="/lkml/2016/8/23/877">Kees Cook</a><ul><li><a href="/lkml/2016/8/25/668">Josh Poimboeuf</a></li></ul></li></ul></li><li><a href="/lkml/2016/8/23/569">Josh Poimboeuf</a><ul><li><a href="/lkml/2016/8/23/851">Kees Cook</a></li></ul></li></ul></li><li><a href="/lkml/2016/8/23/615">Andy Lutomirski</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2016/8/23/643">Josh Poimboeuf</a><ul><li><a href="/lkml/2016/8/23/830">Kees Cook</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 23 Aug 2016 17:06:04 -0400</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH v4 54/57] x86/mm: convert arch_within_stack_frames() to use the new unwinder</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Aug 23, 2016 at 4:31 PM, Andy Lutomirski &lt;luto&#64;kernel.org&gt; wrote:<br />&gt;<br />&gt; I'm a bit confused by what you're objecting to.  If I write:<br />&gt;<br />&gt; char buf[123];<br />&gt;<br />&gt; func(buf, size);<br />&gt;<br />&gt; And func eventually does some usercopy to buf, the idea is to check<br />&gt; that size is in bounds.<br /><br />That's the *IDEA*.<br /><br />That's not what the code actually does.<br /><br />The code will follow arbitrary stack frames, which seems silly since<br />it's expensive. At least the old code only checked within one page<br />(looking at the "stackend" thing), and aborted whenever the trivla<br />frame pointer chasing didn't. The new code may be a nice abstraction,<br />but also seems to not do that, and just follow the frame in general.<br /><br />Should we have nested stacks and copy_to_user()? No. But why have<br />generic frame following code when we don't want the generic case to<br />ever trigger? If the code is slower - and Josh said it was quite<br />noticeably slower, then what's the advantage?<br /><br />But my *real* objection is that I suspect that in 99% of all cases we<br />shouldn't do any of this, and the user access hardening should be made<br />smart enough that we don't need to worry about it. Right now the<br />hardening is not that smart. It tries to handle the case you mention,<br />but it does so by *also* handling the case _I_ mentioned, which is the<br />"trivially statically correct at build time", where the code is<br /><br />    struct xyz tmp;<br /><br />    .. fill in tmo ..<br /><br />     copy_to_user(ptr, &amp;tmp, sizeof(tmp));<br /><br />where wasting cycles to see if it's on the stack is just stupid.<br /><br />And quite frankly, I suspect that *most* situations where you copy<br />from or to the stack are very obvious constant sizes like the above.<br /><br />Can  you find a _single_ case of a non-constant buffer on the stack?<br />It's rare. If it's a variably-sized area, 99% of all time it's a<br />dynamic allocation, not a stack variable.<br /><br />So I actually suspect that we could just say "let's make it entirely<br />invalid to copy variably-sized things to/from the stack". Get rid of<br />this "follow frames" code _entirely_, and just make the rule be that a<br />variable copy_to/from_user had better not be on the stack. And the<br />static constant sizes are clearly not about overflows, so if those are<br />wrong, it's because somebody uses the wrong type entirely, and gcc<br />should be catching them statically (or we should catch them with other<br />tools).<br /><br />Because the fs/stat.c copies really have been some of the hottest<br />user-copy code examples we have under certain loads. Do we really want<br />to have stupid code that makes them slower for no possibly valid<br />reason?<br /><br />At some point somebody has to just say "That's just TOO STUPID TO LIVE!".<br /><br />Checking those fs/stat.c copies dynamically is one such case.<br /><br />              Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
