    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2016/8/19/671">First message in thread</a></li><li><a href="/lkml/2016/8/19/749">Al Viro</a><ul><li><a href="/lkml/2016/8/19/757">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2016/8/20/117">Linus Torvalds</a><ul><li><a href="/lkml/2016/8/20/117">Linus Torvalds</a><ul><li><a href="/lkml/2016/8/20/118">Al Viro</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2016/8/19/759/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 19 Aug 2016 15:11:05 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] ARC: uaccess: get_user to zero out dest in cause of fault</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Aug 19, 2016 at 3:00 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; (I have some experimental patches that actually use "asm goto" in<br />&gt; "unsafe_put_user()" to get that nice code generation, but they only<br />&gt; work if your gcc version supports "asm goto", which some older<br />&gt; versions of gcc does not)<br /><br />Since you actually are looking at the user access stuff, I'll just put<br />them here.<br /><br />This is from an old branch of mine, based on commit f6c658df6385 just<br />because that happened to be my top-of-tree when I was playing around<br />with it. It probably doesn't even apply right now, and as mentioned,<br />it depends on "asm goto" (there is no case for !CC_HAVE_ASM_GOTO).<br /><br />With this, you actually get almost perfect code generation if you then<br />replace all the "put_user_ex()" calls with<br /><br />        if (access_ok(..))<br />            return -EFAULT;<br /><br />        user_access_begin();<br />        unsafe_put_user(x,ptr, error_label);<br />        unsafe_put_user(y,ptr2, error_label);<br />        ...<br />        user_access_end();<br />        return 0;<br /><br />    error_label:<br />        user_access_end();<br />        return -EFAULT;<br /><br />or something similar. The exception handler will jump directly to<br />"error_label", and there will be no testing of anything at all in the<br />usual no-exception cases, nor will there be any extra registers for<br />error values etc.<br /><br />           Linus<br />diff --git a/arch/x86/include/asm/uaccess.h b/arch/x86/include/asm/uaccess.h<br />index 2982387ba817..849debe7aa10 100644<br />--- a/arch/x86/include/asm/uaccess.h<br />+++ b/arch/x86/include/asm/uaccess.h<br />&#64;&#64; -204,19 +204,14 &#64;&#64; __typeof__(__builtin_choose_expr(sizeof(x) &gt; sizeof(0UL), 0ULL, 0UL))<br /> <br /> <br /> #ifdef CONFIG_X86_32<br />-#define __put_user_asm_u64(x, addr, err, errret)			\<br />-	asm volatile("\n"						\<br />-		     "1:	movl %%eax,0(%2)\n"			\<br />-		     "2:	movl %%edx,4(%2)\n"			\<br />-		     "3:"						\<br />-		     ".section .fixup,\"ax\"\n"				\<br />-		     "4:	movl %3,%0\n"				\<br />-		     "	jmp 3b\n"					\<br />-		     ".previous\n"					\<br />-		     _ASM_EXTABLE(1b, 4b)				\<br />-		     _ASM_EXTABLE(2b, 4b)				\<br />-		     : "=r" (err)					\<br />-		     : "A" (x), "r" (addr), "i" (errret), "0" (err))<br />+#define __put_user_goto_u64(x, addr, label)			\<br />+	asm volatile("\n"					\<br />+		     "1:	movl %%eax,0(%2)\n"		\<br />+		     "2:	movl %%edx,4(%2)\n"		\<br />+		     _ASM_EXTABLE(1b, %2l)			\<br />+		     _ASM_EXTABLE(2b, %2l)			\<br />+		     : : "A" (x), "r" (addr)			\<br />+		     : : label)<br /> <br /> #define __put_user_asm_ex_u64(x, addr)					\<br /> 	asm volatile("\n"						\<br />&#64;&#64; -231,8 +226,8 &#64;&#64; __typeof__(__builtin_choose_expr(sizeof(x) &gt; sizeof(0UL), 0ULL, 0UL))<br /> 	asm volatile("call __put_user_8" : "=a" (__ret_pu)	\<br /> 		     : "A" ((typeof(*(ptr)))(x)), "c" (ptr) : "ebx")<br /> #else<br />-#define __put_user_asm_u64(x, ptr, retval, errret) \<br />-	__put_user_asm(x, ptr, retval, "q", "", "er", errret)<br />+#define __put_user_goto_u64(x, ptr, label) \<br />+	__put_user_goto(x, ptr, "q", "", "er", label)<br /> #define __put_user_asm_ex_u64(x, addr)	\<br /> 	__put_user_asm_ex(x, addr, "q", "", "er")<br /> #define __put_user_x8(x, ptr, __ret_pu) __put_user_x(8, x, ptr, __ret_pu)<br />&#64;&#64; -293,23 +288,21 &#64;&#64; extern void __put_user_8(void);<br /> 	__builtin_expect(__ret_pu, 0);				\<br /> })<br /> <br />-#define __put_user_size(x, ptr, size, retval, errret)			\<br />+#define __put_user_size(x, ptr, size, label)				\<br /> do {									\<br />-	retval = 0;							\<br /> 	__chk_user_ptr(ptr);						\<br /> 	switch (size) {							\<br /> 	case 1:								\<br />-		__put_user_asm(x, ptr, retval, "b", "b", "iq", errret);	\<br />+		__put_user_goto(x, ptr, "b", "b", "iq", label);	\<br /> 		break;							\<br /> 	case 2:								\<br />-		__put_user_asm(x, ptr, retval, "w", "w", "ir", errret);	\<br />+		__put_user_goto(x, ptr, "w", "w", "ir", label);		\<br /> 		break;							\<br /> 	case 4:								\<br />-		__put_user_asm(x, ptr, retval, "l", "k", "ir", errret);	\<br />+		__put_user_goto(x, ptr, "l", "k", "ir", label);		\<br /> 		break;							\<br /> 	case 8:								\<br />-		__put_user_asm_u64((__typeof__(*ptr))(x), ptr, retval,	\<br />-				   errret);				\<br />+		__put_user_goto_u64((__typeof__(*ptr))(x), ptr, label);	\<br /> 		break;							\<br /> 	default:							\<br /> 		__put_user_bad();					\<br />&#64;&#64; -419,9 +412,12 &#64;&#64; do {									\<br /> <br /> #define __put_user_nocheck(x, ptr, size)			\<br /> ({								\<br />-	int __pu_err;						\<br />+	__label__ __pu_label;					\<br />+	int __pu_err = -EFAULT;					\<br /> 	__uaccess_begin();					\<br />-	__put_user_size((x), (ptr), (size), __pu_err, -EFAULT);	\<br />+	__put_user_size((x), (ptr), (size), __pu_label);	\<br />+	__pu_err = 0;						\<br />+__pu_label:							\<br /> 	__uaccess_end();					\<br /> 	__builtin_expect(__pu_err, 0);				\<br /> })<br />&#64;&#64; -446,17 +442,23 &#64;&#64; struct __large_struct { unsigned long buf[100]; };<br />  * we do not write to any memory gcc knows about, so there are no<br />  * aliasing issues.<br />  */<br />-#define __put_user_asm(x, addr, err, itype, rtype, ltype, errret)	\<br />-	asm volatile("\n"						\<br />-		     "1:	mov"itype" %"rtype"1,%2\n"		\<br />-		     "2:\n"						\<br />-		     ".section .fixup,\"ax\"\n"				\<br />-		     "3:	mov %3,%0\n"				\<br />-		     "	jmp 2b\n"					\<br />-		     ".previous\n"					\<br />-		     _ASM_EXTABLE(1b, 3b)				\<br />-		     : "=r"(err)					\<br />-		     : ltype(x), "m" (__m(addr)), "i" (errret), "0" (err))<br />+#define __put_user_goto(x, addr, itype, rtype, ltype, label)	\<br />+	asm volatile goto("\n"						\<br />+		"1:	mov"itype" %"rtype"0,%1\n"			\<br />+		_ASM_EXTABLE(1b, %l2)					\<br />+		: : ltype(x), "m" (__m(addr))				\<br />+		: : label)<br />+<br />+#define __put_user_failed(x, addr, itype, rtype, ltype, errret)		\<br />+	({	__label__ __puflab;					\<br />+		int __pufret = errret;					\<br />+		__put_user_goto(x,addr,itype,rtype,ltype,__puflab);	\<br />+		__pufret = 0;						\<br />+	__puflab: __pufret; })<br />+<br />+#define __put_user_asm(x, addr, retval, itype, rtype, ltype, errret)	do {	\<br />+	retval = __put_user_failed(x, addr, itype, rtype, ltype, errret);	\<br />+} while (0)<br /> <br /> #define __put_user_asm_ex(x, addr, itype, rtype, ltype)			\<br /> 	asm volatile("1:	mov"itype" %"rtype"0,%1\n"		\<br />&#64;&#64; -793,12 +795,9 &#64;&#64; copy_to_user(void __user *to, const void *from, unsigned long n)<br /> #define user_access_begin()	__uaccess_begin()<br /> #define user_access_end()	__uaccess_end()<br /> <br />-#define unsafe_put_user(x, ptr)						\<br />-({										\<br />-	int __pu_err;								\<br />-	__put_user_size((x), (ptr), sizeof(*(ptr)), __pu_err, -EFAULT);		\<br />-	__builtin_expect(__pu_err, 0);						\<br />-})<br />+#define unsafe_put_user(x, ptr, label)	\<br />+	__put_user_size((x), (ptr), sizeof(*(ptr)), label)<br />+<br /> <br /> #define unsafe_get_user(x, ptr)						\<br /> ({										\</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
