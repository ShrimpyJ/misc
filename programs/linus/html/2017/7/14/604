    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/7/13/757">First message in thread</a></li><li><a href="/lkml/2017/7/14/580">Linus Torvalds</a><ul><li><a href="/lkml/2017/7/14/600">Andrey Ryabinin</a><ul><li class="origin"><a href="/lkml/2017/7/14/623">Linus Torvalds</a><ul><li><a href="/lkml/2017/7/14/623">Andrey Rybainin</a></li><li><a href="/lkml/2017/7/14/634">Daniel Micay</a><ul><li><a href="/lkml/2017/7/14/637">Linus Torvalds</a></li><li><a href="/lkml/2017/7/14/638">Daniel Micay</a></li></ul></li><li><a href="/lkml/2017/7/14/701">Daniel Micay</a></li></ul></li></ul></li><li><a href="/lkml/2017/7/14/601">Dave Jones</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 14 Jul 2017 12:58:52 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [GIT PULL] Please pull NFS client changes for Linux 4.13</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Jul 14, 2017 at 12:43 PM, Andrey Ryabinin<br />&lt;aryabinin&#64;virtuozzo.com&gt; wrote:<br />&gt;<br />&gt;&gt; yet when I look at the generated code for __ip_map_lookup, I see<br />&gt;&gt;<br />&gt;&gt;        movl    $32, %edx       #,<br />&gt;&gt;        movq    %r13, %rsi      # class,<br />&gt;&gt;        leaq    48(%rax), %rdi  #, tmp126<br />&gt;&gt;        call    strscpy #<br />&gt;&gt;<br />&gt;&gt; what's the bug here? Look at that third argume8nt - %rdx. It is<br />&gt;&gt; initialized to 32.<br />&gt;<br />&gt; It's not a compiler bug, it's a bug in our strcpy().<br />&gt; Whoever wrote this strcpy() into strscpy() code apparently didn't read carefully<br />&gt; enough gcc manual about __builtin_object_size().<br />&gt;<br />&gt; Summary from <a href="https://gcc.gnu.org/onlinedocs/gcc/Object-Size-Checking.html">https://gcc.gnu.org/onlinedocs/gcc/Object-Size-Checking.html</a> :<br />&gt;<br />&gt;         __builtin_object_size(ptr, type) returns a constant number of bytes from 'ptr' to the end of the object 'ptr'<br />&gt;         pointer points to. "type" is an integer constant from 0 to 3. If the least significant bit is clear, objects<br />&gt;         are whole variables, if it is set, a closest surrounding subobject is considered the object a pointer points to.<br />&gt;         The second bit determines if maximum or minimum of remaining bytes is computed.<br />&gt;<br />&gt; We have type = 0 in strcpy(), so the least significant bit is clear. So the 'ptr' is considered as a pointer to the whole<br />&gt; variable i.e. pointer to struct ip_map ip;<br />&gt; And the number of bytes from 'ip.m_class' to the end of the ip object is exactly 32.<br />&gt;<br />&gt; I suppose that changing the type to 1 should fix this bug.<br /><br />Oh, that absolutely needs to be done.<br /><br />Because that "strcpy() -&gt; strscpy()" conversion really depends on that<br />size being the right size (well, in this case minimal safe size) for<br />the actual accesses, exactly because "strscpy()" is perfectly willing<br />to write *past* the end of the destination string within that given<br />size limit (ie it reads and writes in the same 8-byte chunks).<br /><br />So if you have a small target string that is contained in a big<br />object, then the "hardened" strcpy() code can actually end up<br />overwriting things past the end of the strring, even if the string<br />itself were to have fit in the buffer.<br /><br />I note that every single use in string.h is buggy, and it worries me<br />that __compiletime_object_size() does this too. The only user of that<br />seems to be check_copy_size(), and now I'm a bit worried what that bug<br />may have hidden.<br /><br />I find "hardening" code that adds bugs to be particularly bad and<br />ugly, the same way that I absolutely *hate* debugging code that turns<br />out to make debugging impossible (we had that with the "better" stack<br />tracing code that caused kernel panics to kill the machine entirely<br />rather than show the backtrace, and I'm still bitter about it a decade<br />after the fact).<br /><br />There is something actively *evil* about it. Daniel, Kees, please jump on this.<br /><br />Andrey, thanks for noticing this thing,<br /><br />                          Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
