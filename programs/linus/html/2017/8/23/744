    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/8/14/1000">First message in thread</a></li><li><a href="/lkml/2017/8/23/486">Tim Chen</a><ul><li><a href="/lkml/2017/8/23/592">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/23/668">"Liang, Kan"</a></li><li class="origin"><a href="/lkml/2017/8/24/705">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/24/705">Tim Chen</a><ul><li><a href="/lkml/2017/8/24/723">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2017/8/23/744/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 23 Aug 2017 16:30:51 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 1/2] sched/wait: Break up long wake list walk</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Aug 23, 2017 at 11:17 AM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt; On Wed, Aug 23, 2017 at 8:58 AM, Tim Chen &lt;tim.c.chen&#64;linux.intel.com&gt; wrote:<br />&gt;&gt;<br />&gt;&gt; Will you still consider the original patch as a fail safe mechanism?<br />&gt;<br />&gt; I don't think we have much choice, although I would *really* want to<br />&gt; get this root-caused rather than just papering over the symptoms.<br /><br />Oh well. Apparently we're not making progress on that, so I looked at<br />the patch again.<br /><br />Can we fix it up a bit? In particular, the "bookmark_wake_function()"<br />thing added no value, and definitely shouldn't have been exported.<br />Just use NULL instead.<br /><br />And the WAITQUEUE_WALK_BREAK_CNT thing should be internal to<br />__wake_up_common(), not in some common header file. Again, there's no<br />value in exporting it to anybody else.<br /><br />And doing<br /><br />                if (curr-&gt;flags &amp; WQ_FLAG_BOOKMARK)<br /><br />looks odd, when we just did<br /><br />                unsigned flags = curr-&gt;flags;<br /><br />one line earlier, so that can be just simplified.<br /><br />So can you test that simplified version of the patch? I'm attaching my<br />suggested edited patch, but you may just want to do those changes<br />directly to your tree instead.<br /><br />Hmm?<br /><br />               Linus<br /> include/linux/wait.h |  1 +<br /> kernel/sched/wait.c  | 74 ++++++++++++++++++++++++++++++++++++++++++----------<br /> 2 files changed, 61 insertions(+), 14 deletions(-)<br /><br />diff --git a/include/linux/wait.h b/include/linux/wait.h<br />index dc19880c02f5..78401ef02d29 100644<br />--- a/include/linux/wait.h<br />+++ b/include/linux/wait.h<br />&#64;&#64; -18,6 +18,7 &#64;&#64; int default_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int<br /> /* wait_queue_entry::flags */<br /> #define WQ_FLAG_EXCLUSIVE	0x01<br /> #define WQ_FLAG_WOKEN		0x02<br />+#define WQ_FLAG_BOOKMARK	0x04<br /> <br /> /*<br />  * A single wait-queue entry structure:<br />diff --git a/kernel/sched/wait.c b/kernel/sched/wait.c<br />index 17f11c6b0a9f..789dc24a323d 100644<br />--- a/kernel/sched/wait.c<br />+++ b/kernel/sched/wait.c<br />&#64;&#64; -53,6 +53,12 &#64;&#64; void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry<br /> }<br /> EXPORT_SYMBOL(remove_wait_queue);<br /> <br />+/*<br />+ * Scan threshold to break wait queue walk.<br />+ * This allows a waker to take a break from holding the<br />+ * wait queue lock during the wait queue walk.<br />+ */<br />+#define WAITQUEUE_WALK_BREAK_CNT 64<br /> <br /> /*<br />  * The core wakeup function. Non-exclusive wakeups (nr_exclusive == 0) just<br />&#64;&#64; -63,17 +69,64 &#64;&#64; EXPORT_SYMBOL(remove_wait_queue);<br />  * started to run but is not in state TASK_RUNNING. try_to_wake_up() returns<br />  * zero in this (rare) case, and we handle it by continuing to scan the queue.<br />  */<br />-static void __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,<br />-			int nr_exclusive, int wake_flags, void *key)<br />+static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,<br />+			int nr_exclusive, int wake_flags, void *key,<br />+			wait_queue_entry_t *bookmark)<br /> {<br /> 	wait_queue_entry_t *curr, *next;<br />+	int cnt = 0;<br />+<br />+	if (bookmark &amp;&amp; (bookmark-&gt;flags &amp; WQ_FLAG_BOOKMARK)) {<br />+		curr = list_next_entry(bookmark, entry);<br /> <br />-	list_for_each_entry_safe(curr, next, &amp;wq_head-&gt;head, entry) {<br />+		list_del(&amp;bookmark-&gt;entry);<br />+		bookmark-&gt;flags = 0;<br />+	} else<br />+		curr = list_first_entry(&amp;wq_head-&gt;head, wait_queue_entry_t, entry);<br />+<br />+	if (&amp;curr-&gt;entry == &amp;wq_head-&gt;head)<br />+		return nr_exclusive;<br />+<br />+	list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) {<br /> 		unsigned flags = curr-&gt;flags;<br /> <br />+		if (flags &amp; WQ_FLAG_BOOKMARK)<br />+			continue;<br />+<br /> 		if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;<br /> 				(flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)<br /> 			break;<br />+<br />+		if (bookmark &amp;&amp; (++cnt &gt; WAITQUEUE_WALK_BREAK_CNT) &amp;&amp;<br />+				(&amp;next-&gt;entry != &amp;wq_head-&gt;head)) {<br />+			bookmark-&gt;flags = WQ_FLAG_BOOKMARK;<br />+			list_add_tail(&amp;bookmark-&gt;entry, &amp;next-&gt;entry);<br />+			break;<br />+		}<br />+	}<br />+	return nr_exclusive;<br />+}<br />+<br />+static void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,<br />+			int nr_exclusive, int wake_flags, void *key)<br />+{<br />+	unsigned long flags;<br />+	wait_queue_entry_t bookmark;<br />+<br />+	bookmark.flags = 0;<br />+	bookmark.private = NULL;<br />+	bookmark.func = NULL;<br />+	INIT_LIST_HEAD(&amp;bookmark.entry);<br />+<br />+	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);<br />+	nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key, &amp;bookmark);<br />+	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);<br />+<br />+	while (bookmark.flags &amp; WQ_FLAG_BOOKMARK) {<br />+		spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);<br />+		nr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,<br />+						wake_flags, key, &amp;bookmark);<br />+		spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);<br /> 	}<br /> }<br /> <br />&#64;&#64; -90,11 +143,7 &#64;&#64; static void __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,<br /> void __wake_up(struct wait_queue_head *wq_head, unsigned int mode,<br /> 			int nr_exclusive, void *key)<br /> {<br />-	unsigned long flags;<br />-<br />-	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);<br />-	__wake_up_common(wq_head, mode, nr_exclusive, 0, key);<br />-	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);<br />+	__wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);<br /> }<br /> EXPORT_SYMBOL(__wake_up);<br /> <br />&#64;&#64; -103,13 +152,13 &#64;&#64; EXPORT_SYMBOL(__wake_up);<br />  */<br /> void __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr)<br /> {<br />-	__wake_up_common(wq_head, mode, nr, 0, NULL);<br />+	__wake_up_common(wq_head, mode, nr, 0, NULL, NULL);<br /> }<br /> EXPORT_SYMBOL_GPL(__wake_up_locked);<br /> <br /> void __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key)<br /> {<br />-	__wake_up_common(wq_head, mode, 1, 0, key);<br />+	__wake_up_common(wq_head, mode, 1, 0, key, NULL);<br /> }<br /> EXPORT_SYMBOL_GPL(__wake_up_locked_key);<br /> <br />&#64;&#64; -133,7 +182,6 &#64;&#64; EXPORT_SYMBOL_GPL(__wake_up_locked_key);<br /> void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,<br /> 			int nr_exclusive, void *key)<br /> {<br />-	unsigned long flags;<br /> 	int wake_flags = 1; /* XXX WF_SYNC */<br /> <br /> 	if (unlikely(!wq_head))<br />&#64;&#64; -142,9 +190,7 &#64;&#64; void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,<br /> 	if (unlikely(nr_exclusive != 1))<br /> 		wake_flags = 0;<br /> <br />-	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);<br />-	__wake_up_common(wq_head, mode, nr_exclusive, wake_flags, key);<br />-	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);<br />+	__wake_up_common_lock(wq_head, mode, nr_exclusive, wake_flags, key);<br /> }<br /> EXPORT_SYMBOL_GPL(__wake_up_sync_key);<br /> </pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
