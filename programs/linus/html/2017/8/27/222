    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/8/25/542">First message in thread</a></li><li><a href="/lkml/2017/8/26/164">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/27/213">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/27/214">Linus Torvalds</a></li><li class="origin"><a href="/lkml/2017/8/27/240">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/27/240">Nicholas Piggin</a><ul><li><a href="/lkml/2017/8/27/243">Nicholas Piggin</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2017/8/28/713">"Liang, Kan"</a><ul><li><a href="/lkml/2017/8/28/829">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/28/969">Tim Chen</a></li><li><a href="/lkml/2017/8/29/333">"Liang, Kan"</a><ul><li><a href="/lkml/2017/8/29/473">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2017/8/29/486">Tim Chen</a><ul><li><a href="/lkml/2017/8/29/487">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2017/8/27/222/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 27 Aug 2017 16:12:19 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 2/2 v2] sched/wait: Introduce lock breaker in wake_up_page_bit</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Aug 27, 2017 at 2:40 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; The race goes like this:<br />&gt;<br />&gt;   thread1       thread2         thread3<br />&gt;   ----          ----            ----<br />&gt;<br />&gt;   .. CPU1 ...<br />&gt;   __lock_page_killable<br />&gt;     wait_on_page_bit_common()<br />&gt;       get wq lock<br />&gt;       __add_wait_queue_entry_tail_exclusive()<br />&gt;       set_current_state(TASK_KILLABLE);<br />&gt;       release wq lock<br />&gt;         io_schedule<br />&gt;<br />&gt;                 ... CPU2 ...<br />&gt;                 __lock_page[_killable]()<br />&gt;                   wait_on_page_bit_common()<br />&gt;                     get wq lock<br />&gt;                     __add_wait_queue_entry_tail_exclusive()<br />&gt;                     set_current_state(TASK_KILLABLE);<br />&gt;                     release wq lock<br />&gt;                     io_schedule<br />&gt;<br />&gt;                                 ... CPU3 ...<br />&gt;                                 unlock_page()<br />&gt;                                 wake_up_page_bit(page, PG_Locked)<br />&gt;                                   wakes up CPU1 _only_<br />&gt;<br />&gt;   ... lethal signal for thread1 happens ...<br />&gt;      if (unlikely(signal_pending_state(state, current))) {<br />&gt;           ret = -EINTR;<br />&gt;           break;<br />&gt;      }<br /><br />With the race meaning that thread2 never gets woken up due to the<br />exclusive wakeup being caught by thread1 (which doesn't actually take<br />the lock).<br /><br />I think that this bug was introduced by commit 62906027091f ("mm: add<br />PageWaiters indicating tasks are waiting for a page bit"), which<br />changed the page lock from using the wait_on_bit_lock() code to its<br />own _slightly_ different version.<br /><br />Because it looks like _almost_ the same thing existed in the old<br />wait_on_bit_lock() code - and that is still used by a couple of<br />filesystems.<br /><br />*Most* of the users seem to use TASK_UNINTERRUPTIBLE, which is fine.<br />But cifs and the sunrpc XPRT_LOCKED code both use the TASK_KILLABLE<br />form that would seem to have the exact same issue: wait_on_bit_lock()<br />uses exclusive wait-queues, but then may return with an error without<br />actually taking the lock.<br /><br />Now, it turns out that I think the wait_on_bit_lock() code is actually<br />safe, for a subtle reason.<br /><br />Why? Unlike the page lock code, the wait_on_bit_lock() code always<br />tries to get the lock bit before returning an error. So<br />wait_on_bit_lock() will prefer a successful lock taking over EINTR,<br />which means that if the bit really was unlocked, it would have been<br />taken.<br /><br />And if something else locked the bit again under us and we didn't get<br />it, that "something else" presumably will then wake things up when it<br />unlocks.<br /><br />So the wait_on_bit_lock() code could _also_ lose the wakeup event, but<br />it would only lose it in situations where somebody else would then<br />re-send it.<br /><br />Do people agree with that analysis?<br /><br />So I think the old wait_on_bit_lock() code ends up being safe -<br />despite having this same pattern of "exclusive wait but might error<br />out without taking the lock".<br /><br />Whether that "wait_on_bit_lock() is safe" was just a fluke or was<br />because people thought about it is unclear. It's old code. People<br />probably *did* think about it. I really can't remember.<br /><br />But it does point to a fix for the page lock case: just move the<br />signal_pending_state() test to after the bit checking.<br /><br />So the page locking code is racy because you could have this:<br /><br /> - another cpu does the unlock_page() and wakes up the process (and<br />uses the exclusive event)<br /><br /> - we then get a lethal signal before we get toi the<br />"signal_pending_state()" state.<br /><br /> - we end up prioritizing the lethal signal, because obviously we<br />don't care about locking the page any more.<br /><br /> - so now the lock bit may be still clear and there's nobody who is<br />going to wake up the remaining waiter<br /><br />Moving the signal_pending_state() down actually fixes the race,<br />because we know that in order for the exclusive thing to have<br />mattered, it *has* to actually wake us up. So the unlock_page() must<br />happen before the lethal signal (where before is well-defined because<br />of that "try_to_wake_up()" taking a lock and looking at the task<br />state). The exclusive accounting is only done if the process is<br />actually woken up, not if it was already running (see<br />"try_to_wake_up()").<br /><br />And if the unlock_page() happened before the lethal signal, then we<br />know that test_and_set_bit_lock() will either work (in which case<br />we're ok), or another locker successfully came in later - in which<br />case we're _also_ ok, because that other locker will then do the<br />unlock again, and wake up subsequent waiters that might have been<br />blocked by our first exclusive waiter.<br /><br />So I propose that the fix might be as simple as this:<br /><br />    diff --git a/mm/filemap.c b/mm/filemap.c<br />    index baba290c276b..0b41c8cbeabc 100644<br />    --- a/mm/filemap.c<br />    +++ b/mm/filemap.c<br />    &#64;&#64; -986,10 +986,6 &#64;&#64; static inline int<br />wait_on_page_bit_common(wait_queue_head_t *q,<br /><br />                if (likely(test_bit(bit_nr, &amp;page-&gt;flags))) {<br />                        io_schedule();<br />    -                   if (unlikely(signal_pending_state(state, current))) {<br />    -                           ret = -EINTR;<br />    -                           break;<br />    -                   }<br />                }<br /><br />                if (lock) {<br />    &#64;&#64; -999,6 +995,11 &#64;&#64; static inline int<br />wait_on_page_bit_common(wait_queue_head_t *q,<br />                        if (!test_bit(bit_nr, &amp;page-&gt;flags))<br />                                break;<br />                }<br />    +<br />    +           if (unlikely(signal_pending_state(state, current))) {<br />    +                   ret = -EINTR;<br />    +                   break;<br />    +           }<br />        }<br />        finish_wait(q, wait);<br /><br />but maybe I'm missing something.<br /><br />Nick, comments?<br /><br />                 Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
