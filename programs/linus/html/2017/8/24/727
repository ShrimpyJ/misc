    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/8/16/534">First message in thread</a></li><li><a href="/lkml/2017/8/24/722">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/24/726">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2017/8/24/772">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/24/772">Stefan Lippers-Hollmann</a><ul><li><a href="/lkml/2017/8/24/774">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2017/8/24/730">(Eric W. Biederman)</a><ul><li><a href="/lkml/2017/8/24/736">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/24/749">(Eric W. Biederman)</a></li><li><a href="/lkml/2017/8/24/769">(Eric W. Biederman)</a><ul><li><a href="/lkml/2017/8/24/812">Stefan Lippers-Hollmann</a></li></ul></li></ul></li><li><a href="/lkml/2017/8/24/747">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/24/750">Linus Torvalds</a></li><li><a href="/lkml/2017/8/24/794">(Eric W. Biederman)</a><ul><li><a href="/lkml/2017/8/24/816">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2017/8/24/763">(Eric W. Biederman)</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2017/8/24/727/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 24 Aug 2017 11:36:09 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 0/1] devpts: use dynamic_dname() to generate proc name</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Thu, Aug 24, 2017 at 11:31 AM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; It should just do a "return ptm_open_peer(file, tty, (int)arg);" instead.<br /><br />Here's the actual tested patch. It "WorksForMe(tm)", including the<br />TIOCGPTPEER ioctl, and also verified that it gets the pathname right<br />in /proc, which was the original problem.<br /><br />But I did *not* check that pbuilder is still happy. Stefan?<br /><br />                  Linus<br /> drivers/tty/pty.c         | 64 ++++++++++++++++++++---------------------------<br /> drivers/tty/tty_io.c      |  2 ++<br /> fs/devpts/inode.c         | 63 ++++++++++++++++++++++++++++++++++------------<br /> include/linux/devpts_fs.h | 10 ++++++++<br /> 4 files changed, 86 insertions(+), 53 deletions(-)<br /><br />diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c<br />index 284749fb0f6b..bfd66fcff7a3 100644<br />--- a/drivers/tty/pty.c<br />+++ b/drivers/tty/pty.c<br />&#64;&#64; -69,13 +69,8 &#64;&#64; static void pty_close(struct tty_struct *tty, struct file *filp)<br /> #ifdef CONFIG_UNIX98_PTYS<br /> 		if (tty-&gt;driver == ptm_driver) {<br /> 			mutex_lock(&amp;devpts_mutex);<br />-			if (tty-&gt;link-&gt;driver_data) {<br />-				struct path *path = tty-&gt;link-&gt;driver_data;<br />-<br />-				devpts_pty_kill(path-&gt;dentry);<br />-				path_put(path);<br />-				kfree(path);<br />-			}<br />+			if (tty-&gt;link-&gt;driver_data)<br />+				devpts_pty_kill(tty-&gt;link-&gt;driver_data);<br /> 			mutex_unlock(&amp;devpts_mutex);<br /> 		}<br /> #endif<br />&#64;&#64; -607,25 +602,24 &#64;&#64; static inline void legacy_pty_init(void) { }<br /> static struct cdev ptmx_cdev;<br /> <br /> /**<br />- *	pty_open_peer - open the peer of a pty<br />- *	&#64;tty: the peer of the pty being opened<br />+ *	ptm_open_peer - open the peer of a pty<br />+ *	&#64;master: the open struct file of the ptmx device node<br />+ *	&#64;tty: the master of the pty being opened<br />+ *	&#64;flags: the flags for open<br />  *<br />- *	Open the cached dentry in tty-&gt;link, providing a safe way for userspace<br />- *	to get the slave end of a pty (where they have the master fd and cannot<br />- *	access or trust the mount namespace /dev/pts was mounted inside).<br />+ *	Provide a race free way for userspace to open the slave end of a pty<br />+ *	(where they have the master fd and cannot access or trust the mount<br />+ *	namespace /dev/pts was mounted inside).<br />  */<br />-static struct file *pty_open_peer(struct tty_struct *tty, int flags)<br />-{<br />-	if (tty-&gt;driver-&gt;subtype != PTY_TYPE_MASTER)<br />-		return ERR_PTR(-EIO);<br />-	return dentry_open(tty-&gt;link-&gt;driver_data, flags, current_cred());<br />-}<br />-<br />-static int pty_get_peer(struct tty_struct *tty, int flags)<br />+int ptm_open_peer(struct file *master, struct tty_struct *tty, int flags)<br /> {<br /> 	int fd = -1;<br />-	struct file *filp = NULL;<br />+	struct file *filp;<br /> 	int retval = -EINVAL;<br />+	struct path path;<br />+<br />+	if (tty-&gt;driver != ptm_driver)<br />+		return -EIO;<br /> <br /> 	fd = get_unused_fd_flags(0);<br /> 	if (fd &lt; 0) {<br />&#64;&#64; -633,7 +627,16 &#64;&#64; static int pty_get_peer(struct tty_struct *tty, int flags)<br /> 		goto err;<br /> 	}<br /> <br />-	filp = pty_open_peer(tty, flags);<br />+	/* Compute the slave's path */<br />+	path.mnt = devpts_mnt(master);<br />+	if (IS_ERR(path.mnt)) {<br />+		retval = PTR_ERR(path.mnt);<br />+		goto err_put;<br />+	}<br />+	path.dentry = tty-&gt;link-&gt;driver_data;<br />+<br />+	filp = dentry_open(&amp;path, flags, current_cred());<br />+	mntput(path.mnt);<br /> 	if (IS_ERR(filp)) {<br /> 		retval = PTR_ERR(filp);<br /> 		goto err_put;<br />&#64;&#64; -662,8 +665,6 &#64;&#64; static int pty_unix98_ioctl(struct tty_struct *tty,<br /> 		return pty_get_pktmode(tty, (int __user *)arg);<br /> 	case TIOCGPTN: /* Get PT Number */<br /> 		return put_user(tty-&gt;index, (unsigned int __user *)arg);<br />-	case TIOCGPTPEER: /* Open the other end */<br />-		return pty_get_peer(tty, (int) arg);<br /> 	case TIOCSIG:    /* Send signal to other side of pty */<br /> 		return pty_signal(tty, (int) arg);<br /> 	}<br />&#64;&#64; -791,7 +792,6 &#64;&#64; static int ptmx_open(struct inode *inode, struct file *filp)<br /> {<br /> 	struct pts_fs_info *fsi;<br /> 	struct tty_struct *tty;<br />-	struct path *pts_path;<br /> 	struct dentry *dentry;<br /> 	int retval;<br /> 	int index;<br />&#64;&#64; -845,26 +845,16 &#64;&#64; static int ptmx_open(struct inode *inode, struct file *filp)<br /> 		retval = PTR_ERR(dentry);<br /> 		goto err_release;<br /> 	}<br />-	/* We need to cache a fake path for TIOCGPTPEER. */<br />-	pts_path = kmalloc(sizeof(struct path), GFP_KERNEL);<br />-	if (!pts_path)<br />-		goto err_release;<br />-	pts_path-&gt;mnt = filp-&gt;f_path.mnt;<br />-	pts_path-&gt;dentry = dentry;<br />-	path_get(pts_path);<br />-	tty-&gt;link-&gt;driver_data = pts_path;<br />+	tty-&gt;link-&gt;driver_data = dentry;<br /> <br /> 	retval = ptm_driver-&gt;ops-&gt;open(tty, filp);<br /> 	if (retval)<br />-		goto err_path_put;<br />+		goto err_release;<br /> <br /> 	tty_debug_hangup(tty, "opening (count=%d)\n", tty-&gt;count);<br /> <br /> 	tty_unlock(tty);<br /> 	return 0;<br />-err_path_put:<br />-	path_put(pts_path);<br />-	kfree(pts_path);<br /> err_release:<br /> 	tty_unlock(tty);<br /> 	// This will also put-ref the fsi<br />diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c<br />index 974b13d24401..18be15fc3e18 100644<br />--- a/drivers/tty/tty_io.c<br />+++ b/drivers/tty/tty_io.c<br />&#64;&#64; -2518,6 +2518,8 &#64;&#64; long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)<br /> 	case TIOCSSERIAL:<br /> 		tty_warn_deprecated_flags(p);<br /> 		break;<br />+	case TIOCGPTPEER:<br />+		return ptm_open_peer(file, tty, (int)arg);<br /> 	default:<br /> 		retval = tty_jobctrl_ioctl(tty, real_tty, file, cmd, arg);<br /> 		if (retval != -ENOIOCTLCMD)<br />diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c<br />index 108df2e3602c..8ed105a22de3 100644<br />--- a/fs/devpts/inode.c<br />+++ b/fs/devpts/inode.c<br />&#64;&#64; -133,6 +133,48 &#64;&#64; static inline struct pts_fs_info *DEVPTS_SB(struct super_block *sb)<br /> 	return sb-&gt;s_fs_info;<br /> }<br /> <br />+static int devpts_ptmx_path(struct path *path)<br />+{<br />+	int err;<br />+	struct super_block *sb;<br />+<br />+	/* Has the devpts filesystem already been found? */<br />+	sb = path-&gt;mnt-&gt;mnt_sb;<br />+	if (sb-&gt;s_magic == DEVPTS_SUPER_MAGIC)<br />+		return 0;<br />+<br />+	/* Is a devpts filesystem at "pts" in the same directory? */<br />+	err = path_pts(path);<br />+	if (err)<br />+		return err;<br />+<br />+	sb = path-&gt;mnt-&gt;mnt_sb;<br />+<br />+	/* Is the path the root of a devpts filesystem? */<br />+	if ((sb-&gt;s_magic != DEVPTS_SUPER_MAGIC) ||<br />+	    (path-&gt;mnt-&gt;mnt_root != sb-&gt;s_root))<br />+		return -ENODEV;<br />+<br />+	return 0;<br />+}<br />+<br />+struct vfsmount *devpts_mnt(struct file *filp)<br />+{<br />+	struct path path;<br />+	int err;<br />+<br />+	path = filp-&gt;f_path;<br />+	path_get(&amp;path);<br />+<br />+	err = devpts_ptmx_path(&amp;path);<br />+	if (err) {<br />+		mntput(path.mnt);<br />+		path.mnt = ERR_PTR(err);<br />+	}<br />+	dput(path.dentry);<br />+	return path.mnt;<br />+}<br />+<br /> struct pts_fs_info *devpts_acquire(struct file *filp)<br /> {<br /> 	struct pts_fs_info *result;<br />&#64;&#64; -143,27 +185,16 &#64;&#64; struct pts_fs_info *devpts_acquire(struct file *filp)<br /> 	path = filp-&gt;f_path;<br /> 	path_get(&amp;path);<br /> <br />-	/* Has the devpts filesystem already been found? */<br />-	sb = path.mnt-&gt;mnt_sb;<br />-	if (sb-&gt;s_magic != DEVPTS_SUPER_MAGIC) {<br />-		/* Is a devpts filesystem at "pts" in the same directory? */<br />-		err = path_pts(&amp;path);<br />-		if (err) {<br />-			result = ERR_PTR(err);<br />-			goto out;<br />-		}<br />-<br />-		/* Is the path the root of a devpts filesystem? */<br />-		result = ERR_PTR(-ENODEV);<br />-		sb = path.mnt-&gt;mnt_sb;<br />-		if ((sb-&gt;s_magic != DEVPTS_SUPER_MAGIC) ||<br />-		    (path.mnt-&gt;mnt_root != sb-&gt;s_root))<br />-			goto out;<br />+	err = devpts_ptmx_path(&amp;path);<br />+	if (err) {<br />+		result = ERR_PTR(err);<br />+		goto out;<br /> 	}<br /> <br /> 	/*<br /> 	 * pty code needs to hold extra references in case of last /dev/tty close<br /> 	 */<br />+	sb = path.mnt-&gt;mnt_sb;<br /> 	atomic_inc(&amp;sb-&gt;s_active);<br /> 	result = DEVPTS_SB(sb);<br /> <br />diff --git a/include/linux/devpts_fs.h b/include/linux/devpts_fs.h<br />index 277ab9af9ac2..e27c548acfb0 100644<br />--- a/include/linux/devpts_fs.h<br />+++ b/include/linux/devpts_fs.h<br />&#64;&#64; -19,6 +19,7 &#64;&#64;<br /> <br /> struct pts_fs_info;<br /> <br />+struct vfsmount *devpts_mnt(struct file *);<br /> struct pts_fs_info *devpts_acquire(struct file *);<br /> void devpts_release(struct pts_fs_info *);<br /> <br />&#64;&#64; -32,6 +33,15 &#64;&#64; void *devpts_get_priv(struct dentry *);<br /> /* unlink */<br /> void devpts_pty_kill(struct dentry *);<br /> <br />+/* in pty.c */<br />+int ptm_open_peer(struct file *master, struct tty_struct *tty, int flags);<br />+<br />+#else<br />+static inline int<br />+ptm_open_peer(struct file *master, struct tty_struct *tty, int flags)<br />+{<br />+	return -EIO;<br />+}<br /> #endif<br /> <br /> </pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
