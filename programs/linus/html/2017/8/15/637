    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/8/14/1000">First message in thread</a></li><li><a href="/lkml/2017/8/14/1225">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/15/623">Tim Chen</a><ul><li class="origin"><a href="/lkml/2017/8/15/641">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/15/641">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2017/8/15/703">Davidlohr Bueso</a><ul><li><a href="/lkml/2017/8/15/707">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/15/708">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/15/719">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 15 Aug 2017 12:41:01 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 1/2] sched/wait: Break up long wake list walk</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Aug 15, 2017 at 12:05 PM, Tim Chen &lt;tim.c.chen&#64;linux.intel.com&gt; wrote:<br />&gt;<br />&gt; We have a test case but it is a customer workload.  We'll try to get<br />&gt; a bit more info.<br /><br />Ok. Being a customer workload is lovely in the sense that it is<br />actually a real load, not just a microbecnhmark.<br /><br />But yeah, it makes it harder to describe and show what's going on.<br /><br />But you do have access to that workload internally at Intel, and can<br />at least test things out that way, I assume?<br /><br />&gt; I agree that dynamic sizing makes a lot of sense.  We'll check to<br />&gt; see if additional size to the hash table helps, assuming that the<br />&gt; waiters are distributed among different pages for our test case.<br /><br />One more thing: it turns out that there are two very different kinds<br />of users of the page waitqueue.<br /><br />There's the "wait_on_page_bit*()" users - people waiting for a page to<br />unlock or stop being under writeback etc.<br /><br />Those *should* generally be limited to just one wait-queue per waiting<br />thread, I think.<br /><br />Then there is the "cachefiles" use, which ends up adding a lot of<br />waitqueues to a lot of paghes to monitor their state.<br /><br />Honestly, I think that second use a horrible hack. It basically adds a<br />waitqueue to each page in order to get a callback when it is ready,<br />and then copies it.<br /><br />And it does this for things like cachefiles_read_backing_file(), so<br />you might have a huge list of pages for copying a large file, and it<br />adds a callback for every single one of those all at once.<br /><br />The fix for the cachefiles behavior might be very different from the<br />fix to the "normal" operations. But making the wait queue hash tables<br />bigger _should_ help both cases.<br /><br />We might also want to hash based on the actual bit we're waiting for.<br />Right now we just do a<br /><br />        wait_queue_head_t *q = page_waitqueue(page);<br /><br />but I think the actual bit is always explicit (well, the cachefiles<br />interface doesn't have that, but looking at the callback for that, it<br />really only cares about PG_locked, so it *should* make the bit it is<br />waiting for explicit).<br /><br />So if we have unnecessarily collisions because we have waiters looking<br />at different bits of the same page, we could just hash in the bit<br />number that we're waiting for too.<br /><br />               Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
