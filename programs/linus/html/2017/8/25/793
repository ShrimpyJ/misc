    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/8/25/542">First message in thread</a></li><li><a href="/lkml/2017/8/25/779">Tim Chen</a><ul><li><a href="/lkml/2017/8/25/789">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2017/8/25/804">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/25/804">Linus Torvalds</a><ul><li><a href="/lkml/2017/8/25/832">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2017/8/25/793/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 25 Aug 2017 16:03:50 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 2/2 v2] sched/wait: Introduce lock breaker in wake_up_page_bit</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Aug 25, 2017 at 3:51 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; So take it as that: example pseudo-code that happens to pass a<br />&gt; compiler, but is meant as a RFD rather than actually working.<br /><br />Oh, and after I sent it out, I wanted to look once again, and realized<br />that the "remove_myself_from()" function is entirely broken.<br /><br />The caller has already removed the page entry, we don't want to remove<br />it again, we want to add a *new* one with us removed from it.<br /><br />So here's an updated 2/2 patch with that fixed.<br /><br />Let this be a lesson in just *how* little tested, and *how* crap that<br />patch probably still is.<br /><br />                 Linus<br />From 3f3355eab709e6fa418466e5487a30eb6ec80423 Mon Sep 17 00:00:00 2001<br />From: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />Date: Fri, 25 Aug 2017 16:01:36 -0700<br />Subject: [PATCH 2/2] Re-implement the page bit-wait code<br /><br />The page wait-queues have some horrible scaling issues, and they seem to<br />be hard to fix.  And the way they use the regular wait-queues made that<br />really bad, with interrupts disabled for long times etc.<br /><br />This tries to re-implement them with a totally different model.  It's<br />known broken, and the add_page_wait_queue() thing that the cachefiles<br />code wants to use is not implemented at all (it probably will just need<br />to have a parallel set of wait-queues that are *only* used for that).<br /><br />The code is untested and probably horribly buggy, but I'm hoping others<br />will take a look at this.<br /><br />Not-signed-off-yet-by: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />---<br /> mm/page_wait_bit.c | 335 +++++++++++++++++++++++++++++++++++++----------------<br /> 1 file changed, 235 insertions(+), 100 deletions(-)<br /><br />diff --git a/mm/page_wait_bit.c b/mm/page_wait_bit.c<br />index 7550b6d2715a..968bc9b1cf21 100644<br />--- a/mm/page_wait_bit.c<br />+++ b/mm/page_wait_bit.c<br />&#64;&#64; -9,9 +9,38 &#64;&#64;<br /> #include &lt;linux/wait.h&gt;<br /> #include &lt;linux/export.h&gt;<br /> #include &lt;linux/sched/signal.h&gt;<br />+#include &lt;linux/list_bl.h&gt;<br /> <br /> #include "internal.h"<br /> <br />+/*<br />+ * Each waiter on a page will register this<br />+ * 'page_wait_struct' as part of waiting.<br />+ *<br />+ * Note that for any particular page, only one of the<br />+ * structs will actually be visible at the head of the<br />+ * wait queue hash table at any particular time, but<br />+ * everybody has one, because as one waiter is woken<br />+ * up we will need to pick another head for waiters.<br />+ *<br />+ * NOTE! All the list operations are protected by the<br />+ * hlist_bl_lock on the hash table.<br />+ */<br />+struct page_wait_struct {<br />+	// This is the hash queue head entry<br />+	// only used once per { page, bit }<br />+	struct hlist_bl_node list;<br />+	struct page *page;<br />+	int bit;<br />+<br />+	struct page_wait_struct *all;<br />+	struct page_wait_struct *exclusive;<br />+<br />+	// This is the waiter list<br />+	struct page_wait_struct *next;<br />+	struct task_struct *wake;<br />+};<br />+<br /> /*<br />  * In order to wait for pages to become available there must be<br />  * waitqueues associated with pages. By using a hash table of<br />&#64;&#64; -22,11 +51,11 &#64;&#64;<br />  * at a cost of "thundering herd" phenomena during rare hash<br />  * collisions.<br />  */<br />-#define PAGE_WAIT_TABLE_BITS 8<br />+#define PAGE_WAIT_TABLE_BITS 12<br /> #define PAGE_WAIT_TABLE_SIZE (1 &lt;&lt; PAGE_WAIT_TABLE_BITS)<br />-static wait_queue_head_t page_wait_table[PAGE_WAIT_TABLE_SIZE] __cacheline_aligned;<br />+static struct hlist_bl_head page_wait_table[PAGE_WAIT_TABLE_SIZE] __cacheline_aligned;<br /> <br />-static wait_queue_head_t *page_waitqueue(struct page *page)<br />+static struct hlist_bl_head *page_waitqueue(struct page *page)<br /> {<br /> 	return &amp;page_wait_table[hash_ptr(page, PAGE_WAIT_TABLE_BITS)];<br /> }<br />&#64;&#64; -36,73 +65,155 &#64;&#64; void __init pagecache_init(void)<br /> 	int i;<br /> <br /> 	for (i = 0; i &lt; PAGE_WAIT_TABLE_SIZE; i++)<br />-		init_waitqueue_head(&amp;page_wait_table[i]);<br />+		INIT_HLIST_BL_HEAD(&amp;page_wait_table[i]);<br /> <br /> 	page_writeback_init();<br /> }<br /> <br />-struct wait_page_key {<br />-	struct page *page;<br />-	int bit_nr;<br />-	int page_match;<br />-};<br />+/*<br />+ * We found a wait entry for the requested page and bit.<br />+ *<br />+ * We now need to create a wakeup list, which includes the<br />+ * first exclusive waiter (if any), and all the non-exclusive<br />+ * ones.<br />+ *<br />+ * If there are more than one exclusive waiters, we need to<br />+ * turns the next exclusive waiter into a wait entry, and<br />+ * add it back to the page wait list.<br />+ */<br />+static struct page_wait_struct *create_wake_up_list(struct page_wait_struct *entry, struct hlist_bl_head *head)<br />+{<br />+	struct page_wait_struct *all = entry-&gt;all;<br />+	struct page_wait_struct *exclusive = entry-&gt;exclusive;<br /> <br />-struct wait_page_queue {<br />-	struct page *page;<br />-	int bit_nr;<br />-	wait_queue_entry_t wait;<br />-};<br />+	if (exclusive) {<br />+		struct page_wait_struct *remain = exclusive-&gt;next;<br />+<br />+		if (remain) {<br />+			remain-&gt;all = NULL;<br />+			remain-&gt;exclusive = remain;<br />+			hlist_bl_add_head(&amp;remain-&gt;list, head);<br />+		}<br />+		exclusive-&gt;next = all;<br />+		all = exclusive;<br />+	}<br />+	return all;<br />+}<br /> <br />-static int wake_page_function(wait_queue_entry_t *wait, unsigned mode, int sync, void *arg)<br />+static inline int remove_myself_from_one_list(struct page_wait_struct **p, struct page_wait_struct *entry)<br /> {<br />-	struct wait_page_key *key = arg;<br />-	struct wait_page_queue *wait_page<br />-		= container_of(wait, struct wait_page_queue, wait);<br />+	while (*p) {<br />+		struct page_wait_struct *n = *p;<br />+		if (n == entry) {<br />+			*p = n-&gt;next;<br />+			return 1;<br />+		}<br />+		p = &amp;n-&gt;next;<br />+	}<br />+	return 0;<br />+}<br /> <br />-	if (wait_page-&gt;page != key-&gt;page)<br />-	       return 0;<br />-	key-&gt;page_match = 1;<br />+/*<br />+ * We got woken up, and we need to make sure there is no more<br />+ * access to us in the list.<br />+ */<br />+static void remove_myself_from(struct page_wait_struct *old, struct page_wait_struct *entry, struct hlist_bl_head *head)<br />+{<br />+	struct page_wait_struct *new;<br /> <br />-	if (wait_page-&gt;bit_nr != key-&gt;bit_nr)<br />-		return 0;<br />-	if (test_bit(key-&gt;bit_nr, &amp;key-&gt;page-&gt;flags))<br />-		return 0;<br />+	/* We can be on only one list */<br />+	if (!remove_myself_from_one_list(&amp;old-&gt;all, entry))<br />+		remove_myself_from_one_list(&amp;old-&gt;exclusive, entry);<br /> <br />-	return autoremove_wake_function(wait, mode, sync, key);<br />+	/*<br />+	 * If we were the old entry for the page/bit on the hash list,<br />+	 * we need to create a new one from one of the existing other<br />+	 * ones.<br />+	 *<br />+	 * If the head entry was somebody else, or if there are no<br />+	 * other wait entries for this page, we're done.<br />+	 */<br />+	if (old != entry)<br />+		return;<br />+<br />+	new = entry-&gt;exclusive;<br />+	if (!new) {<br />+		new = entry-&gt;all;<br />+		if (!new)<br />+			return;<br />+	}<br />+<br />+	/*<br />+	 * We can just use our old lists - we already removed our own<br />+	 * entry from them above.<br />+	 */<br />+	new-&gt;exclusive = entry-&gt;exclusive;<br />+	new-&gt;all = entry-&gt;all;<br />+	hlist_bl_add_head(&amp;new-&gt;list, head);<br />+}<br />+<br />+<br />+/*<br />+ * Find and remove the matching page/bit entry from the (locked) bl list<br />+ *<br />+ * Return ERR_PTR(-ESRCH) if no matching page at all, NULL if page found<br />+ * but not with matching bit.<br />+ */<br />+static struct page_wait_struct *find_del_entry(struct page *page, int bit_nr, struct hlist_bl_head *head)<br />+{<br />+	struct page_wait_struct *entry;<br />+	struct page_wait_struct *ret = ERR_PTR(-ESRCH);<br />+	struct hlist_bl_node *node;<br />+<br />+	hlist_bl_for_each_entry(entry, node, head, list) {<br />+		if (entry-&gt;page != page)<br />+			continue;<br />+		ret = NULL;<br />+		if (entry-&gt;bit != bit_nr)<br />+			continue;<br />+		__hlist_bl_del(node);<br />+		INIT_HLIST_BL_NODE(node);<br />+		ret = entry;<br />+		break;<br />+	}<br />+	return ret;<br /> }<br /> <br /> static void wake_up_page_bit(struct page *page, int bit_nr)<br /> {<br />-	wait_queue_head_t *q = page_waitqueue(page);<br />-	struct wait_page_key key;<br />+	struct hlist_bl_head *head = page_waitqueue(page);<br />+	struct page_wait_struct *wake;<br /> 	unsigned long flags;<br /> <br />-	key.page = page;<br />-	key.bit_nr = bit_nr;<br />-	key.page_match = 0;<br />+	local_save_flags(flags);<br />+	hlist_bl_lock(head);<br />+<br />+	wake = find_del_entry(page, bit_nr, head);<br />+	if (IS_ERR(wake)) {<br />+		ClearPageWaiters(page);<br />+		wake = NULL;<br />+	} else if (wake) {<br />+		wake = create_wake_up_list(wake, head);<br />+	}<br />+<br />+	hlist_bl_unlock(head);<br />+	local_irq_restore(flags);<br /> <br />-	spin_lock_irqsave(&amp;q-&gt;lock, flags);<br />-	__wake_up_locked_key(q, TASK_NORMAL, &amp;key);<br /> 	/*<br />-	 * It is possible for other pages to have collided on the waitqueue<br />-	 * hash, so in that case check for a page match. That prevents a long-<br />-	 * term waiter<br />+	 * Actually wake everybody up. Note that as we<br />+	 * wake them up, we can't use the 'wake_list'<br />+	 * entry any more, because it's on their stack.<br /> 	 *<br />-	 * It is still possible to miss a case here, when we woke page waiters<br />-	 * and removed them from the waitqueue, but there are still other<br />-	 * page waiters.<br />+	 * We also clear the 'wake' field so that the<br />+	 * target process can see if they got woken up<br />+	 * by a page bit event.<br /> 	 */<br />-	if (!waitqueue_active(q) || !key.page_match) {<br />-		ClearPageWaiters(page);<br />-		/*<br />-		 * It's possible to miss clearing Waiters here, when we woke<br />-		 * our page waiters, but the hashed waitqueue has waiters for<br />-		 * other pages on it.<br />-		 *<br />-		 * That's okay, it's a rare case. The next waker will clear it.<br />-		 */<br />-	}<br />-	spin_unlock_irqrestore(&amp;q-&gt;lock, flags);<br />+	while (wake) {<br />+		struct task_struct *p = wake-&gt;wake;<br />+		wake = wake-&gt;next;<br />+		smp_store_release(&amp;wake-&gt;wake, NULL);<br />+		wake_up_process(p);<br />+	};<br /> }<br /> <br /> static void wake_up_page(struct page *page, int bit)<br />&#64;&#64; -112,76 +223,101 &#64;&#64; static void wake_up_page(struct page *page, int bit)<br /> 	wake_up_page_bit(page, bit);<br /> }<br /> <br />-static inline int wait_on_page_bit_common(wait_queue_head_t *q,<br />-		struct page *page, int bit_nr, int state, bool lock)<br />+/*<br />+ * Wait for the specific page bit to clear.<br />+ */<br />+static void wait_once_on_page_bit(struct page *page, int bit_nr, int state, bool lock)<br /> {<br />-	struct wait_page_queue wait_page;<br />-	wait_queue_entry_t *wait = &amp;wait_page.wait;<br />-	int ret = 0;<br />+	struct page_wait_struct entry, *old;<br />+	struct hlist_bl_head *head;<br />+	unsigned long flags;<br /> <br />-	init_wait(wait);<br />-	wait-&gt;func = wake_page_function;<br />-	wait_page.page = page;<br />-	wait_page.bit_nr = bit_nr;<br />+	INIT_HLIST_BL_NODE(&amp;entry.list);<br />+	entry.page = page;<br />+	entry.bit = bit_nr;<br />+	entry.all = entry.exclusive = NULL;<br />+	entry.next = NULL;<br />+	entry.wake = current;<br />+<br />+	head = page_waitqueue(page);<br />+	local_save_flags(flags);<br />+	hlist_bl_lock(head);<br />+<br />+	old = find_del_entry(page, bit_nr, head);<br />+	if (IS_ERR(old))<br />+		old = NULL;<br />+	if (old) {<br />+		entry.all = old-&gt;all;<br />+		entry.exclusive = old-&gt;exclusive;<br />+	}<br /> <br />-	for (;;) {<br />-		spin_lock_irq(&amp;q-&gt;lock);<br />-<br />-		if (likely(list_empty(&amp;wait-&gt;entry))) {<br />-			if (lock)<br />-				__add_wait_queue_entry_tail_exclusive(q, wait);<br />-			else<br />-				__add_wait_queue(q, wait);<br />-			SetPageWaiters(page);<br />-		}<br />+	if (lock) {<br />+		entry.next = entry.exclusive;<br />+		entry.exclusive = &amp;entry;<br />+	} else {<br />+		entry.next = entry.all;<br />+		entry.all = &amp;entry;<br />+	}<br /> <br />-		set_current_state(state);<br />+	hlist_bl_add_head(&amp;entry.list, head);<br />+	current-&gt;state = state;<br /> <br />-		spin_unlock_irq(&amp;q-&gt;lock);<br />+	hlist_bl_unlock(head);<br />+	local_irq_restore(flags);<br /> <br />-		if (likely(test_bit(bit_nr, &amp;page-&gt;flags))) {<br />-			io_schedule();<br />-			if (unlikely(signal_pending_state(state, current))) {<br />-				ret = -EINTR;<br />-				break;<br />-			}<br />-		}<br />+	if (likely(test_bit(bit_nr, &amp;page-&gt;flags)))<br />+		io_schedule();<br /> <br />+	/*<br />+	 * NOTE! If we were woken up by something else,<br />+	 * we have to remove ourselves from the hash list.<br />+	 *<br />+	 * But in order to avoid extra locking overhead in<br />+	 * the common case, we only do this if we can't<br />+	 * already tell that we were woken up (and thus<br />+	 * no longer on the lists).<br />+	 */<br />+	if (smp_load_acquire(&amp;entry.wake) != NULL) {<br />+		local_save_flags(flags);<br />+		hlist_bl_lock(head);<br />+<br />+		old = find_del_entry(page, bit_nr, head);<br />+		if (old &amp;&amp; !IS_ERR(old))<br />+			remove_myself_from(old, &amp;entry, head);<br />+<br />+		hlist_bl_unlock(head);<br />+		local_irq_restore(flags);<br />+	}<br />+}<br />+<br />+static inline int wait_on_page_bit_common(struct page *page, int bit_nr, int state, bool lock)<br />+{<br />+	for (;;) {<br />+		wait_once_on_page_bit(page, bit_nr, state, lock);<br /> 		if (lock) {<br /> 			if (!test_and_set_bit_lock(bit_nr, &amp;page-&gt;flags))<br />-				break;<br />+				return 0;<br /> 		} else {<br /> 			if (!test_bit(bit_nr, &amp;page-&gt;flags))<br />-				break;<br />+				return 0;<br /> 		}<br />+		if (unlikely(signal_pending_state(state, current)))<br />+			return -EINTR;<br /> 	}<br />-<br />-	finish_wait(q, wait);<br />-<br />-	/*<br />-	 * A signal could leave PageWaiters set. Clearing it here if<br />-	 * !waitqueue_active would be possible (by open-coding finish_wait),<br />-	 * but still fail to catch it in the case of wait hash collision. We<br />-	 * already can fail to clear wait hash collision cases, so don't<br />-	 * bother with signals either.<br />-	 */<br />-<br />-	return ret;<br /> }<br /> <br /> void wait_on_page_bit(struct page *page, int bit_nr)<br /> {<br />-	wait_queue_head_t *q = page_waitqueue(page);<br />-	wait_on_page_bit_common(q, page, bit_nr, TASK_UNINTERRUPTIBLE, false);<br />+	wait_on_page_bit_common(page, bit_nr, TASK_UNINTERRUPTIBLE, false);<br /> }<br /> EXPORT_SYMBOL(wait_on_page_bit);<br /> <br /> int wait_on_page_bit_killable(struct page *page, int bit_nr)<br /> {<br />-	wait_queue_head_t *q = page_waitqueue(page);<br />-	return wait_on_page_bit_common(q, page, bit_nr, TASK_KILLABLE, false);<br />+	return wait_on_page_bit_common(page, bit_nr, TASK_KILLABLE, false);<br /> }<br /> <br />+#if 0<br /> /**<br />  * add_page_wait_queue - Add an arbitrary waiter to a page's wait queue<br />  * &#64;page: Page defining the wait queue of interest<br />&#64;&#64; -200,6 +336,7 &#64;&#64; void add_page_wait_queue(struct page *page, wait_queue_entry_t *waiter)<br /> 	spin_unlock_irqrestore(&amp;q-&gt;lock, flags);<br /> }<br /> EXPORT_SYMBOL_GPL(add_page_wait_queue);<br />+#endif<br /> <br /> <br /> /**<br />&#64;&#64; -209,16 +346,14 &#64;&#64; EXPORT_SYMBOL_GPL(add_page_wait_queue);<br /> void __lock_page(struct page *__page)<br /> {<br /> 	struct page *page = compound_head(__page);<br />-	wait_queue_head_t *q = page_waitqueue(page);<br />-	wait_on_page_bit_common(q, page, PG_locked, TASK_UNINTERRUPTIBLE, true);<br />+	wait_on_page_bit_common(page, PG_locked, TASK_UNINTERRUPTIBLE, true);<br /> }<br /> EXPORT_SYMBOL(__lock_page);<br /> <br /> int __lock_page_killable(struct page *__page)<br /> {<br /> 	struct page *page = compound_head(__page);<br />-	wait_queue_head_t *q = page_waitqueue(page);<br />-	return wait_on_page_bit_common(q, page, PG_locked, TASK_KILLABLE, true);<br />+	return wait_on_page_bit_common(page, PG_locked, TASK_KILLABLE, true);<br /> }<br /> EXPORT_SYMBOL_GPL(__lock_page_killable);<br /> <br />-- <br />2.14.0.rc1.2.g4c8247ec3<br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
