    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/10/31/610">First message in thread</a></li><li><a href="/lkml/2017/10/31/646">Linus Torvalds</a><ul><li><a href="/lkml/2017/10/31/660">Russell King - ARM Linux</a><ul><li class="origin"><a href="/lkml/2017/10/31/712">Linus Torvalds</a><ul><li><a href="/lkml/2017/10/31/712">Linus Torvalds</a></li><li><a href="/lkml/2017/10/31/988">Doug Anderson</a><ul><li><a href="/lkml/2017/11/1/111">Russell King - ARM Linux</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 31 Oct 2017 10:45:22 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC] Improving udelay/ndelay on platforms where that is possible</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Oct 31, 2017 at 9:56 AM, Russell King - ARM Linux<br />&lt;linux&#64;armlinux.org.uk&gt; wrote:<br />&gt;<br />&gt; Marc is stating something that's incorrect there.  On ARM32, we don't<br />&gt; have a TSC, and we aren't guaranteed to have a timer usable for delays.<br />&gt; Where there is a suitable timer, it can be used for delays.<br />&gt;<br />&gt; However, where there isn't a timer, we fall back to using the software<br />&gt; loop, and that's where the problem lies.  For example, some platforms<br />&gt; have a relatively slow timer (32kHz).<br /><br />Right.<br /><br />So that is actually the basic issue: there is no way for us to really<br />_ever_ give any kind of guarantees about the behavior of<br />udelay/ndelay() in every general case.<br /><br />We can't even guarantee some kind of "at least" behavior, because on<br />some platforms there is no reasonable stable clock at all.<br /><br />We can give good results in certain _particular_ cases, but not in<br />some kind of blanket "we will always do well" way.<br /><br />Traditionally, we used to obviously do the bogo-loop, but it depends<br />on processor frequency, which can (and does) change even outside SW<br />control, never mind things like interrupts etc.<br /><br />On lots of platforms, we can generally do platform-specific clocks. On<br />modern x86, as mentioned, the TSC is stable and fairly high frequency<br />(it isn't really the gigahertz frequency that it reports - reading it<br />takes time, and even ignoring that, the implementation is actually not<br />a true adder at the reported frequency, but it is generally tens of<br />hundreds of megahertz, so you should get something that is close to<br />the "tens of nanoseconds" resolution).<br /><br />But on others we can't even get *close* to that kind of behavior, and<br />if the clock is something like a 32kHz timer that you mention, you<br />obviously aren't going to get even microsecond resotulion, much less<br />nanoseconds.<br /><br />You can (and on x86 we do) calibrate a faster non-architected clock<br />against a slow clock, but all the faster clocks tend to have that<br />frequency shifting issue.<br /><br />So then you tend to be forced to simply rely on platform-specific<br />hacks if you really need something more precise. Most people don't,<br />which is why most people just use udelay() and friends.<br /><br />In particular, several drivers end up depending not on an explicit<br />clock at all, but on the IO fabric itself. For a driver for a<br />particular piece of hardware, that is often the sanest way to do<br />really short timing: if you know you are on a PCI bus and you know<br />your own hardware, you can often do things like "reading the status<br />register takes 6 bus cycles, which is 200 nsec". Things like that are<br />very hacky, but for a driver that is looking at times in the usec<br />range, it's often the best you can do.<br /><br />Don't get me wrong. I think<br /><br /> (a) platform code could try to make their udelay/ndelay() be as good<br />as it can be on a particular platform<br /><br /> (b) we could maybe export some interface to give estimated errors so<br />that drivers could then try to corrtect for them depending on just how<br />much they care.<br /><br />so I'm certainly not _opposed_ to trying to improve on<br />udelay/ndelay(). It's just that for the generic case, we know we're<br />never going to be very good, and the error (both absolute and<br />relative) can be pretty damn big.<br /><br />One of the issues has historically been that because so few people<br />care, and because there are probably more platforms than there are<br />cases that care deeply, even that (a) thing is actually fairly hard to<br />do. On the x86 side, for example, I doubt that most core kernel<br />developers even have access to platforms that have unstable TSC's any<br />more. I certainly don't. I complained to Intel for many many _years_,<br />but they finally did fix it, and now it's been a long time since I<br />cared.<br /><br />That's why I actually would encourage driver writers that really care<br />deeply about delays to look at ways to get those delays from their own<br />hardware (ie exactly that "read the status register three times" kind<br />of model). It sounds hacky, but it couples the timing constraint with<br />the piece of hardware that actually depends on it, which means that<br />you don't get the nasty kinds of "worry about each platform"<br />complications.<br /><br />I realize that this is not what people want to hear. In a perfect<br />world, we'd just make "ndelay()" work and give the right behavior, and<br />have some strictly bounded error.<br /><br />It's just that it's really fundamentally hard in the general case,<br />even if it sounds like it should be pretty trivial in most<br />_particular_ cases.<br /><br />So I'm very much open to udelay improvements, and if somebody sends<br />patches for particular platforms to do particularly well on that<br />platform, I think we should merge them. But ...<br /><br />                Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
