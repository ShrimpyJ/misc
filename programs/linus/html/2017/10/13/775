    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/10/12/846">First message in thread</a></li><li><a href="/lkml/2017/10/12/891">Linus Torvalds</a><ul><li><a href="/lkml/2017/10/13/190">Ben Maurer</a><ul><li class="origin"><a href="/lkml/2017/10/13/907">Linus Torvalds</a><ul><li><a href="/lkml/2017/10/13/907">"Paul E. McKenney"</a><ul><li><a href="/lkml/2017/10/13/916">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2017/10/13/1022">Andi Kleen</a><ul><li><a href="/lkml/2017/10/14/9">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 13 Oct 2017 11:30:29 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC PATCH v9 for 4.15 01/14] Restartable sequences system call</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Oct 13, 2017 at 2:35 AM, Ben Maurer &lt;bmaurer&#64;fb.com&gt; wrote:<br />&gt;<br />&gt; I'm really excited to hear that you're open to this patch set and totally understand the desire for some more numbers.<br /><br />So the patch-set actually looks very reasonable today. I looked<br />through it (ok, I wasn't cc'd on the ppc-only patches so I didn't look<br />at those, but I don't think they are likely objectionable either), and<br />everything looked fine from a patch standpoint.<br /><br />But it's not _just_ numbers for real loads I'm looking for, it's<br />actually an _existence proof_ for a real load too. I'd like to know<br />that the suggested interface _really_ works in practice too for all<br />the expected users.<br /><br />In particular, it's easy to make test-cases to show basic<br />functionality, but that does not necessarily show that the interface<br />then works in "real life".<br /><br />For example, if this is supposed to work for a malloc library, it's<br />important that people show that yes, this can really work in a<br />*LIBRARY*.<br /><br />That sounds so obvious and stupid that you might go "What do you<br />mean?", but for things to work for libraries, they have to work<br />together with *other* users, and with *independent* users.<br /><br />For example, say that you're some runtime that wants to use the percpu<br />thing for percpu counters - because you want to avoid cache ping-pong,<br />and you want to avoid per-thread allocation overhead (or per-thread<br />scaling for just summing up the counters) when you have potentially<br />tens of thousands of threads.<br /><br />Now, how does this runtime work *together* with<br /><br /> - CPU hotplug adding new cpu's while you are running (and after you<br />allocated your percpu areas)<br /><br /> - libraries and system admins that limit - or extend - you to a<br />certain set of CPUs<br /><br /> - another library (like the malloc library) that wants to use the<br />same interface for its percpu allocation queues.<br /><br />maybe all of this "just works", but I really want to see an existence<br />proof.  Not just a "dedicated use of the interface for one benchmark".<br /><br />So yes, I want to see numbers, but I really want to see something much<br />more fundamental. I want to feel like there is a good reason to<br />believe that the interface really is sufficient and that it really<br />does work, even when a single thread may have multiple *different*<br />uses for this. Statistics, memory allocation queues, RCU, per-cpu<br />locking, yadda yadda. All these things may want to use this, but they<br />want to use it *together*, and without you having to write special<br />code where every user needs to know about every other user statically.<br /><br />Can you load two different *dynamic* libraries that each independently<br />uses this thing for their own use, without having to be built together<br />for each other?<br /><br />&gt;&gt; A "increment percpu value" simply isn't relevant.<br />&gt;<br />&gt; While I understand it seems trivial, my experience has been that this type of operation can actually be important in many server workloads.<br /><br />Oh, I'm not saying that it's not relevant to have high-performance<br />statistics gathering using percpu data structures. Of _course_ that is<br />important, we do that very much in the kernel itself.<br /><br />But a benchmark that does nothing else really isn't relevant.  If the<br />*only* thing somebody uses this for is statistics, it's simply not<br />good enough.<br /><br /><br />&gt;&gt; Because without real-world uses, it's not obvious that there won't be<br />&gt;&gt; somebody who goes "oh, this isn't quite enough for us, the semantics<br />&gt;&gt; are subtly incompatible with our real-world use case".<br />&gt;<br />&gt; Is your concern mainly this question (is this patchset a good way to<br />&gt; bring per-cpu algorithms to userspace)? I'm hoping that given the<br />&gt; variety of ways that per-cpu data structures are used in the kernel<br />&gt; the concerns around this patch set are mainly around what approach we<br />&gt; should take rather than if per-cpu algorithms are a good idea at all.<br />&gt; If this is your main concern perhaps our focus should be around<br />&gt; demonstrating that a number of useful per-cpu algorithms can be<br />&gt; implemented using restartable sequences.<br /><br />The important thing for me is that it should demonstrate that you can<br />have users co-exists, and that the interface is sufficient for that.<br /><br />So I do want to see "just numbers" in the sense that I would want to<br />see that people have actually written code that takes advantage of the<br />percpu nature to do real things (like an allocator). But more than<br />that, I want to see *use*.<br /><br />&gt; Ultimately I'm worried there's a chicken and egg problem here.<br /><br />This patch-set has been around for *years* in some form. It's improved<br />over the years, but the basic approaches are not new.<br /><br />Honestly, if people still don't have any actual user-level code that<br />really _uses_ this, I'm not interested in merging it.<br /><br />There's no chicken-and-egg here. Anybody who wants to push this<br />patch-set needs to write the user level code to validate that the<br />patch-set makes sense. That's not chicken-and-egg, that's just<br />"without the user-space code, the kernel code has never been tested,<br />validated or used".<br /><br />And if nobody can be bothered to write the user-level code and test<br />this patch-series, then obviously it's not important enough for the<br />kernel to merge it.<br /><br />                      Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
