    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/12/3/87">First message in thread</a></li><li><a href="/lkml/2017/12/13/822">Thomas Gleixner</a><ul><li><a href="/lkml/2017/12/13/887">"Rafael J. Wysocki"</a></li><li><a href="/lkml/2017/12/14/211">Thomas Gleixner</a><ul><li><a href="/lkml/2017/12/14/221">"Rafael J. Wysocki"</a><ul><li><a href="/lkml/2017/12/14/229">Thomas Gleixner</a><ul><li><a href="/lkml/2017/12/14/437">"Rafael J. Wysocki"</a></li></ul></li></ul></li><li><a href="/lkml/2017/12/14/288">Thomas Gleixner</a></li><li class="origin"><a href="/lkml/2017/12/14/861">Linus Torvalds</a><ul><li><a href="/lkml/2017/12/14/861">Thomas Gleixner</a><ul><li><a href="/lkml/2017/12/14/867">Linus Torvalds</a></li><li><a href="/lkml/2017/12/14/913">"Rafael J. Wysocki"</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 14 Dec 2017 11:03:27 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Linux 4.15-rc2: Regression in resume from ACPI S3</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Thu, Dec 14, 2017 at 3:54 AM, Thomas Gleixner &lt;tglx&#64;linutronix.de&gt; wrote:<br />&gt;<br />&gt; So the old scheme silently consumed the spurious vector. I added debug code<br />&gt; to that effect to 4.14 and on that machine IRQ7 is triggered at the same<br />&gt; point post resume and the core code drops it silently because the interrupt<br />&gt; is marked masked and no action assigned.<br />&gt;<br />&gt; So the only difference to today is that the new code complains, while the<br />&gt; old one does an extra mask of the already masked IOAPIC pin and silently<br />&gt; returns.<br /><br />Great debugging, and it looks like Rafael has a patch that already got<br />positive testing.<br /><br />I just wanted to pipe up about that "irq7", because judging from your<br />email it seems like you think it's a real irq:<br /><br />&gt;        Now there is a race<br />&gt; whether the kernel resume path manages to mask the PIC again early enough<br />&gt; before something triggers IRQ7 or not.<br /><br />..and that's not how the PIC works.<br /><br />In fact, "legacy irq 7" is the _normal_ and very traditional spurious<br />interrupt, and it's documented. If the PIC gets an interrupt from<br />_any_ source, but the interrupt goes away before the PIC gets an<br />acknowledge from the CPU (and by "acknowledge", I'm not talking about<br />the explicit software IRQ ACK, I'm talking about the hardware<br />protocol, between the PIC and the CPU), the PIC will then report irq 7<br />as the interrupt - regardless of what the original was.<br /><br />The reason is almost always something like<br /><br /> - CPU interrupts are disabled or masked<br /><br /> - driver does a write to the external hardware that causes an<br />interrupt to be raised<br /><br /> - CPU doesn't react to the irq due to the disabled/masked nature<br /><br /> - but the driver then does something that masks the interrupt again<br /><br /> - interrupts are enabled/unmasked on the CPU<br /><br /> - CPU now acks the interrupt, but the PIC no longer sees any<br />interrupt source, so the PIC (that has to reply with *something*)<br />replies with that documented spurious irq7.<br /><br />To confuse things further, irq7 is not _exclusively_ the spurious<br />interrupt, You can definitely put real hardware and connect it to pin7<br />of the PIC, and get real irq7 reports.<br /><br />And to confuse things even *more*, this "irq7" thing is per-PIC, and<br />the PC model obviously has the whole "nested PIC" thing where the<br />second PIC is connected to irq2 of the first PIC. So there are *two*<br />different "spurious interrupt" reports, one for each PIC.<br /><br />Anyway, to avoid this issue, drivers should strive to<br /><br /> (a) actually take the interrupt when doing things that can cause<br />them, and have the interrupt handler do whatever it is that causes the<br />interrupt to go away (ie: "normal operation")<br /><br /> (b) if you play games with clearing the source of the interrupt<br />_without_ taking the interrupt, you should strive to basically mask<br />the interrupt first.<br /><br />So to do (b) you can do something like<br /><br />      mask_device_interrupt(dev);<br />      read_from_device_to_synchronize(dev);<br /><br />instead of (or perhaps _before_) disabling interrupts at a CPU level.<br />Suspend/resume obviously does tend to play games with these kinds of<br />things where you are no longer in "normal operation" and you do setup<br />without having interrupts actually enabled.<br /><br />Or you can just decide that spurious interrupts are ok, and ignore the<br />issue. But they *can* be very confusing, and obviously in this case<br />that confusion then seems to have caused actual problems.<br /><br />            Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
