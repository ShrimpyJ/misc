    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2017/11/29/959">First message in thread</a></li><li><a href="/lkml/2017/11/29/959">Cong Wang</a><ul><li class="origin"><a href="/lkml/2017/11/29/1331">Linus Torvalds</a><ul><li><a href="/lkml/2017/11/29/1331">Al Viro</a></li><li><a href="/lkml/2017/11/30/333">Christoph Hellwig</a><ul><li><a href="/lkml/2017/11/30/537">Al Viro</a><ul><li><a href="/lkml/2018/2/13/851">Dmitry Vyukov</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2017/11/29/1000">Eric Dumazet</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 29 Nov 2017 12:24:55 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: KASAN: use-after-free Read in sock_release</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Nov 29, 2017 at 11:37 AM, Cong Wang &lt;xiyou.wangcong&#64;gmail.com&gt; wrote:<br />&gt; (Cc'ing fs people...)<br />&gt;<br />&gt; On Wed, Nov 29, 2017 at 12:33 AM, syzbot wrote:<br />&gt;&gt; BUG: KASAN: use-after-free in sock_release+0x1c6/0x1e0 net/socket.c:601<br /><br />Lovely.<br /><br />Yeah, that is:<br /><br />   601          if (rcu_dereference_protected(sock-&gt;wq, 1)-&gt;fasync_list)<br /><br />and as you say, that "rcu_dereference_protected()" is confusing, but<br />that should be ok because we have a ref to the inode, and we're really<br />just testing that the pointer is zero.<br /><br />The call trace here is:<br /><br />&gt;&gt;  sock_release+0x1c6/0x1e0 net/socket.c:601<br />&gt;&gt;  sock_close+0x16/0x20 net/socket.c:1125<br />&gt;&gt;  __fput+0x333/0x7f0 fs/file_table.c:210<br />&gt;&gt;  ____fput+0x15/0x20 fs/file_table.c:244<br />&gt;&gt;  task_work_run+0x199/0x270 kernel/task_work.c:113<br /><br />and there is no RCU protection anywhere, but it's really just a sanity<br />check, and the access _should_ be ok.<br /><br />The stale access does seem to be because 'sock' (embedded in the<br />inode) itself that has been free'd:<br /><br />&gt;&gt; Allocated by task 31066:<br />&gt;&gt;  kmalloc include/linux/slab.h:499 [inline]<br />&gt;&gt;  sock_alloc_inode+0xb4/0x300 net/socket.c:253<br />&gt;&gt;  alloc_inode+0x65/0x180 fs/inode.c:208<br />&gt;&gt;  new_inode_pseudo+0x69/0x190 fs/inode.c:890<br />&gt;&gt;  sock_alloc+0x41/0x270 net/socket.c:565<br />&gt;&gt;  __sock_create+0x148/0x850 net/socket.c:1225<br />&gt;&gt;  sock_create net/socket.c:1301 [inline]<br />&gt;&gt;  SYSC_socket net/socket.c:1331 [inline]<br />&gt;&gt;  SyS_socket+0xeb/0x200 net/socket.c:1311<br />&gt;<br />&gt; This looks more like a fs issue than network, my fs knowledge<br />&gt; is not good enough to justify why the hell the inode could be<br />&gt; destroyed before we release the fd.<br /><br />Ugh. The inode freeing really is confusing and fairly involved, but<br />the last free *should* happen as part of the final dput() that is done<br />at the end of __fput().<br /><br />So in __fput() calls into the<br /><br />        if (file-&gt;f_op-&gt;release)<br />                file-&gt;f_op-&gt;release(inode, file);<br /><br />then the inode should still be around, because the final ref won't be<br />done until later. And RCU simply shouldn't be an issue, because of<br />that reference count on the inode.<br /><br />So it smells like some reference counting went wrong. The socket inode<br />creation is a bit confusing, and then in "sock_release()" we do have<br />that<br /><br />        if (!sock-&gt;file) {<br />                iput(SOCK_INODE(sock));<br />                return;<br />        }<br />        sock-&gt;file = NULL;<br /><br />which *also* tries to free the inode. I'm not sure what the logic (and<br />what the locking) behind that code all is.<br /><br />What *is* the locking for "sock-&gt;file" anyway?<br /><br />Al, can you take a look on the vfs side? But I'm inclined to blame the<br />socket code, because if we really had a "inode free'd early" issue at<br />a vfs level, I'd have expected us to see infinite chaos.<br /><br />             Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
