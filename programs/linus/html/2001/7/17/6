    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/7/17/2">First message in thread</a></li><li><a href="/lkml/2001/7/17/2">Tachino Nobuhiro</a><ul><li><a href="/lkml/2001/7/17/1">Linus Torvalds</a></li><li><a href="/lkml/2001/7/17/8">Tachino Nobuhiro</a><ul><li class="origin"><a href="/lkml/2001/7/17/9">Linus Torvalds</a><ul><li><a href="/lkml/2001/7/17/9">Ulrich Drepper</a><ul><li><a href="/lkml/2001/7/17/107">bert hubert</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 16 Jul 2001 23:40:02 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [BUG 2.4.6] PPID of a process is set to itself</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Tue, 17 Jul 2001, Tachino Nobuhiro wrote:<br />&gt; At Mon, 16 Jul 2001 21:41:56 -0700,<br />&gt; Linus Torvalds wrote:<br />&gt; &gt;<br />&gt; &gt; HOWEVER, the bug you hit is because CLONE_THREAD also implies<br />&gt; &gt; CLONE_PARENT, and the fork() code didn't actually enforce this. So<br />&gt; &gt; instead of your patch, we just should not allow the parent and the child<br />&gt; &gt; to be in the same thread group. Suggested real patch appended. Does this<br />&gt; &gt; fix it for you too?<br />&gt;<br />&gt; Thank you for the patch.<br />&gt; I tried it and found the the process cloned by my test program became<br />&gt; the zombie child of my shell and is not reaped because the shell is<br />&gt; not expecting the process.<br /><br />Right.<br /><br />That, however, is because you're using CLONE_THREAD in a manner it wasn't<br />really meant to be used (but now it is purely _your_ problem, and will no<br />longer cause processes that cannot be reaped by anybody).<br /><br />The real design for CLONE_THREAD is basically to allow pthreads-like<br />thread handling by having pthread_create() do roughly something like this:<br /><br />	static int has_created_master_process = 0;<br /><br />	if (!has_created_master_process) {<br />		new_me = clone(CLONE_VM | SIGCHLD);<br />		if (new_me &gt; 0) {<br />			/* Original thread turns into master process */<br />			printf("I am the new master process, bow down before me!\n");<br />			has_created_master_process = 1;<br />			for (;;) {<br />				if (!waitpid(-1, NULL, 0))<br />					continue;<br />				if (errno == ENOCHLD)<br />					exit(0);<br />				.. we could do signal propagation here ..<br />			}<br />		}<br />		/* This child now takes over the role of the original thread */<br />	}<br /><br />	clone(CLONE_VM | CLONE_THREAD | SIGCHLD);<br />	/* The child of this clone is the new thread */<br /><br />ie we'd always have "n+1" kernel threads for the "n" pthreads threads,<br />where the extra additional thread is there to make the real parent of the<br />threaded application see just one "process". More importantly, it means<br />that the real parent sees the death of the "clone group" only after all<br />threads have exited.<br /><br />Alternatively, you can always use a zero signal specifier to clone(), but<br />you have to realize that if you do that, the original parent will only see<br />one exit code, and it will be the one from the first thread. The other<br />threads may still be running - and the original parent simply won't know<br />anything at all about them. This is quite acceptable thread behaviour for<br />some thread usage, but it is not the behaviour that pthreads is supposed<br />to have (this is how you can make "IO slaves" or similar - threads that<br />are not full-fledged parts of the process that the parent is supposed to<br />see).<br /><br />Also, please do notice that one fundamental part of the CLONE_THREAD logic<br />never made it into a stable kernel: the shared signal handling. So while<br />CLONE_THREAD allows for many pthread-like things (one common process ID<br />shared by all threads, for example), the most fundamental part of it was<br />not actually merged into the standard kernel because of stability concerns<br />in late pre-2.4 test cycle.<br /><br />			Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
