    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/12/15/15">First message in thread</a></li><li><a href="/lkml/2001/12/16/134">GOTO Masanori</a><ul><li><a href="/lkml/2001/12/16/51">Andrew Morton</a><ul><li><a href="/lkml/2001/12/16/12">Suresh Gopalakrishnan</a><ul><li><a href="/lkml/2001/12/16/2">Terje Eggestad</a><ul><li><a href="/lkml/2001/12/16/55">Suresh Gopalakrishnan</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2001/12/17/127">Andrea Arcangeli</a><ul><li><a href="/lkml/2001/12/17/107">Andrea Arcangeli</a></li><li><a href="/lkml/2001/12/17/110">Hugh Dickins</a></li><li><a href="/lkml/2001/12/17/125">Andrew Morton</a></li><li class="origin"><a href="/lkml/2001/12/17/137">(Linus Torvalds)</a><ul><li><a href="/lkml/2001/12/17/137">Joel Becker</a><ul><li><a href="/lkml/2001/12/17/168">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2001/12/26/48">Riley Williams</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">(Linus Torvalds)</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: O_DIRECT wierd behavior..</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 17 Dec 2001 19:26:05 +0000 (UTC)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">In article &lt;3C1E400B.A4D25F9D&#64;zip.com.au&gt;,<br />Andrew Morton  &lt;akpm&#64;zip.com.au&gt; wrote:<br />&gt;<br />&gt;SUS says: ( <a href="https://www.opengroup.org/onlinepubs/007908799/xsh/write.html">http://www.opengroup.org/onlinepubs/007908799/xsh/write.html</a> )<br />&gt;<br />&gt; RETURN VALUE<br />&gt;<br />&gt;     Upon successful completion, write() and pwrite() will return the number of bytes<br />&gt;     actually written to the file associated with fildes. This number will never be greater<br />&gt;     than nbyte. Otherwise, -1 is returned and errno is set to indicate the error. <br />&gt;<br />&gt;I take that to mean that if an error occurs, we return that<br />&gt;error regardless of how much was written.<br /><br />I disagree.<br /><br />Note that writing 15 characters out of 30 is also a "successful write" -<br />it's just a _partial_ write.<br /><br />So it is acceptable to return an intermediate value.<br /><br />In particular, returning "error" when 15 bytes were written loses<br />information that the application _cannot_ recover from. <br /><br />Which is why Linux does what Linux does now:<br /> - if you get an error half-way, we return the number of bytes<br />   successfully written.<br /> - a well-written app will handle partial writes correctly (otherwise it<br />   can never handle things like sockets or pipes), so it will try to<br />   write the remaining chunk later,<br /> - if, at that later date, the error persists, and we cannot write any<br />   data, the application gets the error message.<br /><br />this means:<br /> - good applications can recover gracefully from errors<br /> - you never lose "information" about what has happened<br /><br />In contrast, if you wrote and committed 15 bytes, and an error occurs<br />when writing the 16th byte, and you return an error, the application is<br />now hosed. It has no way of knowing whether _any_ of the write was<br />successful or not.<br /><br />&gt;Which makes sense.  Consider this code:<br />&gt;<br />&gt;	open(file)<br />&gt;	write(100k)<br />&gt;	close(fd)<br />&gt;<br />&gt;if the write gets an IO error halfway through, it looks like<br />&gt;the caller never gets to hear about it at present.<br /><br />No, the caller _does_ get to hear about it. If the caller cares about<br />robust handling, it will notice "Hmm, I tried to write 100k bytes, but<br />the system only write 50k, what's up"?<br /><br />Note that the caller _has_ to do this anyway, or it wouldn't be able to<br />handle things like interruptible NFS mounts, sockets, pipes, out-of-disk<br />errors etc etc.<br /><br />And if the caller does _not_ care about robustness, then who cares?<br />It's going to ignore whatever we return anyway.<br /><br />&gt;						  Except via<br />&gt;the short return value from the write.  But from my reading of SUS,<br />&gt;a short return value from write implicitly means ENOSPC.<br /><br />I disagree. A short write is _normal_ for a lot of file descriptors.<br /><br />Yes, ENOSPC implies short write. But short write does not imply ENOSPC.<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
