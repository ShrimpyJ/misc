    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/11/17/14">First message in thread</a></li><li><a href="/lkml/2001/11/17/14">Momchil Velikov</a><ul><li><a href="/lkml/2001/11/17/54">Jan Hubicka</a><ul><li class="origin"><a href="/lkml/2001/11/17/26">Linus Torvalds</a><ul><li><a href="/lkml/2001/11/17/26">"H. Peter Anvin"</a></li><li><a href="/lkml/2001/11/17/56">Momchil Velikov</a><ul><li><a href="/lkml/2001/11/17/68">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2001/11/17/98">Jan Hubicka</a><ul><li><a href="/lkml/2001/11/17/101">"H. Peter Anvin"</a></li><li><a href="/lkml/2001/11/17/114">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2001/11/23/187">Roman Zippel</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 17 Nov 2001 11:20:45 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: i386 flags register clober in inline assembly</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">In article &lt;20011117161436.B23331&#64;atrey.karlin.mff.cuni.cz&gt; you write:<br />&gt;<br />&gt;They don't need to be. On i386, the flags are (partly for historical reasons) clobbered<br />&gt;by default.<br /><br />However, this is one area where I would just be tickled pink if gcc were<br />to allow asm's to return status in eflags, even if that means that we<br />need to fix all our existing asms.<br /><br />We have some really _horrid_ code where we use operations that<br />intrinsically set the flag bits, and we actually want to use them.<br />Using things like cmpxchg, and atomic decrement-and-test-with-zero have<br />these horrid asm statements that have to move the eflags value (usually<br />just one bit) into a register, so that we can tell gcc where it is.<br /><br />(Example code:<br /><br />atomic_sub_and_test:<br />	__asm__ __volatile__(<br />		LOCK "subl %2,%0; sete %1"<br />		:"=m" (v-&gt;counter), "=qm" (c)<br />		:"ir" (i), "m" (v-&gt;counter) : "memory");<br /><br />Where we first get the value we _really_ want in ZF in eflags, then we<br />use "sete" to move it to a register, and then gcc will end up generating<br />code to test that register by hand, so the end result is usually<br />something like:<br /><br />#APP<br />        lock ; decl 20(%edi); sete %al<br />#NO_APP<br />        testb   %al, %al<br />        je      .L1570<br /><br />even though what we'd _want_ is really<br /><br />	lock ; decl 20(%edi)<br />	jne .L1570<br /><br />which is not only smaller and faster, but is often _really_ faster<br />because at least some Intel CPU's will forward the flags values to the<br />branch prediction stuff, and going through a register dependency will<br />add non-forwarded state and thus extra cycles.<br /><br />So I would personally _really_ really like for some way to expose the<br />internal gcc<br /><br />	"(set (cc0) ..asm..)"<br /><br />construct, together with some way of setting the cc_status.flags.<br /><br />&gt;From what I can tell, all the x86 machine description already uses "cc0"<br />together with the notion of comparing it to zero (either signed or<br />unsigned), so something like this _might_ just work<br /><br />	unsigned long result;<br />	asm volatile(<br />		LOCK "decl %m"<br />		:"+m" (v-&gt;counter),<br />		 "=cc" (result)<br />		: :"memory");<br />	if (result &gt; 0)		/* "jnb" */<br />		...<br /><br />which would be wonderful, and would expand to<br /><br />	(set (cc0) ..asm..)<br />	(set (pc)<br />		(if_then_else (gtu (cc0) (const_int 0))<br />			(label_ref (match_operand ..<br />			(pc))<br /><br />Which _should_ just automatically give us<br /><br />	lock ; decl ..<br />	ja ..<br /><br />which is exactly what we want.<br /><br />I know this used to be impossible in gcc, because the x86 didn't<br />actually track the flags values, and conditional jumps were really a<br />_combination_ of the conditional and the jump, and splitting it up so<br />that the conditional would be in an asm was thus not possible.<br /><br />But I think gcc makes cc0 explicit on x86 these days, and that the above<br />kind of setup might be possible today, no?<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
