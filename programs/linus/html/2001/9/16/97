    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/9/16/12">First message in thread</a></li><li><a href="/lkml/2001/9/16/48">(Linus Torvalds)</a><ul><li><a href="/lkml/2001/9/16/59">Rik van Riel</a></li><li><a href="/lkml/2001/9/16/65">Rik van Riel</a></li><li><a href="/lkml/2001/9/16/76">Andreas Steinmetz</a></li><li><a href="/lkml/2001/9/16/83">Daniel Phillips</a><ul><li class="origin"><a href="/lkml/2001/9/17/6">Linus Torvalds</a><ul><li><a href="/lkml/2001/9/17/6">Jan Harkes</a><ul><li><a href="/lkml/2001/9/17/181">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2001/9/16/85">Daniel Phillips</a></li><li><a href="/lkml/2001/9/17/58">Jan Harkes</a><ul><li><a href="/lkml/2001/9/17/68">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2001/9/20/254">Bill Davidsen</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2001/9/16/97/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 16 Sep 2001 18:07:34 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: broken VM in 2.4.10-pre9</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Mon, 17 Sep 2001, Daniel Phillips wrote:<br />&gt;<br />&gt; Can we confirm that the mp3 player is making subpage accesses? (strace)<br /><br />People claim that they do mmap's, which the old code definitely didn't<br />handle correctly at all.<br /><br />I'm not 100% sure that the 2.4.10-pre10 aging is right for anonymous pages<br />either, and the page-referenced handling at COW time looks suspiciously<br />broken, for example. It's not something we have ever gotten right, I think<br />- if the old pre-C-O-W page was marked accessed, we should mark that page<br />referenced before we break the COW. Otherwise we'll move over to a new<br />page without crediting the source.<br /><br />&gt; The 'partially read/written' state isn't handled properly now.  The<br />&gt; transition to the 'used-once' state should only occur if the transfer ends at<br />&gt; the exact end of the page.  Right now it always takes place after the *first*<br />&gt; transfer on the page which is correct only for full-page transfers.<br /><br />No, it's not as easy as you make it sound.<br /><br />The problem is that partial accesses are real, and they should be counted<br />as such - except when they are _linear_ partial accesses, in which case<br />they should not be counted at all except for the first one.<br /><br />Having some "if transfer ends at end of page" logic would minimally get<br />the enf-of-file case wrong, for example, never mind the case of a reader<br />that is seeking around in the file. The EOF case could be worked around<br />with yet another hack, but I suspect that the real fix is to try to fix<br />applications that do bad things.<br /><br />&gt; It's still best to start all pages unreferenced, because otherwise we don't<br />&gt; have a means of distinguishing between the first and subsequent page cache<br />&gt; lookups.  The check_used_once logic should set the page referenced if the IO<br />&gt; transfer ends in the interior of the page or unreferenced if it ends at the<br />&gt; end of the page.<br /><br />See how 2.4.10-pre10 doesn't have any use_once hackery at all, but instead<br />has a clear path on references:<br /><br /> prefetching: non-referenced page on inactive list<br /> after 1st reference: refrenced page on inactive list<br /> after 2nd reference: non-referenced page on active list<br /> after 3rd and subsequent accesses: referenced page on active list<br /><br />while the "age down" logic is the exact reverse of the above. Logical and<br />easy to implement, and gives four distinct "stages" for all pages (along<br />with the LRU ordering within each list, of course).<br /><br />Now, the above _is_ different from what we used to do. For one thing, it's<br />logical. But it might be different enough that the heuristics we have for<br />aging may need some tuning again. "Logical" is not enough..<br /><br />There's also a few issues that I don't like right now wrt reference<br />handling, notably:<br /><br /> - COW issue mentioned above. Probably trivially fixed by something like<br /><br />	diff -u --recursive --new-file pre10/linux/mm/memory.c linux/mm/memory.c<br />	--- pre10/linux/mm/memory.c     Sun Sep 16 18:01:48 2001<br />	+++ linux/mm/memory.c   Sun Sep 16 18:00:59 2001<br />	&#64;&#64; -955,6 +955,8 &#64;&#64;<br />	        if (pte_same(*page_table, pte)) {<br />	                if (PageReserved(old_page))<br />	                        ++mm-&gt;rss;<br />	+               if (pte_young(pte))<br />	+                       mark_page_accessed(old_page);<br />	                break_cow(vma, new_page, address, page_table);<br /><br />	                /* Free the old page.. */<br /><br />   which looks right (it basically saves off the referenced bit for the<br />   old page table entry in the physical page reference count).<br /><br /> - truly anonymous pages (ie before they've been added to the swap cache)<br />   are not necessarily going to behave as nicely as other pages. They<br />   magically appear after VM scanning as a "1st reference", and I have a<br />   reasonably good argument that says that they'll have been aged up and<br />   down roughly the same number of times, which makes this more-or-less<br />   correct. But it's still a theoretical argument, nothing more.<br />   This could reasonably easily be fixed by adding these anonymous pages<br />   to the LRU lists anyway (with a bogus "page-&gt;mapping" which causes them<br />   to be re-mapped as _real_ swap cache pages when they need writeout),<br />   but that's a bit too subtle for my taste. If anybody wants to look into<br />   this, I'd love to know if it makes a difference in behaviour, though..<br /><br /> - I don't like the lack of aging in 'reclaim_page()'. It will walk the<br />   whole LRU list if required, which kind of defeats the purpose of having<br />   reference bits and LRU on that list. The code _claims_ that it almost<br />   always succeeds with the first page, but I don't see why it would. I<br />   think that comment assumed that the inactive_clean list cannot have any<br />   referenced pages, but that's never been true.<br /><br />There are probably other issues too, these are the ones I was wondering<br />about when I walked over the use of the PG_referenced bit..<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
