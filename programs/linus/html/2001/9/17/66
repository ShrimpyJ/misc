    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/9/17/66">First message in thread</a></li><li class="origin"><a href="/lkml/2001/9/17/82">Linus Torvalds</a><ul><li><a href="/lkml/2001/9/17/82">Linus Torvalds</a></li><li><a href="/lkml/2001/9/18/72">Rik van Riel</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2001/9/17/66/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 17 Sep 2001 10:33:51 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: broken VM in 2.4.10-pre9</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Mon, 17 Sep 2001, Rik van Riel wrote:<br />&gt;<br />&gt; &gt;  - truly anonymous pages (ie before they've been added to the swap cache)<br />&gt; &gt;    are not necessarily going to behave as nicely as other pages. They<br />&gt; &gt;    magically appear after VM scanning as a "1st reference", and I have a<br />&gt; &gt;    reasonably good argument that says that they'll have been aged up and<br />&gt; &gt;    down roughly the same number of times, which makes this more-or-less<br />&gt; &gt;    correct. But it's still a theoretical argument, nothing more.<br />&gt;<br />&gt; This nicely points out the problem with page aging which Linux<br />&gt; has always had. Pages which are referenced all the time by the<br />&gt; processes using them STILL get aged down all the time.<br />&gt;<br />&gt; I suspect that the biggest impact the reverse mapping patch<br />&gt; has right now seems to be caused by fixing this behaviour and<br />&gt; just aging up a page when it is referenced and down when it is<br />&gt; not.<br /><br />Well, here's a 10-line patch to make the anonymous pages get on the LRU<br />queues, and thus get aged along with all the others.<br /><br />NOTE NOTE NOTE! This is _literally_ a 15-minute hack, and I expect that<br />there are paths where I forget to remove the page from the LRU queue<br />(which should result in a nice big oops in __free_pages_ok()).<br /><br />Also, I didn't look into shm handling - it _looks_ like shm will remove<br />the page from the LRU list and re-insert it, which will lose all list<br />information, of course.<br /><br />But the point being that keeping anonymous pages on the LRU list shouldn't<br />be all that hard. Even if I missed something on this first try.<br /><br />		Linus<br /><br />------<br />diff -u --recursive --new-file penguin/linux/mm/filemap.c linux/mm/filemap.c<br />--- penguin/linux/mm/filemap.c	Mon Sep 17 09:22:57 2001<br />+++ linux/mm/filemap.c	Mon Sep 17 09:15:45 2001<br />&#64;&#64; -489,7 +489,6 &#64;&#64;<br /> 	page-&gt;index = index;<br /> 	add_page_to_inode_queue(mapping, page);<br /> 	add_page_to_hash_queue(page, page_hash(mapping, index));<br />-	lru_cache_add(page);<br /> 	spin_unlock(&amp;pagecache_lock);<br /> }<br /><br />diff -u --recursive --new-file penguin/linux/mm/memory.c linux/mm/memory.c<br />--- penguin/linux/mm/memory.c	Mon Sep 17 09:23:55 2001<br />+++ linux/mm/memory.c	Mon Sep 17 10:15:57 2001<br />&#64;&#64; -958,6 +958,7 &#64;&#64;<br /> 		if (pte_young(pte))<br /> 			mark_page_accessed(old_page);<br /> 		break_cow(vma, new_page, address, page_table);<br />+		lru_cache_add(new_page);<br /><br /> 		/* Free the old page.. */<br /> 		new_page = old_page;<br />&#64;&#64; -1198,6 +1199,7 &#64;&#64;<br /> 		mm-&gt;rss++;<br /> 		flush_page_to_ram(page);<br /> 		entry = pte_mkwrite(pte_mkdirty(mk_pte(page, vma-&gt;vm_page_prot)));<br />+		lru_cache_add(page);<br /> 	}<br /><br /> 	set_pte(page_table, entry);<br />diff -u --recursive --new-file penguin/linux/mm/shmem.c linux/mm/shmem.c<br />--- penguin/linux/mm/shmem.c	Mon Sep 17 09:22:57 2001<br />+++ linux/mm/shmem.c	Mon Sep 17 09:17:12 2001<br />&#64;&#64; -356,6 +356,7 &#64;&#64;<br /> 		flags = page-&gt;flags &amp; ~((1 &lt;&lt; PG_uptodate) | (1 &lt;&lt; PG_error) | (1 &lt;&lt; PG_referenced) | (1 &lt;&lt; PG_arch_1));<br /> 		page-&gt;flags = flags | (1 &lt;&lt; PG_dirty);<br /> 		add_to_page_cache_locked(page, mapping, idx);<br />+		lru_cache_add(page);<br /> 		info-&gt;swapped--;<br /> 		spin_unlock (&amp;info-&gt;lock);<br /> 	} else {<br />diff -u --recursive --new-file penguin/linux/mm/swap.c linux/mm/swap.c<br />--- penguin/linux/mm/swap.c	Wed Aug  8 15:17:26 2001<br />+++ linux/mm/swap.c	Mon Sep 17 09:50:33 2001<br />&#64;&#64; -153,8 +153,6 &#64;&#64;<br /> void lru_cache_add(struct page * page)<br /> {<br /> 	spin_lock(&amp;pagemap_lru_lock);<br />-	if (!PageLocked(page))<br />-		BUG();<br /> 	add_page_to_inactive_dirty_list(page);<br /> 	page-&gt;age = 0;<br /> 	spin_unlock(&amp;pagemap_lru_lock);<br />&#64;&#64; -176,7 +174,7 &#64;&#64;<br /> 	} else if (PageInactiveClean(page)) {<br /> 		del_page_from_inactive_clean_list(page);<br /> 	} else {<br />-		printk("VM: __lru_cache_del, found unknown page ?!\n");<br />+//		printk("VM: __lru_cache_del, found unknown page ?!\n");<br /> 	}<br /> 	DEBUG_ADD_PAGE<br /> }<br />&#64;&#64; -187,8 +185,6 &#64;&#64;<br />  */<br /> void lru_cache_del(struct page * page)<br /> {<br />-	if (!PageLocked(page))<br />-		BUG();<br /> 	spin_lock(&amp;pagemap_lru_lock);<br /> 	__lru_cache_del(page);<br /> 	spin_unlock(&amp;pagemap_lru_lock);<br />diff -u --recursive --new-file penguin/linux/mm/swap_state.c linux/mm/swap_state.c<br />--- penguin/linux/mm/swap_state.c	Mon Sep 17 09:22:57 2001<br />+++ linux/mm/swap_state.c	Mon Sep 17 09:42:20 2001<br />&#64;&#64; -147,6 +147,10 &#64;&#64;<br />  */<br /> void free_page_and_swap_cache(struct page *page)<br /> {<br />+	if (page_count(page) == 1 &amp;&amp; !page-&gt;mapping) {<br />+		lru_cache_del(page);<br />+	}<br />+<br /> 	/*<br /> 	 * If we are the only user, then try to free up the swap cache.<br /> 	 *<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
