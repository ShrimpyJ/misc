    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/10/24/6">First message in thread</a></li><li><a href="/lkml/2001/10/26/71">Jens Axboe</a><ul><li><a href="/lkml/2001/10/26/72">Zlatko Calusic</a><ul><li><a href="/lkml/2001/10/26/54">Linus Torvalds</a><ul><li><a href="/lkml/2001/10/26/149">Linus Torvalds</a><ul><li><a href="/lkml/2001/10/28/64">Zlatko Calusic</a></li><li><a href="/lkml/2001/11/2/3">Andrea Arcangeli</a></li><li><a href="/lkml/2001/11/2/134">Andrea Arcangeli</a></li><li><a href="/lkml/2001/11/2/143">Zlatko Calusic</a></li><li><a href="/lkml/2001/11/2/193">Simon Kirby</a></li><li><a href="/lkml/2001/11/2/209">(Miquel van Smoorenburg)</a></li></ul></li></ul></li><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2001/10/26/95">Jens Axboe</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 26 Oct 2001 09:04:04 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: xmm2 - monitor Linux MM active/inactive lists graphically</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On 26 Oct 2001, Zlatko Calusic wrote:<br />&gt;<br />&gt; OK. Anyway, neither configuration works well, so the problem might be<br />&gt; somewhere else.<br />&gt;<br />&gt; While at it, could you give short explanation of those two parameters?<br /><br />Did you try the ones 2.4.14-2 does?<br /><br />Basically, the "queue_nr_requests" means how many requests there can be<br />for this queue. Half of them are allocated to reads, half of them are<br />allocated to writes.<br /><br />The "batch_requests" thing is something that kicks in when the queue has<br />emptied - we don't want to "trickle" requests to users, because if we do<br />that means that a new large write will not be able to merge its new<br />requests sanely because it basically has to do them one at a time. So when<br />we run out of requests (ie "queue_nr_requests" isn't enough), we start<br />putting the freed-up requests on a "pending" list, and we release them<br />only when the pending list is bigger than "batch_requests".<br /><br />Now, one thing to remember is that "queue_nr_requests" is for the whole<br />queue (half of them for reads, half for writes), and "batch_requests" is a<br />per-type thing (ie we batch reads and writes separately). So<br />"batch_requests" must be less than half of "queue_nr_requests", or we will<br />never release anything at all.<br /><br />Now, in Alan's tree, there is a separate tuning thing, which is the "max<br />nr of _sectors_ in flight", which in my opinion is pretty bogus. It's<br />really a memory-management thing, but it also does something else: it has<br />low-and-high water-marks, and those might well be a good idea. It is<br />possible that we should just ditch the "batch_requests" thing, and use the<br />watermarks instead.<br /><br />Side note: all of this is relevant really only for writes - reads pretty<br />much only care about the maximum queue-size, and it's very hard to get a<br />_huge_ queue-size with reads unless you do tons of read-ahead.<br /><br />Now, the "batching" is technically equivalent with water-marking if there<br />is _one_ writer. But if there are multiple writers, water-marking may<br />actually has some advantages: it might allow the other writer to make some<br />progress when the first one has stopped, while the batching will stop<br />everybody until the batch is released. Who knows.<br /><br />Anyway, the reason I think Alan's "max nr of sectors" is bogus is because:<br /><br /> - it's a global count, and if you have 10 controllers and want to write<br />   to all 10, you _should_ be able to - you can write 10 times as many<br />   requests in the same latency, so there is nothing "global" with it.<br /><br />   (It turns out that one advantage of the globalism is that it ends up<br />   limiting MM write-outs, but I personally think that is a _MM_ thing, ie<br />   we might want to have a "we have half of all our pages in flight, we<br />   have to throttle now" thing in "writepage()", not in the queue)<br /><br /> - "nr of sectors" has very little to do with request latency on most<br />   hardware. You can do 255 sectors (ie one request) almost as fast as you<br />   can do just one, if you do them in one request. While just _two_<br />   sectors might be much slower than the 255, if they are in separate<br />   requests and cause seeking.<br /><br />   So from a latency standpoint, the "request" is a much better number.<br /><br />So Alan almost never throttles on requests (on big machines, the -ac tree<br />allows thousands of requests in flight per queue), while he _does_ have<br />this water-marking for sectors.<br /><br />So I have two suspicions:<br /><br /> - 128 requests (ie 64 for writes) like the default kernel should be<br />   _plenty_ enough to keep the disks busy, especially for streaming<br />   writes. It's small enough that you don't get the absolutely _huge_<br />   spikes you get with thousands of requests, while being large enough for<br />   fast writers that even if they _do_ block for 32 of the 64 requests,<br />   they'll have time to refill the next 32 long before the 32 pending one<br />   have finished.<br /><br />   Also: limiting the write queue to 128 requests means that you can<br />   pretty much guarantee that you can get at least a few read requests<br />   per second, even if the write queue is constantly full, and even if<br />   your reader is serialized.<br /><br />BUT:<br /><br /> - the hard "batch" count is too harsh. It works as a watermark in the<br />   degenerate case, but doesn't allow a second writer to use up _some_ of<br />   the requests while the first writer is blocked due to watermarking.<br /><br />   So with batching, when the queue is full and another process wants<br />   memory, that _OTHER_ process will also always block untilt he queue has<br />   emptied.<br /><br />   With watermarks, when the writer has filled up the queue and starts<br />   waiting, other processes can still do some writing as long as they<br />   don't fill up the queue again. So if you have MM pressure but the<br />   writer is blocked (and some requests _have_ completed, but the writer<br />   waits for the low-water-mark), you can still push out requests.<br /><br />   That's also likely to be a lot more fair - batching tends to give the<br />   whole batch to the big writer, while watermarking automatically allows<br />   others to get a look at the queue.<br /><br />I'll whip up a patch for testing (2.4.14-2 made the batching slightly<br />saner, but the same "hard" behaviour is pretty much unavoidable with<br />batching)<br /><br />			Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
