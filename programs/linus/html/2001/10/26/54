    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/10/24/6">First message in thread</a></li><li><a href="/lkml/2001/10/26/71">Jens Axboe</a><ul><li><a href="/lkml/2001/10/26/72">Zlatko Calusic</a><ul><li class="origin"><a href="/lkml/2001/10/26/149">Linus Torvalds</a><ul><li><a href="/lkml/2001/10/26/149">Linus Torvalds</a><ul><li><a href="/lkml/2001/10/28/64">Zlatko Calusic</a></li><li><a href="/lkml/2001/11/2/3">Andrea Arcangeli</a></li><li><a href="/lkml/2001/11/2/134">Andrea Arcangeli</a></li><li><a href="/lkml/2001/11/2/143">Zlatko Calusic</a></li><li><a href="/lkml/2001/11/2/193">Simon Kirby</a></li><li><a href="/lkml/2001/11/2/209">(Miquel van Smoorenburg)</a></li></ul></li></ul></li><li><a href="/lkml/2001/10/26/63">Linus Torvalds</a></li><li><a href="/lkml/2001/10/26/95">Jens Axboe</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2001/10/26/54/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 26 Oct 2001 09:57:02 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: xmm2 - monitor Linux MM active/inactive lists graphically</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On 26 Oct 2001, Zlatko Calusic wrote:<br />&gt;<br />&gt; When I find some time, I'll dig around that code. It is very<br />&gt; interesting part of the kernel, I'm sure, I just didn't have enough<br />&gt; time so far, to spend hacking on that part.<br /><br />Attached is a very untested patch (but hey, it compiles, so it must work,<br />right?) against 2.4.14-pre2, that makes the batching be a high/low<br />watermark thing instead. It actually simplified the code, but that is, of<br />course, assuming that it works at all ;)<br /><br />(If I got the comparisons wrong, of if I update the counts wrong, your IO<br />queue will probably stop cold. So be careful. The code is obvious<br />enough, but typos and thinkos happen).<br /><br />		Linus<br />diff -u --recursive pre2/linux/drivers/block/ll_rw_blk.c linux/drivers/block/ll_rw_blk.c<br />--- pre2/linux/drivers/block/ll_rw_blk.c	Fri Oct 26 09:48:25 2001<br />+++ linux/drivers/block/ll_rw_blk.c	Fri Oct 26 09:53:54 2001<br />&#64;&#64; -140,21 +140,23 &#64;&#64;<br /> 		return &amp;blk_dev[MAJOR(dev)].request_queue;<br /> }<br /> <br />-static int __blk_cleanup_queue(struct list_head *head)<br />+static int __blk_cleanup_queue(struct request_list *list)<br /> {<br />+	struct list_head *head = &amp;list-&gt;free;<br /> 	struct request *rq;<br /> 	int i = 0;<br /> <br />-	if (list_empty(head))<br />-		return 0;<br />-<br />-	do {<br />+	while (!list_empty(head)) {<br /> 		rq = list_entry(head-&gt;next, struct request, queue);<br /> 		list_del(&amp;rq-&gt;queue);<br /> 		kmem_cache_free(request_cachep, rq);<br /> 		i++;<br />-	} while (!list_empty(head));<br />+	};<br /> <br />+	if (i != list-&gt;count)<br />+		printk("request list leak!\n");<br />+<br />+	list-&gt;count = 0;<br /> 	return i;<br /> }<br /> <br />&#64;&#64; -176,10 +178,8 &#64;&#64;<br /> {<br /> 	int count = queue_nr_requests;<br /> <br />-	count -= __blk_cleanup_queue(&amp;q-&gt;request_freelist[READ]);<br />-	count -= __blk_cleanup_queue(&amp;q-&gt;request_freelist[WRITE]);<br />-	count -= __blk_cleanup_queue(&amp;q-&gt;pending_freelist[READ]);<br />-	count -= __blk_cleanup_queue(&amp;q-&gt;pending_freelist[WRITE]);<br />+	count -= __blk_cleanup_queue(&amp;q-&gt;rq[READ]);<br />+	count -= __blk_cleanup_queue(&amp;q-&gt;rq[WRITE]);<br /> <br /> 	if (count)<br /> 		printk("blk_cleanup_queue: leaked requests (%d)\n", count);<br />&#64;&#64; -331,11 +331,10 &#64;&#64;<br /> 	struct request *rq;<br /> 	int i;<br /> <br />-	INIT_LIST_HEAD(&amp;q-&gt;request_freelist[READ]);<br />-	INIT_LIST_HEAD(&amp;q-&gt;request_freelist[WRITE]);<br />-	INIT_LIST_HEAD(&amp;q-&gt;pending_freelist[READ]);<br />-	INIT_LIST_HEAD(&amp;q-&gt;pending_freelist[WRITE]);<br />-	q-&gt;pending_free[READ] = q-&gt;pending_free[WRITE] = 0;<br />+	INIT_LIST_HEAD(&amp;q-&gt;rq[READ].free);<br />+	INIT_LIST_HEAD(&amp;q-&gt;rq[WRITE].free);<br />+	q-&gt;rq[READ].count = 0;<br />+	q-&gt;rq[WRITE].count = 0;<br /> <br /> 	/*<br /> 	 * Divide requests in half between read and write<br />&#64;&#64; -349,7 +348,8 &#64;&#64;<br /> 		}<br /> 		memset(rq, 0, sizeof(struct request));<br /> 		rq-&gt;rq_status = RQ_INACTIVE;<br />-		list_add(&amp;rq-&gt;queue, &amp;q-&gt;request_freelist[i &amp; 1]);<br />+		list_add(&amp;rq-&gt;queue, &amp;q-&gt;rq[i&amp;1].free);<br />+		q-&gt;rq[i&amp;1].count++;<br /> 	}<br /> <br /> 	init_waitqueue_head(&amp;q-&gt;wait_for_request);<br />&#64;&#64; -423,10 +423,12 &#64;&#64;<br /> static inline struct request *get_request(request_queue_t *q, int rw)<br /> {<br /> 	struct request *rq = NULL;<br />+	struct request_list *rl = q-&gt;rq + rw;<br /> <br />-	if (!list_empty(&amp;q-&gt;request_freelist[rw])) {<br />-		rq = blkdev_free_rq(&amp;q-&gt;request_freelist[rw]);<br />+	if (!list_empty(&amp;rl-&gt;free)) {<br />+		rq = blkdev_free_rq(&amp;rl-&gt;free);<br /> 		list_del(&amp;rq-&gt;queue);<br />+		rl-&gt;count--;<br /> 		rq-&gt;rq_status = RQ_ACTIVE;<br /> 		rq-&gt;special = NULL;<br /> 		rq-&gt;q = q;<br />&#64;&#64; -443,17 +445,13 &#64;&#64;<br /> 	register struct request *rq;<br /> 	DECLARE_WAITQUEUE(wait, current);<br /> <br />+	generic_unplug_device(q);<br /> 	add_wait_queue_exclusive(&amp;q-&gt;wait_for_request, &amp;wait);<br />-	for (;;) {<br />-		__set_current_state(TASK_UNINTERRUPTIBLE);<br />-		spin_lock_irq(&amp;io_request_lock);<br />-		rq = get_request(q, rw);<br />-		spin_unlock_irq(&amp;io_request_lock);<br />-		if (rq)<br />-			break;<br />-		generic_unplug_device(q);<br />-		schedule();<br />-	}<br />+	do {<br />+		set_current_state(TASK_UNINTERRUPTIBLE);<br />+		if (q-&gt;rq[rw].count &lt; batch_requests)<br />+			schedule();<br />+	} while ((rq = get_request(q,rw)) == NULL);<br /> 	remove_wait_queue(&amp;q-&gt;wait_for_request, &amp;wait);<br /> 	current-&gt;state = TASK_RUNNING;<br /> 	return rq;<br />&#64;&#64; -542,15 +540,6 &#64;&#64;<br /> 	list_add(&amp;req-&gt;queue, insert_here);<br /> }<br /> <br />-inline void blk_refill_freelist(request_queue_t *q, int rw)<br />-{<br />-	if (q-&gt;pending_free[rw]) {<br />-		list_splice(&amp;q-&gt;pending_freelist[rw], &amp;q-&gt;request_freelist[rw]);<br />-		INIT_LIST_HEAD(&amp;q-&gt;pending_freelist[rw]);<br />-		q-&gt;pending_free[rw] = 0;<br />-	}<br />-}<br />-<br /> /*<br />  * Must be called with io_request_lock held and interrupts disabled<br />  */<br />&#64;&#64; -564,28 +553,12 &#64;&#64;<br /> <br /> 	/*<br /> 	 * Request may not have originated from ll_rw_blk. if not,<br />-	 * asumme it has free buffers and check waiters<br />+	 * assume it has free buffers and check waiters<br /> 	 */<br /> 	if (q) {<br />-		/*<br />-		 * If nobody is waiting for requests, don't bother<br />-		 * batching up.<br />-		 */<br />-		if (!list_empty(&amp;q-&gt;request_freelist[rw])) {<br />-			list_add(&amp;req-&gt;queue, &amp;q-&gt;request_freelist[rw]);<br />-			return;<br />-		}<br />-<br />-		/*<br />-		 * Add to pending free list and batch wakeups<br />-		 */<br />-		list_add(&amp;req-&gt;queue, &amp;q-&gt;pending_freelist[rw]);<br />-<br />-		if (++q-&gt;pending_free[rw] &gt;= batch_requests) {<br />-			int wake_up = q-&gt;pending_free[rw];<br />-			blk_refill_freelist(q, rw);<br />-			wake_up_nr(&amp;q-&gt;wait_for_request, wake_up);<br />-		}<br />+		list_add(&amp;req-&gt;queue, &amp;q-&gt;rq[rw].free);<br />+		if (++q-&gt;rq[rw].count &gt;= batch_requests &amp;&amp; waitqueue_active(&amp;q-&gt;wait_for_request))<br />+			wake_up(&amp;q-&gt;wait_for_request);<br /> 	}<br /> }<br /> <br />&#64;&#64; -1144,7 +1117,7 &#64;&#64;<br /> 	/*<br /> 	 * Batch frees according to queue length<br /> 	 */<br />-	batch_requests = queue_nr_requests/3;<br />+	batch_requests = queue_nr_requests/4;<br /> 	printk("block: %d slots per queue, batch=%d\n", queue_nr_requests, batch_requests);<br /> <br /> #ifdef CONFIG_AMIGA_Z2RAM<br />diff -u --recursive pre2/linux/include/linux/blkdev.h linux/include/linux/blkdev.h<br />--- pre2/linux/include/linux/blkdev.h	Tue Oct 23 22:01:01 2001<br />+++ linux/include/linux/blkdev.h	Fri Oct 26 09:36:41 2001<br />&#64;&#64; -66,14 +66,17 &#64;&#64;<br />  */<br /> #define QUEUE_NR_REQUESTS	8192<br /> <br />+struct request_list {<br />+	unsigned int count;<br />+	struct list_head free;<br />+};<br />+<br /> struct request_queue<br /> {<br /> 	/*<br /> 	 * the queue request freelist, one for reads and one for writes<br /> 	 */<br />-	struct list_head	request_freelist[2];<br />-	struct list_head	pending_freelist[2];<br />-	int			pending_free[2];<br />+	struct request_list	rq[2];<br /> <br /> 	/*<br /> 	 * Together with queue_head for cacheline sharing</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
