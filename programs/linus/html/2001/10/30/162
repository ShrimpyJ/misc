    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/10/30/39">First message in thread</a></li><li><a href="/lkml/2001/10/30/192">Andrea Arcangeli</a><ul><li><a href="/lkml/2001/10/30/161">Linus Torvalds</a></li><li><a href="/lkml/2001/10/30/167">Andrea Arcangeli</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 30 Oct 2001 12:25:36 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: need help interpreting 'free' output.</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 30 Oct 2001, Andrea Arcangeli wrote:<br />&gt;<br />&gt; incidentally if trylock fails do_wp_page doesn't even try to check the<br />&gt; swap count, it just lefts the swap cache there. same thing do_swap_page<br />&gt; can do at the early-cow stage. this is the only point I'm making.<br /><br />Yes.<br /><br />At some point we need to lock the page _if_ we actually decide we have to<br />do something with it. The current strategy is along the lines: if we can<br />obviously share it, let's do so, but let's not wait for it to be<br />unsharable.<br /><br />&gt; Go ahead and implement this thing in do_swap_page:<br />&gt;<br />&gt;         remove = 0;<br />&gt;         if ((vm_swap_full() &amp;&amp; (remove = exclusive_swap_cache_delete())) ||<br />&gt;             only_swap_user()) {<br />&gt;                 pte = mk_pte(page, vma-&gt;vm_page_prot);<br />&gt;                 if (remove || write_access)<br />&gt;                         pte = pte_mkdirty(pte);<br />&gt;                 if (vma-&gt;vm_page_prot &amp; VM_WRITE)<br />&gt;                         pte = pte_mkwrite(pte);<br />&gt;                 install_pte();<br />&gt;                 return;<br />&gt;         }<br />&gt;<br />&gt; and you'll find yourself grabbing the page lock somehow first in the<br />&gt; do_swap_page path, or exclusive_swap_cache_delete will obviously BUG()<br />&gt; on you.<br /><br />We'll trylock it yes, but that has nothing to do with the page count<br />protections. We'll trylock it if we end up _deleting_ the page, but not<br />for count reasons, but because deletion needs the lock in order to wait<br />for pages.<br /><br />And realize that that is the really rare case, where we really don't care<br />for performance - we've just realized that we don't even have enough swap<br />for the kind of load the machine is under.<br /><br />So your point is that the "we're out of swap space" case is a bit slower<br />because we potentially take the swapspace spinlocks twice? Sure.<br /><br />But look at the fast paths: no waiting anywhere, and no unnecessary locks.<br /><br />&gt; This is why I'm saying the real magic is to conver the lock_page of pre4<br />&gt; in a TryLockPage, all other changes are not interesting in real load<br /><br />NO NO NO.<br /><br />Read my mails again.<br /><br />Th epage lock used to protect the integrity of the "swap_count()" test<br />(which is part of the old "exclusive_swap_page()"). The ruls was: the<br />swap count cannot change on a page when it is locked.<br /><br />Making the lock_page() be a TryLockPage, and doing the "swap_free()"<br />without holding the page lock means that that integrity NO LONEGR EXISTS.<br /><br />Which means that the old "exclusive_swap_page()" DOES NOT WORK RELIABLY.<br />It tested "page_count()" and "swap_count()" in ways that were no longer<br />guaranteed to be meaningful - swap_count() could go down to 1 _after_<br />somebody else had incremented "page_count()" on another CPU due to a<br />swap-in of another process that shared the swap entry (or even another<br />thread on the same MM - we don't hold the page table spinlock there)..<br /><br />Do you get it now?<br /><br />By making the unconditional "always lock the page on swap-in" be a "try to<br />lock the page if you _need_ to", exclusive_swap_page() no longer worked,<br />and had to be gotten rid of or at least changed to do the right thing.<br />Considering that all users of the function also wanted to remove the page,<br />the change was obvious.<br /><br />Might we want to split it up differently if we do the "only_user()"?<br />Maybe.  But _please_ realize that the changes in pre5 are correctness<br />fixes, not some random movement of code.<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
