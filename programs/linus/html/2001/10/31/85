    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/10/31/85">First message in thread</a></li><li class="origin"><a href="/lkml/2001/10/31/157">Linus Torvalds</a><ul><li><a href="/lkml/2001/10/31/157">Andrew Morton</a><ul><li><a href="/lkml/2001/10/31/153">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2001/11/1/50">Neil Brown</a><ul><li><a href="/lkml/2001/11/1/128">Andrew Morton</a><ul><li><a href="/lkml/2001/11/1/114">Chris Mason</a></li><li><a href="/lkml/2001/11/2/13">Helge Hafting</a></li><li><a href="/lkml/2001/11/4/199">Pavel Machek</a><ul><li><a href="/lkml/2001/11/4/192">Daniel Phillips</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 31 Oct 2001 08:15:10 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: 2.4.14-pre6</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />In article &lt;3BDFBFF5.9F54B938&#64;zip.com.au&gt;,<br />Andrew Morton  &lt;akpm&#64;zip.com.au&gt; wrote:<br />&gt;<br />&gt;Appended here is a program which creates 100,000 small files.<br />&gt;Using ext2 on -pre5.  We see how long it takes to run<br />&gt;<br />&gt;	(make-many-files ; sync)<br />&gt;<br />&gt;For several values of queue_nr_requests:<br />&gt;<br />&gt;queue_nr_requests:	128	8192	32768<br />&gt;execution time:		4:43	3:25	3:20<br />&gt;<br />&gt;Almost all of the execution time is in the `sync'.<br /><br />Hmm..  I don't consider "sync" to be a benchmark, and one of the things<br />that made me limit the queue size was in fact that Linux in the<br />timeframe before roughly 2.4.7 or so was _completely_ unresponsive when<br />you did a big "untar" followed by a "sync".<br /><br />I'd rather have a machine where I don't even much notice the sync than<br />one where a made-up-load and a "sync" that servers no purpose shows<br />lower throughput.<br /><br />Do you actually have any real load that cares?<br /><br />&gt;By restricting the number of requests in flight to 128 we're<br />&gt;giving new requests only a very small chance of getting merged with<br />&gt;an existing request.  More seeking.<br /><br />If you can come up with alternatives that do not suck from a latency<br />standpoint, I'm open to ideas.<br /><br />However, having tested the -ac approach, I know from personal experience<br />that it's just way too easy to find behaviour with so horrible latency<br />on a 2GB machine that it's not in the _least_ funny.<br /><br />Making the elevator heavily favour reads over writes might be ok enough<br />to make the long queues even an option but:<br /><br />&gt;OK, not an interesting workload.  But I suspect that there are real<br />&gt;workloads which will be bitten by this.<br />&gt;<br />&gt;Why is the queue length so tiny now?  Latency?  If so, couldn't this<br />&gt;be addressed by giving reads higher priority versus writes?<br /><br />It's a write-write latency thing too, but that's probably not as strong an<br />argument.<br /><br />Trivial example: do the above thing at the same time you have a mail agent<br />open that does a "fsync()" on its mail store (and depending on your mail<br />agent and your mail folder layout, you may have quite a lot of small<br />fsyncs going on).<br /><br />I don't know about you, but I start up mail agents a _lot_ more often<br />than I do "sync". And I'd rather do "sync &amp;" than have bad interactive<br />performance from the mail agent.<br /><br />I'm not against making the queues larger, but on the other hand I see so<br />many _better_ approaches that I would rather people spent some effort on,<br />for example, making the dirty list itself be more ordered.<br /><br />We have actually talked about some higher-level ordering of the dirty list<br />for at least five years, but nobody has ever done it. And I bet you $5<br />that you'll get (a) better throughput than by making the queues longer and<br />(b) you'll have fine latency while you write and (c) that you want to<br />order the write-queue anyway for filesystems that care about ordering.<br /><br />So yes, making the queue longer is an "easy" solution, but if it then<br />leads to complex problems like how to make an elevator that is guaranteed<br />to not have bad latency behaviour, I actually think that doing some (even<br />just fairly rudimentary) ordering of the write queue ends up being easier<br />_and_ more effective.<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
