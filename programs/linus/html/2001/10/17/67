    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2001/10/14/31">First message in thread</a></li><li><a href="/lkml/2001/10/17/78">Linus Torvalds</a><ul><li><a href="/lkml/2001/10/17/60">Marcelo Tosatti</a><ul><li class="origin"><a href="/lkml/2001/10/17/121">Linus Torvalds</a><ul><li><a href="/lkml/2001/10/17/121">Andrea Arcangeli</a><ul><li><a href="/lkml/2001/10/17/119"> &lt;chris&#64;scary ...</a></li><li><a href="/lkml/2001/10/17/125">Andrea Arcangeli</a></li><li><a href="/lkml/2001/10/17/173">Marcelo Tosatti</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2001/10/17/81">John Levon</a></li><li><a href="/lkml/2001/10/17/95">Benjamin LaHaise</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2001/10/17/67/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 17 Oct 2001 11:21:03 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Making diff(1) of linux kernels faster</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Wed, 17 Oct 2001, Marcelo Tosatti wrote:<br />&gt; &gt;<br />&gt; &gt; And I've for a long time thought about adding a "readahead()" system call.<br />&gt; &gt; There are just too many uses for it, it has come up in many different<br />&gt; &gt; areas..<br />&gt;<br />&gt; There is a paper on USENIX 2001 which does implement directory readahead<br />&gt; and it shows huge improvements for some workload.<br /><br />Hmm.. The implementation is trivial, it's really just a simple 3-line<br />while-loop, with the rest of the code just doing argument checking etc.<br /><br />Attached is the kernel diff ("ra-diff") along with a stupid program<br />("preread.c"), cribbed mostly from Pauls first patch to use it to pre-read<br />a while tree.<br /><br />It took much longer to compile the kernel and reboot, and write the<br />test-program than it did to write the patch itself ;)<br /><br />It walks the whole kernel tree in 0.2 seconds of CPU-time on my machine<br />(of course, if it actually needs to start IO, the 0.2 seconds becomes 0.3<br />seconds of CPU time and almost a minute and a half of wall-clock.<br />Anyway, it clearly isn't a CPU-hog like doing a real "read" would have<br />been).<br /><br />And unlike the read, it doesn't have any impact on the active queue.<br /><br />		Linus<br />diff -u --recursive --new-file pre3/linux/arch/i386/kernel/entry.S linux/arch/i386/kernel/entry.S<br />--- pre3/linux/arch/i386/kernel/entry.S	Mon Oct  8 10:39:58 2001<br />+++ linux/arch/i386/kernel/entry.S	Wed Oct 17 10:02:39 2001<br />&#64;&#64; -621,6 +621,7 &#64;&#64;<br /> 	.long SYMBOL_NAME(sys_ni_syscall)	/* reserved for TUX */<br /> 	.long SYMBOL_NAME(sys_ni_syscall)	/* Reserved for Security */<br /> 	.long SYMBOL_NAME(sys_gettid)<br />+	.long SYMBOL_NAME(sys_readahead)	/* 225 */<br /> <br /> 	.rept NR_syscalls-(.-sys_call_table)/4<br /> 		.long SYMBOL_NAME(sys_ni_syscall)<br />diff -u --recursive --new-file pre3/linux/include/asm-i386/unistd.h linux/include/asm-i386/unistd.h<br />--- pre3/linux/include/asm-i386/unistd.h	Mon Oct  8 10:40:16 2001<br />+++ linux/include/asm-i386/unistd.h	Wed Oct 17 10:03:03 2001<br />&#64;&#64; -229,6 +229,7 &#64;&#64;<br /> #define __NR_fcntl64		221<br /> #define __NR_security		223	/* syscall for security modules */<br /> #define __NR_gettid		224<br />+#define __NR_readahead		225<br /> <br /> /* user-visible error numbers are in the range -1 - -124: see &lt;asm-i386/errno.h&gt; */<br /> <br />diff -u --recursive --new-file pre3/linux/mm/filemap.c linux/mm/filemap.c<br />--- pre3/linux/mm/filemap.c	Mon Oct 15 16:17:40 2001<br />+++ linux/mm/filemap.c	Wed Oct 17 10:21:37 2001<br />&#64;&#64; -1520,6 +1520,53 &#64;&#64;<br /> 	return retval;<br /> }<br /> <br />+static ssize_t do_readahead(struct file *file, unsigned long index, unsigned long nr)<br />+{<br />+	struct address_space *mapping = file-&gt;f_dentry-&gt;d_inode-&gt;i_mapping;<br />+	unsigned long max;<br />+<br />+	if (!mapping || !mapping-&gt;a_ops || !mapping-&gt;a_ops-&gt;readpage)<br />+		return -EINVAL;<br />+<br />+	/* Limit it to the size of the file.. */<br />+	max = (mapping-&gt;host-&gt;i_size + ~PAGE_CACHE_MASK) &gt;&gt; PAGE_CACHE_SHIFT;<br />+	if (index &gt; max)<br />+		return 0;<br />+	max -= index;<br />+	if (nr &gt; max)<br />+		nr = max;<br />+<br />+	/* And limit it to a sane percentage of the inactive list.. */<br />+	max = nr_inactive_pages / 2;<br />+	if (nr &gt; max)<br />+		nr = max;<br />+<br />+	while (nr) {<br />+		page_cache_read(file, index);<br />+		index++;<br />+		nr--;<br />+	}<br />+	return 0;<br />+}<br />+<br />+asmlinkage ssize_t sys_readahead(int fd, loff_t offset, size_t count)<br />+{<br />+	ssize_t ret;<br />+	struct file *file;<br />+<br />+	ret = -EBADF;<br />+	file = fget(fd);<br />+	if (file) {<br />+		if (file-&gt;f_mode &amp; FMODE_READ) {<br />+			unsigned long start = offset &gt;&gt; PAGE_CACHE_SHIFT;<br />+			unsigned long len = (count + ((long)offset &amp; ~PAGE_CACHE_MASK)) &gt;&gt; PAGE_CACHE_SHIFT;<br />+			ret = do_readahead(file, start, len);<br />+		}<br />+		fput(file);<br />+	}<br />+	return ret;<br />+}<br />+<br /> /*<br />  * Read-ahead and flush behind for MADV_SEQUENTIAL areas.  Since we are<br />  * sure this is sequential access, we don't need a flexible read-ahead#include &lt;sys/types.h&gt;<br />#include &lt;sys/stat.h&gt;<br />#include &lt;dirent.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;sys/fcntl.h&gt;<br /><br />/* Preload the OS's cache with all files of one branch for recursive diffs */<br /><br />#define __NR_readahead 225<br /><br />asm(<br />"__readahead:\n\t"<br />        "pushl %ebx\n\t"<br />        "pushl %esi\n\t"<br />	"movl 12(%esp),%ebx\n\t"<br />	"movl 16(%esp),%ecx\n\t"<br />	"movl 20(%esp),%edx\n\t"<br />	"movl 24(%esp),%esi\n\t"<br />	"movl $225,%eax\n\t"<br />	"int $0x80\n\t"<br />	"popl %esi\n\t"<br />	"popl %ebx\n\t"<br />	"ret"<br />);<br /><br />extern ssize_t __readahead(int fd, loff_t offset, size_t size);<br /><br />void<br />preread (dir)<br />	const char *dir;<br />{<br /><br />  DIR *d;<br />  struct dirent *dent;<br /><br />  d = opendir(dir);<br />  if (d == NULL) return;<br /><br />  while ((dent = readdir(d)) != NULL)<br />    {<br />      int fd;<br />      struct stat st;<br />      char *name, *path;<br /><br />      name = dent-&gt;d_name;<br />      if (name[0] == '.' &amp;&amp; (name[1] == 0 || (name[1] == '.' &amp;&amp; name[2] == 0)))<br />            continue;<br /><br />      path = malloc(strlen(dir)+strlen(name)+2);<br />      strcpy(path, dir);<br />      strcat(path, "/");<br />      strcat(path, name);<br /><br />      fd = open(path, O_RDONLY);<br />      if (fd &gt;= 0) {<br />      	if (fstat(fd, &amp;st) == 0) {<br />	      if (S_ISDIR(st.st_mode))<br />	           preread(path);<br />	      else if (S_ISREG(st.st_mode))<br />	        {<br />          	__readahead(fd, 0, ~0UL);<br />	        }<br />	}<br />	close(fd);<br />      }<br />      free(path);<br />  }<br />  closedir(d);<br />}<br /><br />int main(int argc, char **argv)<br />{<br />	preread(argv[1]);<br />	return 0;<br />}<br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
