    </div></td><td width="32"> </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2011/10/21/185">First message in thread</a></li><li><a href="/lkml/2011/10/21/185">Roland McGrath</a><ul><li><a href="/lkml/2011/10/21/186">Roland McGrath</a></li><li class="origin"><a href="/lkml/2011/10/22/169">Linus Torvalds</a><ul><li><a href="/lkml/2011/10/22/169">Roland McGrath</a><ul><li><a href="/lkml/2011/10/22/174">Linus Torvalds</a><ul><li><a href="/lkml/2011/10/22/175">Linus Torvalds</a></li><li><a href="/lkml/2011/10/23/201">Roland McGrath</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 22 Oct 2011 06:38:33 +0300</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 1/2] LSM: Do not apply mmap_min_addr check to PROT_NONE mappings</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">So I'm not against this, but I'm wondering what triggers the need for it?<br /><br />It does make the security checks more complicated, since now<br />mprotect() suddenly has to care about mmap_min_addr. So I don't think<br />it's a security enhancement ("attempt to ensure robustness").<br /><br />But if there is some actual use-case that is shown to be helped,<br />please document that n the explanations for the changeset.<br /><br />                  Linus<br /><br />On Sat, Oct 22, 2011 at 12:39 AM, Roland McGrath &lt;roland&#64;hack.frob.com&gt; wrote:<br />&gt; An mmap with PROT_NONE is done specifically to ensure that an address will<br />&gt; fault.  So doing this on addresses below mmap_min_addr is not seeking a<br />&gt; "dangerous" operation.  Conversely, it's an attempt to ensure robustness in<br />&gt; case mmap_min_addr is less restrictive than the user wants to be.<br />&gt;<br />&gt; Since we might let a low mapping exist at all without a check, we add<br />&gt; another check to prevent mprotect from granting access to such a mapping.<br />&gt;<br />&gt; Signed-off-by: Roland McGrath &lt;roland&#64;hack.frob.com&gt;<br />&gt; ---<br />&gt;  include/linux/security.h |    5 ++-<br />&gt;  security/apparmor/lsm.c  |    7 ++++++<br />&gt;  security/capability.c    |    6 -----<br />&gt;  security/commoncap.c     |   48 ++++++++++++++++++++++++++++++++++++---------<br />&gt;  security/selinux/hooks.c |    8 ++++++-<br />&gt;  5 files changed, 55 insertions(+), 19 deletions(-)<br />&gt;<br />&gt; diff --git a/include/linux/security.h b/include/linux/security.h<br />&gt; index ebd2a53..aba8071 100644<br />&gt; --- a/include/linux/security.h<br />&gt; +++ b/include/linux/security.h<br />&gt; &#64;&#64; -73,6 +73,8 &#64;&#64; extern int cap_inode_killpriv(struct dentry *dentry);<br />&gt;  extern int cap_file_mmap(struct file *file, unsigned long reqprot,<br />&gt;                         unsigned long prot, unsigned long flags,<br />&gt;                         unsigned long addr, unsigned long addr_only);<br />&gt; +extern int cap_file_mprotect(struct vm_area_struct *vma,<br />&gt; +                            unsigned long reqprot, unsigned long prot);<br />&gt;  extern int cap_task_fix_setuid(struct cred *new, const struct cred *old, int flags);<br />&gt;  extern int cap_task_prctl(int option, unsigned long arg2, unsigned long arg3,<br />&gt;                          unsigned long arg4, unsigned long arg5);<br />&gt; &#64;&#64; -2213,7 +2215,7 &#64;&#64; static inline int security_file_mprotect(struct vm_area_struct *vma,<br />&gt;                                         unsigned long reqprot,<br />&gt;                                         unsigned long prot)<br />&gt;  {<br />&gt; -       return 0;<br />&gt; +       return cap_file_mprotect(vma, reqprot, prot);<br />&gt;  }<br />&gt;<br />&gt;  static inline int security_file_lock(struct file *file, unsigned int cmd)<br />&gt; &#64;&#64; -3044,4 +3046,3 &#64;&#64; static inline void free_secdata(void *secdata)<br />&gt;  #endif /* CONFIG_SECURITY */<br />&gt;<br />&gt;  #endif /* ! __LINUX_SECURITY_H */<br />&gt; -<br />&gt; diff --git a/security/apparmor/lsm.c b/security/apparmor/lsm.c<br />&gt; index 3783202..d2a9693 100644<br />&gt; --- a/security/apparmor/lsm.c<br />&gt; +++ b/security/apparmor/lsm.c<br />&gt; &#64;&#64; -508,6 +508,13 &#64;&#64; static int apparmor_file_mmap(struct file *file, unsigned long reqprot,<br />&gt;  static int apparmor_file_mprotect(struct vm_area_struct *vma,<br />&gt;                                  unsigned long reqprot, unsigned long prot)<br />&gt;  {<br />&gt; +        int rc;<br />&gt; +<br />&gt; +       /* do DAC check */<br />&gt; +       rc = cap_file_mprotect(vma, reqprot, prot);<br />&gt; +       if (rc)<br />&gt; +               return rc;<br />&gt; +<br />&gt;        return common_mmap(OP_FMPROT, vma-&gt;vm_file, prot,<br />&gt;                           !(vma-&gt;vm_flags &amp; VM_SHARED) ? MAP_PRIVATE : 0);<br />&gt;  }<br />&gt; diff --git a/security/capability.c b/security/capability.c<br />&gt; index 2984ea4..3c60f07 100644<br />&gt; --- a/security/capability.c<br />&gt; +++ b/security/capability.c<br />&gt; &#64;&#64; -316,12 +316,6 &#64;&#64; static int cap_file_ioctl(struct file *file, unsigned int command,<br />&gt;        return 0;<br />&gt;  }<br />&gt;<br />&gt; -static int cap_file_mprotect(struct vm_area_struct *vma, unsigned long reqprot,<br />&gt; -                            unsigned long prot)<br />&gt; -{<br />&gt; -       return 0;<br />&gt; -}<br />&gt; -<br />&gt;  static int cap_file_lock(struct file *file, unsigned int cmd)<br />&gt;  {<br />&gt;        return 0;<br />&gt; diff --git a/security/commoncap.c b/security/commoncap.c<br />&gt; index a93b3b7..0d4685a 100644<br />&gt; --- a/security/commoncap.c<br />&gt; +++ b/security/commoncap.c<br />&gt; &#64;&#64; -942,11 +942,26 &#64;&#64; int cap_vm_enough_memory(struct mm_struct *mm, long pages)<br />&gt;        return __vm_enough_memory(mm, pages, cap_sys_admin);<br />&gt;  }<br />&gt;<br />&gt; +static int cap_mmap_min_addr(unsigned long addr)<br />&gt; +{<br />&gt; +       int ret = 0;<br />&gt; +<br />&gt; +       if (addr &lt; dac_mmap_min_addr) {<br />&gt; +               ret = cap_capable(current, current_cred(), &amp;init_user_ns,<br />&gt; +                                 CAP_SYS_RAWIO, SECURITY_CAP_AUDIT);<br />&gt; +               /* set PF_SUPERPRIV if it turns out we allow the low mmap */<br />&gt; +               if (ret == 0)<br />&gt; +                       current-&gt;flags |= PF_SUPERPRIV;<br />&gt; +       }<br />&gt; +<br />&gt; +       return ret;<br />&gt; +}<br />&gt; +<br />&gt;  /*<br />&gt;  * cap_file_mmap - check if able to map given addr<br />&gt;  * &#64;file: unused<br />&gt;  * &#64;reqprot: unused<br />&gt; - * &#64;prot: unused<br />&gt; + * &#64;prot: protection being requested<br />&gt;  * &#64;flags: unused<br />&gt;  * &#64;addr: address attempting to be mapped<br />&gt;  * &#64;addr_only: unused<br />&gt; &#64;&#64; -960,14 +975,27 &#64;&#64; int cap_file_mmap(struct file *file, unsigned long reqprot,<br />&gt;                  unsigned long prot, unsigned long flags,<br />&gt;                  unsigned long addr, unsigned long addr_only)<br />&gt;  {<br />&gt; -       int ret = 0;<br />&gt; +       if (addr_only || prot != PROT_NONE)<br />&gt; +               return cap_mmap_min_addr(addr);<br />&gt; +       return 0;<br />&gt; +}<br />&gt;<br />&gt; -       if (addr &lt; dac_mmap_min_addr) {<br />&gt; -               ret = cap_capable(current, current_cred(), &amp;init_user_ns, CAP_SYS_RAWIO,<br />&gt; -                                 SECURITY_CAP_AUDIT);<br />&gt; -               /* set PF_SUPERPRIV if it turns out we allow the low mmap */<br />&gt; -               if (ret == 0)<br />&gt; -                       current-&gt;flags |= PF_SUPERPRIV;<br />&gt; -       }<br />&gt; -       return ret;<br />&gt; +/*<br />&gt; + * cap_file_mprotect - check if able to mprotect given addr<br />&gt; + * &#64;vma: entry being changed<br />&gt; + * &#64;reqprot: unused<br />&gt; + * &#64;prot: protection being changed to<br />&gt; + *<br />&gt; + * If the process is attempting to change memory below dac_mmap_min_addr to<br />&gt; + * anything but PROT_NONE, they need CAP_SYS_RAWIO.  The other parameters<br />&gt; + * to this function are unused by the capability security module.  Returns<br />&gt; + * 0 if this mapping should be allowed -EPERM if not.<br />&gt; + */<br />&gt; +int cap_file_mprotect(struct vm_area_struct *vma,<br />&gt; +                     unsigned long reqprot,<br />&gt; +                     unsigned long prot)<br />&gt; +{<br />&gt; +       if (prot != PROT_NONE)<br />&gt; +               return cap_mmap_min_addr(vma-&gt;vm_start);<br />&gt; +       return 0;<br />&gt;  }<br />&gt; diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c<br />&gt; index 266a229..76e6f04 100644<br />&gt; --- a/security/selinux/hooks.c<br />&gt; +++ b/security/selinux/hooks.c<br />&gt; &#64;&#64; -3086,13 +3086,19 &#64;&#64; static int selinux_file_mprotect(struct vm_area_struct *vma,<br />&gt;                                 unsigned long prot)<br />&gt;  {<br />&gt;        const struct cred *cred = current_cred();<br />&gt; +       int rc;<br />&gt;<br />&gt;        if (selinux_checkreqprot)<br />&gt;                prot = reqprot;<br />&gt;<br />&gt; +       /* do DAC check on address space usage */<br />&gt; +       rc = cap_file_mprotect(vma, reqprot, prot)<br />&gt; +       if (rc)<br />&gt; +               return rc;<br />&gt; +<br />&gt;        if (default_noexec &amp;&amp;<br />&gt;            (prot &amp; PROT_EXEC) &amp;&amp; !(vma-&gt;vm_flags &amp; VM_EXEC)) {<br />&gt; -               int rc = 0;<br />&gt; +               rc = 0;<br />&gt;                if (vma-&gt;vm_start &gt;= vma-&gt;vm_mm-&gt;start_brk &amp;&amp;<br />&gt;                    vma-&gt;vm_end &lt;= vma-&gt;vm_mm-&gt;brk) {<br />&gt;                        rc = cred_has_perm(cred, cred, PROCESS__EXECHEAP);<br />&gt;<br />--<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
