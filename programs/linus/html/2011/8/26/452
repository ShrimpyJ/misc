    </div></td><td width="32"> </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2011/8/26/415">First message in thread</a></li><li><a href="/lkml/2011/8/26/444">Linus Torvalds</a><ul><li><a href="/lkml/2011/8/26/445">"H. Peter Anvin"</a><ul><li><a href="/lkml/2011/8/26/449">Linus Torvalds</a><ul><li><a href="/lkml/2011/8/26/451">"H. Peter Anvin"</a><ul><li><a href="/lkml/2011/8/26/453">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2011/8/26/448">"H. Peter Anvin"</a><ul><li class="origin"><a href="/lkml/2011/8/29/383">Linus Torvalds</a><ul><li><a href="/lkml/2011/8/29/383">Geert Uytterhoeven</a><ul><li><a href="/lkml/2011/8/29/385">"H. Peter Anvin"</a></li><li><a href="/lkml/2011/8/29/546">Ted Ts'o</a></li><li><a href="/lkml/2011/8/29/550">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2011/9/6/302">Florian Weimer</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 26 Aug 2011 18:42:35 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: RFD: x32 ABI system call numbers</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Aug 26, 2011 at 6:12 PM, H. Peter Anvin &lt;hpa&#64;zytor.com&gt; wrote:<br />&gt; For reference, this is the current list (again, unaudited!) of unshared<br />&gt; system calls.  Only the ones with *x32* in the the entry point name have<br />&gt; any new code in the kernel at all.<br /><br />So a *lot* of these make me extremely unhappy.<br /><br />&gt; # x32 system calls start at 512 to avoid cache impact for native 32 bit<br />&gt; #<br />&gt; 512     x32     open                    compat_sys_open<br /><br />The only difference between open and compat_sys_open() is that the<br />latter doesn't set O_LARGEFILE, no?<br /><br />That seems *extremely* wrong. Darn it, there is no reason we should<br />ever allow the old LARGEFILE crap in a new model. So why would we ever<br />want to that compat_open()?<br /><br />&gt; 513     x32     stat                    compat_sys_newstat<br />&gt; 514     x32     fstat                   compat_sys_newfstat<br />&gt; 515     x32     lstat                   compat_sys_newlstat<br /><br />So these I'm unhappy with because I really think we should just use<br />the 64-bit stat format, instead of dicking around with the legacy<br />formats.<br /><br />The native x86-64 stat is *better* than the crazy i386 formats, for<br />chissake! The i386 "newstat" has those crazy padding fields. They make<br />no sense.<br /><br />&gt; 516     x32     rt_sigaction            sys32_rt_sigaction<br />&gt; 517     x32     rt_sigprocmask          sys32_rt_sigprocmask<br />&gt; 518     x32     rt_sigreturn            stub_x32_rt_sigreturn<br /><br />So these may be valid. I don't know what your stub_x32_rt_sigreturn<br />is, but I hope it still restores the full 64-bit registers? Even in<br />ULP64, I assume we still use 64-bit registers for "long long" etc?<br /><br />&gt; 519     x32     ioctl                   compat_sys_ioctl<br />&gt; 520     x32     readv                   compat_sys_readv<br />&gt; 521     x32     writev                  compat_sys_writev<br /><br />Ok, these are the ones I expect. They are all about structures with<br />pointers in user space.<br /><br />&gt; 522     x32     select                  compat_sys_select<br /><br />But this one I really suspect we'd be better off just having 64-bit<br />timeval, obviating the need for the compat system call.<br /><br />time_t really *should* be 64-bit, the same way "off_t" should be. If<br />it's not, there's something wrong.<br /><br />&gt; 523     x32     shmat                   compat_sys_x32_shmat<br />&gt; 524     x32     shmctl                  compat_sys_shmctl<br /><br />I assume this is due to the same "return shm segment in low 4GB" thing.<br /><br />I do think it would be better to have a "SHM_4G" flag that gets set by<br />user space, but I guess that's ok.<br /><br />&gt; 525     x32     nanosleep               compat_sys_nanosleep<br />&gt; 526     x32     getitimer               compat_sys_getitimer<br />&gt; 527     x32     setitimer               compat_sys_setitimer<br /><br />Again, these would be better off with a 64-bit time_t. Seriously.<br /><br />&gt; 528     x32     recvfrom                compat_sys_recvfrom<br />&gt; 529     x32     sendmsg                 compat_sys_sendmsg<br />&gt; 530     x32     recvmsg                 compat_sys_recvmsg<br /><br />Ok, pointers in user land.<br /><br />&gt; 531     x32     setsockopt              compat_sys_setsockopt<br />&gt; 532     x32     getsockopt              compat_sys_getsockopt<br /><br />Grr. I guess these fall under the same heading.<br /><br />&gt; 533     x32     execve                  stub_x32_execve<br /><br />Yes.<br /><br />&gt; 534     x32     wait4                   compat_sys_wait4<br /><br />Why is this? "rusage"? Can't we just make that 64-bit?<br /><br />&gt; 535     x32     semctl                  compat_sys_x32_semctl<br />&gt; 536     x32     msgsnd                  compat_sys_x32_msgsnd<br />&gt; 537     x32     msgrcv                  compat_sys_x32_msgrcv<br />&gt; 538     x32     msgctl                  compat_sys_msgctl<br /><br />Ok.<br /><br />&gt; 539     x32     fcntl                   compat_sys_fcntl64<br /><br />flock?<br /><br />&gt; 540     x32     getdents                compat_sys_getdents<br /><br />.. but why this? Isn't 'linux_dirent64' good enough?<br /><br />&gt; 541     x32     gettimeofday            compat_sys_gettimeofday<br /><br />64-bit time_t?<br /><br />&gt; 542     x32     getrlimit               compat_sys_getrlimit<br />&gt; 543     x32     getrusage               compat_sys_getrusage<br /><br />Looks like another "should just be 64-bit"<br /><br />&gt; 544     x32     sysinfo                 compat_sys_sysinfo<br />&gt; 545     x32     times                   compat_sys_times<br /><br />64-bit time_t should fix this.<br />...<br />&gt; 560     x32     nfsservctl              compat_sys_nfsservctl<br /><br />We've removed this one.<br /><br />.. lots more. It really looks annoying to me. A lot of the remaining<br />ones should just be "int 0x80", they aren't performance critical. Why<br />do they have to have new system call entry points?<br /><br />                        Linus<br />--<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
