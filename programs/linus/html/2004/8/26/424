    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/8/24/220">First message in thread</a></li><li><a href="/lkml/2004/8/26/382">	viro&#64;parcelfa ...</a><ul><li><a href="/lkml/2004/8/26/375">Christophe Saout</a></li><li><a href="/lkml/2004/8/26/466">Linus Torvalds</a><ul><li><a href="/lkml/2004/8/26/403">	viro&#64;parcelfa ...</a></li><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2004/8/26/439">	viro&#64;parcelfa ...</a></li><li><a href="/lkml/2004/8/26/444">	viro&#64;parcelfa ...</a></li><li><a href="/lkml/2004/8/26/445">Linus Torvalds</a></li><li><a href="/lkml/2004/8/26/459">Linus Torvalds</a></li><li><a href="/lkml/2004/8/26/469">	viro&#64;parcelfa ...</a><ul><li><a href="/lkml/2004/8/26/476">Linus Torvalds</a><ul><li><a href="/lkml/2004/8/26/510">	viro&#64;parcelfa ...</a></li></ul></li></ul></li><li><a href="/lkml/2004/8/27/26">Anton Altaparmakov</a><ul><li><a href="/lkml/2004/8/27/28">Christoph Hellwig</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 26 Aug 2004 15:04:21 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [some sanity for a change] possible design issues for hybrids</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />[ This is quite possibly just impossible and buggy, but here's my<br />  implementation notes. You asked for them. ]<br /><br />On Thu, 26 Aug 2004 viro&#64;parcelfarce.linux.theplanet.co.uk wrote:<br />&gt; <br />&gt; All right, let's see where that would take us.<br />&gt; <br />&gt; 1) we would need to find all vfsmounts over given dentry.  Probably a cyclic<br />&gt; list (we want to check if there are normal mounts/bindings among those and<br />&gt; we want to dissolve them if there's none).<br /><br />Not per-inode? dentries are a bitmore memory-constrained than inodes, and <br />we only need this for filesystems that want to support it, so we wouldn't <br />need to put this information in each dentry.<br /><br />Since the vfsmounts have back-pointers to the dentry they are mounted on,<br />you can still do a "per-dentry" traversal, by just doign the inode list<br />and checking the dentry pointer. No?<br /><br />Alternatively, we could just put the list on an external hash-chain <br />entirely, and hash off the dentry. It depends on how often we end up <br />needing it.<br /><br />Or we could just put it in the dentry itself. I'd hate to make it any <br />bigger than it already is, but maybe it doesn't matter that much.<br /><br />&gt; 2) we would need to do something about locking, since mount trees in other<br />&gt; guys' namespaces are protected by semaphores of their own.<br /><br />Ok, I'll admit that I don't know how to handle namespaces. These things <br />should just go into a global namespace, and I was kind of assuming it <br />would happen automatically in "lookup_mnt()" or something like that. A <br />special case in lookup_mnt which says something like "if you didn't find a <br />vfsmount, we create a new one for you".<br /><br />It should be reasonably easy to create new ones on-the-fly, since we'd<br />have all the information (the parent vfsmount comes stated, and the<br />vfsmount we create would point to the same things that the "base" one<br />would).<br /><br />&gt; 3) what do we do on umount(2)?  We can get a bunch of vfsmounts hanging off<br />&gt; it.  MNT_DETACH will have no problems, but normal umount() is a different<br />&gt; story.  Note that it's not just hybrid-related problem - implementing the<br />&gt; mount traps will cause the same kind of trouble,<br /><br />Don't allow umount. It's not something the user can unmount - the mount is <br />"implied" in the file. <br /><br />&gt; 4) OK, we have those hybrids and want to create vfsmounts when crossing a<br />&gt; mountpoint.  When do they go away, anyway?  When we don't reference them<br />&gt; anymore?  Right now "attached to mount tree" == "+1 to refcount" and detaching<br />&gt; happens explicitly - outside of the "dropping the final reference" path.<br />&gt; Might become a locking issue.<br /><br />Ahh. Umm.. Yes. I think this might be the real problem. Unless I seriously <br />clossed something over when I blathered about the "create the vfsmount on <br />the fly" thing above ;)<br /><br />&gt; 5) Creation of these vfsmounts: fs should somehow tell us whether it wants<br />&gt; one or not (at the very least, we should stop *somewhere*).  Can we use<br />&gt; the same dentry/inode?  I'm not sure and I really doubt that we'd like that.<br /><br />Why not? When doing the -&gt;lookup() operation, the filesystem would create<br />the vfsmount and bind it to the current vfsmount. That guarantees that it<br />has a vfsmount, and will mean that it will show up positive with the<br />"d_mountpoint()" query, which in turn will cause us to do the<br />"lookup_mnt()".<br /><br />Which in turn will create the other vfsmounts as needed, if you have <br />multiple namespaces.<br /><br />So I _think_ creation is easy. Getting rid of the dang things migth be <br />harder.<br /><br />&gt; 6) if it's a method, where should it live, *especially* if we want them on<br />&gt; device nodes.  Note that inode_operations belongs to underlying fs, so it's<br />&gt; not particulary good place for device case.<br /><br />Why not just let the existing .lookup method initialize the mount-point <br />thing? After that, it's all in the VFS layer (I'd hate to have filesystems <br />mess around with vfsmounts - they'll just get it wrong).<br /><br />&gt; 7) automount folks want partially shared mount trees (well, mirrored,<br />&gt; actually).<br /><br />I don't think you can get partial sharing on one of these puppies. You'd <br />always have one vfsmount per namespace (well, lazily created, so maybe in <br />practice you'd see a lot fewer).<br /><br />&gt; 8) what should happen when something is mounted on top of directory-over-file?<br />&gt; How do we treat such beasts?  What are the implications?<br /><br />Allow file-on-file mounts - it will just totally hide the thing (in that<br />namespace, at least). But don't allow the dir-on-file thing (that we<br />already don't allow).<br /><br />&gt; 9) how do we recognize such mountpoints in the path lookups?  It *is* a<br />&gt; hot path, so we should be careful in that area; the impact will be felt<br />&gt; by everything in the system.<br /><br />I don't think you'll have any special cases. Same d_mountpount(), same <br />lookup_mnt().<br /><br />&gt; 10) how do we deal with directories, anyway?  Mixing "attributes" with<br />&gt; normal directory contents is going to be fun, what with lseek() insanity.<br /><br />You couldn't get at the attributes that way anyway, so I think the point <br />is moot. The "real" directory always takes over.<br /><br />Crazy people could try to just use the regular "xattrs" interfaces if they <br />really want attributes on directories. You wouldn't ever be able to use <br />the "easy" one.<br /><br />&gt; 11) if we go for your "here's stuff that belongs in device node viewed<br />&gt; as directory", how would that play with fs metadata exporters?  Again,<br />&gt; due to the insanity of lseek() on directories it's *very* hard to deal<br />&gt; with unions, when parts of directory come from different chunks of code.<br /><br />Don't go there. See above. Directories would be just plain directories, <br />you could never see their metadata. Same goes for at least symlinks, and <br />possibly other filetypes too (ie at least initially, a block or character <br />special device will just take over the whole "file_operations", which <br />includes "readdir", so it's actually hard to have the filesystem do <br />anything about those).<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
