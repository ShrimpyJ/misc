    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/8/24/220">First message in thread</a></li><li><a href="/lkml/2004/8/26/382">	viro&#64;parcelfa ...</a><ul><li><a href="/lkml/2004/8/26/375">Christophe Saout</a></li><li><a href="/lkml/2004/8/26/466">Linus Torvalds</a><ul><li><a href="/lkml/2004/8/26/403">	viro&#64;parcelfa ...</a></li><li><a href="/lkml/2004/8/26/424">Linus Torvalds</a></li><li><a href="/lkml/2004/8/26/439">	viro&#64;parcelfa ...</a></li><li><a href="/lkml/2004/8/26/444">	viro&#64;parcelfa ...</a></li><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2004/8/26/459">Linus Torvalds</a></li><li><a href="/lkml/2004/8/26/469">	viro&#64;parcelfa ...</a><ul><li><a href="/lkml/2004/8/26/476">Linus Torvalds</a><ul><li><a href="/lkml/2004/8/26/510">	viro&#64;parcelfa ...</a></li></ul></li></ul></li><li><a href="/lkml/2004/8/27/26">Anton Altaparmakov</a><ul><li><a href="/lkml/2004/8/27/28">Christoph Hellwig</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 26 Aug 2004 15:45:09 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [some sanity for a change] possible design issues for hybrids</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 26 Aug 2004 viro&#64;parcelfarce.linux.theplanet.co.uk wrote:<br />&gt; &gt; <br />&gt; &gt; It should be reasonably easy to create new ones on-the-fly, since we'd<br />&gt; &gt; have all the information (the parent vfsmount comes stated, and the<br />&gt; &gt; vfsmount we create would point to the same things that the "base" one<br />&gt; &gt; would).<br />&gt; <br />&gt; Erm...  What do we do upon unlink()?  I'm killing a file, fs it's in is<br />&gt; mounted in a dozen of places (no namespaces, just chroot jails, whatever).<br />&gt; We need to find all vfsmounts to be killed by that.<br /><br />But that should be trivial: that's what the per-inode vfsmount list was <br />(your first question in the last email).<br /><br />&gt; And BTW that's an argument against anchoring that list in inode - unlink()<br />&gt; on foo should not screw bar/... even if bar and foo are links to the same<br />&gt; file.  So we'll need to check for dentry match anyway.<br /><br />And again - I talked about this in the previous email. Even if you anchor <br />the list in "struct inode", or you do it with a totally external <br />hash-list, you'll always have the "vfsmount-&gt;mnt_mountpoint" pointer to <br />point to the dentry. So you can just iterate over the list, and <br />cherry-pick the ones that point to the dentry you are removing.<br /><br />&gt; <br />&gt; &gt; &gt; 3) what do we do on umount(2)?  We can get a bunch of vfsmounts hanging off<br />&gt; &gt; &gt; it.  MNT_DETACH will have no problems, but normal umount() is a different<br />&gt; &gt; &gt; story.  Note that it's not just hybrid-related problem - implementing the<br />&gt; &gt; &gt; mount traps will cause the same kind of trouble,<br />&gt; &gt; <br />&gt; &gt; Don't allow umount. It's not something the user can unmount - the mount is <br />&gt; &gt; "implied" in the file. <br />&gt; <br />&gt; See below.<br />&gt; <br />&gt; &gt; &gt; 4) OK, we have those hybrids and want to create vfsmounts when crossing a<br />&gt; &gt; &gt; mountpoint.  When do they go away, anyway?  When we don't reference them<br />&gt; &gt; &gt; anymore?  Right now "attached to mount tree" == "+1 to refcount" and detaching<br />&gt; &gt; &gt; happens explicitly - outside of the "dropping the final reference" path.<br />&gt; &gt; &gt; Might become a locking issue.<br />&gt; &gt; <br />&gt; &gt; Ahh. Umm.. Yes. I think this might be the real problem. Unless I seriously <br />&gt; &gt; clossed something over when I blathered about the "create the vfsmount on <br />&gt; &gt; the fly" thing above ;)<br />&gt; <br />&gt; &gt; &gt; 5) Creation of these vfsmounts: fs should somehow tell us whether it wants<br />&gt; &gt; &gt; one or not (at the very least, we should stop *somewhere*).  Can we use<br />&gt; &gt; &gt; the same dentry/inode?  I'm not sure and I really doubt that we'd like that.<br />&gt; &gt; <br />&gt; &gt; Why not? When doing the -&gt;lookup() operation, the filesystem would create<br />&gt; &gt; the vfsmount and bind it to the current vfsmount. That guarantees that it<br />&gt; &gt; has a vfsmount, and will mean that it will show up positive with the<br />&gt; &gt; "d_mountpoint()" query, which in turn will cause us to do the<br />&gt; &gt; "lookup_mnt()".<br />&gt; <br />&gt; Several paragraphs below you are saying that you don't like fs messing with<br />&gt; vfsmounts.  Use of -&gt;lookup() would mean that we should not only create<br />&gt; and attach vfsmounts from within fs code, but would actually have to make<br />&gt; -&gt;lookup() return vfsmount+dentry, AFAICS.<br /><br />No, lookup would just return the dentry, but the dentry would already be <br />filled in with the mount-point information.<br /><br />And you can do that with a simple vfs helper function, ie the filesystem <br />itself would just need to do<br /><br />	pseudo_mount(dentry, inode);<br /><br />thing - which just fills in dentry-&gt;d_mountpoint with a new vfsmount<br />thing. It would allocate a new root dentry (for the pseudo-mount) and a<br />new vfsmount, and make dentry-&gt;d_mountpoint point to it.<br /><br />IOW, the filesystem itself would never mess around with d_mountpoint <br />itself.<br /><br />&gt; Err...  What about dir-on-dir-that-is-on-file?  I.e. mount on foo/. when foo<br />&gt; is a file?<br /><br />Hmm.. We might as well allow it, I suspect. It's not like it should hurt.  <br />We'd end up following the mount-chain twice, but we already have that<br />issue with multi-mount cases..<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
