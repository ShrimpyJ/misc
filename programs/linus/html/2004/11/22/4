    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/11/15/196">First message in thread</a></li><li><a href="/lkml/2004/11/21/202">Davide Libenzi</a><ul><li><a href="/lkml/2004/11/21/203">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2004/11/22/62">Linus Torvalds</a><ul><li><a href="/lkml/2004/11/22/62">Andreas Schwab</a><ul><li><a href="/lkml/2004/11/22/154">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2004/11/22/109">Davide Libenzi</a></li><li><a href="/lkml/2004/11/22/334">Jesse Allen</a><ul><li><a href="/lkml/2004/11/22/319">Jesse Allen</a></li><li><a href="/lkml/2004/11/28/88">Eric Pouech</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2004/11/22/4/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 21 Nov 2004 22:23:41 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: ptrace single-stepping change breaks Wine</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sun, 21 Nov 2004, Linus Torvalds wrote:<br />&gt; <br />&gt; I'm by no means 100% sure that we should encourage the kind of programming <br />&gt; "skills" I showed with that example program, so in that sense this may not <br />&gt; be worth worrying about. That said, I do hate the notion of having <br />&gt; programs that are basically undebuggable, so from a QoI standpoint I'd <br />&gt; really like to say that you can run my horrid little program under the <br />&gt; debugger and see it work...<br /><br />Ok, how about this patch?<br /><br />It does basically two things:<br /><br /> - it makes the x86 version of ptrace be a lot more careful about the TF <br />   bit in eflags, and in particular it never touches it _unless_ the <br />   tracer has explicitly asked for it (ie we set TF only when doing a<br />   PTRACE_SINGESTEP, and we clear it only when it has been set by us, not <br />   if it has been set by the program itself).<br /><br />   This patch also cleans up the codepaths by doing all the common stuff<br />   in set_singlestep()/clear_singlestep().<br /><br /> - It clarifies signal handling, and makes it clear that we always push <br />   the full eflags onto the signal stack, _except_ if the TF bit was set <br />   by an external ptrace user, in which case we hide it so that the tracee <br />   doesn't see it when it looks at its stack contents.<br /><br />   It also adds a few comments, and makes it clear that the signal handler<br />   itself is always set up with TF _clear_. But if we were single-stepped <br />   into it, we will have notified the debugger, so the debugger obviously <br />   can (and often will) decide to continue single-stepping.<br /><br />IMHO, this is a nice cleanup, and it also means that I can actually debug <br />my "program from hell":<br /><br />	[torvalds&#64;evo ~]$ gdb ./a.out <br />	GNU gdb Red Hat Linux (6.1post-1.20040607.41rh)<br />	Copyright 2004 Free Software Foundation, Inc.<br />	GDB is free software, covered by the GNU General Public License, and you are<br />	welcome to change it and/or distribute copies of it under certain conditions.<br />	Type "show copying" to see the conditions.<br />	There is absolutely no warranty for GDB.  Type "show warranty" for details.<br />	This GDB was configured as "i386-redhat-linux-gnu"...(no debugging symbols <br />	found)...Using host libthread_db library "/lib/tls/libthread_db.so.1".<br /><br />	(gdb) run<br />	Starting program: /home/torvalds/a.out <br />	Reading symbols from shared object read from target memory...(no debugging <br />	symbols found)...done.<br />	Loaded system supplied DSO at 0xffffe000<br />	(no debugging symbols found)...(no debugging symbols found)...<br />	Program received signal SIGTRAP, Trace/breakpoint trap.<br />	0x08048480 in main ()<br />	(gdb) signal SIGTRAP<br />	Continuing with signal SIGTRAP.<br /><br />	Program received signal SIGTRAP, Trace/breakpoint trap.<br />	0x08048487 in main ()<br />	(gdb) signal SIGTRAP<br />	Continuing with signal SIGTRAP.<br /><br />	Program received signal SIGTRAP, Trace/breakpoint trap.<br />	0x08048488 in smc ()<br />	(gdb) signal SIGTRAP<br />	Continuing with signal SIGTRAP.<br />	Copy protected: ok<br /><br />	Program exited with code 01.<br />	(gdb) <br /><br />which I think is a sign that this patch actually fixes ptrace.<br /><br />Does this help with wine? I dunno. Maybe some wine people can comment..<br /><br />Roland, mind take a look? I assume you have some gdb test-suite that you <br />use to test the things?<br /><br />		Linus<br /><br />----<br /><br />===== arch/i386/kernel/ptrace.c 1.27 vs edited =====<br />--- 1.27/arch/i386/kernel/ptrace.c	2004-11-07 18:10:34 -08:00<br />+++ edited/arch/i386/kernel/ptrace.c	2004-11-21 21:34:58 -08:00<br />&#64;&#64; -138,6 +138,28 &#64;&#64;<br /> 	return retval;<br /> }<br /> <br />+static void set_singlestep(struct task_struct *child)<br />+{<br />+	long eflags;<br />+<br />+	set_tsk_thread_flag(child, TIF_SINGLESTEP);<br />+	eflags = get_stack_long(child, EFL_OFFSET);<br />+	put_stack_long(child, EFL_OFFSET, eflags | TRAP_FLAG);<br />+	child-&gt;ptrace |= PT_DTRACE;<br />+}<br />+<br />+static void clear_singlestep(struct task_struct *child)<br />+{<br />+	if (child-&gt;ptrace &amp; PT_DTRACE) {<br />+		long eflags;<br />+<br />+		clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br />+		eflags = get_stack_long(child, EFL_OFFSET);<br />+		put_stack_long(child, EFL_OFFSET, eflags &amp; ~TRAP_FLAG);<br />+		child-&gt;ptrace &amp;= ~PT_DTRACE;<br />+	}<br />+}<br />+<br /> /*<br />  * Called by kernel/ptrace.c when detaching..<br />  *<br />&#64;&#64; -145,11 +167,7 &#64;&#64;<br />  */<br /> void ptrace_disable(struct task_struct *child)<br /> { <br />-	long tmp;<br />-<br />-	clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br />-	tmp = get_stack_long(child, EFL_OFFSET) &amp; ~TRAP_FLAG;<br />-	put_stack_long(child, EFL_OFFSET, tmp);<br />+	clear_singlestep(child);<br /> }<br /> <br /> /*<br />&#64;&#64; -388,10 +406,8 &#64;&#64;<br /> 		  }<br /> 		  break;<br /> <br />-	case PTRACE_SYSCALL: /* continue and stop at next (return from) syscall */<br />-	case PTRACE_CONT: { /* restart after signal. */<br />-		long tmp;<br />-<br />+	case PTRACE_SYSCALL:	/* continue and stop at next (return from) syscall */<br />+	case PTRACE_CONT:	/* restart after signal. */<br /> 		ret = -EIO;<br /> 		if ((unsigned long) data &gt; _NSIG)<br /> 			break;<br />&#64;&#64; -401,56 +417,39 &#64;&#64;<br /> 		else {<br /> 			clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);<br /> 		}<br />-		clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br /> 		child-&gt;exit_code = data;<br />-	/* make sure the single step bit is not set. */<br />-		tmp = get_stack_long(child, EFL_OFFSET) &amp; ~TRAP_FLAG;<br />-		put_stack_long(child, EFL_OFFSET,tmp);<br />+		/* make sure the single step bit is not set. */<br />+		clear_singlestep(child);<br /> 		wake_up_process(child);<br /> 		ret = 0;<br /> 		break;<br />-	}<br /> <br /> /*<br />  * make the child exit.  Best I can do is send it a sigkill. <br />  * perhaps it should be put in the status that it wants to <br />  * exit.<br />  */<br />-	case PTRACE_KILL: {<br />-		long tmp;<br />-<br />+	case PTRACE_KILL:<br /> 		ret = 0;<br /> 		if (child-&gt;exit_state == EXIT_ZOMBIE)	/* already dead */<br /> 			break;<br /> 		child-&gt;exit_code = SIGKILL;<br />-		clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br /> 		/* make sure the single step bit is not set. */<br />-		tmp = get_stack_long(child, EFL_OFFSET) &amp; ~TRAP_FLAG;<br />-		put_stack_long(child, EFL_OFFSET, tmp);<br />+		clear_singlestep(child);<br /> 		wake_up_process(child);<br /> 		break;<br />-	}<br />-<br />-	case PTRACE_SINGLESTEP: {  /* set the trap flag. */<br />-		long tmp;<br /> <br />+	case PTRACE_SINGLESTEP:	/* set the trap flag. */<br /> 		ret = -EIO;<br /> 		if ((unsigned long) data &gt; _NSIG)<br /> 			break;<br /> 		clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);<br />-		if ((child-&gt;ptrace &amp; PT_DTRACE) == 0) {<br />-			/* Spurious delayed TF traps may occur */<br />-			child-&gt;ptrace |= PT_DTRACE;<br />-		}<br />-		tmp = get_stack_long(child, EFL_OFFSET) | TRAP_FLAG;<br />-		put_stack_long(child, EFL_OFFSET, tmp);<br />-		set_tsk_thread_flag(child, TIF_SINGLESTEP);<br />+		set_singlestep(child);<br /> 		child-&gt;exit_code = data;<br /> 		/* give it a chance to run. */<br /> 		wake_up_process(child);<br /> 		ret = 0;<br /> 		break;<br />-	}<br /> <br /> 	case PTRACE_DETACH:<br /> 		/* detach a process that was attached. */<br />===== arch/i386/kernel/signal.c 1.48 vs edited =====<br />--- 1.48/arch/i386/kernel/signal.c	2004-11-15 00:56:24 -08:00<br />+++ edited/arch/i386/kernel/signal.c	2004-11-21 21:33:21 -08:00<br />&#64;&#64; -292,10 +292,15 &#64;&#64;<br /> 	err |= __put_user(current-&gt;thread.error_code, &amp;sc-&gt;err);<br /> 	err |= __put_user(regs-&gt;eip, &amp;sc-&gt;eip);<br /> 	err |= __put_user(regs-&gt;xcs, (unsigned int __user *)&amp;sc-&gt;cs);<br />+<br />+	/*<br />+	 * Iff TF was set because the program is being single-stepped by a<br />+	 * debugger, don't save that information on the signal stack.. We<br />+	 * don't want debugging to change state.<br />+	 */<br /> 	eflags = regs-&gt;eflags;<br />-	if (current-&gt;ptrace &amp; PT_PTRACED) {<br />+	if (current-&gt;ptrace &amp; PT_DTRACE)<br /> 		eflags &amp;= ~TF_MASK;<br />-	}<br /> 	err |= __put_user(eflags, &amp;sc-&gt;eflags);<br /> 	err |= __put_user(regs-&gt;esp, &amp;sc-&gt;esp_at_signal);<br /> 	err |= __put_user(regs-&gt;xss, (unsigned int __user *)&amp;sc-&gt;ss);<br />&#64;&#64; -412,12 +417,17 &#64;&#64;<br /> 	regs-&gt;xes = __USER_DS;<br /> 	regs-&gt;xss = __USER_DS;<br /> 	regs-&gt;xcs = __USER_CS;<br />+<br />+	/*<br />+	 * Clear TF when entering the signal handler, but<br />+	 * notify any tracer that was single-stepping it.<br />+	 * The tracer may want to single-step inside the<br />+	 * handler too.<br />+	 */<br /> 	if (regs-&gt;eflags &amp; TF_MASK) {<br />-		if ((current-&gt;ptrace &amp; (PT_PTRACED | PT_DTRACE)) == (PT_PTRACED | PT_DTRACE)) {<br />+		regs-&gt;eflags &amp;= ~TF_MASK;<br />+		if (current-&gt;ptrace &amp; PT_DTRACE)<br /> 			ptrace_notify(SIGTRAP);<br />-		} else {<br />-			regs-&gt;eflags &amp;= ~TF_MASK;<br />-		}<br /> 	}<br /> <br /> #if DEBUG_SIG<br />&#64;&#64; -502,12 +512,17 &#64;&#64;<br /> 	regs-&gt;xes = __USER_DS;<br /> 	regs-&gt;xss = __USER_DS;<br /> 	regs-&gt;xcs = __USER_CS;<br />+<br />+	/*<br />+	 * Clear TF when entering the signal handler, but<br />+	 * notify any tracer that was single-stepping it.<br />+	 * The tracer may want to single-step inside the<br />+	 * handler too.<br />+	 */<br /> 	if (regs-&gt;eflags &amp; TF_MASK) {<br />-		if (current-&gt;ptrace &amp; PT_PTRACED) {<br />+		regs-&gt;eflags &amp;= ~TF_MASK;<br />+		if (current-&gt;ptrace &amp; PT_DTRACE)<br /> 			ptrace_notify(SIGTRAP);<br />-		} else {<br />-			regs-&gt;eflags &amp;= ~TF_MASK;<br />-		}<br /> 	}<br /> <br /> #if DEBUG_SIG<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
