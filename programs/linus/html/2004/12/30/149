    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/11/15/196">First message in thread</a></li><li><a href="/lkml/2004/12/30/121">Jesse Allen</a><ul><li><a href="/lkml/2004/12/30/122">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2004/12/30/151">Linus Torvalds</a><ul><li><a href="/lkml/2004/12/30/151">Daniel Jacobowitz</a><ul><li><a href="/lkml/2004/12/30/155">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2004/12/30/154">Andi Kleen</a><ul><li><a href="/lkml/2004/12/30/170">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2004/12/30/200">Jesse Allen</a><ul><li><a href="/lkml/2004/12/31/3">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2004/12/30/149/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 30 Dec 2004 14:46:17 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: ptrace single-stepping change breaks Wine</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 30 Dec 2004, Linus Torvalds wrote:<br />&gt; <br />&gt; Working on a patch for this right now, I'll send something out soonish <br />&gt; (and I'll test it on my test-case before sending it, so that it at least <br />&gt; has some chance of working).<br /><br />Ok, here's a patch that may or may not make Wine happier. It's a _lot_ <br />more careful about TF handling, and in particular it's trying really <br />really hard to make sure that a controlling process does not change the <br />trap flag as it is modified or used by the process.<br /><br />This hopefully fixes:<br /><br /> - single-step over "popf" should work - we won't clear TF after the popf, <br />   but instead let the popf results remain. <br /><br />   NOTE! I tried to make sure that it does the right thing for segments <br />   with non-zero bases, but I never actually tested that code. It's fairly <br />   obvious, but it's also fairly likely to have some silly problems. Wine<br />   may well show effects of this, although I don't know how common <br />   non-zero bases are with any kind of half-modern windows binaries.<br /><br /> - ptrace reporting of "eflags" register after a single-step (we used to <br />   report TF as being set because the debugger set it - even though the<br />   "native state" without debugging had it cleared).<br /><br />   This also hopefully means that all the conditional TF clearing games<br />   etc aren't necessary, since arch/i386/kernel/traps.c should now be <br />   taking care of hiding the debugger for most cases ("pushf" still <br />   remains, and is hard. See comment in ptrace.c part of the patch)<br /><br />It's a bit more involved than I'd like, since especially the "popf" case <br />just is pretty complex, but I'd love to hear whether it works.<br /><br />NOTE NOTE NOTE! I've tested it, but only on one small test-case, so it <br />might be totally broken in many ways. I'd love to have people who are x86 <br />and ptrace-aware give this a second look, and I'm confident Jesse will <br />find that it won't work, but can hopefully try to debug it a bit with <br />this..<br /><br />		Linus<br /><br />-----<br />===== arch/i386/kernel/signal.c 1.49 vs edited =====<br />--- 1.49/arch/i386/kernel/signal.c	2004-11-22 09:47:16 -08:00<br />+++ edited/arch/i386/kernel/signal.c	2004-12-30 11:40:35 -08:00<br />&#64;&#64; -270,7 +270,6 &#64;&#64;<br /> 		 struct pt_regs *regs, unsigned long mask)<br /> {<br /> 	int tmp, err = 0;<br />-	unsigned long eflags;<br /> <br /> 	tmp = 0;<br /> 	__asm__("movl %%gs,%0" : "=r"(tmp): "0"(tmp));<br />&#64;&#64; -292,16 +291,7 &#64;&#64;<br /> 	err |= __put_user(current-&gt;thread.error_code, &amp;sc-&gt;err);<br /> 	err |= __put_user(regs-&gt;eip, &amp;sc-&gt;eip);<br /> 	err |= __put_user(regs-&gt;xcs, (unsigned int __user *)&amp;sc-&gt;cs);<br />-<br />-	/*<br />-	 * Iff TF was set because the program is being single-stepped by a<br />-	 * debugger, don't save that information on the signal stack.. We<br />-	 * don't want debugging to change state.<br />-	 */<br />-	eflags = regs-&gt;eflags;<br />-	if (current-&gt;ptrace &amp; PT_DTRACE)<br />-		eflags &amp;= ~TF_MASK;<br />-	err |= __put_user(eflags, &amp;sc-&gt;eflags);<br />+	err |= __put_user(regs-&gt;eflags, &amp;sc-&gt;eflags);<br /> 	err |= __put_user(regs-&gt;esp, &amp;sc-&gt;esp_at_signal);<br /> 	err |= __put_user(regs-&gt;xss, (unsigned int __user *)&amp;sc-&gt;ss);<br /> <br />&#64;&#64; -424,11 +414,9 &#64;&#64;<br /> 	 * The tracer may want to single-step inside the<br /> 	 * handler too.<br /> 	 */<br />-	if (regs-&gt;eflags &amp; TF_MASK) {<br />-		regs-&gt;eflags &amp;= ~TF_MASK;<br />-		if (current-&gt;ptrace &amp; PT_DTRACE)<br />-			ptrace_notify(SIGTRAP);<br />-	}<br />+	regs-&gt;eflags &amp;= ~TF_MASK;<br />+	if (test_thread_flag(TIF_SINGLESTEP))<br />+		ptrace_notify(SIGTRAP);<br /> <br /> #if DEBUG_SIG<br /> 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",<br />&#64;&#64; -519,11 +507,9 &#64;&#64;<br /> 	 * The tracer may want to single-step inside the<br /> 	 * handler too.<br /> 	 */<br />-	if (regs-&gt;eflags &amp; TF_MASK) {<br />-		regs-&gt;eflags &amp;= ~TF_MASK;<br />-		if (current-&gt;ptrace &amp; PT_DTRACE)<br />-			ptrace_notify(SIGTRAP);<br />-	}<br />+	regs-&gt;eflags &amp;= ~TF_MASK;<br />+	if (test_thread_flag(TIF_SINGLESTEP))<br />+		ptrace_notify(SIGTRAP);<br /> <br /> #if DEBUG_SIG<br /> 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",<br />===== arch/i386/kernel/traps.c 1.92 vs edited =====<br />--- 1.92/arch/i386/kernel/traps.c	2004-12-28 11:07:48 -08:00<br />+++ edited/arch/i386/kernel/traps.c	2004-12-30 12:36:30 -08:00<br />&#64;&#64; -718,8 +718,17 &#64;&#64;<br /> 		 */<br /> 		if ((regs-&gt;xcs &amp; 3) == 0)<br /> 			goto clear_TF_reenable;<br />-		if ((tsk-&gt;ptrace &amp; (PT_DTRACE|PT_PTRACED)) == PT_DTRACE)<br />-			goto clear_TF;<br />+<br />+		/*<br />+		 * Was the TF flag set by a debugger? If so, clear it now,<br />+		 * so that register information is correct.<br />+		 */<br />+		if (tsk-&gt;ptrace &amp; PT_DTRACE) {<br />+			regs-&gt;eflags &amp;= ~TF_MASK;<br />+			tsk-&gt;ptrace &amp;= ~PT_DTRACE;<br />+			if (!tsk-&gt;ptrace &amp; PT_DTRACE)<br />+				goto clear_TF;<br />+		}<br /> 	}<br /> <br /> 	/* Ok, finally something we can handle */<br />===== arch/i386/kernel/ptrace.c 1.28 vs edited =====<br />--- 1.28/arch/i386/kernel/ptrace.c	2004-11-22 09:44:52 -08:00<br />+++ edited/arch/i386/kernel/ptrace.c	2004-12-30 14:35:45 -08:00<br />&#64;&#64; -42,6 +42,12 &#64;&#64;<br />  */<br /> #define EFL_OFFSET ((EFL-2)*4-sizeof(struct pt_regs))<br /> <br />+static inline struct pt_regs *get_child_regs(struct task_struct *task)<br />+{<br />+	void *stack_top = (void *)task-&gt;thread.esp0;<br />+	return stack_top - sizeof(struct pt_regs);<br />+}<br />+<br /> /*<br />  * this routine will get a word off of the processes privileged stack. <br />  * the offset is how far from the base addr as stored in the TSS.  <br />&#64;&#64; -138,24 +144,119 &#64;&#64;<br /> 	return retval;<br /> }<br /> <br />+#define LDT_SEGMENT 4<br />+<br />+static unsigned long convert_eip_to_linear(struct task_struct *child, struct pt_regs *regs)<br />+{<br />+	unsigned long addr, seg;<br />+<br />+	addr = regs-&gt;eip;<br />+	seg = regs-&gt;xcs &amp; 0xffff;<br />+	if (regs-&gt;eflags &amp; VM_MASK) {<br />+		addr = (addr &amp; 0xffff) + (seg &lt;&lt; 4);<br />+		return addr;<br />+	}<br />+<br />+	/*<br />+	 * We'll assume that the code segments in the GDT<br />+	 * are all zero-based. That is largely true: the<br />+	 * TLS segments are used for data, and the PNPBIOS<br />+	 * and APM bios ones we just ignore here.<br />+	 */<br />+	if (seg &amp; LDT_SEGMENT) {<br />+		u32 *desc;<br />+		unsigned long base;<br />+<br />+		down(&amp;child-&gt;mm-&gt;context.sem);<br />+		desc = child-&gt;mm-&gt;context.ldt + (seg &amp; ~7);<br />+		base = (desc[0] &gt;&gt; 16) | ((desc[1] &amp; 0xff) &lt;&lt; 16) | (desc[1] &amp; 0xff000000);<br />+<br />+		/* 16-bit code segment? */<br />+		if (!((desc[1] &gt;&gt; 22) &amp; 1))<br />+			addr &amp;= 0xffff;<br />+		addr += base;<br />+		up(&amp;child-&gt;mm-&gt;context.sem);<br />+	}<br />+	return addr;<br />+}<br />+<br />+static inline int is_at_popf(struct task_struct *child, struct pt_regs *regs)<br />+{<br />+	int i, copied;<br />+	unsigned char opcode[16];<br />+	unsigned long addr = convert_eip_to_linear(child, regs);<br />+<br />+	copied = access_process_vm(child, addr, opcode, sizeof(opcode), 0);<br />+	for (i = 0; i &lt; copied; i++) {<br />+		switch (opcode[i]) {<br />+		/* popf */<br />+		case 0x9d:<br />+			return 1;<br />+		/* opcode and address size prefixes */<br />+		case 0x66: case 0x67:<br />+			continue;<br />+		/* irrelevant prefixes (segment overrides and repeats) */<br />+		case 0x26: case 0x2e:<br />+		case 0x36: case 0x3e:<br />+		case 0x64: case 0x65:<br />+		case 0xf0: case 0xf2: case 0xf3:<br />+			continue;<br />+<br />+		/*<br />+		 * pushf: NOTE! We should probably not let<br />+		 * the user see the TF bit being set. But<br />+		 * it's more pain than it's worth to avoid<br />+		 * it, and a debugger could emulate this<br />+		 * all in user space if it _really_ cares.<br />+		 */<br />+		case 0x9c:<br />+		default:<br />+			return 0;<br />+		}<br />+	}<br />+	return 0;<br />+}<br />+<br /> static void set_singlestep(struct task_struct *child)<br /> {<br />-	long eflags;<br />+	struct pt_regs *regs = get_child_regs(child);<br /> <br />+	/*<br />+	 * Always set TIF_SINGLESTEP - this guarantees that <br />+	 * we single-step system calls etc..  This will also<br />+	 * cause us to set TF when returning to user mode.<br />+	 */<br /> 	set_tsk_thread_flag(child, TIF_SINGLESTEP);<br />-	eflags = get_stack_long(child, EFL_OFFSET);<br />-	put_stack_long(child, EFL_OFFSET, eflags | TRAP_FLAG);<br />+<br />+	/*<br />+	 * If TF was already set, don't do anything else<br />+	 */<br />+	if (regs-&gt;eflags &amp; TRAP_FLAG)<br />+		return;<br />+<br />+	/* Set TF on the kernel stack.. */<br />+	regs-&gt;eflags |= TRAP_FLAG;<br />+<br />+	/*<br />+	 * ..but if TF is changed by the instruction we will trace,<br />+	 * don't mark it as being "us" that set it, so that we<br />+	 * won't clear it by hand later.<br />+	 */<br />+	if (is_at_popf(child, regs))<br />+		return;<br />+<br /> 	child-&gt;ptrace |= PT_DTRACE;<br /> }<br /> <br /> static void clear_singlestep(struct task_struct *child)<br /> {<br />-	if (child-&gt;ptrace &amp; PT_DTRACE) {<br />-		long eflags;<br />+	/* Always clear TIF_SINGLESTEP... */<br />+	clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br /> <br />-		clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br />-		eflags = get_stack_long(child, EFL_OFFSET);<br />-		put_stack_long(child, EFL_OFFSET, eflags &amp; ~TRAP_FLAG);<br />+	/* But touch TF only if it was set by us.. */<br />+	if (child-&gt;ptrace &amp; PT_DTRACE) {<br />+		struct pt_regs *regs = get_child_regs(child);<br />+		regs-&gt;eflags &amp;= ~TRAP_FLAG;<br /> 		child-&gt;ptrace &amp;= ~PT_DTRACE;<br /> 	}<br /> }<br />&#64;&#64; -559,6 +660,8 &#64;&#64;<br /> __attribute__((regparm(3)))<br /> void do_syscall_trace(struct pt_regs *regs, int entryexit)<br /> {<br />+	struct siginfo info;<br />+<br /> 	if (unlikely(current-&gt;audit_context)) {<br /> 		if (!entryexit)<br /> 			audit_syscall_entry(current, regs-&gt;orig_eax,<br />&#64;&#64; -573,18 +676,18 &#64;&#64;<br /> 		return;<br /> 	if (!(current-&gt;ptrace &amp; PT_PTRACED))<br /> 		return;<br />+<br />+	memset(&amp;info, 0, sizeof(info));<br />+	info.si_signo = SIGTRAP;<br />+<br /> 	/* the 0x80 provides a way for the tracing parent to distinguish<br /> 	   between a syscall stop and SIGTRAP delivery */<br />-	ptrace_notify(SIGTRAP | ((current-&gt;ptrace &amp; PT_TRACESYSGOOD) &amp;&amp;<br />-				 !test_thread_flag(TIF_SINGLESTEP) ? 0x80 : 0));<br />+	info.si_code = SIGTRAP;<br />+	if ((current-&gt;ptrace &amp; PT_TRACESYSGOOD) &amp;&amp; !test_thread_flag(TIF_SINGLESTEP))<br />+		info.si_code = SIGTRAP | 0x80;<br />+	info.si_pid = current-&gt;tgid;<br />+	info.si_uid = current-&gt;uid;<br /> <br />-	/*<br />-	 * this isn't the same as continuing with a signal, but it will do<br />-	 * for normal use.  strace only continues with a signal if the<br />-	 * stopping signal is not SIGTRAP.  -brl<br />-	 */<br />-	if (current-&gt;exit_code) {<br />-		send_sig(current-&gt;exit_code, current, 1);<br />-		current-&gt;exit_code = 0;<br />-	}<br />+	/* Send us the fakey SIGTRAP */<br />+	send_sig_info(SIGTRAP, &amp;info, current);<br /> }<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
