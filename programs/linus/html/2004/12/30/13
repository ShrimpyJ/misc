    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/11/15/196">First message in thread</a></li><li><a href="/lkml/2004/12/29/194">Linus Torvalds</a><ul><li><a href="/lkml/2004/12/30/4">Davide Libenzi</a><ul><li class="origin"><a href="/lkml/2004/12/30/111">Linus Torvalds</a><ul><li><a href="/lkml/2004/12/30/111">Davide Libenzi</a><ul><li><a href="/lkml/2004/12/30/115">Linus Torvalds</a></li><li><a href="/lkml/2004/12/30/121">Jesse Allen</a></li></ul></li><li><a href="/lkml/2004/12/30/120">Davide Libenzi</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2004/12/30/13/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 29 Dec 2004 23:26:11 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: ptrace single-stepping change breaks Wine</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 29 Dec 2004, Davide Libenzi wrote:<br />&gt; <br />&gt; I think same. My test simply let the function processing to let thru and <br />&gt; reach the fake signal sending point.<br /><br />No, your test-case doesn't even send a signal at all, because your<br />test-program just uses a PTRACE_SINGLESTEP without any "send signal" - so<br />"exit_code" will be zero after the debuggee gets released from the<br />"ptrace_notify()", and the suspect code will never be executed..<br /><br />The problem I think I see (and which the comment alludes to) is that if<br />the controlling process continues the debuggee with a signal, we'll be<br />doing the wrong thing: the code in do_syscall_trace() will take that<br />signal (in "current-&gt;exit_code") and send it as a real signal to the<br />debuggee, but since it is debugged, it will be caught (again) by the<br />controlling process, which apparently in the case of Wine gets very<br />confused.<br /><br />So I _think_ the problem happens for the following schenario:<br /> - wine for some reason does a PTRACE_SINGLESTEP over a system call<br /> - after the single-step, wine ends up trying to get the sub-process to <br />   enter a signal handler with ptrace( PTRACE_CONT, ... sig)<br /> - the normal ptrace path (where we trap a signal - see kernel/signal.c <br />   and the "ptrace_stop()" logic) handles this correctly, but <br />   do_syscall_trace() will do a "send_sig()"<br /> - we'll try to handle the signal when returning to the traced process<br /> - now "get_signal_to_deliver()" will invoce the ptrace logic AGAIN, and <br />   call ptrace_stop() for this fake signal, and we'll report a new event <br />   to the controlling process.<br /><br />Does this make sense?<br /><br />If so, we have a few options:<br /><br /> - very hacky one: teach all ptrace users that sometimes the signal you<br />   continue with can be reflected back at you, and you should just "cont<br />   signr"  _again_.<br /><br />   This is a really bad option, partly because it's hard to tell when it's <br />   just a spurious reflected signal, partly because there are many ptrace <br />   users, and to a large part just because it's clearly too hacky. But it<br />   might be a valid approach for a Wine person who is used to Wine, and<br />   wants to verify whether this is indeed the schenario that triggers the<br />   problem..<br /><br /> - Stupid approach: mark the siginfo that we send as the fake one as being <br />   reflected, and have get_signal_to_deliver() not apply the ptrace <br />   stopping to that.<br /><br /> - Possibly cleaner approach: make system call tracing just use a proper<br />   SIGTRAP in the first place, and always handle all the ptrace_stop() etc<br />   cruft in kernel/signal.c like it handles all other calls.<br /><br />I dunno. The final one looks fairly simple and clean, something like the<br />following, but I'm most likely overlooking some reason why this won't<br />work..<br /><br />(And as usual, this patch has not been tested in any shape, way or form. <br />In fact, it hasn't even seen an x86 machine, since I edited it out as a <br />fake on my ppc64.. Somebody with more brains than me should actually try <br />to get it to work)<br /><br />		Linus<br /><br />----<br />===== arch/i386/kernel/ptrace.c 1.28 vs edited =====<br />--- 1.28/arch/i386/kernel/ptrace.c	2004-11-22 09:44:52 -08:00<br />+++ edited/arch/i386/kernel/ptrace.c	2004-12-29 23:21:58 -08:00<br />&#64;&#64; -559,6 +559,8 &#64;&#64;<br /> __attribute__((regparm(3)))<br /> void do_syscall_trace(struct pt_regs *regs, int entryexit)<br /> {<br />+	struct siginfo info;<br />+<br /> 	if (unlikely(current-&gt;audit_context)) {<br /> 		if (!entryexit)<br /> 			audit_syscall_entry(current, regs-&gt;orig_eax,<br />&#64;&#64; -573,18 +575,18 &#64;&#64;<br /> 		return;<br /> 	if (!(current-&gt;ptrace &amp; PT_PTRACED))<br /> 		return;<br />+<br />+	memset(&amp;info, 0, sizeof(info));<br />+	info.si_signo = SIGTRAP;<br />+<br /> 	/* the 0x80 provides a way for the tracing parent to distinguish<br /> 	   between a syscall stop and SIGTRAP delivery */<br />-	ptrace_notify(SIGTRAP | ((current-&gt;ptrace &amp; PT_TRACESYSGOOD) &amp;&amp;<br />-				 !test_thread_flag(TIF_SINGLESTEP) ? 0x80 : 0));<br />+	info.si_code = SIGTRAP;<br />+	if ((current-&gt;ptrace &amp; PT_TRACESYSGOOD) &amp;&amp; !test_thread_flag(TIF_SINGLESTEP))<br />+		info.si_code = SIGTRAP | 0x80;<br />+	info.si_pid = current-&gt;tgid;<br />+	info.si_uid = current-&gt;uid;<br /> <br />-	/*<br />-	 * this isn't the same as continuing with a signal, but it will do<br />-	 * for normal use.  strace only continues with a signal if the<br />-	 * stopping signal is not SIGTRAP.  -brl<br />-	 */<br />-	if (current-&gt;exit_code) {<br />-		send_sig(current-&gt;exit_code, current, 1);<br />-		current-&gt;exit_code = 0;<br />-	}<br />+	/* Send us the fakey SIGTRAP */<br />+	send_sig_info(SIGTRAP, &amp;info, current);<br /> }<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
