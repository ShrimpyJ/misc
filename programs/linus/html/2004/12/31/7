    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/11/15/196">First message in thread</a></li><li><a href="/lkml/2004/12/30/155">Linus Torvalds</a><ul><li><a href="/lkml/2004/12/31/5">Daniel Jacobowitz</a><ul><li class="origin"><a href="/lkml/2004/12/31/12">Linus Torvalds</a><ul><li><a href="/lkml/2004/12/31/12">Jesse Allen</a></li><li><a href="/lkml/2004/12/31/70">Daniel Jacobowitz</a><ul><li><a href="/lkml/2004/12/31/82">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2005/1/29/27">Kari Hurtta</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2004/12/31/7/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 30 Dec 2004 21:47:42 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: ptrace single-stepping change breaks Wine</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 31 Dec 2004, Daniel Jacobowitz wrote:<br />&gt; <br />&gt; Well, you put SIGTRAP|0x80 in si_code.  Coincidentally, 0x80 is<br />&gt; SI_KERNEL.  So testing for SI_KERNEL | 0x80 is probably OK in the<br />&gt; signal path, since most of its other arbitrary values would be either<br />&gt; negative or not include SI_KERNEL.<br /><br />Somebody would need to validate that no user can fool the kernel into <br />doing something stupid...<br /><br />That said, I think I solved the problem a different way: the <br />TIF_SINGLESTEP code really fundamentally doesn't want to have _any_ of <br />that SIGTRAP | 0x80 nonsense in its path, it actually wants to look like a <br />debug trap - which sets si_code to TRAP_BRKPT. Which makes more sense <br />anyway.<br /><br />So I looked at just sharing the code with the debug trap handler, and the<br />result is appended. strace works, as does all the TF tests I've thrown at<br />it, and the code actually looks better anyway (the old do_debug code looks<br />like it got the EIP wrong in VM86 mode, for example, this just cleans <br />that up too). Just use a common "send_sigtrap()" routine.<br /><br />Does this look saner?<br /><br />		Linus<br /><br />----<br />===== include/asm-i386/ptrace.h 1.7 vs edited =====<br />--- 1.7/include/asm-i386/ptrace.h	2004-09-03 16:55:27 -07:00<br />+++ edited/include/asm-i386/ptrace.h	2004-12-30 21:27:39 -08:00<br />&#64;&#64; -55,6 +55,7 &#64;&#64;<br /> #define PTRACE_SET_THREAD_AREA    26<br /> <br /> #ifdef __KERNEL__<br />+extern void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs, int error_code);<br /> #define user_mode(regs) ((VM_MASK &amp; (regs)-&gt;eflags) || (3 &amp; (regs)-&gt;xcs))<br /> #define instruction_pointer(regs) ((regs)-&gt;eip)<br /> #if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_FRAME_POINTER)<br />===== arch/i386/kernel/signal.c 1.49 vs edited =====<br />--- 1.49/arch/i386/kernel/signal.c	2004-11-22 09:47:16 -08:00<br />+++ edited/arch/i386/kernel/signal.c	2004-12-30 11:40:35 -08:00<br />&#64;&#64; -270,7 +270,6 &#64;&#64;<br /> 		 struct pt_regs *regs, unsigned long mask)<br /> {<br /> 	int tmp, err = 0;<br />-	unsigned long eflags;<br /> <br /> 	tmp = 0;<br /> 	__asm__("movl %%gs,%0" : "=r"(tmp): "0"(tmp));<br />&#64;&#64; -292,16 +291,7 &#64;&#64;<br /> 	err |= __put_user(current-&gt;thread.error_code, &amp;sc-&gt;err);<br /> 	err |= __put_user(regs-&gt;eip, &amp;sc-&gt;eip);<br /> 	err |= __put_user(regs-&gt;xcs, (unsigned int __user *)&amp;sc-&gt;cs);<br />-<br />-	/*<br />-	 * Iff TF was set because the program is being single-stepped by a<br />-	 * debugger, don't save that information on the signal stack.. We<br />-	 * don't want debugging to change state.<br />-	 */<br />-	eflags = regs-&gt;eflags;<br />-	if (current-&gt;ptrace &amp; PT_DTRACE)<br />-		eflags &amp;= ~TF_MASK;<br />-	err |= __put_user(eflags, &amp;sc-&gt;eflags);<br />+	err |= __put_user(regs-&gt;eflags, &amp;sc-&gt;eflags);<br /> 	err |= __put_user(regs-&gt;esp, &amp;sc-&gt;esp_at_signal);<br /> 	err |= __put_user(regs-&gt;xss, (unsigned int __user *)&amp;sc-&gt;ss);<br /> <br />&#64;&#64; -424,11 +414,9 &#64;&#64;<br /> 	 * The tracer may want to single-step inside the<br /> 	 * handler too.<br /> 	 */<br />-	if (regs-&gt;eflags &amp; TF_MASK) {<br />-		regs-&gt;eflags &amp;= ~TF_MASK;<br />-		if (current-&gt;ptrace &amp; PT_DTRACE)<br />-			ptrace_notify(SIGTRAP);<br />-	}<br />+	regs-&gt;eflags &amp;= ~TF_MASK;<br />+	if (test_thread_flag(TIF_SINGLESTEP))<br />+		ptrace_notify(SIGTRAP);<br /> <br /> #if DEBUG_SIG<br /> 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",<br />&#64;&#64; -519,11 +507,9 &#64;&#64;<br /> 	 * The tracer may want to single-step inside the<br /> 	 * handler too.<br /> 	 */<br />-	if (regs-&gt;eflags &amp; TF_MASK) {<br />-		regs-&gt;eflags &amp;= ~TF_MASK;<br />-		if (current-&gt;ptrace &amp; PT_DTRACE)<br />-			ptrace_notify(SIGTRAP);<br />-	}<br />+	regs-&gt;eflags &amp;= ~TF_MASK;<br />+	if (test_thread_flag(TIF_SINGLESTEP))<br />+		ptrace_notify(SIGTRAP);<br /> <br /> #if DEBUG_SIG<br /> 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",<br />===== arch/i386/kernel/traps.c 1.92 vs edited =====<br />--- 1.92/arch/i386/kernel/traps.c	2004-12-28 11:07:48 -08:00<br />+++ edited/arch/i386/kernel/traps.c	2004-12-30 21:26:14 -08:00<br />&#64;&#64; -718,23 +718,21 &#64;&#64;<br /> 		 */<br /> 		if ((regs-&gt;xcs &amp; 3) == 0)<br /> 			goto clear_TF_reenable;<br />-		if ((tsk-&gt;ptrace &amp; (PT_DTRACE|PT_PTRACED)) == PT_DTRACE)<br />-			goto clear_TF;<br />+<br />+		/*<br />+		 * Was the TF flag set by a debugger? If so, clear it now,<br />+		 * so that register information is correct.<br />+		 */<br />+		if (tsk-&gt;ptrace &amp; PT_DTRACE) {<br />+			regs-&gt;eflags &amp;= ~TF_MASK;<br />+			tsk-&gt;ptrace &amp;= ~PT_DTRACE;<br />+			if (!tsk-&gt;ptrace &amp; PT_DTRACE)<br />+				goto clear_TF;<br />+		}<br /> 	}<br /> <br /> 	/* Ok, finally something we can handle */<br />-	tsk-&gt;thread.trap_no = 1;<br />-	tsk-&gt;thread.error_code = error_code;<br />-	info.si_signo = SIGTRAP;<br />-	info.si_errno = 0;<br />-	info.si_code = TRAP_BRKPT;<br />-	<br />-	/* If this is a kernel mode trap, save the user PC on entry to <br />-	 * the kernel, that's what the debugger can make sense of.<br />-	 */<br />-	info.si_addr = ((regs-&gt;xcs &amp; 3) == 0) ? (void __user *)tsk-&gt;thread.eip<br />-	                                      : (void __user *)regs-&gt;eip;<br />-	force_sig_info(SIGTRAP, &amp;info, tsk);<br />+	send_sigtrap(tsk, regs, error_code);<br /> <br /> 	/* Disable additional traps. They'll be re-enabled when<br /> 	 * the signal is delivered.<br />===== arch/i386/kernel/ptrace.c 1.28 vs edited =====<br />--- 1.28/arch/i386/kernel/ptrace.c	2004-11-22 09:44:52 -08:00<br />+++ edited/arch/i386/kernel/ptrace.c	2004-12-30 21:26:16 -08:00<br />&#64;&#64; -42,6 +42,12 &#64;&#64;<br />  */<br /> #define EFL_OFFSET ((EFL-2)*4-sizeof(struct pt_regs))<br /> <br />+static inline struct pt_regs *get_child_regs(struct task_struct *task)<br />+{<br />+	void *stack_top = (void *)task-&gt;thread.esp0;<br />+	return stack_top - sizeof(struct pt_regs);<br />+}<br />+<br /> /*<br />  * this routine will get a word off of the processes privileged stack. <br />  * the offset is how far from the base addr as stored in the TSS.  <br />&#64;&#64; -138,24 +144,119 &#64;&#64;<br /> 	return retval;<br /> }<br /> <br />+#define LDT_SEGMENT 4<br />+<br />+static unsigned long convert_eip_to_linear(struct task_struct *child, struct pt_regs *regs)<br />+{<br />+	unsigned long addr, seg;<br />+<br />+	addr = regs-&gt;eip;<br />+	seg = regs-&gt;xcs &amp; 0xffff;<br />+	if (regs-&gt;eflags &amp; VM_MASK) {<br />+		addr = (addr &amp; 0xffff) + (seg &lt;&lt; 4);<br />+		return addr;<br />+	}<br />+<br />+	/*<br />+	 * We'll assume that the code segments in the GDT<br />+	 * are all zero-based. That is largely true: the<br />+	 * TLS segments are used for data, and the PNPBIOS<br />+	 * and APM bios ones we just ignore here.<br />+	 */<br />+	if (seg &amp; LDT_SEGMENT) {<br />+		u32 *desc;<br />+		unsigned long base;<br />+<br />+		down(&amp;child-&gt;mm-&gt;context.sem);<br />+		desc = child-&gt;mm-&gt;context.ldt + (seg &amp; ~7);<br />+		base = (desc[0] &gt;&gt; 16) | ((desc[1] &amp; 0xff) &lt;&lt; 16) | (desc[1] &amp; 0xff000000);<br />+<br />+		/* 16-bit code segment? */<br />+		if (!((desc[1] &gt;&gt; 22) &amp; 1))<br />+			addr &amp;= 0xffff;<br />+		addr += base;<br />+		up(&amp;child-&gt;mm-&gt;context.sem);<br />+	}<br />+	return addr;<br />+}<br />+<br />+static inline int is_at_popf(struct task_struct *child, struct pt_regs *regs)<br />+{<br />+	int i, copied;<br />+	unsigned char opcode[16];<br />+	unsigned long addr = convert_eip_to_linear(child, regs);<br />+<br />+	copied = access_process_vm(child, addr, opcode, sizeof(opcode), 0);<br />+	for (i = 0; i &lt; copied; i++) {<br />+		switch (opcode[i]) {<br />+		/* popf */<br />+		case 0x9d:<br />+			return 1;<br />+		/* opcode and address size prefixes */<br />+		case 0x66: case 0x67:<br />+			continue;<br />+		/* irrelevant prefixes (segment overrides and repeats) */<br />+		case 0x26: case 0x2e:<br />+		case 0x36: case 0x3e:<br />+		case 0x64: case 0x65:<br />+		case 0xf0: case 0xf2: case 0xf3:<br />+			continue;<br />+<br />+		/*<br />+		 * pushf: NOTE! We should probably not let<br />+		 * the user see the TF bit being set. But<br />+		 * it's more pain than it's worth to avoid<br />+		 * it, and a debugger could emulate this<br />+		 * all in user space if it _really_ cares.<br />+		 */<br />+		case 0x9c:<br />+		default:<br />+			return 0;<br />+		}<br />+	}<br />+	return 0;<br />+}<br />+<br /> static void set_singlestep(struct task_struct *child)<br /> {<br />-	long eflags;<br />+	struct pt_regs *regs = get_child_regs(child);<br /> <br />+	/*<br />+	 * Always set TIF_SINGLESTEP - this guarantees that <br />+	 * we single-step system calls etc..  This will also<br />+	 * cause us to set TF when returning to user mode.<br />+	 */<br /> 	set_tsk_thread_flag(child, TIF_SINGLESTEP);<br />-	eflags = get_stack_long(child, EFL_OFFSET);<br />-	put_stack_long(child, EFL_OFFSET, eflags | TRAP_FLAG);<br />+<br />+	/*<br />+	 * If TF was already set, don't do anything else<br />+	 */<br />+	if (regs-&gt;eflags &amp; TRAP_FLAG)<br />+		return;<br />+<br />+	/* Set TF on the kernel stack.. */<br />+	regs-&gt;eflags |= TRAP_FLAG;<br />+<br />+	/*<br />+	 * ..but if TF is changed by the instruction we will trace,<br />+	 * don't mark it as being "us" that set it, so that we<br />+	 * won't clear it by hand later.<br />+	 */<br />+	if (is_at_popf(child, regs))<br />+		return;<br />+<br /> 	child-&gt;ptrace |= PT_DTRACE;<br /> }<br /> <br /> static void clear_singlestep(struct task_struct *child)<br /> {<br />-	if (child-&gt;ptrace &amp; PT_DTRACE) {<br />-		long eflags;<br />+	/* Always clear TIF_SINGLESTEP... */<br />+	clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br /> <br />-		clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br />-		eflags = get_stack_long(child, EFL_OFFSET);<br />-		put_stack_long(child, EFL_OFFSET, eflags &amp; ~TRAP_FLAG);<br />+	/* But touch TF only if it was set by us.. */<br />+	if (child-&gt;ptrace &amp; PT_DTRACE) {<br />+		struct pt_regs *regs = get_child_regs(child);<br />+		regs-&gt;eflags &amp;= ~TRAP_FLAG;<br /> 		child-&gt;ptrace &amp;= ~PT_DTRACE;<br /> 	}<br /> }<br />&#64;&#64; -553,6 +654,29 &#64;&#64;<br /> 	return ret;<br /> }<br /> <br />+void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs, int error_code)<br />+{<br />+	struct siginfo info;<br />+<br />+	tsk-&gt;thread.trap_no = 1;<br />+	tsk-&gt;thread.error_code = error_code;<br />+<br />+	memset(&amp;info, 0, sizeof(info));<br />+	info.si_signo = SIGTRAP;<br />+	info.si_code = TRAP_BRKPT;<br />+<br />+	/*<br />+	 * If this is a kernel mode trap, save the user PC on entry to<br />+	 * the kernel, that's what the debugger can make sense of.<br />+	 */<br />+	info.si_addr = user_mode(regs) ?<br />+			(void __user *) regs-&gt;eip :<br />+			(void __user *)tsk-&gt;thread.eip;<br />+<br />+	/* Send us the fakey SIGTRAP */<br />+	force_sig_info(SIGTRAP, &amp;info, tsk);<br />+}<br />+<br /> /* notification of system call entry/exit<br />  * - triggered by current-&gt;work.syscall_trace<br />  */<br />&#64;&#64; -568,15 +692,16 &#64;&#64;<br /> 			audit_syscall_exit(current, regs-&gt;eax);<br /> 	}<br /> <br />-	if (!test_thread_flag(TIF_SYSCALL_TRACE) &amp;&amp;<br />-	    !test_thread_flag(TIF_SINGLESTEP))<br />-		return;<br /> 	if (!(current-&gt;ptrace &amp; PT_PTRACED))<br /> 		return;<br />-	/* the 0x80 provides a way for the tracing parent to distinguish<br />-	   between a syscall stop and SIGTRAP delivery */<br />-	ptrace_notify(SIGTRAP | ((current-&gt;ptrace &amp; PT_TRACESYSGOOD) &amp;&amp;<br />-				 !test_thread_flag(TIF_SINGLESTEP) ? 0x80 : 0));<br />+<br />+	/* Fake a debug trap */<br />+	if (test_thread_flag(TIF_SINGLESTEP))<br />+		send_sigtrap(current, regs, 0);<br />+<br />+	if (!test_thread_flag(TIF_SYSCALL_TRACE))<br />+		return;<br />+	ptrace_notify(SIGTRAP | ((current-&gt;ptrace &amp; PT_TRACESYSGOOD) ? 0x80 : 0));<br /> <br /> 	/*<br /> 	 * this isn't the same as continuing with a signal, but it will do<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
