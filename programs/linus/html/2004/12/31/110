    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/11/15/196">First message in thread</a></li><li><a href="/lkml/2004/12/31/74">Jesse Allen</a><ul><li><a href="/lkml/2004/12/31/77">Davide Libenzi</a><ul><li><a href="/lkml/2004/12/31/78">Jesse Allen</a></li><li class="origin"><a href="/lkml/2005/1/1/42">Linus Torvalds</a><ul><li><a href="/lkml/2005/1/1/42">Davide Libenzi</a><ul><li><a href="/lkml/2005/1/1/43">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2005/1/7/1">John Kacur</a><ul><li><a href="/lkml/2005/1/7/10">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patches in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2004/12/31/110/1">Get diff 1</a></li><li><a href="/lkml/diff/2004/12/31/110/2">Get diff 2</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 31 Dec 2004 14:01:08 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: ptrace single-stepping change breaks Wine</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 31 Dec 2004, Davide Libenzi wrote:<br />&gt; <br />&gt; I don't think Linus ever posted a POPF-only patch. Try to comment those <br />&gt; lines in his POPF patch ...<br /><br />Here the two patches are independently, if people want to take a look.<br /><br />If somebody wants to split (and test) the TF-careful thing further (the<br />"send_sigtrap()" changes are independent, I think), that would be<br />wonderful... Hint hint.<br /><br />		Linus# This is a BitKeeper generated diff -Nru style patch.<br />#<br /># ChangeSet<br />#   2004/12/31 13:29:27-08:00 torvalds&#64;evo.osdl.org <br />#   Use common helper routine to send debug event SIGTRAPs<br />#   <br />#   Also be more careful with setting and clearing TF: don't<br />#   set it unless we really need to, and don't clear it unless<br />#   it was set by the kernel.<br /># <br /># include/asm-i386/ptrace.h<br />#   2004/12/31 13:29:16-08:00 torvalds&#64;evo.osdl.org +1 -0<br />#   Use common helper routine to send debug event SIGTRAPs<br />#   <br />#   Also be more careful with setting and clearing TF: don't<br />#   set it unless we really need to, and don't clear it unless<br />#   it was set by the kernel.<br /># <br /># arch/i386/kernel/traps.c<br />#   2004/12/31 13:29:16-08:00 torvalds&#64;evo.osdl.org +12 -14<br />#   Use common helper routine to send debug event SIGTRAPs<br />#   <br />#   Also be more careful with setting and clearing TF: don't<br />#   set it unless we really need to, and don't clear it unless<br />#   it was set by the kernel.<br /># <br /># arch/i386/kernel/signal.c<br />#   2004/12/31 13:29:16-08:00 torvalds&#64;evo.osdl.org +7 -21<br />#   Use common helper routine to send debug event SIGTRAPs<br />#   <br />#   Also be more careful with setting and clearing TF: don't<br />#   set it unless we really need to, and don't clear it unless<br />#   it was set by the kernel.<br /># <br /># arch/i386/kernel/ptrace.c<br />#   2004/12/31 13:29:15-08:00 torvalds&#64;evo.osdl.org +58 -15<br />#   Use common helper routine to send debug event SIGTRAPs<br />#   <br />#   Also be more careful with setting and clearing TF: don't<br />#   set it unless we really need to, and don't clear it unless<br />#   it was set by the kernel.<br /># <br />diff -Nru a/arch/i386/kernel/ptrace.c b/arch/i386/kernel/ptrace.c<br />--- a/arch/i386/kernel/ptrace.c	2004-12-31 13:34:35 -08:00<br />+++ b/arch/i386/kernel/ptrace.c	2004-12-31 13:34:35 -08:00<br />&#64;&#64; -42,6 +42,12 &#64;&#64;<br />  */<br /> #define EFL_OFFSET ((EFL-2)*4-sizeof(struct pt_regs))<br /> <br />+static inline struct pt_regs *get_child_regs(struct task_struct *task)<br />+{<br />+	void *stack_top = (void *)task-&gt;thread.esp0;<br />+	return stack_top - sizeof(struct pt_regs);<br />+}<br />+<br /> /*<br />  * this routine will get a word off of the processes privileged stack. <br />  * the offset is how far from the base addr as stored in the TSS.  <br />&#64;&#64; -140,22 +146,35 &#64;&#64;<br /> <br /> static void set_singlestep(struct task_struct *child)<br /> {<br />-	long eflags;<br />+	struct pt_regs *regs = get_child_regs(child);<br /> <br />+	/*<br />+	 * Always set TIF_SINGLESTEP - this guarantees that <br />+	 * we single-step system calls etc..  This will also<br />+	 * cause us to set TF when returning to user mode.<br />+	 */<br /> 	set_tsk_thread_flag(child, TIF_SINGLESTEP);<br />-	eflags = get_stack_long(child, EFL_OFFSET);<br />-	put_stack_long(child, EFL_OFFSET, eflags | TRAP_FLAG);<br />+<br />+	/*<br />+	 * If TF was already set, don't do anything else<br />+	 */<br />+	if (regs-&gt;eflags &amp; TRAP_FLAG)<br />+		return;<br />+<br />+	/* Set TF on the kernel stack, and set the flag to say so */<br />+	regs-&gt;eflags |= TRAP_FLAG;<br /> 	child-&gt;ptrace |= PT_DTRACE;<br /> }<br /> <br /> static void clear_singlestep(struct task_struct *child)<br /> {<br />-	if (child-&gt;ptrace &amp; PT_DTRACE) {<br />-		long eflags;<br />+	/* Always clear TIF_SINGLESTEP... */<br />+	clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br /> <br />-		clear_tsk_thread_flag(child, TIF_SINGLESTEP);<br />-		eflags = get_stack_long(child, EFL_OFFSET);<br />-		put_stack_long(child, EFL_OFFSET, eflags &amp; ~TRAP_FLAG);<br />+	/* But touch TF only if it was set by us.. */<br />+	if (child-&gt;ptrace &amp; PT_DTRACE) {<br />+		struct pt_regs *regs = get_child_regs(child);<br />+		regs-&gt;eflags &amp;= ~TRAP_FLAG;<br /> 		child-&gt;ptrace &amp;= ~PT_DTRACE;<br /> 	}<br /> }<br />&#64;&#64; -553,6 +572,29 &#64;&#64;<br /> 	return ret;<br /> }<br /> <br />+void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs, int error_code)<br />+{<br />+	struct siginfo info;<br />+<br />+	tsk-&gt;thread.trap_no = 1;<br />+	tsk-&gt;thread.error_code = error_code;<br />+<br />+	memset(&amp;info, 0, sizeof(info));<br />+	info.si_signo = SIGTRAP;<br />+	info.si_code = TRAP_BRKPT;<br />+<br />+	/*<br />+	 * If this is a kernel mode trap, save the user PC on entry to<br />+	 * the kernel, that's what the debugger can make sense of.<br />+	 */<br />+	info.si_addr = user_mode(regs) ?<br />+			(void __user *) regs-&gt;eip :<br />+			(void __user *)tsk-&gt;thread.eip;<br />+<br />+	/* Send us the fakey SIGTRAP */<br />+	force_sig_info(SIGTRAP, &amp;info, tsk);<br />+}<br />+<br /> /* notification of system call entry/exit<br />  * - triggered by current-&gt;work.syscall_trace<br />  */<br />&#64;&#64; -568,15 +610,16 &#64;&#64;<br /> 			audit_syscall_exit(current, regs-&gt;eax);<br /> 	}<br /> <br />-	if (!test_thread_flag(TIF_SYSCALL_TRACE) &amp;&amp;<br />-	    !test_thread_flag(TIF_SINGLESTEP))<br />-		return;<br /> 	if (!(current-&gt;ptrace &amp; PT_PTRACED))<br /> 		return;<br />-	/* the 0x80 provides a way for the tracing parent to distinguish<br />-	   between a syscall stop and SIGTRAP delivery */<br />-	ptrace_notify(SIGTRAP | ((current-&gt;ptrace &amp; PT_TRACESYSGOOD) &amp;&amp;<br />-				 !test_thread_flag(TIF_SINGLESTEP) ? 0x80 : 0));<br />+<br />+	/* Fake a debug trap */<br />+	if (test_thread_flag(TIF_SINGLESTEP))<br />+		send_sigtrap(current, regs, 0);<br />+<br />+	if (!test_thread_flag(TIF_SYSCALL_TRACE))<br />+		return;<br />+	ptrace_notify(SIGTRAP | ((current-&gt;ptrace &amp; PT_TRACESYSGOOD) ? 0x80 : 0));<br /> <br /> 	/*<br /> 	 * this isn't the same as continuing with a signal, but it will do<br />diff -Nru a/arch/i386/kernel/signal.c b/arch/i386/kernel/signal.c<br />--- a/arch/i386/kernel/signal.c	2004-12-31 13:34:35 -08:00<br />+++ b/arch/i386/kernel/signal.c	2004-12-31 13:34:35 -08:00<br />&#64;&#64; -270,7 +270,6 &#64;&#64;<br /> 		 struct pt_regs *regs, unsigned long mask)<br /> {<br /> 	int tmp, err = 0;<br />-	unsigned long eflags;<br /> <br /> 	tmp = 0;<br /> 	__asm__("movl %%gs,%0" : "=r"(tmp): "0"(tmp));<br />&#64;&#64; -292,16 +291,7 &#64;&#64;<br /> 	err |= __put_user(current-&gt;thread.error_code, &amp;sc-&gt;err);<br /> 	err |= __put_user(regs-&gt;eip, &amp;sc-&gt;eip);<br /> 	err |= __put_user(regs-&gt;xcs, (unsigned int __user *)&amp;sc-&gt;cs);<br />-<br />-	/*<br />-	 * Iff TF was set because the program is being single-stepped by a<br />-	 * debugger, don't save that information on the signal stack.. We<br />-	 * don't want debugging to change state.<br />-	 */<br />-	eflags = regs-&gt;eflags;<br />-	if (current-&gt;ptrace &amp; PT_DTRACE)<br />-		eflags &amp;= ~TF_MASK;<br />-	err |= __put_user(eflags, &amp;sc-&gt;eflags);<br />+	err |= __put_user(regs-&gt;eflags, &amp;sc-&gt;eflags);<br /> 	err |= __put_user(regs-&gt;esp, &amp;sc-&gt;esp_at_signal);<br /> 	err |= __put_user(regs-&gt;xss, (unsigned int __user *)&amp;sc-&gt;ss);<br /> <br />&#64;&#64; -424,11 +414,9 &#64;&#64;<br /> 	 * The tracer may want to single-step inside the<br /> 	 * handler too.<br /> 	 */<br />-	if (regs-&gt;eflags &amp; TF_MASK) {<br />-		regs-&gt;eflags &amp;= ~TF_MASK;<br />-		if (current-&gt;ptrace &amp; PT_DTRACE)<br />-			ptrace_notify(SIGTRAP);<br />-	}<br />+	regs-&gt;eflags &amp;= ~TF_MASK;<br />+	if (test_thread_flag(TIF_SINGLESTEP))<br />+		ptrace_notify(SIGTRAP);<br /> <br /> #if DEBUG_SIG<br /> 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",<br />&#64;&#64; -519,11 +507,9 &#64;&#64;<br /> 	 * The tracer may want to single-step inside the<br /> 	 * handler too.<br /> 	 */<br />-	if (regs-&gt;eflags &amp; TF_MASK) {<br />-		regs-&gt;eflags &amp;= ~TF_MASK;<br />-		if (current-&gt;ptrace &amp; PT_DTRACE)<br />-			ptrace_notify(SIGTRAP);<br />-	}<br />+	regs-&gt;eflags &amp;= ~TF_MASK;<br />+	if (test_thread_flag(TIF_SINGLESTEP))<br />+		ptrace_notify(SIGTRAP);<br /> <br /> #if DEBUG_SIG<br /> 	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",<br />diff -Nru a/arch/i386/kernel/traps.c b/arch/i386/kernel/traps.c<br />--- a/arch/i386/kernel/traps.c	2004-12-31 13:34:35 -08:00<br />+++ b/arch/i386/kernel/traps.c	2004-12-31 13:34:35 -08:00<br />&#64;&#64; -718,23 +718,21 &#64;&#64;<br /> 		 */<br /> 		if ((regs-&gt;xcs &amp; 3) == 0)<br /> 			goto clear_TF_reenable;<br />-		if ((tsk-&gt;ptrace &amp; (PT_DTRACE|PT_PTRACED)) == PT_DTRACE)<br />-			goto clear_TF;<br />+<br />+		/*<br />+		 * Was the TF flag set by a debugger? If so, clear it now,<br />+		 * so that register information is correct.<br />+		 */<br />+		if (tsk-&gt;ptrace &amp; PT_DTRACE) {<br />+			regs-&gt;eflags &amp;= ~TF_MASK;<br />+			tsk-&gt;ptrace &amp;= ~PT_DTRACE;<br />+			if (!tsk-&gt;ptrace &amp; PT_DTRACE)<br />+				goto clear_TF;<br />+		}<br /> 	}<br /> <br /> 	/* Ok, finally something we can handle */<br />-	tsk-&gt;thread.trap_no = 1;<br />-	tsk-&gt;thread.error_code = error_code;<br />-	info.si_signo = SIGTRAP;<br />-	info.si_errno = 0;<br />-	info.si_code = TRAP_BRKPT;<br />-	<br />-	/* If this is a kernel mode trap, save the user PC on entry to <br />-	 * the kernel, that's what the debugger can make sense of.<br />-	 */<br />-	info.si_addr = ((regs-&gt;xcs &amp; 3) == 0) ? (void __user *)tsk-&gt;thread.eip<br />-	                                      : (void __user *)regs-&gt;eip;<br />-	force_sig_info(SIGTRAP, &amp;info, tsk);<br />+	send_sigtrap(tsk, regs, error_code);<br /> <br /> 	/* Disable additional traps. They'll be re-enabled when<br /> 	 * the signal is delivered.<br />diff -Nru a/include/asm-i386/ptrace.h b/include/asm-i386/ptrace.h<br />--- a/include/asm-i386/ptrace.h	2004-12-31 13:34:35 -08:00<br />+++ b/include/asm-i386/ptrace.h	2004-12-31 13:34:35 -08:00<br />&#64;&#64; -55,6 +55,7 &#64;&#64;<br /> #define PTRACE_SET_THREAD_AREA    26<br /> <br /> #ifdef __KERNEL__<br />+extern void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs, int error_code);<br /> #define user_mode(regs) ((VM_MASK &amp; (regs)-&gt;eflags) || (3 &amp; (regs)-&gt;xcs))<br /> #define instruction_pointer(regs) ((regs)-&gt;eip)<br /> #if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_FRAME_POINTER)# This is a BitKeeper generated diff -Nru style patch.<br />#<br /># ChangeSet<br />#   2004/12/31 13:33:39-08:00 torvalds&#64;evo.osdl.org <br />#   x86 TF handling: don't clear after user "popf"<br />#   <br />#   The "popf" will have set TF to something new,<br />#   we should not clear it.<br />#   <br />#   NOTE! We should not allow the user to see TF on<br />#   the stack after a "pushf", but that is better done<br />#   by the controlling process in user space. This just<br />#   makes it possible to do non-intrusive single-stepping,<br />#   but the final part is up to the debugger.<br /># <br /># arch/i386/kernel/ptrace.c<br />#   2004/12/31 13:33:29-08:00 torvalds&#64;evo.osdl.org +83 -1<br />#   x86 TF handling: don't clear after user "popf"<br />#   <br />#   The "popf" will have set TF to something new,<br />#   we should not clear it.<br />#   <br />#   NOTE! We should not allow the user to see TF on<br />#   the stack after a "pushf", but that is better done<br />#   by the controlling process in user space. This just<br />#   makes it possible to do non-intrusive single-stepping,<br />#   but the final part is up to the debugger.<br /># <br />diff -Nru a/arch/i386/kernel/ptrace.c b/arch/i386/kernel/ptrace.c<br />--- a/arch/i386/kernel/ptrace.c	2004-12-31 13:34:48 -08:00<br />+++ b/arch/i386/kernel/ptrace.c	2004-12-31 13:34:48 -08:00<br />&#64;&#64; -144,6 +144,79 &#64;&#64;<br /> 	return retval;<br /> }<br /> <br />+#define LDT_SEGMENT 4<br />+<br />+static unsigned long convert_eip_to_linear(struct task_struct *child, struct pt_regs *regs)<br />+{<br />+	unsigned long addr, seg;<br />+<br />+	addr = regs-&gt;eip;<br />+	seg = regs-&gt;xcs &amp; 0xffff;<br />+	if (regs-&gt;eflags &amp; VM_MASK) {<br />+		addr = (addr &amp; 0xffff) + (seg &lt;&lt; 4);<br />+		return addr;<br />+	}<br />+<br />+	/*<br />+	 * We'll assume that the code segments in the GDT<br />+	 * are all zero-based. That is largely true: the<br />+	 * TLS segments are used for data, and the PNPBIOS<br />+	 * and APM bios ones we just ignore here.<br />+	 */<br />+	if (seg &amp; LDT_SEGMENT) {<br />+		u32 *desc;<br />+		unsigned long base;<br />+<br />+		down(&amp;child-&gt;mm-&gt;context.sem);<br />+		desc = child-&gt;mm-&gt;context.ldt + (seg &amp; ~7);<br />+		base = (desc[0] &gt;&gt; 16) | ((desc[1] &amp; 0xff) &lt;&lt; 16) | (desc[1] &amp; 0xff000000);<br />+<br />+		/* 16-bit code segment? */<br />+		if (!((desc[1] &gt;&gt; 22) &amp; 1))<br />+			addr &amp;= 0xffff;<br />+		addr += base;<br />+		up(&amp;child-&gt;mm-&gt;context.sem);<br />+	}<br />+	return addr;<br />+}<br />+<br />+static inline int is_at_popf(struct task_struct *child, struct pt_regs *regs)<br />+{<br />+	int i, copied;<br />+	unsigned char opcode[16];<br />+	unsigned long addr = convert_eip_to_linear(child, regs);<br />+<br />+	copied = access_process_vm(child, addr, opcode, sizeof(opcode), 0);<br />+	for (i = 0; i &lt; copied; i++) {<br />+		switch (opcode[i]) {<br />+		/* popf */<br />+		case 0x9d:<br />+			return 1;<br />+		/* opcode and address size prefixes */<br />+		case 0x66: case 0x67:<br />+			continue;<br />+		/* irrelevant prefixes (segment overrides and repeats) */<br />+		case 0x26: case 0x2e:<br />+		case 0x36: case 0x3e:<br />+		case 0x64: case 0x65:<br />+		case 0xf0: case 0xf2: case 0xf3:<br />+			continue;<br />+<br />+		/*<br />+		 * pushf: NOTE! We should probably not let<br />+		 * the user see the TF bit being set. But<br />+		 * it's more pain than it's worth to avoid<br />+		 * it, and a debugger could emulate this<br />+		 * all in user space if it _really_ cares.<br />+		 */<br />+		case 0x9c:<br />+		default:<br />+			return 0;<br />+		}<br />+	}<br />+	return 0;<br />+}<br />+<br /> static void set_singlestep(struct task_struct *child)<br /> {<br /> 	struct pt_regs *regs = get_child_regs(child);<br />&#64;&#64; -161,8 +234,17 &#64;&#64;<br /> 	if (regs-&gt;eflags &amp; TRAP_FLAG)<br /> 		return;<br /> <br />-	/* Set TF on the kernel stack, and set the flag to say so */<br />+	/* Set TF on the kernel stack.. */<br /> 	regs-&gt;eflags |= TRAP_FLAG;<br />+<br />+	/*<br />+	 * ..but if TF is changed by the instruction we will trace,<br />+	 * don't mark it as being "us" that set it, so that we<br />+	 * won't clear it by hand later.<br />+	 */<br />+	if (is_at_popf(child, regs))<br />+		return;<br />+	<br /> 	child-&gt;ptrace |= PT_DTRACE;<br /> }<br /> </pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
