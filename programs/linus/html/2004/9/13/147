    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/9/10/206">First message in thread</a></li><li><a href="/lkml/2004/9/12/238">Michel =?ISO-8859-1?Q?D=E4nzer?=</a><ul><li><a href="/lkml/2004/9/13/135">Vladimir Dergachev</a><ul><li class="origin"><a href="/lkml/2004/9/13/222">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/13/222">Alex Deucher</a><ul><li><a href="/lkml/2004/9/13/244">David Bronaugh</a></li></ul></li></ul></li><li><a href="/lkml/2004/9/13/152">Alan Cox</a><ul><li><a href="/lkml/2004/9/13/150">Vladimir Dergachev</a></li><li><a href="/lkml/2004/9/13/162">Alan Cox</a></li></ul></li><li><a href="/lkml/2004/9/13/173">Michel =?ISO-8859-1?Q?D=E4nzer?=</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 13 Sep 2004 08:20:58 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: radeon-pre-2</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 13 Sep 2004, Vladimir Dergachev wrote:<br />&gt; <br />&gt; The overlay window is currently using part of what is being proposed by<br />&gt; "multiple drivers" proponents. It has to make engine queiscent so it can <br />&gt; write data directly to the video memory. It does *not* have to save the <br />&gt; state.<br /><br />It doesn't even really need to make the engine quiesce.<br /><br />If two subsystems are aware of the locking rules (and the helper driver<br />obviously doesn't much care), they can just design their own handoff<br />trivially. For example, it might make sense to make the "wait for the<br />engine to stop" be the responsibility of the side that actually _needs_<br />it, namely the PIO user.<br /><br />So if both users use the engine, not PIO, there's no need to ever stop the<br />engine. In my example of how to use the locking, it looked something like<br />this:<br /><br />	if (get_lock(data-&gt;gfx.accelerator)) {<br />		/* Somebody else used the engine, need to re-load cached index */<br />		mydev-&gt;offset = readl(mydev-&gt;mmio + OFFSET_PORT);<br />	}<br />	OUT_RING(mydev, cmd);<br />	OUT_RING(mydev, arg);<br />	put_lock(data-&gt;gfx.accelerator);<br /><br />See? You can have two clients doing accelerator things, and they _never_ <br />wait for anything (well, obviously "OUT_RING()" needs to wait for the <br />buffer to be empty enough ;).<br /><br />They still need to know whether there was a previous user, because <br />efficient command filling does require that you don't read the "where is <br />the command buffer end" thing all the time, so that's why you have to <br />cache that one in real RAM instead of reading it from the card every op. <br />And because you cache it, you have to update your cache if somebody else <br />uses the engine.<br /><br />Now, a PIO writer would look different<br /><br />	if (get_lock(data-&gt;gfx.accelerator)) {<br />		/* Somebody else used the engine, need to quiesce */<br />		wait_for_engine_idle(mydev);<br />	}<br />	outl(cmd, mydev-&gt;pio + OFFSET_CMD);<br />	...<br />	put_lock(data-&gt;gfx.accelerator);<br /><br />and here if we switch back and forth between a client that uses <br />synchronous commands (ie normally PIO) rather than the engine, then yes, <br />we'd obviously halt the engine all the time. But hey, you can't avoid <br />that: if you want good performance with most modern chips, you do all your <br />work with the engine, not with synchronous commands.<br /><br />&gt; So, as Jon rightly points out the "multiple drivers" scheme only makes <br />&gt; sense in the current usage patter - you either use X or framebuffer, never <br />&gt; both at the same time and you consider a few seconds per switch normal.<br /><br />I disagree. You can use a combination of X, framebuffer and "special <br />clients", where the special client can be _exactly_ things like video <br />overlays etc. <br /><br />Now, obviously we'd wish that X has support for video overlays directly, <br />and thus you wouldn't even need to switch between clients at that level, <br />but there are certainly cases where you may end up with an "external <br />client". It might be some very card-specific thing that X or DRM just <br />doesn't support yet, so you whip up a quick client for just that.<br /><br />For example (and this may be a horribly _bad_ example, for all I know),  <br />let's say that somebody decides that they want to do a DirectX library, <br />and all the DRM people just throw their hands up in horror and say "over <br />my dead body".<br /><br />In that case you have two choices: kill the DRM people and dance on their<br />graves, or just say "ok, I'll make this other client that does the DirectX<br />interfaces". And the thing is, it shouldn't fundamentally not work. As far<br />as I can tell, with some rudimentary locking support like the above (the<br />trivial part) and some memory management support (the _hard_ part), you<br />should be able to have the two clients work together quite well.<br /><br />And yes, I realize that this is what DRM already does internally. I agree. <br />I applaud it. I'm saying that if we moved that internal locking to be <br />_external_, so that other clients can use it too, then fbcon and DRM and <br />some random new subsystem could all live together in peace and harmony.<br /><br />Now, let's all sit around the fire and sing Kumbaya.<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
