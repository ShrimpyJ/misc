    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/9/23/46">First message in thread</a></li><li><a href="/lkml/2004/9/23/82">Michal Rokos</a><ul><li><a href="/lkml/2004/9/30/123">(Franz Pletz)</a><ul><li class="origin"><a href="/lkml/2004/9/30/146">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/30/146">"Andrey S. Klochko"</a><ul><li><a href="/lkml/2004/9/30/153">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2004/9/30/149">(Franz Pletz)</a></li><li><a href="/lkml/2004/9/30/154">Jeff Garzik</a><ul><li><a href="/lkml/2004/9/30/157">Linus Torvalds</a></li><li><a href="/lkml/2004/9/30/162">Tim Hockin</a></li><li><a href="/lkml/2004/9/30/188">"David S. Miller"</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2004/9/30/135/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 30 Sep 2004 10:24:49 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 2.6] Natsemi - remove compilation warnings</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 30 Sep 2004, Franz Pletz wrote:<br />&gt;<br />&gt; It seems like your patch unfortunately went into 2.6.9-rc2-mm[3,4] and <br />&gt; 2.6.9-rc3.<br /><br />It's definitely not in _my_ -rc3. Which kernel are you looking at?<br /><br />&gt; My Natsemi network card stops working with 2.6.9-rc3. After succesfully <br />&gt; revoking your patch from <br />&gt; <a href="https://www.kernel.org/pub/linux/kernel/people/akpm/patches/2.6/2.6.9-rc2/2.6.9-rc2-mm3/broken-out/natsemi-remove-compilation-warnings.patch">http://www.kernel.org/pub/linux/kernel/people/akpm/patches/2.6/2.6.9-rc2/2.6.9-rc2-mm3/broken-out/natsemi-remove-compilation-warnings.patch</a><br />&gt; everything works fine.<br /><br />That patch does indeed look totally bogus. The reason a lot of network<br />drivers complain about readl/writel is that "struct net_device" is very<br />confused about what the IO addresses mean, and they mean different things<br />for different users. Which makes type safety basically disappear, and now<br />that we check it more carefully, things break.<br /><br />This patch should clean up natsemi.c a bit, and makes the warnings go <br />away. Does it work for you? (It really should, it's just a basic <br />search-and-replace fix).<br /><br />This is bigger than the broken patch, but that's really pretty<br />unavoidable, unless "struct net_device" is fixed. And the way it's<br />structured, if "net_device" ever _is_ fixed, this driver will now be<br />trivially updated.<br /><br />		Linus<br /><br />----<br />===== drivers/net/natsemi.c 1.68 vs edited =====<br />--- 1.68/drivers/net/natsemi.c	2004-07-27 11:18:53 -07:00<br />+++ edited/drivers/net/natsemi.c	2004-09-30 10:22:44 -07:00<br />&#64;&#64; -719,7 +719,7 &#64;&#64;<br /> };<br /> <br /> static void move_int_phy(struct net_device *dev, int addr);<br />-static int eeprom_read(long ioaddr, int location);<br />+static int eeprom_read(void __iomem *ioaddr, int location);<br /> static int mdio_read(struct net_device *dev, int reg);<br /> static void mdio_write(struct net_device *dev, int reg, u16 data);<br /> static void init_phy_fixup(struct net_device *dev);<br />&#64;&#64; -769,9 +769,15 &#64;&#64;<br /> static int netdev_get_regs(struct net_device *dev, u8 *buf);<br /> static int netdev_get_eeprom(struct net_device *dev, u8 *buf);<br /> <br />+static inline void __iomem *ns_ioaddr(struct net_device *dev)<br />+{<br />+	return (void __iomem *) dev-&gt;base_addr;<br />+}<br />+<br /> static void move_int_phy(struct net_device *dev, int addr)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> 	int target = 31;<br /> <br /> 	/* <br />&#64;&#64; -788,8 +794,8 &#64;&#64;<br /> 		target--;<br /> 	if (target == np-&gt;phy_addr_external)<br /> 		target--;<br />-	writew(target, dev-&gt;base_addr + PhyCtrl);<br />-	readw(dev-&gt;base_addr + PhyCtrl);<br />+	writew(target, ioaddr + PhyCtrl);<br />+	readw(ioaddr + PhyCtrl);<br /> 	udelay(1);<br /> }<br /> <br />&#64;&#64; -800,7 +806,8 &#64;&#64;<br /> 	struct netdev_private *np;<br /> 	int i, option, irq, chip_idx = ent-&gt;driver_data;<br /> 	static int find_cnt = -1;<br />-	unsigned long ioaddr, iosize;<br />+	unsigned long iostart, iosize;<br />+	void __iomem *ioaddr;<br /> 	const int pcibar = 1; /* PCI base address register */<br /> 	int prev_eedata;<br /> 	u32 tmp;<br />&#64;&#64; -827,7 +834,7 &#64;&#64;<br /> 	}<br /> <br /> 	find_cnt++;<br />-	ioaddr = pci_resource_start(pdev, pcibar);<br />+	iostart = pci_resource_start(pdev, pcibar);<br /> 	iosize = pci_resource_len(pdev, pcibar);<br /> 	irq = pdev-&gt;irq;<br /> <br />&#64;&#64; -844,7 +851,7 &#64;&#64;<br /> 	if (i)<br /> 		goto err_pci_request_regions;<br /> <br />-	ioaddr = (unsigned long) ioremap (ioaddr, iosize);<br />+	ioaddr = ioremap(iostart, iosize);<br /> 	if (!ioaddr) {<br /> 		i = -ENOMEM;<br /> 		goto err_ioremap;<br />&#64;&#64; -859,7 +866,7 &#64;&#64;<br /> 		prev_eedata = eedata;<br /> 	}<br /> <br />-	dev-&gt;base_addr = ioaddr;<br />+	dev-&gt;base_addr = (unsigned long __force) ioaddr;<br /> 	dev-&gt;irq = irq;<br /> <br /> 	np = netdev_priv(dev);<br />&#64;&#64; -879,7 +886,7 &#64;&#64;<br /> 	 * The address would be used to access a phy over the mii bus, but<br /> 	 * the internal phy is accessed through mapped registers.<br /> 	 */<br />-	if (readl(dev-&gt;base_addr + ChipConfig) &amp; CfgExtPhy)<br />+	if (readl(ioaddr + ChipConfig) &amp; CfgExtPhy)<br /> 		dev-&gt;if_port = PORT_MII;<br /> 	else<br /> 		dev-&gt;if_port = PORT_TP;<br />&#64;&#64; -971,7 +978,7 &#64;&#64;<br /> <br /> 	if (netif_msg_drv(np)) {<br /> 		printk(KERN_INFO "natsemi %s: %s at %#08lx (%s), ",<br />-			dev-&gt;name, natsemi_pci_info[chip_idx].name, ioaddr,<br />+			dev-&gt;name, natsemi_pci_info[chip_idx].name, iostart,<br /> 			pci_name(np-&gt;pci_dev));<br /> 		for (i = 0; i &lt; ETH_ALEN-1; i++)<br /> 				printk("%02x:", dev-&gt;dev_addr[i]);<br />&#64;&#64; -984,7 +991,7 &#64;&#64;<br /> 	return 0;<br /> <br />  err_register_netdev:<br />-	iounmap ((void *) dev-&gt;base_addr);<br />+	iounmap(ioaddr);<br /> <br />  err_ioremap:<br /> 	pci_release_regions(pdev);<br />&#64;&#64; -1016,12 +1023,13 &#64;&#64;<br /> 	EE_WriteCmd=(5 &lt;&lt; 6), EE_ReadCmd=(6 &lt;&lt; 6), EE_EraseCmd=(7 &lt;&lt; 6),<br /> };<br /> <br />-static int eeprom_read(long addr, int location)<br />+static int eeprom_read(void __iomem *addr, int location)<br /> {<br /> 	int i;<br /> 	int retval = 0;<br />-	long ee_addr = addr + EECtrl;<br />+	void __iomem *ee_addr = addr + EECtrl;<br /> 	int read_cmd = location | EE_ReadCmd;<br />+<br /> 	writel(EE_Write0, ee_addr);<br /> <br /> 	/* Shift the read command bits out. */<br />&#64;&#64; -1058,15 +1066,16 &#64;&#64;<br /> /* clock transitions &gt;= 20ns (25MHz)<br />  * One readl should be good to PCI &#64; 100MHz<br />  */<br />-#define mii_delay(dev)  readl(dev-&gt;base_addr + EECtrl)<br />+#define mii_delay(dev)  readl(ioaddr + EECtrl)<br /> <br /> static int mii_getbit (struct net_device *dev)<br /> {<br /> 	int data;<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> <br />-	writel(MII_ShiftClk, dev-&gt;base_addr + EECtrl);<br />-	data = readl(dev-&gt;base_addr + EECtrl);<br />-	writel(0, dev-&gt;base_addr + EECtrl);<br />+	writel(MII_ShiftClk, ioaddr + EECtrl);<br />+	data = readl(ioaddr + EECtrl);<br />+	writel(0, ioaddr + EECtrl);<br /> 	mii_delay(dev);<br /> 	return (data &amp; MII_Data)? 1 : 0;<br /> }<br />&#64;&#64; -1074,16 +1083,17 &#64;&#64;<br /> static void mii_send_bits (struct net_device *dev, u32 data, int len)<br /> {<br /> 	u32 i;<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> <br /> 	for (i = (1 &lt;&lt; (len-1)); i; i &gt;&gt;= 1)<br /> 	{<br /> 		u32 mdio_val = MII_Write | ((data &amp; i)? MII_Data : 0);<br />-		writel(mdio_val, dev-&gt;base_addr + EECtrl);<br />+		writel(mdio_val, ioaddr + EECtrl);<br /> 		mii_delay(dev);<br />-		writel(mdio_val | MII_ShiftClk, dev-&gt;base_addr + EECtrl);<br />+		writel(mdio_val | MII_ShiftClk, ioaddr + EECtrl);<br /> 		mii_delay(dev);<br /> 	}<br />-	writel(0, dev-&gt;base_addr + EECtrl);<br />+	writel(0, ioaddr + EECtrl);<br /> 	mii_delay(dev);<br /> }<br /> <br />&#64;&#64; -1129,13 +1139,14 &#64;&#64;<br /> static int mdio_read(struct net_device *dev, int reg)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> <br /> 	/* The 83815 series has two ports:<br /> 	 * - an internal transceiver<br /> 	 * - an external mii bus<br /> 	 */<br /> 	if (dev-&gt;if_port == PORT_TP)<br />-		return readw(dev-&gt;base_addr+BasicControl+(reg&lt;&lt;2));<br />+		return readw(ioaddr+BasicControl+(reg&lt;&lt;2));<br /> 	else<br /> 		return miiport_read(dev, np-&gt;phy_addr_external, reg);<br /> }<br />&#64;&#64; -1143,10 +1154,11 &#64;&#64;<br /> static void mdio_write(struct net_device *dev, int reg, u16 data)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> <br /> 	/* The 83815 series has an internal transceiver; handle separately */<br /> 	if (dev-&gt;if_port == PORT_TP)<br />-		writew(data, dev-&gt;base_addr+BasicControl+(reg&lt;&lt;2));<br />+		writew(data, ioaddr+BasicControl+(reg&lt;&lt;2));<br /> 	else<br /> 		miiport_write(dev, np-&gt;phy_addr_external, reg, data);<br /> }<br />&#64;&#64; -1154,7 +1166,7 &#64;&#64;<br /> static void init_phy_fixup(struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> 	int i;<br /> 	u32 cfg;<br /> 	u16 tmp;<br />&#64;&#64; -1186,7 +1198,7 &#64;&#64;<br /> 		 */<br /> 	}<br /> 	mdio_write(dev, MII_BMCR, tmp);<br />-	readl(dev-&gt;base_addr + ChipConfig);<br />+	readl(ioaddr + ChipConfig);<br /> 	udelay(1);<br /> <br /> 	/* find out what phy this is */<br />&#64;&#64; -1208,7 +1220,7 &#64;&#64;<br /> 	default:<br /> 		break;<br /> 	}<br />-	cfg = readl(dev-&gt;base_addr + ChipConfig);<br />+	cfg = readl(ioaddr + ChipConfig);<br /> 	if (cfg &amp; CfgExtPhy)<br /> 		return;<br /> <br />&#64;&#64; -1266,9 +1278,10 &#64;&#64;<br /> static int switch_port_external(struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> 	u32 cfg;<br /> <br />-	cfg = readl(dev-&gt;base_addr + ChipConfig);<br />+	cfg = readl(ioaddr + ChipConfig);<br /> 	if (cfg &amp; CfgExtPhy)<br /> 		return 0;<br /> <br />&#64;&#64; -1278,8 +1291,8 &#64;&#64;<br /> 	}<br /> <br /> 	/* 1) switch back to external phy */<br />-	writel(cfg | (CfgExtPhy | CfgPhyDis), dev-&gt;base_addr + ChipConfig);<br />-	readl(dev-&gt;base_addr + ChipConfig);<br />+	writel(cfg | (CfgExtPhy | CfgPhyDis), ioaddr + ChipConfig);<br />+	readl(ioaddr + ChipConfig);<br /> 	udelay(1);<br /> <br /> 	/* 2) reset the external phy: */<br />&#64;&#64; -1298,11 +1311,12 &#64;&#64;<br /> static int switch_port_internal(struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> 	int i;<br /> 	u32 cfg;<br /> 	u16 bmcr;<br /> <br />-	cfg = readl(dev-&gt;base_addr + ChipConfig);<br />+	cfg = readl(ioaddr + ChipConfig);<br /> 	if (!(cfg &amp;CfgExtPhy))<br /> 		return 0;<br /> <br />&#64;&#64; -1312,17 +1326,17 &#64;&#64;<br /> 	}<br /> 	/* 1) switch back to internal phy: */<br /> 	cfg = cfg &amp; ~(CfgExtPhy | CfgPhyDis);<br />-	writel(cfg, dev-&gt;base_addr + ChipConfig);<br />-	readl(dev-&gt;base_addr + ChipConfig);<br />+	writel(cfg, ioaddr + ChipConfig);<br />+	readl(ioaddr + ChipConfig);<br /> 	udelay(1);<br /> 	<br /> 	/* 2) reset the internal phy: */<br />-	bmcr = readw(dev-&gt;base_addr+BasicControl+(MII_BMCR&lt;&lt;2));<br />-	writel(bmcr | BMCR_RESET, dev-&gt;base_addr+BasicControl+(MII_BMCR&lt;&lt;2));<br />-	readl(dev-&gt;base_addr + ChipConfig);<br />+	bmcr = readw(ioaddr+BasicControl+(MII_BMCR&lt;&lt;2));<br />+	writel(bmcr | BMCR_RESET, ioaddr+BasicControl+(MII_BMCR&lt;&lt;2));<br />+	readl(ioaddr + ChipConfig);<br /> 	udelay(10);<br /> 	for (i=0;i&lt;NATSEMI_HW_TIMEOUT;i++) {<br />-		bmcr = readw(dev-&gt;base_addr+BasicControl+(MII_BMCR&lt;&lt;2));<br />+		bmcr = readw(ioaddr+BasicControl+(MII_BMCR&lt;&lt;2));<br /> 		if (!(bmcr &amp; BMCR_RESET))<br /> 			break;<br /> 		udelay(10);<br />&#64;&#64; -1398,6 +1412,7 &#64;&#64;<br /> 	u16 pmatch[3];<br /> 	u16 sopass[3];<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> <br /> 	/*<br /> 	 * Resetting the chip causes some registers to be lost.<br />&#64;&#64; -1408,26 +1423,26 &#64;&#64;<br /> 	 */<br /> <br /> 	/* CFG */<br />-	cfg = readl(dev-&gt;base_addr + ChipConfig) &amp; CFG_RESET_SAVE;<br />+	cfg = readl(ioaddr + ChipConfig) &amp; CFG_RESET_SAVE;<br /> 	/* WCSR */<br />-	wcsr = readl(dev-&gt;base_addr + WOLCmd) &amp; WCSR_RESET_SAVE;<br />+	wcsr = readl(ioaddr + WOLCmd) &amp; WCSR_RESET_SAVE;<br /> 	/* RFCR */<br />-	rfcr = readl(dev-&gt;base_addr + RxFilterAddr) &amp; RFCR_RESET_SAVE;<br />+	rfcr = readl(ioaddr + RxFilterAddr) &amp; RFCR_RESET_SAVE;<br /> 	/* PMATCH */<br /> 	for (i = 0; i &lt; 3; i++) {<br />-		writel(i*2, dev-&gt;base_addr + RxFilterAddr);<br />-		pmatch[i] = readw(dev-&gt;base_addr + RxFilterData);<br />+		writel(i*2, ioaddr + RxFilterAddr);<br />+		pmatch[i] = readw(ioaddr + RxFilterData);<br /> 	}<br /> 	/* SOPAS */<br /> 	for (i = 0; i &lt; 3; i++) {<br />-		writel(0xa+(i*2), dev-&gt;base_addr + RxFilterAddr);<br />-		sopass[i] = readw(dev-&gt;base_addr + RxFilterData);<br />+		writel(0xa+(i*2), ioaddr + RxFilterAddr);<br />+		sopass[i] = readw(ioaddr + RxFilterData);<br /> 	}<br /> <br /> 	/* now whack the chip */<br />-	writel(ChipReset, dev-&gt;base_addr + ChipCmd);<br />+	writel(ChipReset, ioaddr + ChipCmd);<br /> 	for (i=0;i&lt;NATSEMI_HW_TIMEOUT;i++) {<br />-		if (!(readl(dev-&gt;base_addr + ChipCmd) &amp; ChipReset))<br />+		if (!(readl(ioaddr + ChipCmd) &amp; ChipReset))<br /> 			break;<br /> 		udelay(5);<br /> 	}<br />&#64;&#64; -1440,40 +1455,41 &#64;&#64;<br /> 	}<br /> <br /> 	/* restore CFG */<br />-	cfg |= readl(dev-&gt;base_addr + ChipConfig) &amp; ~CFG_RESET_SAVE;<br />+	cfg |= readl(ioaddr + ChipConfig) &amp; ~CFG_RESET_SAVE;<br /> 	/* turn on external phy if it was selected */<br /> 	if (dev-&gt;if_port == PORT_TP)<br /> 		cfg &amp;= ~(CfgExtPhy | CfgPhyDis);<br /> 	else<br /> 		cfg |= (CfgExtPhy | CfgPhyDis);<br />-	writel(cfg, dev-&gt;base_addr + ChipConfig);<br />+	writel(cfg, ioaddr + ChipConfig);<br /> 	/* restore WCSR */<br />-	wcsr |= readl(dev-&gt;base_addr + WOLCmd) &amp; ~WCSR_RESET_SAVE;<br />-	writel(wcsr, dev-&gt;base_addr + WOLCmd);<br />+	wcsr |= readl(ioaddr + WOLCmd) &amp; ~WCSR_RESET_SAVE;<br />+	writel(wcsr, ioaddr + WOLCmd);<br /> 	/* read RFCR */<br />-	rfcr |= readl(dev-&gt;base_addr + RxFilterAddr) &amp; ~RFCR_RESET_SAVE;<br />+	rfcr |= readl(ioaddr + RxFilterAddr) &amp; ~RFCR_RESET_SAVE;<br /> 	/* restore PMATCH */<br /> 	for (i = 0; i &lt; 3; i++) {<br />-		writel(i*2, dev-&gt;base_addr + RxFilterAddr);<br />-		writew(pmatch[i], dev-&gt;base_addr + RxFilterData);<br />+		writel(i*2, ioaddr + RxFilterAddr);<br />+		writew(pmatch[i], ioaddr + RxFilterData);<br /> 	}<br /> 	for (i = 0; i &lt; 3; i++) {<br />-		writel(0xa+(i*2), dev-&gt;base_addr + RxFilterAddr);<br />-		writew(sopass[i], dev-&gt;base_addr + RxFilterData);<br />+		writel(0xa+(i*2), ioaddr + RxFilterAddr);<br />+		writew(sopass[i], ioaddr + RxFilterData);<br /> 	}<br /> 	/* restore RFCR */<br />-	writel(rfcr, dev-&gt;base_addr + RxFilterAddr);<br />+	writel(rfcr, ioaddr + RxFilterAddr);<br /> }<br /> <br /> static void natsemi_reload_eeprom(struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> 	int i;<br /> <br />-	writel(EepromReload, dev-&gt;base_addr + PCIBusCfg);<br />+	writel(EepromReload, ioaddr + PCIBusCfg);<br /> 	for (i=0;i&lt;NATSEMI_HW_TIMEOUT;i++) {<br /> 		udelay(50);<br />-		if (!(readl(dev-&gt;base_addr + PCIBusCfg) &amp; EepromReload))<br />+		if (!(readl(ioaddr + PCIBusCfg) &amp; EepromReload))<br /> 			break;<br /> 	}<br /> 	if (i==NATSEMI_HW_TIMEOUT) {<br />&#64;&#64; -1487,7 +1503,7 &#64;&#64;<br /> <br /> static void natsemi_stop_rxtx(struct net_device *dev)<br /> {<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	struct netdev_private *np = netdev_priv(dev);<br /> 	int i;<br /> <br />&#64;&#64; -1509,7 +1525,7 &#64;&#64;<br /> static int netdev_open(struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	int i;<br /> <br /> 	/* Reset the chip, just in case. */<br />&#64;&#64; -1558,6 +1574,7 &#64;&#64;<br /> static void do_cable_magic(struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem *ioaddr = ns_ioaddr(dev);<br /> <br /> 	if (dev-&gt;if_port != PORT_TP)<br /> 		return;<br />&#64;&#64; -1571,15 +1588,15 &#64;&#64;<br /> 	 * activity LED while idle.  This process is based on instructions<br /> 	 * from engineers at National.<br /> 	 */<br />-	if (readl(dev-&gt;base_addr + ChipConfig) &amp; CfgSpeed100) {<br />+	if (readl(ioaddr + ChipConfig) &amp; CfgSpeed100) {<br /> 		u16 data;<br /> <br />-		writew(1, dev-&gt;base_addr + PGSEL);<br />+		writew(1, ioaddr + PGSEL);<br /> 		/*<br /> 		 * coefficient visibility should already be enabled via<br /> 		 * DSPCFG | 0x1000<br /> 		 */<br />-		data = readw(dev-&gt;base_addr + TSTDAT) &amp; 0xff;<br />+		data = readw(ioaddr + TSTDAT) &amp; 0xff;<br /> 		/*<br /> 		 * the value must be negative, and within certain values<br /> 		 * (these values all come from National)<br />&#64;&#64; -1588,13 +1605,13 &#64;&#64;<br /> 			struct netdev_private *np = netdev_priv(dev);<br /> <br /> 			/* the bug has been triggered - fix the coefficient */<br />-			writew(TSTDAT_FIXED, dev-&gt;base_addr + TSTDAT);<br />+			writew(TSTDAT_FIXED, ioaddr + TSTDAT);<br /> 			/* lock the value */<br />-			data = readw(dev-&gt;base_addr + DSPCFG);<br />+			data = readw(ioaddr + DSPCFG);<br /> 			np-&gt;dspcfg = data | DSPCFG_LOCK;<br />-			writew(np-&gt;dspcfg, dev-&gt;base_addr + DSPCFG);<br />+			writew(np-&gt;dspcfg, ioaddr + DSPCFG);<br /> 		}<br />-		writew(0, dev-&gt;base_addr + PGSEL);<br />+		writew(0, ioaddr + PGSEL);<br /> 	}<br /> }<br /> <br />&#64;&#64; -1602,6 +1619,7 &#64;&#64;<br /> {<br /> 	u16 data;<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 	if (dev-&gt;if_port != PORT_TP)<br /> 		return;<br />&#64;&#64; -1609,18 +1627,18 &#64;&#64;<br /> 	if (np-&gt;srr &gt;= SRR_DP83816_A5)<br /> 		return;<br /> <br />-	writew(1, dev-&gt;base_addr + PGSEL);<br />+	writew(1, ioaddr + PGSEL);<br /> 	/* make sure the lock bit is clear */<br />-	data = readw(dev-&gt;base_addr + DSPCFG);<br />+	data = readw(ioaddr + DSPCFG);<br /> 	np-&gt;dspcfg = data &amp; ~DSPCFG_LOCK;<br />-	writew(np-&gt;dspcfg, dev-&gt;base_addr + DSPCFG);<br />-	writew(0, dev-&gt;base_addr + PGSEL);<br />+	writew(np-&gt;dspcfg, ioaddr + DSPCFG);<br />+	writew(0, ioaddr + PGSEL);<br /> }<br /> <br /> static void check_link(struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	int duplex;<br /> 	u16 bmsr;<br />        <br />&#64;&#64; -1681,7 +1699,7 &#64;&#64;<br /> static void init_registers(struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 	init_phy_fixup(dev);<br /> <br />&#64;&#64; -1760,6 +1778,7 &#64;&#64;<br /> {<br /> 	struct net_device *dev = (struct net_device *)data;<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	int next_tick = 5*HZ;<br /> <br /> 	if (netif_msg_timer(np)) {<br />&#64;&#64; -1771,7 +1790,6 &#64;&#64;<br /> 	}<br /> <br /> 	if (dev-&gt;if_port == PORT_TP) {<br />-		long ioaddr = dev-&gt;base_addr;<br /> 		u16 dspcfg;<br /> <br /> 		spin_lock_irq(&amp;np-&gt;lock);<br />&#64;&#64; -1814,7 +1832,7 &#64;&#64;<br /> 		refill_rx(dev);<br /> 		enable_irq(dev-&gt;irq);<br /> 		if (!np-&gt;oom) {<br />-			writel(RxOn, dev-&gt;base_addr + ChipCmd);<br />+			writel(RxOn, ioaddr + ChipCmd);<br /> 		} else {<br /> 			next_tick = 1;<br /> 		}<br />&#64;&#64; -1848,7 +1866,7 &#64;&#64;<br /> static void tx_timeout(struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 	disable_irq(dev-&gt;irq);<br /> 	spin_lock_irq(&amp;np-&gt;lock);<br />&#64;&#64; -2048,6 +2066,7 &#64;&#64;<br /> static int start_tx(struct sk_buff *skb, struct net_device *dev)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	unsigned entry;<br /> <br /> 	/* Note: Ordering is important here, set the field with the<br />&#64;&#64; -2076,7 +2095,7 &#64;&#64;<br /> 				netif_stop_queue(dev);<br /> 		}<br /> 		/* Wake the potentially-idle transmit channel. */<br />-		writel(TxOn, dev-&gt;base_addr + ChipCmd);<br />+		writel(TxOn, ioaddr + ChipCmd);<br /> 	} else {<br /> 		dev_kfree_skb_irq(skb);<br /> 		np-&gt;stats.tx_dropped++;<br />&#64;&#64; -2141,7 +2160,7 &#64;&#64;<br /> {<br /> 	struct net_device *dev = dev_instance;<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	int boguscnt = max_interrupt_work;<br /> 	unsigned int handled = 0;<br /> <br />&#64;&#64; -2203,6 +2222,7 &#64;&#64;<br /> 	int boguscnt = np-&gt;dirty_rx + RX_RING_SIZE - np-&gt;cur_rx;<br /> 	s32 desc_status = le32_to_cpu(np-&gt;rx_head_desc-&gt;cmd_status);<br /> 	unsigned int buflen = np-&gt;rx_buf_sz;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 	/* If the driver owns the next entry it's a new packet. Send it up. */<br /> 	while (desc_status &lt; 0) { /* e.g. &amp; DescOwn */<br />&#64;&#64; -2284,13 +2304,13 &#64;&#64;<br /> 	if (np-&gt;oom)<br /> 		mod_timer(&amp;np-&gt;timer, jiffies + 1);<br /> 	else<br />-		writel(RxOn, dev-&gt;base_addr + ChipCmd);<br />+		writel(RxOn, ioaddr + ChipCmd);<br /> }<br /> <br /> static void netdev_error(struct net_device *dev, int intr_status)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 	spin_lock(&amp;np-&gt;lock);<br /> 	if (intr_status &amp; LinkChange) {<br />&#64;&#64; -2349,7 +2369,7 &#64;&#64;<br /> <br /> static void __get_stats(struct net_device *dev)<br /> {<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	struct netdev_private *np = netdev_priv(dev);<br /> <br /> 	/* The chip only need report frame silently dropped. */<br />&#64;&#64; -2382,7 +2402,7 &#64;&#64;<br /> #define HASH_TABLE	0x200<br /> static void __set_rx_mode(struct net_device *dev)<br /> {<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	struct netdev_private *np = netdev_priv(dev);<br /> 	u8 mc_filter[64]; /* Multicast hash filter */<br /> 	u32 rx_mode;<br />&#64;&#64; -2428,7 +2448,7 &#64;&#64;<br /> 	/* synchronized against open : rtnl_lock() held by caller */<br /> 	if (netif_running(dev)) {<br /> 		struct netdev_private *np = netdev_priv(dev);<br />-		long ioaddr = dev-&gt;base_addr;<br />+		void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 		disable_irq(dev-&gt;irq);<br /> 		spin_lock(&amp;np-&gt;lock);<br />&#64;&#64; -2631,7 +2651,8 &#64;&#64;<br /> static int netdev_set_wol(struct net_device *dev, u32 newval)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	u32 data = readl(dev-&gt;base_addr + WOLCmd) &amp; ~WakeOptsSummary;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br />+	u32 data = readl(ioaddr + WOLCmd) &amp; ~WakeOptsSummary;<br /> <br /> 	/* translate to bitmasks this chip understands */<br /> 	if (newval &amp; WAKE_PHY)<br />&#64;&#64; -2652,7 +2673,7 &#64;&#64;<br /> 		}<br /> 	}<br /> <br />-	writel(data, dev-&gt;base_addr + WOLCmd);<br />+	writel(data, ioaddr + WOLCmd);<br /> <br /> 	return 0;<br /> }<br />&#64;&#64; -2660,7 +2681,8 &#64;&#64;<br /> static int netdev_get_wol(struct net_device *dev, u32 *supported, u32 *cur)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	u32 regval = readl(dev-&gt;base_addr + WOLCmd);<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br />+	u32 regval = readl(ioaddr + WOLCmd);<br /> <br /> 	*supported = (WAKE_PHY | WAKE_UCAST | WAKE_MCAST | WAKE_BCAST<br /> 			| WAKE_ARP | WAKE_MAGIC);<br />&#64;&#64; -2695,6 +2717,7 &#64;&#64;<br /> static int netdev_set_sopass(struct net_device *dev, u8 *newval)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	u16 *sval = (u16 *)newval;<br /> 	u32 addr;<br /> <br />&#64;&#64; -2703,22 +2726,22 &#64;&#64;<br /> 	}<br /> <br /> 	/* enable writing to these registers by disabling the RX filter */<br />-	addr = readl(dev-&gt;base_addr + RxFilterAddr) &amp; ~RFCRAddressMask;<br />+	addr = readl(ioaddr + RxFilterAddr) &amp; ~RFCRAddressMask;<br /> 	addr &amp;= ~RxFilterEnable;<br />-	writel(addr, dev-&gt;base_addr + RxFilterAddr);<br />+	writel(addr, ioaddr + RxFilterAddr);<br /> <br /> 	/* write the three words to (undocumented) RFCR vals 0xa, 0xc, 0xe */<br />-	writel(addr | 0xa, dev-&gt;base_addr + RxFilterAddr);<br />-	writew(sval[0], dev-&gt;base_addr + RxFilterData);<br />+	writel(addr | 0xa, ioaddr + RxFilterAddr);<br />+	writew(sval[0], ioaddr + RxFilterData);<br /> <br />-	writel(addr | 0xc, dev-&gt;base_addr + RxFilterAddr);<br />-	writew(sval[1], dev-&gt;base_addr + RxFilterData);<br />+	writel(addr | 0xc, ioaddr + RxFilterAddr);<br />+	writew(sval[1], ioaddr + RxFilterData);<br /> <br />-	writel(addr | 0xe, dev-&gt;base_addr + RxFilterAddr);<br />-	writew(sval[2], dev-&gt;base_addr + RxFilterData);<br />+	writel(addr | 0xe, ioaddr + RxFilterAddr);<br />+	writew(sval[2], ioaddr + RxFilterData);<br /> <br /> 	/* re-enable the RX filter */<br />-	writel(addr | RxFilterEnable, dev-&gt;base_addr + RxFilterAddr);<br />+	writel(addr | RxFilterEnable, ioaddr + RxFilterAddr);<br /> <br /> 	return 0;<br /> }<br />&#64;&#64; -2726,6 +2749,7 &#64;&#64;<br /> static int netdev_get_sopass(struct net_device *dev, u8 *data)<br /> {<br /> 	struct netdev_private *np = netdev_priv(dev);<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	u16 *sval = (u16 *)data;<br /> 	u32 addr;<br /> <br />&#64;&#64; -2735,18 +2759,18 &#64;&#64;<br /> 	}<br /> <br /> 	/* read the three words from (undocumented) RFCR vals 0xa, 0xc, 0xe */<br />-	addr = readl(dev-&gt;base_addr + RxFilterAddr) &amp; ~RFCRAddressMask;<br />+	addr = readl(ioaddr + RxFilterAddr) &amp; ~RFCRAddressMask;<br /> <br />-	writel(addr | 0xa, dev-&gt;base_addr + RxFilterAddr);<br />-	sval[0] = readw(dev-&gt;base_addr + RxFilterData);<br />+	writel(addr | 0xa, ioaddr + RxFilterAddr);<br />+	sval[0] = readw(ioaddr + RxFilterData);<br /> <br />-	writel(addr | 0xc, dev-&gt;base_addr + RxFilterAddr);<br />-	sval[1] = readw(dev-&gt;base_addr + RxFilterData);<br />+	writel(addr | 0xc, ioaddr + RxFilterAddr);<br />+	sval[1] = readw(ioaddr + RxFilterData);<br /> <br />-	writel(addr | 0xe, dev-&gt;base_addr + RxFilterAddr);<br />-	sval[2] = readw(dev-&gt;base_addr + RxFilterData);<br />+	writel(addr | 0xe, ioaddr + RxFilterAddr);<br />+	sval[2] = readw(ioaddr + RxFilterData);<br /> <br />-	writel(addr, dev-&gt;base_addr + RxFilterAddr);<br />+	writel(addr, ioaddr + RxFilterAddr);<br /> <br /> 	return 0;<br /> }<br />&#64;&#64; -2909,10 +2933,11 &#64;&#64;<br /> 	int j;<br /> 	u32 rfcr;<br /> 	u32 *rbuf = (u32 *)buf;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 	/* read non-mii page 0 of registers */<br /> 	for (i = 0; i &lt; NATSEMI_PG0_NREGS/2; i++) {<br />-		rbuf[i] = readl(dev-&gt;base_addr + i*4);<br />+		rbuf[i] = readl(ioaddr + i*4);<br /> 	}<br /> <br /> 	/* read current mii registers */<br />&#64;&#64; -2920,20 +2945,20 &#64;&#64;<br /> 		rbuf[i] = mdio_read(dev, i &amp; 0x1f);<br /> <br /> 	/* read only the 'magic' registers from page 1 */<br />-	writew(1, dev-&gt;base_addr + PGSEL);<br />-	rbuf[i++] = readw(dev-&gt;base_addr + PMDCSR);<br />-	rbuf[i++] = readw(dev-&gt;base_addr + TSTDAT);<br />-	rbuf[i++] = readw(dev-&gt;base_addr + DSPCFG);<br />-	rbuf[i++] = readw(dev-&gt;base_addr + SDCFG);<br />-	writew(0, dev-&gt;base_addr + PGSEL);<br />+	writew(1, ioaddr + PGSEL);<br />+	rbuf[i++] = readw(ioaddr + PMDCSR);<br />+	rbuf[i++] = readw(ioaddr + TSTDAT);<br />+	rbuf[i++] = readw(ioaddr + DSPCFG);<br />+	rbuf[i++] = readw(ioaddr + SDCFG);<br />+	writew(0, ioaddr + PGSEL);<br /> <br /> 	/* read RFCR indexed registers */<br />-	rfcr = readl(dev-&gt;base_addr + RxFilterAddr);<br />+	rfcr = readl(ioaddr + RxFilterAddr);<br /> 	for (j = 0; j &lt; NATSEMI_RFDR_NREGS; j++) {<br />-		writel(j*2, dev-&gt;base_addr + RxFilterAddr);<br />-		rbuf[i++] = readw(dev-&gt;base_addr + RxFilterData);<br />+		writel(j*2, ioaddr + RxFilterAddr);<br />+		rbuf[i++] = readw(ioaddr + RxFilterData);<br /> 	}<br />-	writel(rfcr, dev-&gt;base_addr + RxFilterAddr);<br />+	writel(rfcr, ioaddr + RxFilterAddr);<br /> <br /> 	/* the interrupt status is clear-on-read - see if we missed any */<br /> 	if (rbuf[4] &amp; rbuf[5]) {<br />&#64;&#64; -2958,10 +2983,11 &#64;&#64;<br /> {<br /> 	int i;<br /> 	u16 *ebuf = (u16 *)buf;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 	/* eeprom_read reads 16 bits, and indexes by 16 bits */<br /> 	for (i = 0; i &lt; NATSEMI_EEPROM_SIZE/2; i++) {<br />-		ebuf[i] = eeprom_read(dev-&gt;base_addr, i);<br />+		ebuf[i] = eeprom_read(ioaddr, i);<br /> 		/* The EEPROM itself stores data bit-swapped, but eeprom_read<br /> 		 * reads it back "sanely". So we swap it back here in order to<br /> 		 * present it to userland as it is stored. */<br />&#64;&#64; -3031,7 +3057,7 &#64;&#64;<br /> <br /> static void enable_wol_mode(struct net_device *dev, int enable_intr)<br /> {<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	struct netdev_private *np = netdev_priv(dev);<br /> <br /> 	if (netif_msg_wol(np))<br />&#64;&#64; -3064,7 +3090,7 &#64;&#64;<br /> <br /> static int netdev_close(struct net_device *dev)<br /> {<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> 	struct netdev_private *np = netdev_priv(dev);<br /> <br /> 	if (netif_msg_ifdown(np))<br />&#64;&#64; -3141,10 +3167,11 &#64;&#64;<br /> static void __devexit natsemi_remove1 (struct pci_dev *pdev)<br /> {<br /> 	struct net_device *dev = pci_get_drvdata(pdev);<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 	unregister_netdev (dev);<br /> 	pci_release_regions (pdev);<br />-	iounmap ((char *) dev-&gt;base_addr);<br />+	iounmap(ioaddr);<br /> 	free_netdev (dev);<br /> 	pci_set_drvdata(pdev, NULL);<br /> }<br />&#64;&#64; -3178,7 +3205,7 &#64;&#64;<br /> {<br /> 	struct net_device *dev = pci_get_drvdata (pdev);<br /> 	struct netdev_private *np = netdev_priv(dev);<br />-	long ioaddr = dev-&gt;base_addr;<br />+	void __iomem * ioaddr = ns_ioaddr(dev);<br /> <br /> 	rtnl_lock();<br /> 	if (netif_running (dev)) {<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
