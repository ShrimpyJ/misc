    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/9/15/174">First message in thread</a></li><li class="origin"><a href="/lkml/2004/9/15/185">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/15/185">=?iso-8859-1?Q?J=F6rn?= Engel</a><ul><li><a href="/lkml/2004/9/15/192">Jeff Garzik</a></li><li><a href="/lkml/2004/9/15/194">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/15/208">Nikita Danilov</a><ul><li><a href="/lkml/2004/9/15/222">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2004/9/15/209">=?iso-8859-1?Q?J=F6rn?= Engel</a><ul><li><a href="/lkml/2004/9/15/214">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2004/9/15/228">Chris Wedgwood</a></li></ul></li><li><a href="/lkml/2004/9/15/200">Roland Dreier</a><ul><li><a href="/lkml/2004/9/15/205">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/15/256">Russell King</a></li></ul></li></ul></li><li><a href="/lkml/2004/9/15/204">Horst von Brand</a></li><li><a href="/lkml/2004/9/15/206">Brian Gerst</a></li></ul></li><li><a href="/lkml/2004/9/15/186">Dave Jones</a></li><li><a href="/lkml/2004/9/15/198">Roger Luethi</a></li><li><a href="/lkml/2004/9/15/199">"Richard B. Johnson"</a></li><li><a href="/lkml/2004/9/15/324">Roland Dreier</a><ul><li><a href="/lkml/2004/9/15/352">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/15/375">	viro&#64;parcelfa ...</a><ul><li><a href="/lkml/2004/9/16/106">David Woodhouse</a></li></ul></li><li><a href="/lkml/2004/9/16/119">David Woodhouse</a><ul><li><a href="/lkml/2004/9/16/148">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2004/9/15/359">Deepak Saxena</a><ul><li><a href="/lkml/2004/9/15/333">Linus Torvalds</a></li><li><a href="/lkml/2004/9/15/342">Deepak Saxena</a></li><li><a href="/lkml/2004/9/16/128">Geert Uytterhoeven</a><ul><li><a href="/lkml/2004/9/16/303">Deepak Saxena</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 15 Sep 2004 09:30:42 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Being more anal about iospace accesses..</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />This is a background mail mainly for driver writers and/or architecture<br />people. Or others that are just interested in really low-level hw access<br />details. Others - please feel free to ignore.<br /><br />[ This has been discussed to some degree already on the architecture <br />  mailing lists and obviously among the people who actually worked on it, <br />  but I thought I'd bounce it off linux-kernel too, in order to make<br />  people more aware of what the new type-checking does. Most people may<br />  have seen it as only generating a ton of new warnings for some crufty<br />  device drivers. ]<br /><br />The background for this iospace type-checking change is that we've long<br />had some serious confusion about how to access PCI memory mapped IO<br />(MMIO), mainly because on a PC (and some non-PC's too) that IO really does <br />look like regular memory, so you can have a driver that just accesses a <br />pointer directly, and it will actually work on most machines.<br /><br />At the same time, we've had the proper "accessor" functions (read[bwl](), <br />write[bwl]() and friends) that on purpose dropped all type information <br />from the MMIO pointer, mostly just because of historical reasons, and as a <br />result some drivers didn't use a pointer at all, but some kind of integer. <br />Sometimes even one that couldn't _fit_ a MMIO address in it on a 64-bit <br />machine.<br /><br />In short, the PCI MMIO access case was largely the same as the user<br />pointer case, except the access functions were different (readb vs<br />get_user) and they were even less lax about checking for sanity. At least<br />the user access code required a pointer with the right size.<br /><br />We've been very successful in annotating user pointers, and that found a<br />couple of bugs, and more importantly it made the kernel code much more<br />"aware" of what kind of pointer was passed around. In general, a big<br />success, I think. And an obvious example for what MMIO pointers should do.<br /><br />So lately, the kernel infrastructure for MMIO accesses has become a _lot_<br />more strict about what it accepts. Not only do the MMIO access functions<br />want a real pointer (which is already more type-checking than we did<br />before, and causes gcc to spew out lots of warnings for some drivers), but <br />as with user pointers, sparse annotations mark them as being in a <br />different address space, and building the kernel with checking on will <br />warn about mixing up address spaces. So far so good.<br /><br />So right now the current snapshots (and 2.6.9-rc2) have this enabled, and<br />some drivers will be _very_ noisy when compiled. Most of the regular ones<br />are fine, so maybe people haven't even noticed it that much, but some of<br />them were using things like "u32" to store MMIO pointers, and are<br />generally extremely broken on anything but an x86.  We'll hopefully get<br />around to fixing them up eventually, but in the meantime this should at <br />least explain the background for some of the new noise people may see.<br /><br />Perhaps even more interesting is _another_ case of driver, though: one<br />that started warning not because it was ugly and broken, but because it<br />did something fairly rare but something that does happen occasionally: it<br />mixed PIO and MMIO accesses on purpose, because it drove hardware that<br />literally uses one or the other.<br /><br />Sometimes such a "mixed interface" driver does it based on a compile<br />option that just #defines 'writel()' to 'inl()', sometimes it's a runtime<br />decision depending on the hardware or configuration. <br /><br />The anal typechecking obviously ended up being very unhappy about this, <br />since it wants "void __iomem *" for MMIO pointers, and a normal "unsigned <br />long" for PIO accesses. The compile-time option could have been easily <br />fixed up by adding the proper cast when re-defining the IO accessor, but <br />that doesn't work for the dynamic case.<br /><br />Also, the compile-time switchers often really _wanted_ to be dynamic, but<br />it was just too painful with the regular Linux IO interfaces to duplicate <br />the code and do things conditionally one way or the other.<br /><br />To make a long story even longer: rather than scrapping the typechecking,<br />or requiring drivers to do strange and nasty casts all over the place,<br />there's now a new interface in town. It's called "iomap", because it<br />extends the old "ioremap()" interface to work on the PIO accesses too.<br /><br />That way, the drivers that really want to mix both PIO and MMIO accesses<br />can very naturally do it: they just need to remap the PIO space too, the<br />same way that we've required people to remap the MMIO space for a long<br />long time.<br /><br />For example, if you don't know (or, more importantly - don't care) what <br />kind of IO interface you use, you can now do something like<br /><br />	void __iomem * map = pci_iomap(dev, bar, maxbytes);<br />	...<br />	status = ioread32(map + DRIVER_STATUS_OFFSET);<br /><br />and it will do the proper IO mapping for the named PCI BAR for that<br />device. Regardless of whether the BAR was an IO or MEM mapping. Very<br />convenient for cases where the hardware migt expose its IO window in<br />either (or sometimes both).<br /><br />Nothing in the current tree actually uses this new interface, although<br />Jeff has patches for SATA for testing (and they clean up the code quite<br />noticeably, never mind getting rid of the warnings).  The interface has<br />been implemented by yours truly for x86 and ppc64, and David did a<br />first-pass version for sparc64 too (missing the "xxxx_rep()" functions<br />that were added a bit later, I believe).<br /><br />So far experience seems to show that it's a very natural interface for<br />most non-x86 hardware - they all tend to map in both PIO and MMIO into one<br />address space _anyway_, so the two aren't really any different. It's<br />mainly just x86 and it's ilk that actually have two different interfaces<br />for the two kinds of PCI accesses, and at least in that case it's trivial<br />to encode the difference in the virtual ioremap pointer.<br /><br />The best way to explain the interface is to just point you guys at the<br />&lt;asm-generic/iomap.h&gt; file, which isn't very big, has about as much<br />comments than code, and contains nothing but the necessary function<br />declarations. The actual meaning of the functions should be pretty<br />obvious even without the comments.<br /><br />Feel free to flame or discuss rationally,<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
