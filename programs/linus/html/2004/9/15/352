    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/9/15/174">First message in thread</a></li><li><a href="/lkml/2004/9/15/174">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/15/185">=?iso-8859-1?Q?J=F6rn?= Engel</a><ul><li><a href="/lkml/2004/9/15/192">Jeff Garzik</a></li><li><a href="/lkml/2004/9/15/194">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/15/208">Nikita Danilov</a><ul><li><a href="/lkml/2004/9/15/222">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2004/9/15/209">=?iso-8859-1?Q?J=F6rn?= Engel</a><ul><li><a href="/lkml/2004/9/15/214">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2004/9/15/228">Chris Wedgwood</a></li></ul></li><li><a href="/lkml/2004/9/15/200">Roland Dreier</a><ul><li><a href="/lkml/2004/9/15/205">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/15/256">Russell King</a></li></ul></li></ul></li><li><a href="/lkml/2004/9/15/204">Horst von Brand</a></li><li><a href="/lkml/2004/9/15/206">Brian Gerst</a></li></ul></li><li><a href="/lkml/2004/9/15/186">Dave Jones</a></li><li><a href="/lkml/2004/9/15/198">Roger Luethi</a></li><li><a href="/lkml/2004/9/15/199">"Richard B. Johnson"</a></li><li><a href="/lkml/2004/9/15/324">Roland Dreier</a><ul><li class="origin"><a href="/lkml/2004/9/15/375">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/15/375">	viro&#64;parcelfa ...</a><ul><li><a href="/lkml/2004/9/16/106">David Woodhouse</a></li></ul></li><li><a href="/lkml/2004/9/16/119">David Woodhouse</a><ul><li><a href="/lkml/2004/9/16/148">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2004/9/15/359">Deepak Saxena</a><ul><li><a href="/lkml/2004/9/15/333">Linus Torvalds</a></li><li><a href="/lkml/2004/9/15/342">Deepak Saxena</a></li><li><a href="/lkml/2004/9/16/128">Geert Uytterhoeven</a><ul><li><a href="/lkml/2004/9/16/303">Deepak Saxena</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 15 Sep 2004 16:26:12 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Being more careful about iospace accesses..</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />[ Subject line changed to avoid getting caught as spam ;]<br /><br />On Wed, 15 Sep 2004, Roland Dreier wrote:<br />&gt;<br />&gt; Linus, while we're on the subject of new sparse checks, could you give<br />&gt; a quick recap of the semantics of the new __leXX types (and what<br />&gt; __bitwise means to sparse)?  I don't think I've ever seen this stuff<br />&gt; described on LKML.<br /><br />[ The bitwise checks are actually by Al Viro, but I'll explain the basic<br />  idea. Al is Cc'd so that he can add any corrections or extensions. ]<br /><br />Sparse allows a number of extra type qualifiers, including address spaces <br />and various random extra restrictions on what you can do with them. There <br />are "context" bits that allow you to use a symbol or type only in certain <br />contexts, for example, and there are type qualifiers like "noderef" that <br />just say that a pointer cannot be dereferenced (it looks _exactly_ like a <br />pointer in all other respects, but trying to actually access anything <br />through it will cause a sparse warning).<br /><br />The "bitwise" attribute is very much like the "noderef" one, in that it<br />restricts how you can use an expression of that type. Unlike "noderef",<br />it's designed for integer types, though. In fact, sparse will refuse to<br />apply the bitwise attribute to non-integer types.<br /><br />As the name suggests, a "bitwise" expression is one that is restricted to<br />only a certain "bitwise" operations that make sense within that class. In<br />particular, you can't mix a "bitwise" class with a normal integer<br />expression (the constant zero happens to be special, since it's "safe"  <br />for all bitwise ops), and in fact you can't even mix it with _another_<br />bitwise expression of a different type.<br /><br />And when I say "different", I mean even _slightly_ different. Each typedef <br />creates a type of it's own, and will thus create a bitwise type that is <br />not compatible with anything else. So if you declare<br /><br />	int __bitwise i;<br />	int __bitwise j;<br /><br />the two variables "i" and "j" are _not_ compatible, simply because they<br />were declared separately, while in the case of<br /><br />	int __bitwise i, j;<br /><br />they _are_ compatible. The above is a horribly contrieved example, as it<br />shows an extreme case that doesn't make much sense, but it shows how<br />"bitwise" always creates its own new "class".<br /><br />Normally you'd always use "__bitwise"  in a typedef, which effectively<br />makes that particular typedef one single "bitwise class". After that, you <br />can obviously declare any number of variables in that class.<br /><br />Now apart from the classes having to match, "bitwise" as it's name<br />suggests, also restricts all operations within that class to a subset of<br />"bit-safe" operations. For example, addition isn't "bit-safe", since<br />clearly the carry-chain moves bits around. But you can do normal bit-wise<br />operations, and you can compare the values against other values in the<br />same class, since those are all "bit-safe".<br /><br />Oh, as an example of something that isn't obviously bit-safe: look out for<br />things like bit negation: doing a ~ is ok on an bitwise "int" type, but it<br />is _not_ ok on a bitwise "short" or "char". Why?  Because on a bitwise<br />"int" you actually stay within the type. But doing the same thing on a<br />short or char will move "outside" the type by virtue of setting the high<br />bits (normal C semantics: a short gets promoted to an "int", so doign a<br />bitwise negation on a short will actually set the high bits).<br /><br />So as far as sparse is concerned, a "bitwise" type is not really so much <br />about endianness as it is about making sure bits are never lost or moved <br />around.<br /><br />For example, you can use the bitwise operation to verify the __GFP_XXX <br />mask bits. Right now they are just regular integers, which means that you <br />can write<br /><br />	kmalloc(GFP_KERNEL, size);<br /><br />and the compiler will not notice anything wrong. But something is<br />_seriously_ wrong: the GFP_KERNEL should be the _second_ argument. If we<br />mark it to be a "bitwise" type (which it is), that bug would have been<br />noticed immediately, and you could still do all the operations that are<br />valid of GFP_xxx values.<br /><br />See the usage?<br /><br />In the byte-order case, what we have is:<br /><br />	typedef __u16 __bitwise __le16;<br />	typedef __u16 __bitwise __be16;<br />	typedef __u32 __bitwise __le32;<br />	typedef __u32 __bitwise __be32;<br />	typedef __u64 __bitwise __le64;<br />	typedef __u64 __bitwise __be64;<br /><br />and if you think about the above rules about what is acceptable for <br />bitwise types, you'll likely immediately notivce that it automatically <br />means<br /><br /> - you can never assign a __le16 type to any other integer type or any <br />   other bitwise type. You'd get a warnign about incompatible types. Makes <br />   sense, no?<br /> - you can only do operations that are safe within that byte order. For <br />   example, it is safe to do a bitwise "&amp;" on two __le16 values. Clearly <br />   the result is meaningful.<br /> - if you want to go outside that bitwise type, you have to convert it <br />   properly first. For example, if you want to add a constant to a __le16 <br />   type, you can do so, but you have to use the proper sequence:<br /><br />	__le16 sum, a, b;<br /><br />	sum = a + b;	/* INVALID! "warning: incompatible types for operation (+)" */<br />	sum = cpu_to_le16(le16_to_cpu(a) + le16_to_cpu(b));	/* Ok */<br /><br />See? <br /><br />In short, "bitwise" is about more than just byte-order, but the semantics <br />of bitwise-restricted ops happen to be the semantics that are valid for <br />byte-order operations too.<br /><br />Oh, btw, right now you only get the warnings from sparse if you use<br />"-Wbitwise" on the command line. Without that, sparse will ignore the<br />bitwise attribute.<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
