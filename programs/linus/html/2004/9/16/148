    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/9/15/174">First message in thread</a></li><li><a href="/lkml/2004/9/15/352">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/15/375">	viro&#64;parcelfa ...</a><ul><li><a href="/lkml/2004/9/16/106">David Woodhouse</a></li></ul></li><li><a href="/lkml/2004/9/16/119">David Woodhouse</a><ul><li class="origin"><a href="/lkml/2004/9/18/53">Linus Torvalds</a><ul><li><a href="/lkml/2004/9/18/53">(Kai Henningsen)</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 16 Sep 2004 07:01:20 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Being more careful about iospace accesses..</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 16 Sep 2004, David Woodhouse wrote:<br /><br />&gt; On Wed, 2004-09-15 at 16:26 -0700, Linus Torvalds wrote:<br />&gt; &gt;  - if you want to go outside that bitwise type, you have to convert it <br />&gt; &gt;    properly first. For example, if you want to add a constant to a __le16 <br />&gt; &gt;    type, you can do so, but you have to use the proper sequence:<br />&gt; &gt; <br />&gt; &gt; 	__le16 sum, a, b;<br />&gt; &gt; <br />&gt; &gt; 	sum = a + b;	/* INVALID! "warning: incompatible types for operation (+)" */<br />&gt; &gt; 	sum = cpu_to_le16(le16_to_cpu(a) + le16_to_cpu(b));	/* Ok */<br />&gt; &gt; <br />&gt; &gt; See? <br />&gt; <br />&gt; Yeah right, that latter case is _so_ much more readable<br /><br />It's not about readability.<br /><br />It's about the first case being WRONG!<br /><br />You can't add two values in the wrong byte-order. It's not an operation <br />that makes sense. You _have_ to convert them to CPU byte order first.<br /><br />I certainly agree that the first version "looks nicer". <br /><br />&gt; It's even nicer when it ends up as:<br />&gt; <br />&gt; 	sum = cpu_to_le16(le16_to_cpu(a) + le16_to_cpu(b));	/* Ok */<br />&gt; 	sum |= c;<br />&gt; 	sum = cpu_to_le16(le16_to_cpu(sum) + le16_to_cpu(d));<br /><br />This is actually the strongest argument _against_ hiding endianness in the <br />compiler, or hiding it behind macros. Make it very explicit, and just make <br />sure there are tools (ie 'sparse') that can tell you when you do something <br />wrong.<br /><br />Any programmer who sees the above will go "well that's stupid", and <br />rewrite it as something saner instead. You can certainly rewrite it as<br /><br />	cpu_sum = le16_to_cpu(a) + le16_to_cpu(b);<br />	cpu_sum |= le16_to_cpu(c);<br />	cpu_sum += le16_to_cpu(d);<br />	sum = cpu_to_le16(d);<br /><br />which gets rid of the double conversions. <br /><br />But if you hide the endianness in macro's, you'll never see the mess at <br />all, and won't be able to fix it.<br /><br />&gt; I'd really quite like to see the real compiler know about endianness,<br />&gt; too.<br /><br />I would have agreed with you some time ago. Having been bitten by too damn <br />many bompiler bugs I'e become convinced that the compiler doing things <br />behind your back to "help" you just isn't worth it. Not in a kernel, at <br />least. It's much better to build up good typechecking and the <br />infrastructure to help you get the job done.<br /><br />Expressions like the above might happen once or twice in a project with<br />several million lines of code. It's just not worth compiler infrastructure<br />for - that just makes people use it as if it is free, and impossible to<br />find the bugs when they _do_ happen. Much better to have a type system <br />that can warn about the bad uses, but that doesn't actually change any of <br />the code generated..<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
