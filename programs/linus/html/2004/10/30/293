    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2004/10/30/293">First message in thread</a></li><li class="origin"><a href="/lkml/2004/10/31/3">Linus Torvalds</a><ul><li><a href="/lkml/2004/10/31/3">Roland Dreier</a><ul><li><a href="/lkml/2004/10/31/7">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2004/11/11/161">Greg KH</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 30 Oct 2004 20:20:53 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Sparse "context" checking..</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />I just committed the patches to the kernel to start supporting a new <br />automated correctness check that I added to sparse: the counting of static <br />"code context" information.<br /><br />The sparse infrastructure is pretty agnostic, and you can count pretty <br />much anything you want, but it's designed to test that the entry and exit <br />contexts match, and that no path through a function is ever entered with <br />conflicting contexts.<br /><br />In particular, this is designed for doing things like matching up a "lock" <br />with the pairing "unlock", and right now that's exactly what the code <br />does: it makes each spinlock count as "+1" in the context, and each <br />spinunlock count as "-1", and then hopefully it should all add up.<br /><br />It doesn't always, of course. Since it's a purely static analyser, it's <br />unhappy about code like<br /><br />	int fn(arg)<br />	{<br />		if (arg)<br />			spin_lock(lock);<br />		...<br />		if (arg)<br />			spin_unlock(lock);<br />	}<br /><br />because the code is not statically deterministic, and the stuff in between <br />can be called with or without a lock held. That said, this has long been <br />frowned upon, and there aren't that many cases where it happens.<br /><br />Right now the counting is only enabled if you use sparse, and add the <br />"-Wcontext" flag to the sparse command line by hand - and the spinlocks <br />have only been annotated for the SMP case, so right now it only works for <br />CONFIG_SMP. Details, details.<br /><br />Also, since sparse does purely local decisions, if you actually _intend_<br />to grab a lock in one function and release it in another, you need to tell<br />sparse so, by annotating the function that acquires the lock (with<br />"__acquires(lockname)") and the function that releases it (with, surprise<br />surprise, "__releases(lockname)") in the declaration. That tells sparse to<br />update the context in the callers appropriately, but it also tells sparse<br />to expect the proper entry/exit contexts for the annotated functions<br />themselves.<br /><br />I haven't done the annotation for any functions yet, so expect warnings. <br />If you do a checking run, the warnings will look something like:<br /><br />	  CHECK   kernel/resource.c<br />	kernel/resource.c:59:13: warning: context imbalance in 'r_start' - wrong count at exit<br />	kernel/resource.c:69:13: warning: context imbalance in 'r_stop' - unexpected unlock<br /><br />which just shows that "r_start" acquired a lock, and sparse didn't expect <br />it to, while "r_stop" released a lock that sparse hadn't realized it had. <br />In this case, the cause is pretty obvious, and the annotations are equally <br />so.<br /><br />A more complicated case is<br /><br />	  CHECK   kernel/sys.c<br />	kernel/sys.c:465:2: warning: context imbalance in 'sys_reboot' - different lock contexts for basic block<br /><br />where that "different lock contexts" warning means that sparse determined<br />that some code in that function was reachable with two different lock<br />contexts. In this case it's actually harmless, since what happens in this <br />case is that the code after rebooting the machine is unreachable, and <br />sparse just doesn't understand that.<br /><br />But in other cases it's more fundamental, and the lock imbalance is due to<br />dynamic data that sparse just can't understand. The warning in that case <br />can be disabled by hand, but there doesn't seem to be that many of them. A <br />full kernel build for me has about 200 warnings, and most of them seem to <br />be the benign kind (ie the kind above where one function acquires the lock <br />and another releases it, and they just haven't been annotated as such).<br /><br />The sparse thing could be extended to _any_ context that wants pairing, <br />and I just wanted to let people know about this in case they find it <br />interesting..<br /><br />			Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
