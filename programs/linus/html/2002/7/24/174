    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2002/7/23/41">First message in thread</a></li><li><a href="/lkml/2002/7/24/54">Ingo Molnar</a><ul><li><a href="/lkml/2002/7/24/40">Andrew Morton</a><ul><li><a href="/lkml/2002/7/24/57">Ingo Molnar</a></li><li class="origin"><a href="/lkml/2002/7/24/16">Linus Torvalds</a><ul><li><a href="/lkml/2002/7/24/16">george anzinger</a></li><li><a href="/lkml/2002/7/24/155">Robert Love</a></li></ul></li></ul></li><li><a href="/lkml/2002/7/24/41">William Lee Irwin III</a><ul><li><a href="/lkml/2002/7/24/75">Ingo Molnar</a><ul><li><a href="/lkml/2002/7/24/59">William Lee Irwin III</a><ul><li><a href="/lkml/2002/7/24/55">Ingo Molnar</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 24 Jul 2002 09:40:30 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [patch] irqlock patch -G3. [was Re: odd memory corruptionin2.5.27?]</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 24 Jul 2002, Andrew Morton wrote:<br />&gt;<br />&gt; But there is no bug in slab.  The bug is that spin_unlock() is<br />&gt; scheduling inside local_irq_disable().<br /><br />I disagree.<br /><br />There is no reason to believe that you can mix irq disables and<br />spinlocking willy nilly. The two have commonalities, and thinking that you<br />can build up your own special irq-safe spinlocks by hand just isn't<br />_true_.<br /><br />The bug is conceptually definitely in slab.c - although we can't blame it<br />too much since we've modified some behaviour.<br /><br />Just as an example, in the not too distant future what _will_ happen is<br />that<br /><br />	spin_lock_irqsave()<br />	..<br />	spin_unlock_irqrestore()<br /><br />will not necessarily increment the preemtion count. Why should they?<br />They've disabled local interrupts, so there's no preemption to protect<br />against. That's just an _obvious_ optimization.<br /><br />But that optimization also means that you _have_ to pair the things<br />properly. It is incorrect and buggy to play pairing games. The same way<br />you could not pair the global irq lock with a local unlock, you cannot<br />play games with local_irq_disable() and spinlocks, and expect it to "just<br />work".<br /><br />Normal code should always pair these primitives. And, in fact, 99% of all<br />code _does_ pair them properly, and people would consider anything else<br />strange.<br /><br />The 1% (or less) of code that thinks it wants to be clever will have to<br />live with that decision. We will have code that does the preemption<br />regions by hand, and some day you will need to do<br /><br />	spin_lock_irqsave(..)<br />	...<br />	...<br />	preempt_disable();<br />	spin_unlock(..);<br />	...<br />	...<br />	local_irq_restore(..);<br />	preempt_enable();<br /><br />if you want to do what slab apparently wants to do right now.<br /><br />In short, you should _always_ write out what you actually expect of the<br />environment. Making the assumption that "spin_lock_irqsave" is 100% the<br />same as "local_irq_save + preempt_disable + __spin_lock" is a BUG, simply<br />because it assumes something that has never been guaranteed, and is<br />nothign but an implementation detail.<br /><br />&gt; Are you implying that all code which does spin_unlock() inside<br />&gt; local_irq_disable() needs to be converted to use _raw_spin_unlock()?<br />&gt; If so then, umm, ugh.  I hope that the debug check is working<br />&gt; for CONFIG_PREEMPT=n.<br /><br />I'm saying that preempt will have the irq check (for safety and debugging,<br />and it will scream if somebody does something bad), and I'm saying<br />outright that if you expect to not be scheduled, you should _tell_ the<br />kernel so, instead of just thinking that it's implied by something else.<br /><br />You can nest spinlocks any amount you want, but no, you cannot just assume<br />that nesting irq disables and spinlocks gives you the same thing as using<br />the irq-safe spinlocks.<br /><br />We can easily add a debugging check to spin_unlock() that says:<br /><br />	/* Somebody messed up, doesn't hold any other preemption thing<br />	 * than this lock that is now getting released, and has interrupts<br />	 * disabled<br />	 */<br />	BUG_ON(preempt_count() == 1 &amp;&amp; interrupts_enabled())<br /><br />No?<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
