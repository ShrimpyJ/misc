    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2002/7/13/97">First message in thread</a></li><li><a href="/lkml/2002/7/13/97">Andi Kleen</a><ul><li class="origin"><a href="/lkml/2002/7/14/83">Linus Torvalds</a><ul><li><a href="/lkml/2002/7/14/83">Andi Kleen</a></li><li><a href="/lkml/2002/7/14/147">(Eric W. Biederman)</a><ul><li><a href="/lkml/2002/7/15/140">Sandy Harris</a><ul><li><a href="/lkml/2002/7/15/139">Chris Friesen</a></li><li><a href="/lkml/2002/7/16/92">(Eric W. Biederman)</a></li></ul></li></ul></li><li><a href="/lkml/2002/7/16/179">"Martin J. Bligh"</a></li><li><a href="/lkml/2002/7/16/237">Michael Hohnbaum</a></li><li><a href="/lkml/2002/7/16/246">Matthew Dobson</a></li></ul></li><li><a href="/lkml/2002/7/15/176">Matthew Dobson</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 14 Jul 2002 12:17:25 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [patch[ Simple Topology API</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />[ I've been off-line for a week, so I didn't follow all of the discussion,<br />  but here goes anyway ]<br /><br />On 13 Jul 2002, Andi Kleen wrote:<br />&gt;<br />&gt; Current x86-64 NUMA essentially has no 'nodes', just each CPU has<br />&gt; local memory that is slightly faster than remote memory. This means<br />&gt; the node number would be always identical to the CPU number. As long<br />&gt; as the API provides it's ok for me. Just the node concept will not be<br />&gt; very useful on that platform. memblk will also be identity mapped to<br />&gt; node/cpu.<br /><br />The whole "node" concept sounds broken. There is no such thing as a node,<br />since even within nodes latencies will easily differ for different CPU's<br />if you have local memories for CPU's within a node (which is clearly the<br />only sane thing to do).<br /><br />If you want to model memory behaviour, you should have memory descriptors<br />(in linux parlance, "zone_t") have an array of latencies to each CPU. That<br />latency is _not_ a "is this memory local to this CPU" kind of number, that<br />simply doesn't make any sense. The fact is, what matters is the number of<br />hops. Maybe you want to allow one hop, but not five.<br /><br />Then, make the memory binding interface a function of just what kind of<br />latency you allow from a set X of CPU's. Simple, straightforward, and it<br />has a direct meaning in real life, which makes it unabiguous.<br /><br />So your "memory affinity" system call really needs just one number: the<br />acceptable latency. You may also want to have a CPU-set argument, although<br />I suspect that it's equally correct to just assume that the CPU-set is the<br />set of CPU's that the process can already run on.<br /><br />After that, creating a new zone array is nothing more than:<br /><br /> - give each zone a "latency value", which is simply the minimum of all<br />   the latencies for that zone from CPU's that are in the CPU set.<br /><br /> - sort the zone array, lowest latency first.<br /><br /> - the passed-in latency is the cut-off-point - clear the end of the<br />   array (with the sanity check that you always accept one zone, even if<br />   it happens to have a latency higher than the one passed in).<br /><br />End result: you end up with a priority-sorted array of acceptable zones.<br />In other words, a zone list. Which iz _exactly_ what you want anyway<br />(that's what the current "zone_table" is.<br /><br />And then you associate that zone-list with the process, and use that<br />zone-list for all process allocations.<br /><br />Advantages:<br /><br /> - very direct mapping to what the hardware actually does<br /><br /> - no complex data structures for topology<br /><br /> - works for all topologies, the process doesn't even have to know, you<br />   can trivially encode it all internally in the kernel by just having the<br />   CPU latency map for each memory zone we know about.<br /><br />Disadvantages:<br /><br /> - you cannot create "crazy" memory bindings. You can only say "I don't<br />   want to allocate from slow memory". You _can_ do crazy things by<br />   initially using a different CPU binding, then doing the memory<br />   binding, and then re-doing the CPU binding. So if you _want_ bad memory<br />   bindings you can create them, but you have to work at it.<br /><br /> - we have to use some standard latency measure, either purely time-based<br />   (which changes from machine to machine), or based on some notion of<br />   "relative to local memory".<br /><br />My personal suggestion would be the "relative to local memory" thing, and<br />call that 10 units. So a cross-CPU (but same module) hop might imply a<br />latency of 15, which a memory access that goes over the backbone between<br />modules might be a 35. And one that takes two hops might be 55.<br /><br />So then, for each CPU in a machine, you can _trivially_ create the mapping<br />from each memory zone to that CPU. And that's all you really care about.<br /><br />No?<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
