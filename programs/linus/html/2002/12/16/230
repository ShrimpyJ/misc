    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2002/12/9/13">First message in thread</a></li><li><a href="/lkml/2002/12/9/96">(Linus Torvalds)</a><ul><li><a href="/lkml/2002/12/9/132">Dave Jones</a><ul><li><a href="/lkml/2002/12/9/134">"H. Peter Anvin"</a><ul><li><a href="/lkml/2002/12/28/86">Ville Herva</a><ul><li><a href="/lkml/2002/12/28/140">Christian Leber</a></li><li><a href="/lkml/2002/12/30/46">Dave Jones</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2002/12/16/235">Linus Torvalds</a><ul><li><a href="/lkml/2002/12/16/235">Dave Jones</a><ul><li><a href="/lkml/2002/12/16/244">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2002/12/16/230/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 16 Dec 2002 16:47:00 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Intel P6 vs P7 system call performance</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Mon, 9 Dec 2002, Dave Jones wrote:<br />&gt; <br />&gt; Time to look into an alternative like SYSCALL perhaps ?<br /><br />Well, here's a very raw first try at using intel sysenter/sysexit.<br /><br />It does actually work, I've done a "hello world" program that used <br />sysenter to enter the kernel, but kernel exit requires knowing where to <br />return to (the SYSENTER_RETURN define in entry.S), and I didn't set up a <br />fixmap entry for this yet, so I don't have a good value to return to yet.<br /><br />But this, together with a fixmap entry that is user-readable (and thus<br />executable) that contains the "sysenter" instruction (and enough setup so<br />that %ebp points to the stack we want to return with), and together with<br />some debugging should get you there.<br /><br />WARNING! I may be setting up the stack slightly incorrectly, since this<br />also hurls chunks when debugging. Dunno. Ingo, care to take a look?<br /><br />Btw, that per-CPU sysenter entry-point is really clever of me, but it's <br />not strictly NMI-safe. There's a single-instruction window between having <br />started "sysenter" and having a valid kernel stack, and if an NMI comes in <br />at that point, the NMI will now have a bogus stack pointer.<br /><br />That NMI problem is pretty fundamentally unfixable due to the stupid<br />sysenter semantics, but we could just make the NMI handlers be real<br />careful about it and fix it up if it happens.<br /><br />Most of the diff here is actually moving around some of the segments, <br />since sysenter/sysexit wants them in one particular order. The setup code <br />to initialize sysenter is itself pretty trivial.<br /><br />		Linus<br /><br />----<br />===== arch/i386/kernel/sysenter.c 1.1 vs edited =====<br />--- 1.1/arch/i386/kernel/sysenter.c	Sat Dec 14 04:38:56 2002<br />+++ edited/arch/i386/kernel/sysenter.c	2002-12-16 16:37:32.000000000 -0800<br />&#64;&#64; -0,0 +1,52 &#64;&#64;<br />+/*<br />+ * linux/arch/i386/kernel/sysenter.c<br />+ *<br />+ * (C) Copyright 2002 Linus Torvalds<br />+ *<br />+ * This file contains the needed initializations to support sysenter.<br />+ */<br />+<br />+#include &lt;linux/init.h&gt;<br />+#include &lt;linux/smp.h&gt;<br />+#include &lt;linux/thread_info.h&gt;<br />+#include &lt;linux/gfp.h&gt;<br />+<br />+#include &lt;asm/cpufeature.h&gt;<br />+#include &lt;asm/msr.h&gt;<br />+<br />+extern asmlinkage void sysenter_entry(void);<br />+<br />+static void __init enable_sep_cpu(void *info)<br />+{<br />+	unsigned long page = __get_free_page(GFP_ATOMIC);<br />+	int cpu = get_cpu();<br />+	unsigned long *esp0_ptr = &amp;(init_tss + cpu)-&gt;esp0;<br />+	unsigned long rel32;<br />+<br />+	rel32 = (unsigned long) sysenter_entry - (page+11);<br />+<br />+	<br />+	*(short *) (page+0) = 0x258b;		/* movl xxxxx,%esp */<br />+	*(long **) (page+2) = esp0_ptr;<br />+	*(char *)  (page+6) = 0xe9;		/* jmp rl32 */<br />+	*(long *)  (page+7) = rel32;<br />+<br />+	wrmsr(0x174, __KERNEL_CS, 0);		/* SYSENTER_CS_MSR */<br />+	wrmsr(0x175, page+PAGE_SIZE, 0);	/* SYSENTER_ESP_MSR */<br />+	wrmsr(0x176, page, 0);			/* SYSENTER_EIP_MSR */<br />+<br />+	printk("Enabling SEP on CPU %d\n", cpu);<br />+	put_cpu();	<br />+}<br />+<br />+static int __init sysenter_setup(void)<br />+{<br />+	if (!boot_cpu_has(X86_FEATURE_SEP))<br />+		return 0;<br />+<br />+	enable_sep_cpu(NULL);<br />+	smp_call_function(enable_sep_cpu, NULL, 1, 1);<br />+	return 0;<br />+}<br />+<br />+__initcall(sysenter_setup);<br />===== arch/i386/kernel/Makefile 1.30 vs edited =====<br />--- 1.30/arch/i386/kernel/Makefile	Sat Dec 14 04:38:56 2002<br />+++ edited/arch/i386/kernel/Makefile	Mon Dec 16 13:43:57 2002<br />&#64;&#64; -29,6 +29,7 &#64;&#64;<br /> obj-$(CONFIG_PROFILING)		+= profile.o<br /> obj-$(CONFIG_EDD)             	+= edd.o<br /> obj-$(CONFIG_MODULES)		+= module.o<br />+obj-y				+= sysenter.o<br /> <br /> EXTRA_AFLAGS   := -traditional<br /> <br />===== arch/i386/kernel/entry.S 1.41 vs edited =====<br />--- 1.41/arch/i386/kernel/entry.S	Fri Dec  6 09:43:43 2002<br />+++ edited/arch/i386/kernel/entry.S	Mon Dec 16 16:17:47 2002<br />&#64;&#64; -94,7 +94,7 &#64;&#64;<br /> 	movl %edx, %ds; \<br /> 	movl %edx, %es;<br /> <br />-#define RESTORE_ALL	\<br />+#define RESTORE_REGS	\<br /> 	popl %ebx;	\<br /> 	popl %ecx;	\<br /> 	popl %edx;	\<br />&#64;&#64; -104,14 +104,25 &#64;&#64;<br /> 	popl %eax;	\<br /> 1:	popl %ds;	\<br /> 2:	popl %es;	\<br />-	addl $4, %esp;	\<br />-3:	iret;		\<br /> .section .fixup,"ax";	\<br />-4:	movl $0,(%esp);	\<br />+3:	movl $0,(%esp);	\<br /> 	jmp 1b;		\<br />-5:	movl $0,(%esp);	\<br />+4:	movl $0,(%esp);	\<br /> 	jmp 2b;		\<br />-6:	pushl %ss;	\<br />+.previous;		\<br />+.section __ex_table,"a";\<br />+	.align 4;	\<br />+	.long 1b,3b;	\<br />+	.long 2b,4b;	\<br />+.previous<br />+<br />+<br />+#define RESTORE_ALL	\<br />+	RESTORE_REGS	\<br />+	addl $4, %esp;	\<br />+1:	iret;		\<br />+.section .fixup,"ax";   \<br />+2:	pushl %ss;	\<br /> 	popl %ds;	\<br /> 	pushl %ss;	\<br /> 	popl %es;	\<br />&#64;&#64; -120,11 +131,11 &#64;&#64;<br /> .previous;		\<br /> .section __ex_table,"a";\<br /> 	.align 4;	\<br />-	.long 1b,4b;	\<br />-	.long 2b,5b;	\<br />-	.long 3b,6b;	\<br />+	.long 1b,2b;	\<br /> .previous<br /> <br />+<br />+<br /> ENTRY(lcall7)<br /> 	pushfl			# We get a different stack layout with call<br /> 				# gates, which has to be cleaned up later..<br />&#64;&#64; -219,6 +230,39 &#64;&#64;<br /> 	cli<br /> 	jmp need_resched<br /> #endif<br />+<br />+#define SYSENTER_RETURN 0<br />+<br />+	# sysenter call handler stub<br />+	ALIGN<br />+ENTRY(sysenter_entry)<br />+	sti<br />+	pushl $(__USER_DS)<br />+	pushl %ebp<br />+	pushfl<br />+	pushl $(__USER_CS)<br />+	pushl $SYSENTER_RETURN<br />+<br />+	pushl %eax<br />+	SAVE_ALL<br />+	GET_THREAD_INFO(%ebx)<br />+	cmpl $(NR_syscalls), %eax<br />+	jae syscall_badsys<br />+<br />+	testb $_TIF_SYSCALL_TRACE,TI_FLAGS(%ebx)<br />+	jnz syscall_trace_entry<br />+	call *sys_call_table(,%eax,4)<br />+	movl %eax,EAX(%esp)<br />+	cli<br />+	movl TI_FLAGS(%ebx), %ecx<br />+	testw $_TIF_ALLWORK_MASK, %cx<br />+	jne syscall_exit_work<br />+	RESTORE_REGS<br />+	movl 4(%esp),%edx<br />+	movl 16(%esp),%ecx<br />+	sti<br />+	sysexit<br />+<br /> <br /> 	# system call handler stub<br /> 	ALIGN<br />===== arch/i386/kernel/head.S 1.18 vs edited =====<br />--- 1.18/arch/i386/kernel/head.S	Thu Dec  5 18:56:49 2002<br />+++ edited/arch/i386/kernel/head.S	Mon Dec 16 14:14:44 2002<br />&#64;&#64; -414,8 +414,8 &#64;&#64;<br /> 	.quad 0x0000000000000000	/* 0x0b reserved */<br /> 	.quad 0x0000000000000000	/* 0x13 reserved */<br /> 	.quad 0x0000000000000000	/* 0x1b reserved */<br />-	.quad 0x00cffa000000ffff	/* 0x23 user 4GB code at 0x00000000 */<br />-	.quad 0x00cff2000000ffff	/* 0x2b user 4GB data at 0x00000000 */<br />+	.quad 0x0000000000000000	/* 0x20 unused */<br />+	.quad 0x0000000000000000	/* 0x28 unused */<br /> 	.quad 0x0000000000000000	/* 0x33 TLS entry 1 */<br /> 	.quad 0x0000000000000000	/* 0x3b TLS entry 2 */<br /> 	.quad 0x0000000000000000	/* 0x43 TLS entry 3 */<br />&#64;&#64; -425,22 +425,25 &#64;&#64;<br /> <br /> 	.quad 0x00cf9a000000ffff	/* 0x60 kernel 4GB code at 0x00000000 */<br /> 	.quad 0x00cf92000000ffff	/* 0x68 kernel 4GB data at 0x00000000 */<br />-	.quad 0x0000000000000000	/* 0x70 TSS descriptor */<br />-	.quad 0x0000000000000000	/* 0x78 LDT descriptor */<br />+	.quad 0x00cffa000000ffff	/* 0x73 user 4GB code at 0x00000000 */<br />+	.quad 0x00cff2000000ffff	/* 0x7b user 4GB data at 0x00000000 */<br />+<br />+	.quad 0x0000000000000000	/* 0x80 TSS descriptor */<br />+	.quad 0x0000000000000000	/* 0x88 LDT descriptor */<br /> <br /> 	/* Segments used for calling PnP BIOS */<br />-	.quad 0x00c09a0000000000	/* 0x80 32-bit code */<br />-	.quad 0x00809a0000000000	/* 0x88 16-bit code */<br />-	.quad 0x0080920000000000	/* 0x90 16-bit data */<br />-	.quad 0x0080920000000000	/* 0x98 16-bit data */<br />+	.quad 0x00c09a0000000000	/* 0x90 32-bit code */<br />+	.quad 0x00809a0000000000	/* 0x98 16-bit code */<br /> 	.quad 0x0080920000000000	/* 0xa0 16-bit data */<br />+	.quad 0x0080920000000000	/* 0xa8 16-bit data */<br />+	.quad 0x0080920000000000	/* 0xb0 16-bit data */<br /> 	/*<br /> 	 * The APM segments have byte granularity and their bases<br /> 	 * and limits are set at run time.<br /> 	 */<br />-	.quad 0x00409a0000000000	/* 0xa8 APM CS    code */<br />-	.quad 0x00009a0000000000	/* 0xb0 APM CS 16 code (16 bit) */<br />-	.quad 0x0040920000000000	/* 0xb8 APM DS    data */<br />+	.quad 0x00409a0000000000	/* 0xb8 APM CS    code */<br />+	.quad 0x00009a0000000000	/* 0xc0 APM CS 16 code (16 bit) */<br />+	.quad 0x0040920000000000	/* 0xc8 APM DS    data */<br /> <br /> #if CONFIG_SMP<br /> 	.fill (NR_CPUS-1)*GDT_ENTRIES,8,0 /* other CPU's GDT */<br />===== include/asm-i386/segment.h 1.2 vs edited =====<br />--- 1.2/include/asm-i386/segment.h	Mon Aug 12 10:56:27 2002<br />+++ edited/include/asm-i386/segment.h	Mon Dec 16 14:08:09 2002<br />&#64;&#64; -9,8 +9,8 &#64;&#64;<br />  *   2 - reserved<br />  *   3 - reserved<br />  *<br />- *   4 - default user CS		&lt;==== new cacheline<br />- *   5 - default user DS<br />+ *   4 - unused			&lt;==== new cacheline<br />+ *   5 - unused<br />  *<br />  *  ------- start of TLS (Thread-Local Storage) segments:<br />  *<br />&#64;&#64; -25,16 +25,18 &#64;&#64;<br />  *<br />  *  12 - kernel code segment		&lt;==== new cacheline<br />  *  13 - kernel data segment<br />- *  14 - TSS<br />- *  15 - LDT<br />- *  16 - PNPBIOS support (16-&gt;32 gate)<br />- *  17 - PNPBIOS support<br />- *  18 - PNPBIOS support<br />+ *  14 - default user CS<br />+ *  15 - default user DS<br />+ *  16 - TSS<br />+ *  17 - LDT<br />+ *  18 - PNPBIOS support (16-&gt;32 gate)<br />  *  19 - PNPBIOS support<br />  *  20 - PNPBIOS support<br />- *  21 - APM BIOS support<br />- *  22 - APM BIOS support<br />- *  23 - APM BIOS support <br />+ *  21 - PNPBIOS support<br />+ *  22 - PNPBIOS support<br />+ *  23 - APM BIOS support<br />+ *  24 - APM BIOS support<br />+ *  25 - APM BIOS support <br />  */<br /> #define GDT_ENTRY_TLS_ENTRIES	3<br /> #define GDT_ENTRY_TLS_MIN	6<br />&#64;&#64; -42,10 +44,10 &#64;&#64;<br /> <br /> #define TLS_SIZE (GDT_ENTRY_TLS_ENTRIES * 8)<br /> <br />-#define GDT_ENTRY_DEFAULT_USER_CS	4<br />+#define GDT_ENTRY_DEFAULT_USER_CS	14<br /> #define __USER_CS (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)<br /> <br />-#define GDT_ENTRY_DEFAULT_USER_DS	5<br />+#define GDT_ENTRY_DEFAULT_USER_DS	15<br /> #define __USER_DS (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)<br /> <br /> #define GDT_ENTRY_KERNEL_BASE	12<br />&#64;&#64; -56,14 +58,14 &#64;&#64;<br /> #define GDT_ENTRY_KERNEL_DS		(GDT_ENTRY_KERNEL_BASE + 1)<br /> #define __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)<br /> <br />-#define GDT_ENTRY_TSS			(GDT_ENTRY_KERNEL_BASE + 2)<br />-#define GDT_ENTRY_LDT			(GDT_ENTRY_KERNEL_BASE + 3)<br />+#define GDT_ENTRY_TSS			(GDT_ENTRY_KERNEL_BASE + 4)<br />+#define GDT_ENTRY_LDT			(GDT_ENTRY_KERNEL_BASE + 5)<br /> <br />-#define GDT_ENTRY_PNPBIOS_BASE		(GDT_ENTRY_KERNEL_BASE + 4)<br />-#define GDT_ENTRY_APMBIOS_BASE		(GDT_ENTRY_KERNEL_BASE + 9)<br />+#define GDT_ENTRY_PNPBIOS_BASE		(GDT_ENTRY_KERNEL_BASE + 6)<br />+#define GDT_ENTRY_APMBIOS_BASE		(GDT_ENTRY_KERNEL_BASE + 11)<br /> <br /> /*<br />- * The GDT has 21 entries but we pad it to cacheline boundary:<br />+ * The GDT has 23 entries but we pad it to cacheline boundary:<br />  */<br /> #define GDT_ENTRIES 24<br /> <br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
