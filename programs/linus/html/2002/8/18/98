    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2002/8/17/133">First message in thread</a></li><li><a href="/lkml/2002/8/18/42">Linus Torvalds</a><ul><li><a href="/lkml/2002/8/18/18">Oliver Xymoron</a><ul><li class="origin"><a href="/lkml/2002/8/18/75">Linus Torvalds</a><ul><li><a href="/lkml/2002/8/18/75">Robert Love</a></li><li><a href="/lkml/2002/8/18/100">Oliver Xymoron</a></li><li><a href="/lkml/2002/8/23/169">Pavel Machek</a><ul><li><a href="/lkml/2002/8/23/183">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 18 Aug 2002 09:59:41 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] (0/4) Entropy accounting fixes</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Sun, 18 Aug 2002, Oliver Xymoron wrote:<br />&gt; <br />&gt; The key word is actually conservative, as in conservative estimate.<br />&gt; Conservative here means less than or equal to.<br /><br />Your argument is that even with a gigahz logic analyzer on the network<br />line, you should certainly see randomness that is worth considering.<br /><br />I dare you to actually show perfect correlation from it: the interrupt may<br />be synchronized to the PCI clock, but the code executed there-after<br />certainly will not. And even if the machine is 100% idle, and the whole<br />working set fits in the L1 cache, the DMA generated by the packet itself<br />will result in cache invalidations.<br /><br />In other words, in order for you to actually be able to predict the TSC<br />from the outside, you'd have to not just have the gigahz logic analyzer on<br />the network line, you' dalso have to be able to correlate the ethernet<br />heartbeat to the PCI clock (which you probably could do by looking at the<br />timing of the reply packets from a ping flood, although it would be<br />"interestng" to say the least and probably depends on how the network card<br />generates the ethernet clock), _and_ you'd have to be able to do a cache<br />eviction analysis (which in turn requires knowing the initial memory<br />layout for the kernel data structures for networking).<br /><br />And your argument that there is zero randomness in the TSC _depends_ on<br />your ability to perfectly estimate what the TSC is. If you cannot do it,<br />there is obviously at least one bit of randomness there. So I don't think<br />your "zero" is a good conservative estimate.<br /><br />At some point being conservative turns into being useless [ insert <br />obligatory political joke here ].<br /><br />[ Side note: the most common source of pseudo-random numbers is the old<br />  linear congruental generator, which really is a sampling of a "beat"<br />  between two frequencies that are supposed to be "close", but prime.<br /><br />  That's a fairly simple and accepted pseudo-random generator _despite_<br />  the fact that the two frequencies are totally known, and there is zero<br />  noise inserted. I'll bet you'll see a _very_ hard-to-predict stream from<br />  something like the PCI clock / CPU clock thing, with noise inserted<br />  thanks to things like cache misses and shared bus interactions. Never <br />  mind the _real_ noise of having a work-load. ]<br /><br />&gt; No, it says /dev/random is primarily useful for generating large<br />&gt; (&gt;&gt;160 bit) keys.<br /><br />Which is exactly what something like sshd would want to use for generating <br />keys for the machine, right? That is _the_ primary reason to use <br />/dev/random.<br /><br />Yet apparently our /dev/random has been too conservative to be actually <br />useful, because (as you point out somewhere else) even sshd uses <br />/dev/urandom for the host key generation by default.<br /><br />That is really sad. That is the _one_ application that is common and that <br />should really have a reason to maybe care about /dev/random vs urandom. <br />And that application uses urandom. To me that says that /dev/random has <br />turned out to be less than useful in real life.<br /><br />Is there anything that actually uses /dev/random at all (except for <br />clueless programs that really don't need to)?<br /><br />Please realize that _this_ is my worry: making /dev/random so useless <br />that any practical program has no choice but to look elsewhere.<br /><br />&gt; Actually, half of the point here is in fact to make /dev/urandom safer<br />&gt; too, by allowing mixing of untrusted data that would otherwise<br />&gt; compromise /dev/random.<br /><br />Now this I absolutely agree with. The xor'ing of the buffer data is <br />clearly a good idea. I agree 100% with this part. You'll see no arguments <br />against this part at all.<br /><br />&gt;		 99.9% of users aren't using network sampling<br />&gt; currently, after these patches we can turn it on for everyone and<br />&gt; still sleep well at night. See?<br /><br />Oh, that's the _good_ part. Yes. <br /><br />The bad part is that I think our current /dev/random is close to useless <br />already, and I'd like to reverse that trend.<br /><br />&gt; That is an interesting point. A counterpoint is if we account so much as<br />&gt; 1 bit of entropy per network interrupt on a typical system, the system<br />&gt; will basically _always_ feel comfortable (see /proc/interrupts). It will<br />&gt; practically never block and thus it is again identical to /dev/urandom.<br /><br />But what's the problem with that? The "/dev/random may block" is not the <br />intrisic value of /dev/random - if people want to wait they are much <br />better off just using "sleep(1)" than trying to read from /dev/random.<br /><br />My argument is that on a typical system there really _is_ so much<br />randomness that /dev/random is actually a useful thing. I think that you'd<br />have to _work_ at finding a system where /dev/random should block under<br />any normal use (where "normal use" also obviously means that only programs<br />that really need it would use it, ie ssh-keygen etc).<br /><br />			Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
