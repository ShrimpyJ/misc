    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2002/11/17/68">First message in thread</a></li><li><a href="/lkml/2002/11/17/128">Linus Torvalds</a><ul><li><a href="/lkml/2002/11/17/132">Ulrich Drepper</a><ul><li class="origin"><a href="/lkml/2002/11/17/169">Linus Torvalds</a><ul><li><a href="/lkml/2002/11/17/169">Ulrich Drepper</a><ul><li><a href="/lkml/2002/11/17/171">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2002/11/17/154">Jamie Lokier</a><ul><li><a href="/lkml/2002/11/17/170">Ulrich Drepper</a><ul><li><a href="/lkml/2002/11/18/318">Jamie Lokier</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 17 Nov 2002 17:33:23 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [patch] threading fix, tid-2.5.47-A3</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Sun, 17 Nov 2002, Ulrich Drepper wrote:<br />&gt; <br />&gt; &gt; Hmm? I _think_ NPTL is fine with the current semantics, right? It just<br />&gt; &gt; sets both of the current flags, and that's all it really wants? Uli?<br />&gt; <br />&gt; Not for the fork() implementation.  With the patch I've replaced the<br />&gt; fork() syscall with an clone() syscall:<br />&gt; <br />&gt;   sys_clone(CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD, 0,<br />&gt; 	    NULL, NULL, &amp;THREAD_SELF-&gt;tid)<br />&gt; <br />&gt; I.e., the information is stored only in the child.<br /><br />And the point of this is? The child has to re-initialize it's pthread <br />structures anyway after a fork, since the child certainly doesn't have the <br />threads that the fork()ing parent had. I don't see how the TID paths help <br />you there, you still have to make sure that if/when the child tries to <br />create new threads of its own, it re-initializes everything first.<br /><br />&gt; If you dislike the introduction of the additional flag you can use the<br />&gt; less obvious way of the first patch: check whether CLONE_VM is set.<br />&gt; Ingo said you'd dislike this (probably with good reason) but these since<br />&gt; CLONE_CHILD_SETTID and CLONE_PARENT_SETTID have exactly the same<br />&gt; semantics if CLONE_VM is set spending a flag bit might just be as ugly.<br /><br />The thing is, I don't see the _point_. I refuse to add magic flags that<br />are just some obscure implementation issue inside of glibc. A flag should<br />have a _meaning_, and I seriously dislike the "meaning" behind<br />CLONE_CHILD_SETTID. I dislike in particular its asynchronous behaviour, <br />which is visible in the parent if CLONE_VM isn't set.<br /><br />Asynchronous behaviour without good reason is _bad_. Clearly, CLEARTID<br />needs to be async, since it happens when the child exits, which is <br />fundamentally asynchronous for the parent. But SETTID is certainly _not_ <br />an asynchronous thing.<br /><br />&gt; And one last thing.  I am toying with the idea of having a function<br />&gt; <br />&gt;   int cfork (pid_t *);<br />&gt; <br />&gt; (name can be discussed) which works like fork() but always returns the<br />&gt; PID to the caller (in the memory location pointed to by the parameter),<br />&gt; even in the child.  This seems to be the interface fork() should have<br />&gt; gotten from the beginning.  For this implementation something like the<br />&gt; CLONE_CHILD_SETTID flag should be available.<br /><br />Actually, the above interface is most easily done by just havign<br />CLONE_SETTID take effect _before_ we start copying the VM space. Which may<br />well make sense (and avoids any extra page dirtying and COW breakage, as<br />well as all asynchronous behaviour).<br /><br />So moving the CLONE_SETTID check to _before_ copy_mm() will give you<br />exactly the semantics you want. I wouldn't have any issues with that<br />approach (it's certainly synchronous, and in fact it has to be done there<br />if we want to use this for non-CLONE_VM anyway).<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
