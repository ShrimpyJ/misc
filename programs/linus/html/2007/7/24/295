    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/7/23/249">First message in thread</a></li><li><a href="/lkml/2007/7/24/169">Nick Piggin</a><ul><li><a href="/lkml/2007/7/24/171">Satyam Sharma</a><ul><li><a href="/lkml/2007/7/24/181">Nick Piggin</a></li><li class="origin"><a href="/lkml/2007/7/24/349">Linus Torvalds</a><ul><li><a href="/lkml/2007/7/24/349">Satyam Sharma</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 24 Jul 2007 10:12:50 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 8/8] i386: bitops: smp_mb__{before, after}_clear_bit() definitions</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 24 Jul 2007, Satyam Sharma wrote:<br />&gt; <br />&gt; Looks like when you said "CPU memory barrier extends to all memory<br />&gt; references" you were probably referring to a _given_ CPU ... yes,<br />&gt; that statement is correct in that case.<br /><br />No. CPU memory barriers extend to all CPU's. End of discussion.<br /><br />It's not about "that cacheline". The whole *point* of a CPU memory barrier <br />is that it's about independent memory accesses.<br /><br />Yes, for a memory barrier to be effective, all CPU's involved in the <br />transaction have to have the barriers - the same way a lock needs to be <br />taken by everybody in order for it to make sense - but the point is, CPU <br />barriers are about *global* behaviour, not local ones.<br /><br />So there's a *huge* difference between<br /><br />	clear_bit(x,y);<br /><br />and<br /><br />	clear_bit(x,y);<br />	smp_mb__before_after_clear_bit();<br /><br />and it has absolutely nothing to do with the particular cacheline that "y" <br />is in, it's about the *global* memory ordering.<br /><br />Any write you do after that "smp_mb__before_after_clear_bit()" will be <br />guaranteed to be visible to _other_ CPU's *after* they have seen the bit <br />being cleared. Yes, those other CPU's need to have a read barrier between <br />reading the bit and reading some other thign, but the point is, this hass <br />*nothing* to do with cache coherency, and the particular cache line that <br />"y" is in.<br /><br />And no, "smp_mb__before/after_clear_bit()" must *not* be just an empty "do <br />{} while (0)". It needs to be a compiler barrier even when it has no <br />actual CPU meaning, unless clear_bit() itself is guaranteed to be a <br />compiler barrier (which it isn't, although the "volatile" on the asm in <br />practice makes it something *close* to that).<br /><br />Why? Think of the sequence like this:<br /><br />	clear_bit(x,y);<br />	smp_mb__after_clear_bit();<br />	other_variable = 10;<br /><br />the whole *point* of this sequence is that if another CPU does<br /><br />	x = other_variable;<br />	smp_rmb();<br />	bit = test_bit(x,y)<br /><br />then if it sees "x" being 10, then the bit *has* to be clear.<br /><br />And this is why the compiler barrier in "smp_mb__after_clear_bit()" needs <br />to be a compiler barrier:<br /><br /> - it doesn't matter for the action of the "clear_bit()" itself: that one <br />   is locked, and on x86 it thus also happens to be a serializing <br />   instruction, and the cache coherency and lock obviously means that the <br />   bit clearing *itself* is safe!<br /><br /> - but it *does* matter for the compiler scheduling. If the compiler were <br />   to decide that "y" and "other_variable" are totally independent, it <br />   might otherwise decide to move the "other_variable = 10" assignment to <br />   *before* the clear_bit(), which would make the whole code pointless!<br /><br />See? We have two totally independent issues:<br /><br /> - the CPU itself can re-order the visibility of accesses. x86 doesn't do <br />   this very much, and doesn't do it at all across a locked instruction, <br />   but it's still a real issue, even if it tends to be much easier to see <br />   on other architectures.<br /><br /> - the compiler doesn't care about rules of "locked instruction" at all, <br />   because it has no clue. It has *different* rules about how it can <br />   re-order instructions and accesses, and maybe the "asm volatile" will <br />   guarantee that the compiler won't re-order things around the <br />   clear_bit(), and maybe it won't. But making it a compiler barrier (by <br />   using the "memory clobber" thing, *guarantees* that gcc cannot reorder <br />   memory writes or reads.<br /><br />See? Two different - and _totally_ independent - levels of ordering, and <br />we need to make sure that both are valid.<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
