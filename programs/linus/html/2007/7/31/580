    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/7/26/88">First message in thread</a></li><li><a href="/lkml/2007/7/31/566">Badari Pulavarty</a><ul><li><a href="/lkml/2007/7/31/570">Andrew Morton</a><ul><li class="origin"><a href="/lkml/2007/7/31/585">Linus Torvalds</a><ul><li><a href="/lkml/2007/7/31/585">Zach Brown</a></li><li><a href="/lkml/2007/7/31/647">Joe Jin</a><ul><li><a href="/lkml/2007/8/1/144">gurudas pai</a></li></ul></li></ul></li><li><a href="/lkml/2007/7/31/581">Badari Pulavarty</a></li></ul></li><li><a href="/lkml/2007/7/31/584">Zach Brown</a></li><li><a href="/lkml/2007/7/31/635">Joe Jin</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2007/7/31/580/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 31 Jul 2007 15:59:45 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] add check do_direct_IO() return val</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 31 Jul 2007, Andrew Morton wrote:<br />&gt; <br />&gt; We zero out so many fields in there now that a kzalloc() might yield<br />&gt; a net gain.  0.000001% in an unnamed benchmark!<br /><br />Indeed. That's *especially* true since right now it passes a mostly <br />totally uninitialized structure pointer down to direct_io_worker(), but it <br />has actually initialized a _few_ fields. Ie the "die" pointer is almost <br />totally filled with random crap, except for two members: dio-&gt;lock_type <br />and dio-&gt;is_async have been initialized the rest is random crud.<br /><br />That kind of mixing of totally-but-not-entirely-uninitialized pointer <br />passing is just a recipe for disaster.<br /><br />Does a patch like this work? I don't have any test-cases, but it would be <br />good to have something like this tested and passed back with proper <br />explanations and sign-offs.<br /><br />		Linus<br /><br />---<br /> fs/direct-io.c |   17 +----------------<br /> 1 files changed, 1 insertions(+), 16 deletions(-)<br /><br />diff --git a/fs/direct-io.c b/fs/direct-io.c<br />index 52bb263..901dc55 100644<br />--- a/fs/direct-io.c<br />+++ b/fs/direct-io.c<br />&#64;&#64; -958,35 +958,22 &#64;&#64; direct_io_worker(int rw, struct kiocb *iocb, struct inode *inode,<br /> 	ssize_t ret2;<br /> 	size_t bytes;<br /> <br />-	dio-&gt;bio = NULL;<br /> 	dio-&gt;inode = inode;<br /> 	dio-&gt;rw = rw;<br /> 	dio-&gt;blkbits = blkbits;<br /> 	dio-&gt;blkfactor = inode-&gt;i_blkbits - blkbits;<br />-	dio-&gt;start_zero_done = 0;<br />-	dio-&gt;size = 0;<br /> 	dio-&gt;block_in_file = offset &gt;&gt; blkbits;<br />-	dio-&gt;blocks_available = 0;<br />-	dio-&gt;cur_page = NULL;<br /> <br />-	dio-&gt;boundary = 0;<br />-	dio-&gt;reap_counter = 0;<br /> 	dio-&gt;get_block = get_block;<br /> 	dio-&gt;end_io = end_io;<br />-	dio-&gt;map_bh.b_private = NULL;<br /> 	dio-&gt;final_block_in_bio = -1;<br /> 	dio-&gt;next_block_for_io = -1;<br /> <br />-	dio-&gt;page_errors = 0;<br />-	dio-&gt;io_error = 0;<br />-	dio-&gt;result = 0;<br /> 	dio-&gt;iocb = iocb;<br /> 	dio-&gt;i_size = i_size_read(inode);<br /> <br /> 	spin_lock_init(&amp;dio-&gt;bio_lock);<br /> 	dio-&gt;refcount = 1;<br />-	dio-&gt;bio_list = NULL;<br />-	dio-&gt;waiter = NULL;<br /> <br /> 	/*<br /> 	 * In case of non-aligned buffers, we may need 2 more<br />&#64;&#64; -994,8 +981,6 &#64;&#64; direct_io_worker(int rw, struct kiocb *iocb, struct inode *inode,<br /> 	 */<br /> 	if (unlikely(dio-&gt;blkfactor))<br /> 		dio-&gt;pages_in_io = 2;<br />-	else<br />-		dio-&gt;pages_in_io = 0;<br /> <br /> 	for (seg = 0; seg &lt; nr_segs; seg++) {<br /> 		user_addr = (unsigned long)iov[seg].iov_base;<br />&#64;&#64; -1183,7 +1168,7 &#64;&#64; __blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,<br /> 		}<br /> 	}<br /> <br />-	dio = kmalloc(sizeof(*dio), GFP_KERNEL);<br />+	dio = kzalloc(sizeof(*dio), GFP_KERNEL);<br /> 	retval = -ENOMEM;<br /> 	if (!dio)<br /> 		goto out;<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
