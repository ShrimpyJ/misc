    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/7/17/560">First message in thread</a></li><li><a href="/lkml/2007/7/17/661">Roland Dreier</a><ul><li><a href="/lkml/2007/7/17/665">Roland Dreier</a><ul><li class="origin"><a href="/lkml/2007/7/18/3">Linus Torvalds</a><ul><li><a href="/lkml/2007/7/18/3">Roland Dreier</a><ul><li><a href="/lkml/2007/7/18/13">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2007/7/17/666">Linus Torvalds</a><ul><li><a href="/lkml/2007/7/17/669">Roland Dreier</a><ul><li><a href="/lkml/2007/7/17/672">Jeff Garzik</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2007/7/18/1/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 17 Jul 2007 21:00:10 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [git patches 1/2] warnings: attack valid cases spotted by warnings</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 17 Jul 2007, Roland Dreier wrote:<br />&gt;<br />&gt; I think this patch (on top of the previous one) actually makes the<br />&gt; code clearer<br /><br />Quite frankly, calling this "making the code clearer" is a bit ridiculous.<br /><br />That code still is absolute *crap* from a readability angle. It doesn't <br />follow any sane coding standards, and certainly not the most important <br />ones ("keep the function small", "don't have tons of local variables"), <br />and it has absolutely ridiculously ugly casts that get repeated over and <br />over and over again.<br /><br />Quite frankly, I don't quite understand where you get those enormous balls <br />you have, that you can then talk about how ugly it is to just add a "= 0" <br />that shuts up a compiler warning. That's the _least_ ugly part of the <br />whole damn function!<br /><br />So rather than sending out that idiotic patch, look at that code for five <br />seconds, and ponder whether it really needs to be that ugly.<br /><br />Here's a few things that you could *really* do to make it somewhat more <br />readable:<br /><br /> - make that whole "switch()" statement from hell another function <br />   entirely, and have it return the size of the thing, so that you don't <br />   need to have<br /><br />	wqe += xxx<br />	size += xxx / 16;<br /><br />   repeated fifty times (and so that it's also obvious that the xxxx <br />   always matches).<br /><br /> - make each switch case actually call a small function with the argument <br />   cast to the right pointer type, so that you need *one* cast per case, <br />   rather than a handful.<br /><br />End result? More readable source code, with functions that are 20 lines <br />long (or less), rather than 200 lines of spagetti-coding.<br /><br />And you know what? That's actually more important than 16 bytes of object <br />code, although looking at the size of the infiniband code, I *seriously* <br />doubt any infiniband person has ever cared about object code size in their <br />life. That thing is not for weak machines or stomachs.<br /><br />The warnign (and fixing it up) is the _least_ of the problems in that <br />code, methinks.<br /><br />Anyway, here's a totally untested cleanup that compiles but probably <br />doesn't work, because I didn't check that I did the right thing with all <br />the pointer arithmetic (ie when I change "wqe" to a real structure pointer <br />instead of just a "void *", maybe I left some pointer arithmetic around <br />that expected it to work as a byte pointer, but now really works on the <br />whole structure size instead).<br /><br />So this patch is NOT meant to be applied, but it is meant to teach people <br />how things like this should be done. They should *not* be one big function <br />with lots of case statements. They should be lots of small functions!<br /><br />		Linus<br />---<br /> drivers/infiniband/hw/mthca/mthca_qp.c |  236 ++++++++++++++++---------------<br /> 1 files changed, 122 insertions(+), 114 deletions(-)<br /><br />diff --git a/drivers/infiniband/hw/mthca/mthca_qp.c b/drivers/infiniband/hw/mthca/mthca_qp.c<br />index 11f1d99..74da9bc 100644<br />--- a/drivers/infiniband/hw/mthca/mthca_qp.c<br />+++ b/drivers/infiniband/hw/mthca/mthca_qp.c<br />&#64;&#64; -1578,6 +1578,113 &#64;&#64; static inline int mthca_wq_overflow(struct mthca_wq *wq, int nreq,<br /> 	return cur + nreq &gt;= wq-&gt;max;<br /> }<br /> <br />+static int handle_next_seg(struct ib_send_wr *wr, struct mthca_next_seg * wqe)<br />+{<br />+	wqe-&gt;nda_op = 0;<br />+	wqe-&gt;ee_nds = 0;<br />+	wqe-&gt;flags =	((wr-&gt;send_flags &amp; IB_SEND_SIGNALED) ?<br />+			 cpu_to_be32(MTHCA_NEXT_CQ_UPDATE) : 0) |<br />+			((wr-&gt;send_flags &amp; IB_SEND_SOLICITED) ?<br />+			 cpu_to_be32(MTHCA_NEXT_SOLICIT) : 0)   |<br />+			cpu_to_be32(1);<br />+<br />+	if (wr-&gt;opcode == IB_WR_SEND_WITH_IMM ||<br />+	    wr-&gt;opcode == IB_WR_RDMA_WRITE_WITH_IMM)<br />+		wqe-&gt;imm = wr-&gt;imm_data;<br />+<br />+	return sizeof(struct mthca_next_seg);<br />+}<br />+<br />+static int handle_raddr_seg(struct mthca_dev *dev, struct mthca_qp *qp, struct ib_send_wr *wr,<br />+	struct mthca_raddr_seg *wqe, int ind)<br />+{<br />+	switch (qp-&gt;transport) {<br />+	case RC:<br />+		switch (wr-&gt;opcode) {<br />+		case IB_WR_ATOMIC_CMP_AND_SWP:<br />+		case IB_WR_ATOMIC_FETCH_AND_ADD: {<br />+			struct mthca_atomic_seg *atomic;<br />+<br />+			wqe-&gt;raddr = cpu_to_be64(wr-&gt;wr.atomic.remote_addr);<br />+			wqe-&gt;rkey = cpu_to_be32(wr-&gt;wr.atomic.rkey);<br />+			wqe-&gt;reserved = 0;<br />+<br />+			atomic = (struct mthca_atomic_seg *) (wqe+1);<br />+<br />+			if (wr-&gt;opcode == IB_WR_ATOMIC_CMP_AND_SWP) {<br />+				atomic-&gt;swap_add = cpu_to_be64(wr-&gt;wr.atomic.swap);<br />+				atomic-&gt;compare = cpu_to_be64(wr-&gt;wr.atomic.compare_add);<br />+			} else {<br />+				atomic-&gt;swap_add = cpu_to_be64(wr-&gt;wr.atomic.compare_add);<br />+				atomic-&gt;compare = 0;<br />+			}<br />+<br />+			return sizeof (struct mthca_raddr_seg) +<br />+				sizeof (struct mthca_atomic_seg);<br />+		}<br />+<br />+		case IB_WR_RDMA_WRITE:<br />+		case IB_WR_RDMA_WRITE_WITH_IMM:<br />+		case IB_WR_RDMA_READ:<br />+			wqe-&gt;raddr = cpu_to_be64(wr-&gt;wr.rdma.remote_addr);<br />+			wqe-&gt;rkey = cpu_to_be32(wr-&gt;wr.rdma.rkey);<br />+			wqe-&gt;reserved = 0;<br />+			return sizeof (struct mthca_raddr_seg);<br />+<br />+		default:<br />+			/* No extra segments required for sends */<br />+			break;<br />+		}<br />+		return 0;<br />+<br />+	case UC:<br />+		switch (wr-&gt;opcode) {<br />+		case IB_WR_RDMA_WRITE:<br />+		case IB_WR_RDMA_WRITE_WITH_IMM:<br />+			wqe-&gt;raddr = cpu_to_be64(wr-&gt;wr.rdma.remote_addr);<br />+			wqe-&gt;rkey = cpu_to_be32(wr-&gt;wr.rdma.rkey);<br />+			wqe-&gt;reserved = 0;<br />+			return sizeof (struct mthca_raddr_seg);<br />+<br />+		default:<br />+			/* No extra segments required for sends */<br />+			break;<br />+		}<br />+<br />+		break;<br />+<br />+	case UD: {<br />+		struct mthca_tavor_ud_seg *ud = (void *)wqe;<br />+<br />+		ud-&gt;lkey = cpu_to_be32(to_mah(wr-&gt;wr.ud.ah)-&gt;key);<br />+		ud-&gt;av_addr = cpu_to_be64(to_mah(wr-&gt;wr.ud.ah)-&gt;avdma);<br />+		ud-&gt;dqpn = cpu_to_be32(wr-&gt;wr.ud.remote_qpn);<br />+		ud-&gt;qkey = cpu_to_be32(wr-&gt;wr.ud.remote_qkey);<br />+<br />+		return sizeof (struct mthca_tavor_ud_seg);<br />+	}<br />+<br />+	case MLX: {<br />+		int err = build_mlx_header(dev, to_msqp(qp), ind, wr,<br />+				       (void *) wqe - sizeof (struct mthca_next_seg),<br />+				       (void *) wqe);<br />+		if (err)<br />+			return err;<br />+<br />+		return sizeof (struct mthca_data_seg);<br />+	}<br />+	}<br />+	return 0;<br />+}<br />+<br />+static int handle_data_seg(struct mthca_data_seg *wqe, struct ib_sge *sge)<br />+{<br />+	wqe-&gt;byte_count = cpu_to_be32(sge-&gt;length);<br />+	wqe-&gt;lkey = cpu_to_be32(sge-&gt;lkey);<br />+	wqe-&gt;addr = cpu_to_be64(sge-&gt;addr);<br />+	return sizeof(struct mthca_data_seg);<br />+}<br />+<br /> int mthca_tavor_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,<br /> 			  struct ib_send_wr **bad_wr)<br /> {<br />&#64;&#64; -1616,115 +1723,18 &#64;&#64; int mthca_tavor_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,<br /> 		prev_wqe = qp-&gt;sq.last;<br /> 		qp-&gt;sq.last = wqe;<br /> <br />-		((struct mthca_next_seg *) wqe)-&gt;nda_op = 0;<br />-		((struct mthca_next_seg *) wqe)-&gt;ee_nds = 0;<br />-		((struct mthca_next_seg *) wqe)-&gt;flags =<br />-			((wr-&gt;send_flags &amp; IB_SEND_SIGNALED) ?<br />-			 cpu_to_be32(MTHCA_NEXT_CQ_UPDATE) : 0) |<br />-			((wr-&gt;send_flags &amp; IB_SEND_SOLICITED) ?<br />-			 cpu_to_be32(MTHCA_NEXT_SOLICIT) : 0)   |<br />-			cpu_to_be32(1);<br />-		if (wr-&gt;opcode == IB_WR_SEND_WITH_IMM ||<br />-		    wr-&gt;opcode == IB_WR_RDMA_WRITE_WITH_IMM)<br />-			((struct mthca_next_seg *) wqe)-&gt;imm = wr-&gt;imm_data;<br />+		err = handle_next_seg(wr, (struct mthca_next_seg *) wqe);<br /> <br />-		wqe += sizeof (struct mthca_next_seg);<br />-		size = sizeof (struct mthca_next_seg) / 16;<br />+		wqe += err;<br />+		size = err / 16;<br /> <br />-		switch (qp-&gt;transport) {<br />-		case RC:<br />-			switch (wr-&gt;opcode) {<br />-			case IB_WR_ATOMIC_CMP_AND_SWP:<br />-			case IB_WR_ATOMIC_FETCH_AND_ADD:<br />-				((struct mthca_raddr_seg *) wqe)-&gt;raddr =<br />-					cpu_to_be64(wr-&gt;wr.atomic.remote_addr);<br />-				((struct mthca_raddr_seg *) wqe)-&gt;rkey =<br />-					cpu_to_be32(wr-&gt;wr.atomic.rkey);<br />-				((struct mthca_raddr_seg *) wqe)-&gt;reserved = 0;<br />-<br />-				wqe += sizeof (struct mthca_raddr_seg);<br />-<br />-				if (wr-&gt;opcode == IB_WR_ATOMIC_CMP_AND_SWP) {<br />-					((struct mthca_atomic_seg *) wqe)-&gt;swap_add =<br />-						cpu_to_be64(wr-&gt;wr.atomic.swap);<br />-					((struct mthca_atomic_seg *) wqe)-&gt;compare =<br />-						cpu_to_be64(wr-&gt;wr.atomic.compare_add);<br />-				} else {<br />-					((struct mthca_atomic_seg *) wqe)-&gt;swap_add =<br />-						cpu_to_be64(wr-&gt;wr.atomic.compare_add);<br />-					((struct mthca_atomic_seg *) wqe)-&gt;compare = 0;<br />-				}<br />-<br />-				wqe += sizeof (struct mthca_atomic_seg);<br />-				size += (sizeof (struct mthca_raddr_seg) +<br />-					 sizeof (struct mthca_atomic_seg)) / 16;<br />-				break;<br />-<br />-			case IB_WR_RDMA_WRITE:<br />-			case IB_WR_RDMA_WRITE_WITH_IMM:<br />-			case IB_WR_RDMA_READ:<br />-				((struct mthca_raddr_seg *) wqe)-&gt;raddr =<br />-					cpu_to_be64(wr-&gt;wr.rdma.remote_addr);<br />-				((struct mthca_raddr_seg *) wqe)-&gt;rkey =<br />-					cpu_to_be32(wr-&gt;wr.rdma.rkey);<br />-				((struct mthca_raddr_seg *) wqe)-&gt;reserved = 0;<br />-				wqe += sizeof (struct mthca_raddr_seg);<br />-				size += sizeof (struct mthca_raddr_seg) / 16;<br />-				break;<br />-<br />-			default:<br />-				/* No extra segments required for sends */<br />-				break;<br />-			}<br />-<br />-			break;<br />-<br />-		case UC:<br />-			switch (wr-&gt;opcode) {<br />-			case IB_WR_RDMA_WRITE:<br />-			case IB_WR_RDMA_WRITE_WITH_IMM:<br />-				((struct mthca_raddr_seg *) wqe)-&gt;raddr =<br />-					cpu_to_be64(wr-&gt;wr.rdma.remote_addr);<br />-				((struct mthca_raddr_seg *) wqe)-&gt;rkey =<br />-					cpu_to_be32(wr-&gt;wr.rdma.rkey);<br />-				((struct mthca_raddr_seg *) wqe)-&gt;reserved = 0;<br />-				wqe += sizeof (struct mthca_raddr_seg);<br />-				size += sizeof (struct mthca_raddr_seg) / 16;<br />-				break;<br />-<br />-			default:<br />-				/* No extra segments required for sends */<br />-				break;<br />-			}<br />-<br />-			break;<br />-<br />-		case UD:<br />-			((struct mthca_tavor_ud_seg *) wqe)-&gt;lkey =<br />-				cpu_to_be32(to_mah(wr-&gt;wr.ud.ah)-&gt;key);<br />-			((struct mthca_tavor_ud_seg *) wqe)-&gt;av_addr =<br />-				cpu_to_be64(to_mah(wr-&gt;wr.ud.ah)-&gt;avdma);<br />-			((struct mthca_tavor_ud_seg *) wqe)-&gt;dqpn =<br />-				cpu_to_be32(wr-&gt;wr.ud.remote_qpn);<br />-			((struct mthca_tavor_ud_seg *) wqe)-&gt;qkey =<br />-				cpu_to_be32(wr-&gt;wr.ud.remote_qkey);<br />-<br />-			wqe += sizeof (struct mthca_tavor_ud_seg);<br />-			size += sizeof (struct mthca_tavor_ud_seg) / 16;<br />-			break;<br />-<br />-		case MLX:<br />-			err = build_mlx_header(dev, to_msqp(qp), ind, wr,<br />-					       wqe - sizeof (struct mthca_next_seg),<br />-					       wqe);<br />-			if (err) {<br />-				*bad_wr = wr;<br />-				goto out;<br />-			}<br />-			wqe += sizeof (struct mthca_data_seg);<br />-			size += sizeof (struct mthca_data_seg) / 16;<br />-			break;<br />+		err = handle_raddr_seg(dev, qp, wr, wqe, ind);<br />+		if (err &lt; 0) {<br />+			*bad_wr = wr;<br />+			goto out;<br /> 		}<br />+		wqe += err;<br />+		size += err / 16;<br /> <br /> 		if (wr-&gt;num_sge &gt; qp-&gt;sq.max_gs) {<br /> 			mthca_err(dev, "too many gathers\n");<br />&#64;&#64; -1734,14 +1744,12 &#64;&#64; int mthca_tavor_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,<br /> 		}<br /> <br /> 		for (i = 0; i &lt; wr-&gt;num_sge; ++i) {<br />-			((struct mthca_data_seg *) wqe)-&gt;byte_count =<br />-				cpu_to_be32(wr-&gt;sg_list[i].length);<br />-			((struct mthca_data_seg *) wqe)-&gt;lkey =<br />-				cpu_to_be32(wr-&gt;sg_list[i].lkey);<br />-			((struct mthca_data_seg *) wqe)-&gt;addr =<br />-				cpu_to_be64(wr-&gt;sg_list[i].addr);<br />-			wqe += sizeof (struct mthca_data_seg);<br />-			size += sizeof (struct mthca_data_seg) / 16;<br />+			struct ib_sge *sge = wr-&gt;sg_list + i;<br />+			err = handle_data_seg((struct mthca_data_seg *) wqe, sge);<br />+<br />+			/* No errors possible */<br />+			wqe += err;<br />+			size += err / 16;<br /> 		}<br /> <br /> 		/* Add one more inline data segment for ICRC */<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
