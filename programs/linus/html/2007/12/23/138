    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/12/23/138">First message in thread</a></li><li class="origin"><a href="/lkml/2007/12/23/140">Linus Torvalds</a><ul><li><a href="/lkml/2007/12/23/140">Linus Torvalds</a></li><li><a href="/lkml/2007/12/23/151">Ingo Molnar</a><ul><li><a href="/lkml/2007/12/23/153">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2007/12/23/168">"Yinghai Lu"</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 23 Dec 2007 09:53:45 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [Bug 9528] x86: Increase PCIBIOS_MIN_IO to 0x1500 to fix nForce 4 suspend-to-RAM</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sun, 23 Dec 2007, Carlos Corbacho wrote:<br />&gt;<br />&gt; Fix suspend-to-RAM on nForce 4 (CK804) boards by increasing<br />&gt; PCIBIOS_MIN_IO.<br />&gt; <br />&gt; Fixes kernel bugzilla #9528<br />&gt; <br />&gt; Problem:<br />&gt; <br />&gt; Linus' patch (52ade9b3b97fd3bea42842a056fe0786c28d0555) to re-order<br />&gt; suspend (and fix fall out from Rafael's earlier suspend reordering work)<br />&gt; broke suspend-to-RAM on nForce 4 (CK804) boards.<br />&gt; <br />&gt; Why:<br />&gt; <br />&gt; After debugging _PTS() in the DSDT, it turns out these nVidia boards are<br />&gt; trying to write to an IO port &gt; 0x1000 (0x142E) during suspend. Before the<br />&gt; re-ordering, we got away with this.<br /><br />Very interesting.<br /><br />HOWEVER.<br /><br />I'd much rather figure out what the magic IO resource is that clashes. <br /><br />It's almost certainly some hidden and undocumented (or badly documented) <br />ACPI IO area that the kernel doesn't know about, because it's not a <br />regular PCI BAR resource, but some northbridge (or southbridge) magic <br />register range.<br /><br />Those ranges *should* be reserved by the BIOS in the ACPI tables, but this <br />would definitely not be the first time that doesn't happen.<br /><br />But the right fix would be for us to just figure out what the range is ass <br />a PCI quirk, and just know to avoid it on purpose, ratehr than just being <br />lucky and happen to avoid it because PCIBIOS_MIN_IO just happens to be <br />bigger than the particular address.<br /><br />So can you:<br /> - show what your /proc/ioports contains (*with* the bug triggering, ie <br />   non-working suspend, so we see what it is that actually ends up using <br />   that area)<br /> - send out 'dmesg' for a boot (same deal)<br /> - add "lspci -xxxvv" output to the deal too.<br /><br />and also make them part of the bugzilla history (I'm cc'ing bugzilla here, <br />and added the bug number to the subject, so hopefully this thread ends up <br />being archived there too).<br /><br />&gt; There was some previous work in the PCIBIOS_MIN_IO area over two years ago<br />&gt; (71db63acff69618b3d9d3114bd061938150e146b) which bumped this to 0x4000,<br />&gt; but this was reverted (2ba84684e8cf6f980e4e95a2300f53a505eb794e) after<br />&gt; causing new and entirely different problems on another nForce board.<br /><br />The problem here is classic: these magic ranges tend to be *different* on <br />different boards (because they don't tend to be fixed by hardware, they <br />are programmed regions set up by firmware), so trying to change <br />PCIBIOS_MIN_IO to avoid a problem on one board is almost certain to just <br />introduce it on another board instead.<br /><br />On *your* particular board, 0x142E is used for something, but on somebody <br />elses board it might be 0x162E, and now changing PCIBIOS_MIN_IO to 0x1500 <br />might make that other board hang instead.<br /><br />So you seem to have debugged this very successfully, and I'm wondering if <br />you might be able to find out where that 0x142e comes from, and we could <br />fix it for *all* boards using that chipset by just figuring out what the <br />*hardware* rules (rather than the random firmware setup that will be <br />different on different boards) for that chipset actually are!<br /><br />For an example of what I mean, see the file "drivers/pci/quirks.c", and <br />check out the quirks for various chipsets:<br /><br /> - quirk_ali7101_acpi()<br /><br />   Knows about the magic ALI ACPI and SMB OI regions<br /><br /> - quirk_piix4_acpi(), quirk_ich6_lpc_acpi(), quirk_ich4_lpc_acpi()<br /><br />   Same thing for the Intel chipsets<br /><br /> - quirk_vt82c586_acpi(), quirk_vt82c686_acpi()<br /><br />   VIA chipsets<br /><br />etc etc.<br /><br />It would be *wonderful* if somebody could figure out what the equivalent <br />quirks for nVidia chipsets are! Because otherwise we'll just end up <br />bouncing back and forth between different random IO allocations, and they <br />are all almost guaranteed to cause the same problems, just on different <br />boards!<br /><br />It's sometimes possible to even just guess what the registers are, even if <br />things are undocumented. In particular, that 142E range is almost <br />certainly programmed into the host bridge or possibly a "LPC controller" <br />or similar, and it will probably show up as the bytes "20 14" in the <br />output from lspci, so we can guess which register it is that sets the <br />base. That's not *always* how it works, but it's sometimes possible to <br />guess (although you usually need to see a few different cases of the same <br />chipset to have any kind of confirmation of the guess).<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
