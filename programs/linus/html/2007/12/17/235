    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/12/14/313">First message in thread</a></li><li><a href="/lkml/2007/12/17/215">Linus Torvalds</a><ul><li><a href="/lkml/2007/12/17/220">Al Viro</a></li><li><a href="/lkml/2007/12/17/223">Eric Dumazet</a><ul><li><a href="/lkml/2007/12/17/225">"Ray Lee"</a><ul><li><a href="/lkml/2007/12/17/228">Eric Dumazet</a><ul><li><a href="/lkml/2007/12/17/229">"Ray Lee"</a></li></ul></li></ul></li><li><a href="/lkml/2007/12/17/233">Al Viro</a></li><li class="origin"><a href="/lkml/2007/12/17/251">Linus Torvalds</a><ul><li><a href="/lkml/2007/12/17/251">Al Viro</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 17 Dec 2007 10:28:38 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [Security] Signed divides vs shifts (Re: /dev/urandom uses uninit bytes, leaks user data)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 17 Dec 2007, Eric Dumazet wrote:<br />&gt; <br />&gt; while <br />&gt; <br />&gt; long *mid(long *a, long *b)<br />&gt; {<br />&gt; 	return ((a - b) / 2u + a);<br />&gt; }<br /><br />This is exactly what I'm talking about. That "2u" is TOTALLY POINTLESS. <br />It's an "unsigned int", but since (a-b) will be of type ptrdiff_t, and is <br />*wider* on a 64-bit architecture (it's the same as "long" on x86-64), then <br />the 2u will just be converted to "long", and be signed again! <br /><br />So you thought that you did an unsigned divide, but you did no such thing. <br /><br />If you change the "2u" to a "2ul", it works again, and you get<br /><br />	mid:<br />	        movq    %rdi, %rax<br />	        subq    %rsi, %rax<br />	        sarq    %rax<br />	        andq    $-8, %rax<br />	        addq    %rdi, %rax<br />	        ret<br /><br />which is the code you wanted. But quite frankly, you could just have <br />written it with a shift to start with, and avoided the subtle type issue, <br />although gcc then generates<br /><br />        movq    %rdi, %rax<br />        subq    %rsi, %rax<br />        sarq    $4, %rax<br />        leaq    (%rdi,%rax,8), %rax<br />        ret<br /><br />instead. Of course, this all *does* still have subtle sign issues, because <br />the "a-b" part implies a signed divide in itself, which is why you see <br />that "sarq" in he first place (rather than a "shrq"). <br /><br />Signed divides are hard. The "a-b" pointer subtraction is actually cheaper <br />than a general signed divide by sizeof, since the compiler can then assume <br />that the two pointers are mutually aligned, which is why gcc can generate <br />just a single "sarq" instead of having to do an extra "add negative bit" <br />thing to get the rounding right.<br /><br />[ So Al, when you said that<br /><br />	(a-b)<br /><br />  is equivalent to<br /><br />	((char *)a-(char *)b)/4<br /><br />  for a "int *" a and b, you're right in the sense that the *result* is <br />  the same, but the code generation likely isn't. The "a-b" thing can (and <br />  does) allow the compiler to avoid the whole "align up for signed <br />  numbers" thing, and the difference in code generation is clear:<br /><br />	subq    %rsi, %rdi<br />	sarq    $2, %rdi<br /><br />  vs<br /><br />	subq    %rsi, %rdi<br />	leaq    3(%rdi), %rax<br />	testq   %rdi, %rdi<br />	cmovs   %rax, %rdi<br />	sarq    $2, %rdi<br /><br />  exactly because the first case *knows* that the low two bits have to be <br />  zero, and thus there is no rounding issue. ]<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
