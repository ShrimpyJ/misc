    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/12/23/126">First message in thread</a></li><li><a href="/lkml/2007/12/23/220">Carlos Corbacho</a><ul><li><a href="/lkml/2007/12/24/27">"Rafael J. Wysocki"</a><ul><li class="origin"><a href="/lkml/2007/12/24/105">Linus Torvalds</a><ul><li><a href="/lkml/2007/12/24/105">Carlos Corbacho</a></li><li><a href="/lkml/2007/12/25/37">"Rafael J. Wysocki"</a><ul><li><a href="/lkml/2007/12/25/93">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2007/12/24/92/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 24 Dec 2007 10:34:21 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: x86: Increase PCIBIOS_MIN_IO to 0x1500 to fix nForce 4 suspend-to-RAM</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 24 Dec 2007, Rafael J. Wysocki wrote:<br />&gt; <br />&gt; Well, having considered that for a longer while, I think the AML code is<br />&gt; referring to a device that we have suspended already, and since it's in a low<br />&gt; power state, it just can't handle the reference.<br />&gt; <br />&gt; If that is the case, we'll have to find the device (that should be possible<br />&gt; using some code instrumentation) and move the suspending of it into the late<br />&gt; stage.<br /><br />Yes. <br /><br />In general, I'm personally of the opinion that drivers should *not* <br />actually go into D3 at all in the regular "-&gt;suspend()" phase. It should <br />be done in -&gt;suspend_late. The early suspend is for saving state and <br />returning errors.<br /><br />Sadly, we've made it a bit too inconvenient to actually do that. Almost <br />all drivers only do the "-&gt;suspend" thing, and the default PCI behaviour <br />doesn't help us in any way either.<br /><br />Anyway, I wonder if a patch like this could make it easier for driver <br />writers to handle things. It basically does:<br /><br /> - if you don't have a regular "suspend()" function, we'll just save state <br />   at suspend time.<br /><br /> - if you don't have a "suspend_late()" function, we'll look at the <br />   current state, and if it's still in PCI_D0, we'll suspend to PCI_D3hot <br />   if it's a regular PCI device (ie not a bridge or something else odd).<br /><br /> - then, at resume time, by default we don't do anything in the early <br />   resume, but in the late resume we'll undo everything, of course.<br /><br />Anyway, with this, most drivers could just remove the <br />"pci_set_power_state()" call *entirely*, and let the default <br />suspend_late action power the device down. But if you want to override <br />that default action, you can either:<br /><br /> - set the power state in your own -&gt;suspend() routine (either by using <br />   pci_set_power_state(), or by just explicitly setting the state to <br />   unknown with "dev-&gt;current_state =  PCI_UNKNOWN"<br /><br /> - have a "late_suspend()" action, which obviously will override the <br />   default action entirely.<br /><br />Hmm?<br /><br />In the case of the NVidia issue, one thing to try migh be to remove the <br />current call to "pci_set_power_state(pdev, 3);" in agp_nvidia_suspend() in <br />drivers/char/agp/nvidia-agp.c. That sounds like the most likely culprit <br />for something that ACPI might want to shut down.<br /><br />NOTE! This following patch is just for discussion, and while I think it's <br />conceptually a good thing to try, I don't think it will help Carlos' <br />problem. But removing the "pci_set_power_state()" in agp_nvidia_suspend() <br />might.<br /><br />			Linus<br /><br />---<br /> drivers/pci/pci-driver.c |   32 +++++++++++++++++++++++++-------<br /> 1 files changed, 25 insertions(+), 7 deletions(-)<br /><br />diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c<br />index 6d1a216..6992f73 100644<br />--- a/drivers/pci/pci-driver.c<br />+++ b/drivers/pci/pci-driver.c<br />&#64;&#64; -264,6 +264,28 &#64;&#64; static int pci_device_remove(struct device * dev)<br /> 	return 0;<br /> }<br /> <br />+static void pci_default_suspend(struct pci_dev *dev, pm_message_t state)<br />+{<br />+	pci_save_state(dev);<br />+}<br />+<br />+static void pci_default_suspend_late(struct pci_dev *dev, pm_message_t state)<br />+{<br />+	/* Something has already suspended it? Never mind then.. */<br />+	if (dev-&gt;current_state != PCI_D0)<br />+		return;<br />+<br />+	/* We avoid powering down bridges by default.. */<br />+	if (dev-&gt;hdr_type == PCI_HEADER_TYPE_NORMAL)<br />+		pci_set_power_state(dev, PCI_D3hot);<br />+<br />+	/*<br />+	 * mark its power state as "unknown", since we don't know if<br />+	 * e.g. the BIOS will change its device state when we suspend.<br />+	 */<br />+	dev-&gt;current_state = PCI_UNKNOWN;<br />+}<br />+<br /> static int pci_device_suspend(struct device * dev, pm_message_t state)<br /> {<br /> 	struct pci_dev * pci_dev = to_pci_dev(dev);<br />&#64;&#64; -274,13 +296,7 &#64;&#64; static int pci_device_suspend(struct device * dev, pm_message_t state)<br /> 		i = drv-&gt;suspend(pci_dev, state);<br /> 		suspend_report_result(drv-&gt;suspend, i);<br /> 	} else {<br />-		pci_save_state(pci_dev);<br />-		/*<br />-		 * mark its power state as "unknown", since we don't know if<br />-		 * e.g. the BIOS will change its device state when we suspend.<br />-		 */<br />-		if (pci_dev-&gt;current_state == PCI_D0)<br />-			pci_dev-&gt;current_state = PCI_UNKNOWN;<br />+		pci_default_suspend(pci_dev, state);<br /> 	}<br /> 	return i;<br /> }<br />&#64;&#64; -294,6 +310,8 &#64;&#64; static int pci_device_suspend_late(struct device * dev, pm_message_t state)<br /> 	if (drv &amp;&amp; drv-&gt;suspend_late) {<br /> 		i = drv-&gt;suspend_late(pci_dev, state);<br /> 		suspend_report_result(drv-&gt;suspend_late, i);<br />+	} else {<br />+		pci_default_suspend_late(pci_dev, state);<br /> 	}<br /> 	return i;<br /> }<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
