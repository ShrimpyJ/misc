    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/8/9/176">First message in thread</a></li><li><a href="/lkml/2007/8/17/95">Satyam Sharma</a><ul><li><a href="/lkml/2007/8/17/120">Nick Piggin</a><ul><li><a href="/lkml/2007/8/17/127">Satyam Sharma</a></li><li class="origin"><a href="/lkml/2007/8/17/218">Linus Torvalds</a><ul><li><a href="/lkml/2007/8/17/218">"Chris Friesen"</a><ul><li><a href="/lkml/2007/8/17/219">Arjan van de Ven</a></li><li><a href="/lkml/2007/8/17/221">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2007/8/20/84">Chris Snook</a><ul><li><a href="/lkml/2007/8/20/89">Herbert Xu</a></li><li><a href="/lkml/2007/8/21/18">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2007/9/9/81">Denys Vlasenko</a><ul><li><a href="/lkml/2007/9/9/84">Arjan van de Ven</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 17 Aug 2007 09:48:39 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 0/24] make atomic_read() behave consistently across all architectures</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 17 Aug 2007, Nick Piggin wrote:<br />&gt; <br />&gt; That's not obviously just taste to me. Not when the primitive has many<br />&gt; (perhaps, the majority) of uses that do not require said barriers. And<br />&gt; this is not solely about the code generation (which, as Paul says, is<br />&gt; relatively minor even on x86). I prefer people to think explicitly<br />&gt; about barriers in their lockless code.<br /><br />Indeed.<br /><br />I think the important issues are:<br /><br /> - "volatile" itself is simply a badly/weakly defined issue. The semantics <br />   of it as far as the compiler is concerned are really not very good, and <br />   in practice tends to boil down to "I will generate so bad code that <br />   nobody can accuse me of optimizing anything away".<br /><br /> - "volatile" - regardless of how well or badly defined it is - is purely <br />   a compiler thing. It has absolutely no meaning for the CPU itself, so <br />   it at no point implies any CPU barriers. As a result, even if the <br />   compiler generates crap code and doesn't re-order anything, there's <br />   nothing that says what the CPU will do.<br /><br /> - in other words, the *only* possible meaning for "volatile" is a purely <br />   single-CPU meaning. And if you only have a single CPU involved in the <br />   process, the "volatile" is by definition pointless (because even <br />   without a volatile, the compiler is required to make the C code appear <br />   consistent as far as a single CPU is concerned).<br /><br />So, let's take the example *buggy* code where we use "volatile" to wait <br />for other CPU's:<br /><br />	atomic_set(&amp;var, 0);<br />	while (!atomic_read(&amp;var))<br />		/* nothing */;<br /><br /><br />which generates an endless loop if we don't have atomic_read() imply <br />volatile.<br /><br />The point here is that it's buggy whether the volatile is there or not! <br />Exactly because the user expects multi-processing behaviour, but <br />"volatile" doesn't actually give any real guarantees about it. Another CPU <br />may have done:<br /><br />	external_ptr = kmalloc(..);<br />	/* Setup is now complete, inform the waiter */<br />	atomic_inc(&amp;var);<br /><br />but the fact is, since the other CPU isn't serialized in any way, the <br />"while-loop" (even in the presense of "volatile") doesn't actually work <br />right! Whatever the "atomic_read()" was waiting for may not have <br />completed, because we have no barriers!<br /><br />So if "volatile" makes a difference, it is invariably a sign of a bug in <br />serialization (the one exception is for IO - we use "volatile" to avoid <br />having to use inline asm for IO on x86) - and for "random values" like <br />jiffies).<br /><br />So the question should *not* be whether "volatile" actually fixes bugs. It <br />*never* fixes a bug. But what it can do is to hide the obvious ones. In <br />other words, adding a volaile in the above kind of situation of <br />"atomic_read()" will certainly turn an obvious bug into something that <br />works "practically all of the time).<br /><br />So anybody who argues for "volatile" fixing bugs is fundamentally <br />incorrect. It does NO SUCH THING. By arguing that, such people only show <br />that you have no idea what they are talking about.<br /><br />So the only reason to add back "volatile" to the atomic_read() sequence is <br />not to fix bugs, but to _hide_ the bugs better. They're still there, they <br />are just a lot harder to trigger, and tend to be a lot subtler.<br /><br />And hey, sometimes "hiding bugs well enough" is ok. In this case, I'd <br />argue that we've successfully *not* had the volatile there for eight <br />months on x86-64, and that should tell people something. <br /><br />(Does _removing_ the volatile fix bugs? No - callers still need to think <br />about barriers etc, and lots of people don't. So I'm not claiming that <br />removing volatile fixes any bugs either, but I *am* claiming that:<br /><br /> - removing volatile makes some bugs easier to see (which is mostly a good <br />   thing: they were there before, anyway).<br /><br /> - removing volatile generates better code (which is a good thing, even if <br />   it's just 0.1%)<br /><br /> - removing volatile removes a huge mental *bug* that lots of people seem <br />   to have, as shown by this whole thread. Anybody who thinks that <br />   "volatile" actually fixes anything has a gaping hole in their head, and <br />   we should remove volatile just to make sure that nobody thinks that it <br />   means soemthign that it doesn't mean!<br /><br />In other words, this whole discussion has just convinced me that we should <br />*not* add back "volatile" to "atomic_read()" - I was willing to do it for <br />practical and "hide the bugs" reasons, but having seen people argue for <br />it, thinking that it actually fixes something, I'm now convinced that the <br />*last* thing we should do is to encourage that kind of superstitious <br />thinking.<br /><br />"volatile" is like a black cat crossing the road. Sure, it affects <br />*something* (at a minimum: before, the black cat was on one side of the <br />road, afterwards it is on the other side of the road), but it has no <br />bigger and longer-lasting direct affects. <br /><br />People who think "volatile" really matters are just fooling themselves.<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
