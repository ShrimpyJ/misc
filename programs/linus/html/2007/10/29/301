    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/10/29/280">First message in thread</a></li><li><a href="/lkml/2007/10/29/280">Dave Jones</a><ul><li><a href="/lkml/2007/10/29/285">Greg KH</a><ul><li class="origin"><a href="/lkml/2007/10/29/361">Linus Torvalds</a><ul><li><a href="/lkml/2007/10/29/361">Christoph Lameter</a></li><li><a href="/lkml/2007/10/29/363">"Siddha, Suresh B"</a><ul><li><a href="/lkml/2007/10/29/373">Christoph Lameter</a></li></ul></li><li><a href="/lkml/2007/10/29/382">Andy Whitcroft</a></li><li><a href="/lkml/2007/10/29/425">Martin Ebourne</a></li></ul></li></ul></li><li><a href="/lkml/2007/10/29/294">Andi Kleen</a><ul><li><a href="/lkml/2007/10/29/306">Dave Jones</a><ul><li><a href="/lkml/2007/10/29/318">Andi Kleen</a><ul><li><a href="/lkml/2007/10/29/353">Dave Jones</a></li><li><a href="/lkml/2007/10/29/371">Dave Jones</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2007/10/29/301/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 29 Oct 2007 11:37:40 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [stable] 2.6.23 boot failures on x86-64.</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 29 Oct 2007, Greg KH wrote:<br />&gt; <br />&gt; I'll be glad to revert it in -stable, if it's also reverted in Linus's<br />&gt; tree first :)<br /><br />We've had some changes since 2.6.23, and afaik, the <br />"alloc_bootmem_high_node()" code is alreadt effectively dead there. It's <br />only called if CONFIG_SPARSEMEM_VMEMMAP is *not* enabled, and I *think* we <br />enable it by force on x86-64 these days.<br /><br />More people added to Cc, just to clarify whether I'm just confused.<br /><br />Andy, Christoph, Mel: commit 2e1c49db4c640b35df13889b86b9d62215ade4b6 aka <br />"x86_64: allocate sparsemem memmap above 4G" is the one that causes the <br />failures, just fyi.<br /><br />Martin - it would be great if you could try out your failing machine with <br />2.6.24-rc1 (or a nightly snapshot or current git.. the more recent the <br />better).<br /><br />But if I'm right, that commit should be reverted from 2.6.24 just because <br />it's pointless (even if the bug itself is gone). And if I'm wrong, it <br />should be reverted. So something like the appended would make sense <br />regardless.<br /><br />Can I get a "tested-by"? And/or ack/nack's on my half-arsed theory above?<br /><br />		Linus<br />--<br />From: Linus Torvalds &lt;torvalds&#64;woody.linux-foundation.org&gt;<br /><br />Revert "x86_64: allocate sparsemem memmap above 4G"<br /><br />This reverts commit 2e1c49db4c640b35df13889b86b9d62215ade4b6, since<br />testing in Fedora has shown it to cause boot failures, as per Dave<br />Jones. Bisected down by Martin Ebourne.<br /><br />Cc: Dave Jones &lt;davej&#64;redhat.com&gt;<br />Cc: Martin Ebourne &lt;fedora&#64;ebourne.me.uk&gt;<br />Cc: Zou Nan hai &lt;nanhai.zou&#64;intel.com&gt;<br />Cc: Suresh Siddha &lt;suresh.b.siddha&#64;intel.com&gt;<br />Cc: Andrew Morton &lt;akpm&#64;linux-foundation.org&gt;<br />Signed-off-by: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br /><br />diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c<br />index 1e3862e..a7308b2 100644<br />--- a/arch/x86/mm/init_64.c<br />+++ b/arch/x86/mm/init_64.c<br />&#64;&#64; -728,12 +728,6 &#64;&#64; int in_gate_area_no_task(unsigned long addr)<br /> 	return (addr &gt;= VSYSCALL_START) &amp;&amp; (addr &lt; VSYSCALL_END);<br /> }<br /> <br />-void * __init alloc_bootmem_high_node(pg_data_t *pgdat, unsigned long size)<br />-{<br />-	return __alloc_bootmem_core(pgdat-&gt;bdata, size,<br />-			SMP_CACHE_BYTES, (4UL*1024*1024*1024), 0);<br />-}<br />-<br /> const char *arch_vma_name(struct vm_area_struct *vma)<br /> {<br /> 	if (vma-&gt;vm_mm &amp;&amp; vma-&gt;vm_start == (long)vma-&gt;vm_mm-&gt;context.vdso)<br />diff --git a/include/linux/bootmem.h b/include/linux/bootmem.h<br />index c83534e..0365ec9 100644<br />--- a/include/linux/bootmem.h<br />+++ b/include/linux/bootmem.h<br />&#64;&#64; -59,7 +59,6 &#64;&#64; extern void *__alloc_bootmem_core(struct bootmem_data *bdata,<br /> 				  unsigned long align,<br /> 				  unsigned long goal,<br /> 				  unsigned long limit);<br />-extern void *alloc_bootmem_high_node(pg_data_t *pgdat, unsigned long size);<br /> <br /> #ifndef CONFIG_HAVE_ARCH_BOOTMEM_NODE<br /> extern void reserve_bootmem(unsigned long addr, unsigned long size);<br />diff --git a/mm/sparse.c b/mm/sparse.c<br />index 08fb14f..e06f514 100644<br />--- a/mm/sparse.c<br />+++ b/mm/sparse.c<br />&#64;&#64; -220,12 +220,6 &#64;&#64; static int __meminit sparse_init_one_section(struct mem_section *ms,<br /> 	return 1;<br /> }<br /> <br />-__attribute__((weak)) __init<br />-void *alloc_bootmem_high_node(pg_data_t *pgdat, unsigned long size)<br />-{<br />-	return NULL;<br />-}<br />-<br /> static unsigned long usemap_size(void)<br /> {<br /> 	unsigned long size_bytes;<br />&#64;&#64; -267,11 +261,6 &#64;&#64; struct page __init *sparse_mem_map_populate(unsigned long pnum, int nid)<br /> 	if (map)<br /> 		return map;<br /> <br />-  	map = alloc_bootmem_high_node(NODE_DATA(nid),<br />-                       sizeof(struct page) * PAGES_PER_SECTION);<br />-	if (map)<br />-		return map;<br />-<br /> 	map = alloc_bootmem_node(NODE_DATA(nid),<br /> 			sizeof(struct page) * PAGES_PER_SECTION);<br /> 	return map;<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
