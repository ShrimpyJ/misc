    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/10/17/519">First message in thread</a></li><li><a href="/lkml/2007/10/18/473">Herbert Xu</a><ul><li><a href="/lkml/2007/10/18/476">Nick Piggin</a><ul><li><a href="/lkml/2007/10/18/484">Herbert Xu</a><ul><li><a href="/lkml/2007/10/19/17">Nick Piggin</a></li></ul></li></ul></li><li><a href="/lkml/2007/10/18/478">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2007/10/19/3">Linus Torvalds</a><ul><li><a href="/lkml/2007/10/19/3">Benjamin Herrenschmidt</a><ul><li><a href="/lkml/2007/10/19/6">Benjamin Herrenschmidt</a></li></ul></li><li><a href="/lkml/2007/10/19/4">Herbert Xu</a><ul><li><a href="/lkml/2007/10/19/7">Benjamin Herrenschmidt</a></li><li><a href="/lkml/2007/10/19/12">Benjamin Herrenschmidt</a></li><li><a href="/lkml/2007/10/19/16">Herbert Xu</a></li><li><a href="/lkml/2007/10/19/29">Herbert Xu</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 18 Oct 2007 20:26:45 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] synchronize_irq needs a barrier</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 18 Oct 2007, Linus Torvalds wrote:<br />&gt;<br />&gt; I *think* it should work with something like<br />&gt; <br />&gt; 	for (;;) {<br />&gt; 		smp_rmb();<br />&gt; 		if (!spin_is_locked(&amp;desc-&gt;lock)) {<br />&gt; 			smp_rmb();<br />&gt; 			if (!(desc-&gt;status &amp; IRQ_INPROGRESS)<br />&gt; 				break;<br />&gt; 		}<br />&gt; 		cpu_relax();<br />&gt; 	}<br /><br />I'm starting to doubt this. <br /><br />One of the issues is that we still need the smp_mb() in front of the loop <br />(because we want to serialize the loop with any writes in the caller).<br /><br />The other issue is that I don't think it's enough that we saw the <br />descriptor lock unlocked, and then the IRQ_INPROGRESS bit clear. It might <br />have been unlocked *while* the IRQ was in progress, but the interrupt <br />handler is now in its last throes, and re-takes the spinlock and clears <br />the IRQ_INPROGRESS thing. But we're not actually happy until we've seen <br />the IRQ_INPROGRESS bit clear and the spinlock has been released *again*.<br /><br />So those two tests should actually be the other way around: we want to see <br />the IRQ_INPROGRESS bit clear first.<br /><br />It's all just too damn subtle and clever. Something like this should not <br />need to be that subtle. <br /><br />Maybe the rigth thing to do is to not rely on *any* ordering what-so-ever, <br />and just make the rule be: "if you look at the IRQ_INPROGRESS bit, you'd <br />better hold the descriptor spinlock", and not have any subtle ordering <br />issues at all.<br /><br />But that makes us have a loop with getting/releasing the lock all the <br />time, and then we get back to horrid issues with cacheline bouncing and <br />unfairness of cache accesses across cores (ie look at the issues we had <br />with the runqueue starvation in wait_task_inactive()).<br /><br />Those were fixed by starting out with the non-locked and totally unsafe <br />versions, but then having one last "check with lock held, and repeat only <br />if that says things went south". <br /><br />See commit fa490cfd15d7ce0900097cc4e60cfd7a76381138 and ponder. Maybe we <br />should take the same approach here, and do something like<br /><br />	repeat:<br />		/* Optimistic, no-locking loop */<br />		while (desc-&gt;status &amp; IRQ_INPROGRESS)<br />			cpu_relax();<br /><br />		/* Ok, that indicated we're done: double-check carefully */<br />		spin_lock_irqsave(&amp;desc-&gt;lock, flags);<br />		status = desc-&gt;status;<br />		spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);<br /><br />		/* Oops, that failed? */<br />		if (status &amp; IRQ_INPROGRESS)<br />			goto repeat;<br /><br />Hmm?<br /><br />			Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
