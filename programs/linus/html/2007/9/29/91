    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/9/28/212">First message in thread</a></li><li><a href="/lkml/2007/9/28/217">Linus Torvalds</a><ul><li><a href="/lkml/2007/9/29/74">Nick Piggin</a><ul><li class="origin"><a href="/lkml/2007/9/30/39">Linus Torvalds</a><ul><li><a href="/lkml/2007/9/30/39">Nick Piggin</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 29 Sep 2007 09:07:30 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [patch] x86: improved memory barrier implementation</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sat, 29 Sep 2007, Nick Piggin wrote:<br />&gt; &gt; <br />&gt; &gt; The non-temporal stores should be basically considered to be "IO", not any <br />&gt; &gt; normal memory operation.<br />&gt; <br />&gt; Maybe you're thinking of uncached / WC? Non-temporal stores to cacheable<br />&gt; RAM apparently can go out of order too, and they are being used in the kernel<br />&gt; for some things.<br /><br />I'm really saying that people to a first approximation should think "NT is <br />an IO (DMA) thing". Whether cached or not. Exactly because they do not <br />honor the normal memory ordering.<br /><br />It may be worth noting that "clflush" falls under that heading too - even <br />if all the actual *writes* were done with totally normal writes, if <br />anybody does a clflush instruction, that breaks the ordering, and that <br />turns it to "DMA ordering" again - ie we're not talking about the normal <br />SMP ordering rules at all.<br /><br />So all the spinlocks and all the smp_*mb() barriers have never really done <br />*anything* for those things (in particular, "smp_wmb()" has *always* <br />ignored them on i386!)<br /><br />&gt; Likewise for rep stos, apparently.<br /><br />No. As far as I can tell, the fast string operations are unordered <br />*within*themselves*, but not wrt the operations around it.<br /><br />In other words, you cannot depend on the ordering of stores *in* the <br />memcpy() or memset() when it is implemented by "rep movs/stos" - but that <br />is 100% equivalent to the fact that you cannot depend on the ordering even <br />when it isn't - since the "memcpy()" library routine might be copying <br />memory backwards for all you know!<br /><br />The Intel memory ordering paper doesn't talk about the fast string <br />instructions (except to say that the rules it *does* speak about do not <br />hold), but the regular IA manuals do say (for example):<br /><br />   "Code dependent upon sequential store ordering should not use the <br />    string operations for the entire data structure to be stored. Data and <br />    semaphores should be separated. Order dependent code should use a <br />    discrete semaphore uniquely stored to after any string operations to <br />    allow correctly ordered data to be seen by all processors."<br /><br />and note how it says you should just store to the semaphore. If you think <br />about it, that semahore will be involving all the memory ordering <br />requirements that we *already* depend on, so if a semaphore is sufficient <br />to order the fast string instruction, then by definition using a spinlock <br />around them must be the same thing!<br /><br />In other words, by Intels architecture manual, fast string instructions <br />cannot escape a "semaphore" - but that means that they cannot escape a <br />spinlock either (since the two are exactly the same wrt memory ordering <br />rules! In other words, whenever the Intel docs say "semaphore", think <br />"mutual exclusion lock", not necessarily the kernel kind of "sleeping <br />semaphore").<br /><br />But it might be good to have that explicitly mentioned in the IA memory <br />ordering thing, so I'll ask the Intel people about that. However, I'd say <br />that given our *current* documentation, string instructions may be <br />*internally* out-of-order, but they would not escape a lock.<br /><br />&gt; But this means they are already at odds with spin_unlock, unless they <br />&gt; are enclosed with mfences everywhere they are used (of which I think <br />&gt; most are not). So this is an existing bug in the kernel.<br /><br />See above. I do not believe that it's an existing bug, but the basic point <br />that the change to "smp_rmb()" doesn't change our existing rules is true.<br /><br />			Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
