    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/9/12/329">First message in thread</a></li><li><a href="/lkml/2007/9/19/351">Linus Torvalds</a><ul><li><a href="/lkml/2007/9/19/357">Ingo Molnar</a><ul><li><a href="/lkml/2007/9/19/369">Ingo Molnar</a></li><li class="origin"><a href="/lkml/2007/9/19/409">Linus Torvalds</a><ul><li><a href="/lkml/2007/9/19/409">Ingo Molnar</a><ul><li><a href="/lkml/2007/9/19/414">Ingo Molnar</a></li><li><a href="/lkml/2007/9/19/426">Peter Zijlstra</a></li><li><a href="/lkml/2007/9/25/463">Antoine Martin</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 19 Sep 2007 13:28:47 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: CFS: some bad numbers with Java/database threading [FIXED]</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 19 Sep 2007, Ingo Molnar wrote:<br />&gt; <br />&gt; in CFS we dont have a per-nice-level rbtree, so we cannot move it dead <br />&gt; last within the same priority group - but we can move it dead last in <br />&gt; the whole tree. (then they'd be put even after nice +19 tasks.) People <br />&gt; might complain about _that_.<br /><br />Yeah, with reasonably good reason.<br /><br />The sched_yield() behaviour is actually very well-defined for RT tasks <br />(now, whether it's a good interface to use or not is still open to debate, <br />but at least it's a _defined_ interface ;), and I think we should at least <br />try to approximate that behaviour for normal tasks, even if they aren't <br />RT.<br /><br />And the closest you can get is basically to say something that is close to<br /><br />	"sched_yield()" on a non-RT process still means that all<br />	other runnable tasks in that same nice-level will be scheduled <br />	before the task is scheduled again.<br /><br />and I think that would be the optimal approximation of the RT behaviour.<br /><br />Now, quite understandably we might not be able to actually get that <br />*exact* behaviour (since we mix up different nice levels), but I think <br />from a QoI standpoint we should really have that as a "target" behaviour.<br /><br />So I think it should be moved back in the RB-tree, but really preferably <br />only back to behind all other processes at the same nice-level.<br /><br />So I think we have two problems with yield():<br /><br /> - it really doesn't have very nice/good semantics in the first place for <br />   anything but strict round-robin RT tasks.<br /><br />   We can't do much about this problem, apart from trying to make people <br />   use proper locking and other models that do *not* depend on yield().<br /><br /> - Linux has made the problem a bit worse by then having fairly arbitrary <br />   and different semantics over time.<br /><br />   This is where I think it would be a good idea to try to have the above <br />   kind of "this is the ideal behaviour - we don't guarantee it being <br />   precise, but at least we'd have some definition of what people should <br />   be able to expect is the "best" behaviour.<br /><br />So I don't think a "globally last" option is at all the best thing, but I <br />think it's likely better than what CFS does now. And if we then have some <br />agreement on what would be considered a further _improvement_, then that <br />would be a good thing - maybe we're not perfect, but at least having a <br />view of what we want to do is a good idea.<br /><br />Btw, the "enqueue at the end" could easily be a statistical thing, not an <br />absolute thing. So it's possible that we could perhaps implement the CFS <br />"yield()" using the same logic as we have now, except *not* calling the <br />"update_stats()" stuff:<br /><br />	__dequeue_entity(..);<br />	__enqueue_entity(..);<br /><br />and then just force the "fair_key" of the to something that <br />*statistically* means that it should be at the end of its nice queue.<br /><br />I dunno.<br /><br />		Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
