    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/9/11/176">First message in thread</a></li><li><a href="/lkml/2007/9/19/301">Andy Whitcroft</a><ul><li><a href="/lkml/2007/9/24/315">Badari Pulavarty</a><ul><li><a href="/lkml/2007/9/24/344">Andrew Morton</a></li><li class="origin"><a href="/lkml/2007/9/24/400">Linus Torvalds</a><ul><li><a href="/lkml/2007/9/24/400">Badari Pulavarty</a></li><li><a href="/lkml/2007/9/24/473">Badari Pulavarty</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2007/9/24/367/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 24 Sep 2007 13:04:56 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: 2.6.23-rc6: hanging ext3 dbench tests</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 24 Sep 2007, Badari Pulavarty wrote:<br />&gt; <br />&gt; Whats happening on my machine is ..<br />&gt; <br />&gt; dbench forks of 4 children and sends them a signal to start the work.<br />&gt; 3 out of 4 children gets the signal and does the work. One of the child<br />&gt; never gets the signal so, it waits forever in pause(). So, parent waits<br />&gt; for a longtime to kill it.<br /><br />Since this *seems* to have nothing to do with the filesystem, and since it <br />*seems* to have been introduced between -rc3 and -rc4, I did<br /><br />	gitk v2.6.23-rc3..v2.6.23-rc4 -- kernel/<br /><br />to see what has changed. One of the commits was signal-related, and that <br />one doesn't look like it could possibly matter.<br /><br />The rest were scheduler-related, which doesn't surprise me. In fact, even <br />before I looked, my reaction to your bug report was "That sounds like an <br />application race condition".<br /><br />Applications shouldn't use "pause()" for waiting for a signal. It's a <br />fundamentally racy interface - the signal could have happened just <br />*before* calling pause. So it's almost always a bug to use pause(), and <br />any users should be fixed to use "sigsuspend()" instead, which can <br />atomically (and correctly) pause for a signal while the process has masked <br />it outside of the system call.<br /><br />Now, I took a look at the dbench sources, and I have to say that the race <br />looks *very* unlikely (there's quite a small window in which it does<br /><br />	children[i].status = getpid();<br />	** race window here **<br />	pause();<br /><br />and it would require *just* the right timing so that the parent doesn't <br />end up doing the "sleep(1)" (which would make the window even less likely <br />to be hit), but there does seem to be a race condition there. And it <br />*could* be that you just happen to hit it on your hw setup.<br /><br />So before you do anything else, does this patch (TOTALLY UNTESTED! DONE <br />ENTIRELY LOOKING AT THE SOURCE! IT MAY RAPE ALL YOUR PETS, AND CALL YOU <br />BAD NAMES!) make any difference?<br /><br />(patch against unmodified dbench-2.0)<br /><br />		Linus<br /><br />---<br />diff --git a/dbench.c b/dbench.c<br />index ccf5624..4be5712 100644<br />--- a/dbench.c<br />+++ b/dbench.c<br />&#64;&#64; -91,10 +91,15 &#64;&#64; static double create_procs(int nprocs, void (*fn)(struct child_struct * ))<br /> <br /> 	for (i=0;i&lt;nprocs;i++) {<br /> 		if (fork() == 0) {<br />+			sigset_t old, blocked;<br />+<br />+			sigemptyset(&amp;blocked);<br />+			sigaddset(&amp;blocked, SIGCONT);<br />+			sigprocmask(SIG_BLOCK, &amp;blocked, &amp;old);<br /> 			setbuffer(stdout, NULL, 0);<br /> 			nb_setup(&amp;children[i]);<br /> 			children[i].status = getpid();<br />-			pause();<br />+			sigsuspend(&amp;old);<br /> 			fn(&amp;children[i]);<br /> 			_exit(0);<br /> 		}<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
