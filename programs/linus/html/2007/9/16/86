    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2007/9/13/19">First message in thread</a></li><li><a href="/lkml/2007/9/16/66">Randy Dunlap</a><ul><li><a href="/lkml/2007/9/16/72">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2007/9/17/3">Linus Torvalds</a><ul><li><a href="/lkml/2007/9/17/3">Randy Dunlap</a><ul><li><a href="/lkml/2007/9/17/4">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2007/9/16/91">Andi Kleen</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2007/9/16/86/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 16 Sep 2007 11:12:23 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: crashme fault</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sun, 16 Sep 2007, Linus Torvalds wrote:<br />&gt; <br />&gt; I'm really starting to suspect some early EM64T bug, and I also suspect <br />&gt; that it's harmless but that we should just do the trivial patch to say "if <br />&gt; the register state is in user mode, we don't care if the CPU says it was a <br />&gt; kernel access".<br /><br />Namely something like this..<br /><br />The basic idea is that it's pointless to test for "error_code &amp; PF_USER" <br />to decide whether we should oops or kill the process: the *real* issue is <br />whether we *can* kill the process or not. And that depends not on whether <br />the CPU claimed it was a user access or not, but on whether the register <br />state we'd return to is user-mode or not!<br /><br />So anything that decides whether it should send a signal or do to the <br />"no_context" Ooops path should use "user_mode_vm(regs)" (yeah, I realize <br />that the "_vm" part is unnecessary on x86-64, but it doesn't hurt either, <br />and all of the issues are the same on 32/64-bit) which tests the right <br />thing.<br /><br />Now, normally the USER bit in the error code should be the exact same <br />thing, except for<br /><br /> - Some CPU bug (microcode issue, whatever) where some complex fault <br />   situation sets the wrong error code.<br /><br /> - user space accesses that caused a system page fault (ie a page fault <br />   while handling another trap - possibly due to lazy page table setup <br />   and having the LDT or some other CPU data structure in vmalloc space)<br /><br />Now, the vmalloc space accesses should be handled separately anyway, so I <br />really wonder if it's some subtle CPU bug (I can't reproduce any problems <br />on my Core 2 Duo), but the point is that I think this patch really is <br />conceptually a real fix regardless, even if it _shouldn't_ matter.<br /><br />Comments?<br /><br />Randy, this replaces the hacky patch I sent, but also shuts up about the <br />odd thing you're hitting, so for testing your case further this may not be <br />the right thing. However, it would be nice to hear whether this just makes <br />"crashme" work properly for you without any side effects..<br /><br />		Linus<br /><br />----<br /> arch/x86_64/mm/fault.c |    9 ++++-----<br /> 1 files changed, 4 insertions(+), 5 deletions(-)<br /><br />diff --git a/arch/x86_64/mm/fault.c b/arch/x86_64/mm/fault.c<br />index 327c9f2..75270a0 100644<br />--- a/arch/x86_64/mm/fault.c<br />+++ b/arch/x86_64/mm/fault.c<br />&#64;&#64; -87,7 +87,7 &#64;&#64; static noinline int is_prefetch(struct pt_regs *regs, unsigned long addr,<br /> 	instr = (unsigned char __user *)convert_rip_to_linear(current, regs);<br /> 	max_instr = instr + 15;<br /> <br />-	if (user_mode(regs) &amp;&amp; instr &gt;= (unsigned char *)TASK_SIZE)<br />+	if (user_mode_vm(regs) &amp;&amp; instr &gt;= (unsigned char *)TASK_SIZE)<br /> 		return 0;<br /> <br /> 	while (scan_more &amp;&amp; instr &lt; max_instr) { <br />&#64;&#64; -320,7 +320,6 &#64;&#64; asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,<br /> <br /> 	info.si_code = SEGV_MAPERR;<br /> <br />-<br /> 	/*<br /> 	 * We fault-in kernel-space virtual memory on-demand. The<br /> 	 * 'reference' page table is init_mm.pgd.<br />&#64;&#64; -404,7 +403,7 &#64;&#64; asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,<br /> 		goto good_area;<br /> 	if (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))<br /> 		goto bad_area;<br />-	if (error_code &amp; 4) {<br />+	if (error_code &amp; PF_USER) {<br /> 		/* Allow userspace just enough access below the stack pointer<br /> 		 * to let the 'enter' instruction work.<br /> 		 */<br />&#64;&#64; -558,7 +557,7 &#64;&#64; out_of_memory:<br /> 		goto again;<br /> 	}<br /> 	printk("VM: killing process %s\n", tsk-&gt;comm);<br />-	if (error_code &amp; 4)<br />+	if (user_mode_vm(regs))<br /> 		do_group_exit(SIGKILL);<br /> 	goto no_context;<br /> <br />&#64;&#64; -566,7 +565,7 &#64;&#64; do_sigbus:<br /> 	up_read(&amp;mm-&gt;mmap_sem);<br /> <br /> 	/* Kernel mode? Handle exceptions or die */<br />-	if (!(error_code &amp; PF_USER))<br />+	if (!user_mode_vm(regs))<br /> 		goto no_context;<br /> <br /> 	tsk-&gt;thread.cr2 = address;<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
