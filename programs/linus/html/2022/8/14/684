    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2022/8/14/684">First message in thread</a></li><li class="origin"><a href="/lkml/2022/8/14/718">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/14/718">"Kirill A. Shutemov"</a><ul><li><a href="/lkml/2022/8/14/719">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/14/838">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/15/7">"Kirill A. Shutemov"</a></li><li><a href="/lkml/2022/8/15/228">Mike Rapoport</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2022/8/15/168">Peter Zijlstra</a><ul><li><a href="/lkml/2022/8/15/720">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/15/848">Peter Zijlstra</a></li><li><a href="/lkml/2022/8/15/3792">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/16/718">Peter Zijlstra</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2022/8/14/684/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 14 Aug 2022 14:14:08 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Simplify load_unaligned_zeropad() (was Re: [GIT PULL] Ceph updates for 5.20-rc1)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Aug 14, 2022 at 1:29 PM Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; I dug into it some more, and it is really "load_unaligned_zeropad()"<br />&gt; that makes clang really uncomfortable.<br />&gt;<br />&gt; The problem ends up being that clang sees that it's inside that inner<br />&gt; loop, and tries very hard to optimize the shift-and-mask that happens<br />&gt; if the exception happens.<br />&gt;<br />&gt; The fact that the exception *never* happens unless DEBUG_PAGEALLOC is<br />&gt; enabled - and very very seldom even then - is not something we can<br />&gt; really explain to clang.<br /><br />Hmm.<br /><br />The solution to that is actually to move the 'zeropad' part into the<br />exception handler.<br /><br />That makes both gcc and clang generate quite nice code for this all.<br />But perhaps equally importantly, it actually simplifies the code<br />noticeably:<br /><br /> arch/x86/include/asm/extable_fixup_types.h |  2 ++<br /> arch/x86/include/asm/word-at-a-time.h      | 50 +++---------------------------<br /> arch/x86/mm/extable.c                      | 30 ++++++++++++++++++<br /> 3 files changed, 37 insertions(+), 45 deletions(-)<br /><br />and that's with 11 of those 37 new lines being a new block comment.<br /><br />It's mainly because now there's no need to worry about<br />CONFIG_CC_HAS_ASM_GOTO_OUTPUT in load_unaligned_zeropad(), because the<br />asm becomes a simple "address in, data out" thing.<br /><br />And to make the fixup code simple and straightforward, I just made<br />"load_unaligned_zeropad()" use fixed registers for address and output,<br />which doesn't bother the compilers at all, they'll happily adjust<br />their register allocation. The code generation ends up much better<br />than with the goto and the subtle address games that never trigger<br />anyway.<br /><br />PeterZ - you've touched both the load_unaligned_zeropad() and the<br />exception code last, so let's run this past you, but this really does<br />seem to not only fix the code generation issue in fs/dcache.s, it just<br />looks simpler too. Comments?<br /><br />             Linus<br /> arch/x86/include/asm/extable_fixup_types.h |  2 ++<br /> arch/x86/include/asm/word-at-a-time.h      | 50 +++---------------------------<br /> arch/x86/mm/extable.c                      | 30 ++++++++++++++++++<br /> 3 files changed, 37 insertions(+), 45 deletions(-)<br /><br />diff --git a/arch/x86/include/asm/extable_fixup_types.h b/arch/x86/include/asm/extable_fixup_types.h<br />index 503622627400..b53f1919710b 100644<br />--- a/arch/x86/include/asm/extable_fixup_types.h<br />+++ b/arch/x86/include/asm/extable_fixup_types.h<br />&#64;&#64; -64,4 +64,6 &#64;&#64;<br /> #define	EX_TYPE_UCOPY_LEN4		(EX_TYPE_UCOPY_LEN | EX_DATA_IMM(4))<br /> #define	EX_TYPE_UCOPY_LEN8		(EX_TYPE_UCOPY_LEN | EX_DATA_IMM(8))<br /> <br />+#define EX_TYPE_ZEROPAD			20 /* load ax from dx zero-padded */<br />+<br /> #endif<br />diff --git a/arch/x86/include/asm/word-at-a-time.h b/arch/x86/include/asm/word-at-a-time.h<br />index 8338b0432b50..4893f1b30dd6 100644<br />--- a/arch/x86/include/asm/word-at-a-time.h<br />+++ b/arch/x86/include/asm/word-at-a-time.h<br />&#64;&#64; -77,58 +77,18 &#64;&#64; static inline unsigned long find_zero(unsigned long mask)<br />  * and the next page not being mapped, take the exception and<br />  * return zeroes in the non-existing part.<br />  */<br />-#ifdef CONFIG_CC_HAS_ASM_GOTO_OUTPUT<br />-<br /> static inline unsigned long load_unaligned_zeropad(const void *addr)<br /> {<br />-	unsigned long offset, data;<br /> 	unsigned long ret;<br /> <br />-	asm_volatile_goto(<br />-		"1:	mov %[mem], %[ret]\n"<br />-<br />-		_ASM_EXTABLE(1b, %l[do_exception])<br />-<br />-		: [ret] "=r" (ret)<br />-		: [mem] "m" (*(unsigned long *)addr)<br />-		: : do_exception);<br />-<br />-	return ret;<br />-<br />-do_exception:<br />-	offset = (unsigned long)addr &amp; (sizeof(long) - 1);<br />-	addr = (void *)((unsigned long)addr &amp; ~(sizeof(long) - 1));<br />-	data = *(unsigned long *)addr;<br />-	ret = data &gt;&gt; offset * 8;<br />-<br />-	return ret;<br />-}<br />-<br />-#else /* !CONFIG_CC_HAS_ASM_GOTO_OUTPUT */<br />-<br />-static inline unsigned long load_unaligned_zeropad(const void *addr)<br />-{<br />-	unsigned long offset, data;<br />-	unsigned long ret, err = 0;<br />-<br />-	asm(	"1:	mov %[mem], %[ret]\n"<br />+	asm volatile(<br />+		"1:	mov (%[addr]), %[ret]\n"<br /> 		"2:\n"<br />-<br />-		_ASM_EXTABLE_FAULT(1b, 2b)<br />-<br />-		: [ret] "=&amp;r" (ret), "+a" (err)<br />-		: [mem] "m" (*(unsigned long *)addr));<br />-<br />-	if (unlikely(err)) {<br />-		offset = (unsigned long)addr &amp; (sizeof(long) - 1);<br />-		addr = (void *)((unsigned long)addr &amp; ~(sizeof(long) - 1));<br />-		data = *(unsigned long *)addr;<br />-		ret = data &gt;&gt; offset * 8;<br />-	}<br />+		_ASM_EXTABLE_TYPE(1b, 2b, EX_TYPE_ZEROPAD)<br />+		: [ret] "=a" (ret)<br />+		: [addr] "d" (addr));<br /> <br /> 	return ret;<br /> }<br /> <br />-#endif /* CONFIG_CC_HAS_ASM_GOTO_OUTPUT */<br />-<br /> #endif /* _ASM_WORD_AT_A_TIME_H */<br />diff --git a/arch/x86/mm/extable.c b/arch/x86/mm/extable.c<br />index 331310c29349..58c79077a496 100644<br />--- a/arch/x86/mm/extable.c<br />+++ b/arch/x86/mm/extable.c<br />&#64;&#64; -41,6 +41,34 &#64;&#64; static bool ex_handler_default(const struct exception_table_entry *e,<br /> 	return true;<br /> }<br /> <br />+/*<br />+ * This is the *very* rare case where we do a "load_unaligned_zeropad()"<br />+ * and it's a page crosser into a non-existent page.<br />+ *<br />+ * This happens when we optimistically load a pathname a word-at-a-time<br />+ * and the name is less than the full word and the  next page is not<br />+ * mapped. Typically that only happens for CONFIG_DEBUG_PAGEALLOC.<br />+ *<br />+ * NOTE! The load is always of the form "mov (%edx),%eax" to make the<br />+ * fixup simple.<br />+ */<br />+static bool ex_handler_zeropad(const struct exception_table_entry *e,<br />+			       struct pt_regs *regs,<br />+			       unsigned long fault_addr)<br />+{<br />+	const unsigned long mask = sizeof(long) - 1;<br />+	unsigned long offset, addr;<br />+<br />+	offset = regs-&gt;dx &amp; mask;<br />+	addr = regs-&gt;dx &amp; ~mask;<br />+	if (fault_addr != addr + sizeof(long))<br />+		return false;<br />+<br />+	regs-&gt;ax = *(unsigned long *)addr &gt;&gt; (offset * 8);<br />+	regs-&gt;ip = ex_fixup_addr(e);<br />+	return true;<br />+}<br />+<br /> static bool ex_handler_fault(const struct exception_table_entry *fixup,<br /> 			     struct pt_regs *regs, int trapnr)<br /> {<br />&#64;&#64; -217,6 +245,8 &#64;&#64; int fixup_exception(struct pt_regs *regs, int trapnr, unsigned long error_code,<br /> 		return ex_handler_sgx(e, regs, trapnr);<br /> 	case EX_TYPE_UCOPY_LEN:<br /> 		return ex_handler_ucopy_len(e, regs, trapnr, reg, imm);<br />+	case EX_TYPE_ZEROPAD:<br />+		return ex_handler_zeropad(e, regs, fault_addr);<br /> 	}<br /> 	BUG();<br /> }</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
