    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2022/8/15/860">First message in thread</a></li><li><a href="/lkml/2022/8/16/454">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/16/469">Hector Martin</a><ul><li><a href="/lkml/2022/8/16/525">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/16/475">Hector Martin</a><ul><li><a href="/lkml/2022/8/16/600">Herbert Xu</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2022/8/16/530">Herbert Xu</a><ul><li><a href="/lkml/2022/8/16/500">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2022/8/16/1139">Will Deacon</a><ul><li><a href="/lkml/2022/8/16/1196">Boqun Feng</a><ul><li><a href="/lkml/2022/8/16/1329">Boqun Feng</a></li><li><a href="/lkml/2022/8/16/1342">Linus Torvalds</a></li></ul></li><li class="origin"><a href="/lkml/2022/8/17/21">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/17/21">Herbert Xu</a></li></ul></li><li><a href="/lkml/2022/8/16/1344">Tejun Heo</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 16 Aug 2022 09:41:52 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] workqueue: Fix memory ordering race in queue_work*()</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Aug 16, 2022 at 6:42 AM Will Deacon &lt;will&#64;kernel.org&gt; wrote:<br />&gt;<br />&gt; &gt; Will?<br />&gt;<br />&gt; Right, this looks like it's all my fault, so sorry about that.<br /><br />It's interesting how this bug has existed for basically four years.<br /><br />I suspect that the thing is fairly hard to hit in practice,<br />particularly on the kinds of devices most common (ie limited OoO<br />windows on most phone SoCs).<br /><br />Together with phone loads probably not generally being all that<br />exciting from a kernel standpoint (a lot of driver work, probably not<br />a lot of workqueue stuff).<br /><br />&gt;   1. Upgrade test_and_{set,clear}_bit() to have a full memory barrier<br />&gt;      regardless of the value which is read from memory. The lock/unlock<br />&gt;      flavours can remain as-is.<br /><br />I've applied Hector's "locking/atomic: Make test_and_*_bit() ordered<br />on failure".<br /><br />&gt;   2. Fix the documentation<br /><br />That patch had a bit of a fix, but it is probably worth looking at more.<br /><br />&gt;   3. Figure out what to do about architectures building atomics out of<br />&gt;      spinlocks (probably ok as lock+unlock == full barrier there?)<br /><br />Yeah, I wonder how we should describe the memory ordering here. We've<br />always punted on it, saying it's a "memory barrier", but that has been<br />partly a "look, that's the traditional x86 model".<br /><br />And the traditional x86 model really sees the locked RMW operations as<br />being one single operation - in ways that most other architectures<br />don't.<br /><br />So on x86, it's more than "this implies a memory barrier" - it's also<br />that there is no visible load-modify-store sequence where you can<br />start asking "what about the ordering of the _load_ wrt the preceding<br />memory operations".<br /><br />That makes the x86 behavior very easy to think about, but means that<br />when you have bitops implemented other ways, you have questions that<br />are much harder to answer.<br /><br />So in a Lock+read+op+write+unlock sequence, you can have preceding<br />operations move into the locked region, and mix with the read+op+write<br />side.<br /><br />&gt;   4. Accept my sincerest apologies for the mess!<br /><br />I don't think you were the source of the mess. The *source* of the<br />mess is that we've always had very messy rules about the bitops in<br />particular.<br /><br />I think the *code* is fixed (at least wrt the generic implementation,<br />I think the other models are up for discussion), but I think the real<br />issue is how we should describe the requirements.<br /><br />So I think we have at least three cases we need to deal with:<br /><br /> (a) the people who just want atomics, and don't care about any<br />ordering. They are bound to exist.<br /><br /> (b) the people who want "acquire"-like semantics. I think the<br />existing test_and_set_bit_lock() is fine<br /><br /> (c) the people who want "release"-like semantics, where the<br />"test-and-set-bit" is for announcing "I'm done, was I the first one?".<br /><br /> (d) the full barrier case<br /><br />I think we currently actively have (b) and (d), but it's possible that<br />the workqueue case really is only (c).<br /><br />And I think the spinlock implementation really most naturally has that<br />(c) semantics - you don't necessarily get some theoretical full memory<br />barrier, but you *do* get those "handover" semantics.<br /><br />Maybe we never really want or need (d) at all?<br /><br />So I get the feeling that we really shouldn't specify<br />"test_and_set_bit()" in terms of memory barriers at all. I *think* it<br />would be more natural to describe them in terms of "handover" (ie<br />acquire/release), and then the spinlock semantics are obviously fine.<br /><br />So I htink the code problem is easy, I think the real problem here has<br />always been bad documentation, and it would be really good to clarify<br />that.<br /><br />Comments?<br /><br />              Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
