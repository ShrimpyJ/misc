    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2022/8/14/684">First message in thread</a></li><li><a href="/lkml/2022/8/15/3792">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/16/718">Peter Zijlstra</a><ul><li class="origin"><a href="/lkml/2022/8/17/185">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/17/185">Peter Zijlstra</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 16 Aug 2022 10:57:45 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Simplify load_unaligned_zeropad() (was Re: [GIT PULL] Ceph updates for 5.20-rc1)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Aug 16, 2022 at 1:02 AM Peter Zijlstra &lt;peterz&#64;infradead.org&gt; wrote:<br />&gt;<br />&gt; &gt; +#define EX_TYPE_ZEROPAD                      20 /* load ax from dx zero-padded */<br />&gt;<br />&gt; This comment is now woefully incorrect.<br /><br />Yes it is. Will fix.<br /><br />&gt; &gt; +     if (insn_decode(&amp;insn, (void *) regs-&gt;ip, len, INSN_MODE_KERN))<br />&gt; &gt; +             return false;<br />&gt;<br />&gt; We have insn_decode_kernel() for exactly this (very) common case.<br /><br />I did that originally, and then I undid it in disgust, because that<br />interface is too simple.<br /><br />In particular, it just uses MAX_INSN_SIZE blindly. Which I didn't want<br />to do when I actually had the instruction size.<br /><br />Yes, yes, I also check the decode size after-the-fact, but I didn't<br />want the decoder to even look at the invalid bytes.<br /><br />This exception case is about the data being at the end of the page, I<br />wanted the fixup to be aware of code being at the end of a page too.<br /><br />(And yeah, I'm not convinced that the decoder is that careful, but at<br />that point I feel it's a decoder issue, and not an issue with the code<br />I write).<br /><br />&gt; &gt; +     if (insn.length != len)<br />&gt; &gt; +             return false;<br />&gt; &gt; +<br />&gt; &gt; +     if (insn.opcode.bytes[0] != 0x8b)<br />&gt; &gt; +             return false;<br />&gt;<br />&gt; I was wondering if we want something like MOV_INSN_OPCODE for 0x8b to<br />&gt; enhance readability, otoh it's currently 0x8b all over the place, so<br />&gt; whatever. At some point you gotta have the insn tables with you anyway.<br /><br />Oh, I didn't even notice that we had another case of 0x8b checking.<br />But yeah, the MMIO decoding wants to see what kind of access it is.<br /><br />But it wouldn't be MOV_INSN_OPCODE, it would have to be something like<br />MOV_WORD_INSN_MODRM_REG_OPCODE, because that's what people are<br />checking for - not just that it's a 'mov', but direction and size too.<br /><br />And then you'd have to also decide whether you describe those<br />#define's using the Intel ordering or the one we actually use in our<br />asm. So now the symbolic names are ambiguous anyway, in ways that the<br />actual byte value isn't.<br /><br />So yeah, I suspect it ends up just being an issue of "you have to have<br />the opcode tables in front of you anyway".<br /><br />Because you also need to check that that's the only encoding for "mov"<br />(I checked, and yes, it is - there are other 'mov' encodings that move<br />directly from memory into %rax, but those are using absolute addresses<br />that don't make sense for a "this is an unaligned that might be a page<br />crosser")<br /><br />Side note: now that I look at it, I note that the MMIO decoding<br />doesn't handle the absolute address case. It's not really relevant for<br />the kernel, but I could *imagine* that it is relevant in user mode,<br />and the SEV case actually does have a "decode and emulate user mode<br />instruction case".<br /><br />Not a big issue. If some crazy user even maps IO at a fixed address,<br />and then uses a "mov %eax &lt;-&gt; moffset" instruction, the kernel<br />emulation will print out an error and refuse to emulate it.<br /><br />                  Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
