    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2022/8/14/684">First message in thread</a></li><li><a href="/lkml/2022/8/15/168">Peter Zijlstra</a><ul><li><a href="/lkml/2022/8/15/720">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/15/848">Peter Zijlstra</a></li><li class="origin"><a href="/lkml/2022/8/16/718">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/16/718">Peter Zijlstra</a><ul><li><a href="/lkml/2022/8/16/1396">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patches in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2022/8/15/3792/1">Get diff 1</a></li><li><a href="/lkml/diff/2022/8/15/3792/2">Get diff 2</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 15 Aug 2022 15:49:44 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Simplify load_unaligned_zeropad() (was Re: [GIT PULL] Ceph updates for 5.20-rc1)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Aug 15, 2022 at 1:09 PM Peter Zijlstra &lt;peterz&#64;infradead.org&gt; wrote:<br />&gt;<br />&gt; I'm not at all suggesting we do this; but it might be<br />&gt; insn_get_addr_ref() does what is needed.<br /><br />.. you didn't suggest it at all, but I started doing it anyway.<br /><br />It's a bit more complicated, and the fixup certainly isn't that<br />trivial thing any more, but you were right, it's not *that*<br />complicated, and it does allow us to use arbitrary 'mov' instructions.<br /><br />And while it now has more added lines than deletions, and the diffstat now says<br /><br /> 3 files changed, 60 insertions(+), 43 deletions(-)<br /><br />most of the added lines are still that block comment, and some *very*<br />anal but trivial sanity checks of the instruction decode.<br /><br />So I could have made it smaller than it used to be by just not doing<br />any of those verifications, and maybe I went a bit overboard, but I<br />think this is such a rare case that it's better to be ridiculously<br />careful than to try to minimize the number of lines.<br /><br />So it may be a few more lines, but I can argue that it is still at<br />least conceptually simpler than the conditional asm goto with outputs<br />code was.<br /><br />And yeah, it makes some of the code generation places marginally better.<br /><br />So since I was tricked into writing this patch, and it's even tested<br />(the second attachment has a truly stupid patch with my test-case), I<br />think it's worth doing.<br /><br />Comments? I left your "Acked-by" from the previous version of this<br />thing, so holler now if you think this got too ugly in the meantime..<br /><br />               Linus<br />From 310edfc7b6b0c9a7921f11c051234c79385130ed Mon Sep 17 00:00:00 2001<br />From: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />Date: Sun, 14 Aug 2022 14:16:13 -0700<br />Subject: [PATCH] x86: simplify load_unaligned_zeropad() implementation<br /><br />The exception for the "unaligned access at the end of the page, next<br />page not mapped" never happens, but the fixup code ends up causing<br />trouble for compilers to optimize well.<br /><br />clang in particular ends up seeing it being in the middle of a loop, and<br />tries desperately to optimize the exception fixup code that is never<br />really reached.<br /><br />The simple solution is to just move all the fixups into the exception<br />handler itself, which moves it all out of the hot case code, and means<br />that the compiler never sees it or needs to worry about it.<br /><br />Acked-by: Peter Zijlstra &lt;peterz&#64;infradead.org&gt;<br />Signed-off-by: Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt;<br />---<br /> arch/x86/include/asm/extable_fixup_types.h |  2 +<br /> arch/x86/include/asm/word-at-a-time.h      | 46 ++----------------<br /> arch/x86/mm/extable.c                      | 55 ++++++++++++++++++++++<br /> 3 files changed, 60 insertions(+), 43 deletions(-)<br /><br />diff --git a/arch/x86/include/asm/extable_fixup_types.h b/arch/x86/include/asm/extable_fixup_types.h<br />index 503622627400..b53f1919710b 100644<br />--- a/arch/x86/include/asm/extable_fixup_types.h<br />+++ b/arch/x86/include/asm/extable_fixup_types.h<br />&#64;&#64; -64,4 +64,6 &#64;&#64;<br /> #define	EX_TYPE_UCOPY_LEN4		(EX_TYPE_UCOPY_LEN | EX_DATA_IMM(4))<br /> #define	EX_TYPE_UCOPY_LEN8		(EX_TYPE_UCOPY_LEN | EX_DATA_IMM(8))<br /> <br />+#define EX_TYPE_ZEROPAD			20 /* load ax from dx zero-padded */<br />+<br /> #endif<br />diff --git a/arch/x86/include/asm/word-at-a-time.h b/arch/x86/include/asm/word-at-a-time.h<br />index 8338b0432b50..46b4f1f7f354 100644<br />--- a/arch/x86/include/asm/word-at-a-time.h<br />+++ b/arch/x86/include/asm/word-at-a-time.h<br />&#64;&#64; -77,58 +77,18 &#64;&#64; static inline unsigned long find_zero(unsigned long mask)<br />  * and the next page not being mapped, take the exception and<br />  * return zeroes in the non-existing part.<br />  */<br />-#ifdef CONFIG_CC_HAS_ASM_GOTO_OUTPUT<br />-<br /> static inline unsigned long load_unaligned_zeropad(const void *addr)<br /> {<br />-	unsigned long offset, data;<br /> 	unsigned long ret;<br /> <br />-	asm_volatile_goto(<br />+	asm volatile(<br /> 		"1:	mov %[mem], %[ret]\n"<br />-<br />-		_ASM_EXTABLE(1b, %l[do_exception])<br />-<br />-		: [ret] "=r" (ret)<br />-		: [mem] "m" (*(unsigned long *)addr)<br />-		: : do_exception);<br />-<br />-	return ret;<br />-<br />-do_exception:<br />-	offset = (unsigned long)addr &amp; (sizeof(long) - 1);<br />-	addr = (void *)((unsigned long)addr &amp; ~(sizeof(long) - 1));<br />-	data = *(unsigned long *)addr;<br />-	ret = data &gt;&gt; offset * 8;<br />-<br />-	return ret;<br />-}<br />-<br />-#else /* !CONFIG_CC_HAS_ASM_GOTO_OUTPUT */<br />-<br />-static inline unsigned long load_unaligned_zeropad(const void *addr)<br />-{<br />-	unsigned long offset, data;<br />-	unsigned long ret, err = 0;<br />-<br />-	asm(	"1:	mov %[mem], %[ret]\n"<br /> 		"2:\n"<br />-<br />-		_ASM_EXTABLE_FAULT(1b, 2b)<br />-<br />-		: [ret] "=&amp;r" (ret), "+a" (err)<br />+		_ASM_EXTABLE_TYPE(1b, 2b, EX_TYPE_ZEROPAD)<br />+		: [ret] "=r" (ret)<br /> 		: [mem] "m" (*(unsigned long *)addr));<br /> <br />-	if (unlikely(err)) {<br />-		offset = (unsigned long)addr &amp; (sizeof(long) - 1);<br />-		addr = (void *)((unsigned long)addr &amp; ~(sizeof(long) - 1));<br />-		data = *(unsigned long *)addr;<br />-		ret = data &gt;&gt; offset * 8;<br />-	}<br />-<br /> 	return ret;<br /> }<br /> <br />-#endif /* CONFIG_CC_HAS_ASM_GOTO_OUTPUT */<br />-<br /> #endif /* _ASM_WORD_AT_A_TIME_H */<br />diff --git a/arch/x86/mm/extable.c b/arch/x86/mm/extable.c<br />index 331310c29349..60814e110a54 100644<br />--- a/arch/x86/mm/extable.c<br />+++ b/arch/x86/mm/extable.c<br />&#64;&#64; -41,6 +41,59 &#64;&#64; static bool ex_handler_default(const struct exception_table_entry *e,<br /> 	return true;<br /> }<br /> <br />+/*<br />+ * This is the *very* rare case where we do a "load_unaligned_zeropad()"<br />+ * and it's a page crosser into a non-existent page.<br />+ *<br />+ * This happens when we optimistically load a pathname a word-at-a-time<br />+ * and the name is less than the full word and the  next page is not<br />+ * mapped. Typically that only happens for CONFIG_DEBUG_PAGEALLOC.<br />+ *<br />+ * NOTE! The faulting address is always a 'mov mem,reg' type instruction<br />+ * of size 'long', and the exception fixup must always point to right<br />+ * after the instruction.<br />+ */<br />+static bool ex_handler_zeropad(const struct exception_table_entry *e,<br />+			       struct pt_regs *regs,<br />+			       unsigned long fault_addr)<br />+{<br />+	struct insn insn;<br />+	const unsigned long mask = sizeof(long) - 1;<br />+	unsigned long offset, addr, next_ip, len;<br />+	unsigned long *reg;<br />+<br />+	next_ip = ex_fixup_addr(e);<br />+	len = next_ip - regs-&gt;ip;<br />+	if (len &gt; MAX_INSN_SIZE)<br />+		return false;<br />+<br />+	if (insn_decode(&amp;insn, (void *) regs-&gt;ip, len, INSN_MODE_KERN))<br />+		return false;<br />+	if (insn.length != len)<br />+		return false;<br />+<br />+	if (insn.opcode.bytes[0] != 0x8b)<br />+		return false;<br />+	if (insn.opnd_bytes != sizeof(long))<br />+		return false;<br />+<br />+	addr = (unsigned long) insn_get_addr_ref(&amp;insn, regs);<br />+	if (addr == ~0ul)<br />+		return false;<br />+<br />+	offset = addr &amp; mask;<br />+	addr = addr &amp; ~mask;<br />+	if (fault_addr != addr + sizeof(long))<br />+		return false;<br />+<br />+	reg = insn_get_modrm_reg_ptr(&amp;insn, regs);<br />+	if (!reg)<br />+		return false;<br />+<br />+	*reg = *(unsigned long *)addr &gt;&gt; (offset * 8);<br />+	return ex_handler_default(e, regs);<br />+}<br />+<br /> static bool ex_handler_fault(const struct exception_table_entry *fixup,<br /> 			     struct pt_regs *regs, int trapnr)<br /> {<br />&#64;&#64; -217,6 +270,8 &#64;&#64; int fixup_exception(struct pt_regs *regs, int trapnr, unsigned long error_code,<br /> 		return ex_handler_sgx(e, regs, trapnr);<br /> 	case EX_TYPE_UCOPY_LEN:<br /> 		return ex_handler_ucopy_len(e, regs, trapnr, reg, imm);<br />+	case EX_TYPE_ZEROPAD:<br />+		return ex_handler_zeropad(e, regs, fault_addr);<br /> 	}<br /> 	BUG();<br /> }<br />-- <br />2.37.1.289.g45aa1e5c72.dirty<br /> init/main.c | 13 +++++++++++++<br /> 1 file changed, 13 insertions(+)<br /><br />diff --git a/init/main.c b/init/main.c<br />index 91642a4e69be..c1e632582419 100644<br />--- a/init/main.c<br />+++ b/init/main.c<br />&#64;&#64; -108,6 +108,8 &#64;&#64;<br /> #include &lt;asm/sections.h&gt;<br /> #include &lt;asm/cacheflush.h&gt;<br /> <br />+#include &lt;asm/word-at-a-time.h&gt;<br />+<br /> #define CREATE_TRACE_POINTS<br /> #include &lt;trace/events/initcall.h&gt;<br /> <br />&#64;&#64; -1488,6 +1490,15 &#64;&#64; void __weak free_initmem(void)<br /> 	free_initmem_default(POISON_FREE_INITMEM);<br /> }<br /> <br />+static int test_unaligned(void *unused)<br />+{<br />+	void *buf = vmalloc(PAGE_SIZE);<br />+	memset(buf, 0xfe, PAGE_SIZE);<br />+	printk("load_unaligned_zeropad = %016lx\n", load_unaligned_zeropad(buf + PAGE_SIZE - 5));<br />+	kthread_exit(0);<br />+}<br />+<br />+<br /> static int __ref kernel_init(void *unused)<br /> {<br /> 	int ret;<br />&#64;&#64; -1518,6 +1529,8 &#64;&#64; static int __ref kernel_init(void *unused)<br /> 	system_state = SYSTEM_RUNNING;<br /> 	numa_default_policy();<br /> <br />+kernel_thread(test_unaligned, NULL, CLONE_FS | CLONE_FILES);<br />+<br /> 	rcu_end_inkernel_boot();<br /> <br /> 	do_sysctl_args();</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
