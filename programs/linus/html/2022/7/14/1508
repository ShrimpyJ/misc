    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2022/7/14/1420">First message in thread</a></li><li><a href="/lkml/2022/7/14/1420">Nick Desaulniers</a><ul><li><a href="/lkml/2022/7/14/1434">Linus Torvalds</a><ul><li><a href="/lkml/2022/7/14/1454">Nick Desaulniers</a><ul><li><a href="/lkml/2022/7/14/1463">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2022/7/14/1435">Nathan Chancellor</a></li><li class="origin"><a href="/lkml/2022/7/16/258">Linus Torvalds</a><ul><li><a href="/lkml/2022/7/16/258">Linus Torvalds</a><ul><li><a href="/lkml/2022/7/21/712">Nick Desaulniers</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 14 Jul 2022 16:15:35 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] ubsan: disable UBSAN_DIV_ZERO for clang</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Thu, Jul 14, 2022 at 1:56 PM Nick Desaulniers<br />&lt;ndesaulniers&#64;google.com&gt; wrote:<br />&gt;<br />&gt; Building with UBSAN_DIV_ZERO with clang produces numerous fallthrough<br />&gt; warnings from objtool.<br /><br />Ok, with this applied, things are better.<br /><br />There are still the "__ubsan_handle_load_invalid_value() with UACCESS<br />enabled" messages, but those are misfeatures of the kvm cmpxchg<br />implementation.<br /><br />I'm not entirely sure why the clang build warns but gcc doesn't, but I<br />*think* it's because clang is just being silly. It *looks* like it<br />checks that a "bool" has a value range of 0/1, and will complain if<br />not.<br /><br />And the reason I say that's silly is that if I read it correctly, then<br />that value has literally been generated by clang itself, using "setz"<br />instruction.<br /><br />It's the __try_cmpxchg_user_asm() macro, and with clang-14 I have it's<br />that CONFIG_CC_HAS_ASM_GOTO_TIED_OUTPUT case, and the C code uses<br />inline asm and does<br /><br />        asm_volatile_goto("\n"                                          \<br />                     "1: " LOCK_PREFIX "cmpxchg"itype" %[new], %[ptr]\n"\<br />                     _ASM_EXTABLE_UA(1b, %l[label])                     \<br />                     : CC_OUT(z) (success),                             \<br /><br />where that CC_OUT() in this case turns into<br /><br />   # define CC_OUT(c) "=&#64;cc" #c<br /><br />and clang generates this code for it:<br /><br />   7d01e:       f0 48 0f b1 4d 00       lock cmpxchg %rcx,0x0(%rbp)<br />   7d024:       49 89 c5                mov    %rax,%r13<br />   7d027:       0f 94 c0                sete   %al<br />   7d02a:       41 88 c6                mov    %al,%r14b<br />   7d02d:       bf 02 00 00 00          mov    $0x2,%edi<br />   7d032:       44 89 f6                mov    %r14d,%esi<br />   7d035:       e8 00 00 00 00          call    __sanitizer_cov_trace_const_cmp1<br />   7d03a:       41 80 fe 01             cmp    $0x1,%r14b<br />   7d03e:       0f 87 af 01 00 00       ja     7d1f3<br />&lt;emulator_cmpxchg_emulated+0x6b3&gt;<br /><br />where that last "ja     7d1f3" is the branch to the code that then<br />calls __ubsan_handle_load_invalid_value.<br /><br />But look at that code: it's literally<br /><br />    sete   %al<br />    mov    %al,%r14b<br />    cmp    $0x1,%r14b<br /><br />where clang has generated that "sete itself, and then it verifies that<br />the result is "&lt;= 1".<br /><br />IOW, clang seems to be literally just checking that the "sete"<br />instruction works right.<br /><br />That's silly.<br /><br />Maybe I'm misreading this, but I think the reason the clang build<br />complains, but the gcc build does not, is simply because gcc isn't<br />doing crazy checks of how the CPU works.<br /><br />Some mis-feature of the "asm with flag output" code, where clang<br />doesn't understand that it generated that code itself, and the "setcc"<br />instruction always returns 0/1?<br /><br />The old issue with "memcpy/memset() leaves .noinstr.text section"<br />because clang has generated out-of-line functions for trivial copies<br />also remains, but whatever.<br /><br />             Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
