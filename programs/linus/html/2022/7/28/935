    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2022/7/28/935">First message in thread</a></li><li class="origin"><a href="/lkml/2022/7/28/1048">Linus Torvalds</a><ul><li><a href="/lkml/2022/7/28/1048">Linus Torvalds</a><ul><li><a href="/lkml/2022/8/1/981">Nick Desaulniers</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 28 Jul 2022 11:49:24 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 0/5] lib/find: optimize find_bit() functions</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Thu, Jul 28, 2022 at 9:12 AM Yury Norov &lt;yury.norov&#64;gmail.com&gt; wrote:<br />&gt;<br />&gt; In the recent discussion [1], it was noticed that find_next_bit()<br />&gt; functions may be improved by adding wrappers around common<br />&gt; __find_next_bit().<br /><br />So looking at the end result, this generates fairly good code.<br /><br />I say "fairly good" because _find_next_and_bit() ends up being disgusting.<br /><br />The reason? That<br /><br />        if (addr2)<br />                tmp &amp;= addr2[start / BITS_PER_LONG];<br /><br />generates horrific code when 'addr2' isn't seen to be always NULL.<br /><br />So this doesn't affect the regular _find_next_bit case, because the<br />inliner sees that addr2 is always NULL and doesn't generate extra code<br />for it.<br /><br />But the code that actually *does* have two incoming bitmasks will now<br />pointlessly test that second bitmask pointer all the time.<br /><br />Now, that particular function probably doesn't matter, but this code<br />seems to be unnecessarily written to try to be overly generic, and<br />that<br /><br /> (a) makes it hard to read the source code because the source code<br />doesn't do the obvious thing<br /><br /> (b) clearly generates suboptimal code too<br /><br />so I'm really not a huge fan of this "try to share code". Not when the<br />resulting shared code is harder to read, and impossible for the<br />compiler to do a great job at.<br /><br />And the code sharing really doesn't help all that much.<br /><br />If you really want to generate good code, use macros, and share the<br />logic that way. Not hugely readable either, but I think it's actually<br />not bad.<br /><br />I think something like this would work:<br /><br />    #define BIT_FIND_SETUP(addr, size, start)                   \<br />        unsigned long val, idx;                                 \<br />        if (unlikely(start &gt;= size))                            \<br />                return size;                                    \<br />        idx = start / BITS_PER_LONG;<br /><br />    #define BIT_FIND_FIRST_WORD(addr, size, start, EXPRESSION)  \<br />        if (!IS_ALIGNED(start, BITS_PER_LONG)) {                \<br />                unsigned long mask;                             \<br />                mask = BITMAP_FIRST_WORD_MASK(start);           \<br />                if ((val = mask &amp; (EXPRESSION)) != 0)           \<br />                        goto found;                             \<br />                idx++;                                          \<br />        }<br /><br />    #define BIT_WORD_LOOP(ptr, size, idx, val, EXPRESSION)              \<br />        do {                                                    \<br />                if ((val = (EXPRESSION)) != 0)                  \<br />                         goto found;                            \<br />                idx++;                                          \<br />        } while ((idx)*BITS_PER_LONG &lt; (size));<br /><br />    #define BIT_FIND_BODY(addr, size, start, EXPRESSION)                \<br />        BIT_FIND_SETUP(addr, size, start)                       \<br />        BIT_FIND_FIRST_WORD(addr, size, start, EXPRESSION)      \<br />        BIT_WORD_LOOP(addr, size, idx, val, EXPRESSION) \<br />        return size;                                            \<br />    found:      BIT_WORD_SWAB(val);                                     \<br />        return min((idx)*BITS_PER_LONG + __ffs(val), size)<br /><br />    #define BIT_WORD_SWAB(x) /* Nothing */<br /><br />and then for the BE versions you just use the same macros, but you<br />make BIT_WORD_SWAB() do the swab.<br /><br />I'm attaching an UNTESTED version of lib/find_bit.c that works the<br />above way (note: it is based on your header file changes!)<br /><br />It builds for me and seems to generate reasonable code, although I<br />notice that clang messes up the "__ffs()" inline asm and forces the<br />source into memory.<br /><br />(Gcc doesn't do that, but gcc follows the code exactly and generates<br />"shl $6" instructions, while clang seems to figure out that it can<br />just add 64 instead)<br /><br />                        Linus<br />// SPDX-License-Identifier: GPL-2.0-or-later<br />/* bit search implementation<br /> *<br /> * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.<br /> * Written by David Howells (dhowells&#64;redhat.com)<br /> *<br /> * Copyright (C) 2008 IBM Corporation<br /> * 'find_last_bit' is written by Rusty Russell &lt;rusty&#64;rustcorp.com.au&gt;<br /> * (Inspired by David Howell's find_next_bit implementation)<br /> *<br /> * Rewritten by Yury Norov &lt;yury.norov&#64;gmail.com&gt; to decrease<br /> * size and improve performance, 2015.<br /> */<br /><br />#include &lt;linux/bitops.h&gt;<br />#include &lt;linux/bitmap.h&gt;<br />#include &lt;linux/export.h&gt;<br />#include &lt;linux/math.h&gt;<br />#include &lt;linux/minmax.h&gt;<br />#include &lt;linux/swab.h&gt;<br /><br />#define BIT_FIND_SETUP(addr, size, start)			\<br />	unsigned long val, idx;					\<br />	if (unlikely(start &gt;= size))				\<br />		return size;					\<br />	idx = start / BITS_PER_LONG;<br /><br />#define BIT_FIND_FIRST_WORD(addr, size, start, EXPRESSION)	\<br />	if (!IS_ALIGNED(start, BITS_PER_LONG)) {		\<br />		unsigned long mask;				\<br />		mask = BITMAP_FIRST_WORD_MASK(start);		\<br />		if ((val = mask &amp; (EXPRESSION)) != 0)		\<br />			goto found;				\<br />		idx++;						\<br />	}<br /><br />#define BIT_WORD_LOOP(ptr, size, idx, val, EXPRESSION)		\<br />	do {							\<br />		if ((val = (EXPRESSION)) != 0)			\<br />			 goto found;				\<br />		idx++;						\<br />	} while ((idx)*BITS_PER_LONG &lt; (size));<br /><br />#define BIT_FIND_BODY(addr, size, start, EXPRESSION)		\<br />	BIT_FIND_SETUP(addr, size, start)			\<br />	BIT_FIND_FIRST_WORD(addr, size, start, EXPRESSION)	\<br />	BIT_WORD_LOOP(addr, size, idx, val, EXPRESSION)	\<br />	return size;						\<br />found:	BIT_WORD_SWAB(val);					\<br />	return min((idx)*BITS_PER_LONG + __ffs(val), size)<br /><br />#define BIT_WORD_SWAB(x) /* Nothing */<br /><br />unsigned long _find_first_bit(const unsigned long *addr, unsigned long size)<br />{ BIT_FIND_BODY(addr, size, 0, addr[idx]); }<br /><br />unsigned long _find_first_zero_bit(const unsigned long *addr, unsigned long size)<br />{ BIT_FIND_BODY(addr, size, 0, ~addr[idx]); }<br /><br />unsigned long _find_next_bit(const unsigned long *addr, unsigned long size, unsigned long start)<br />{ BIT_FIND_BODY(addr, size, start, addr[idx]); }<br /><br />unsigned long _find_next_zero_bit(const unsigned long *addr, unsigned long size, unsigned long start)<br />{ BIT_FIND_BODY(addr, size, start, ~addr[idx]); }<br /><br />unsigned long _find_first_and_bit(const unsigned long *addr1, const unsigned long *addr2, unsigned long size)<br />{ BIT_FIND_BODY(addr, size, 0, addr1[idx] &amp; addr2[idx]); }<br /><br />unsigned long _find_next_and_bit(const unsigned long *addr1, const unsigned long *addr2, unsigned long size, unsigned long start)<br />{ BIT_FIND_BODY(addr, size, start, addr1[idx] &amp; addr2[idx]); }<br /><br />#ifdef __BIG_ENDIAN<br /><br />#undef BIT_WORD_SWAB<br />#define BIT_WORD_SWAB(val) val = swab(val)<br /><br />.. FIXME: same as above, now with _find_first_bit_le() etc ..<br /><br />#endif<br /><br />#ifndef find_last_bit<br />unsigned long _find_last_bit(const unsigned long *addr, unsigned long size)<br />{<br />	if (size) {<br />		unsigned long val = BITMAP_LAST_WORD_MASK(size);<br />		unsigned long idx = (size-1) / BITS_PER_LONG;<br /><br />		do {<br />			val &amp;= addr[idx];<br />			if (val)<br />				return idx * BITS_PER_LONG + __fls(val);<br /><br />			val = ~0ul;<br />		} while (idx--);<br />	}<br />	return size;<br />}<br />EXPORT_SYMBOL(_find_last_bit);<br />#endif<br /><br />unsigned long find_next_clump8(unsigned long *clump, const unsigned long *addr,<br />			       unsigned long size, unsigned long offset)<br />{<br />	offset = find_next_bit(addr, size, offset);<br />	if (offset == size)<br />		return size;<br /><br />	offset = round_down(offset, 8);<br />	*clump = bitmap_get_value8(addr, offset);<br /><br />	return offset;<br />}<br />EXPORT_SYMBOL(find_next_clump8);<br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
