    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/11/17/169">First message in thread</a></li><li><a href="/lkml/2000/11/17/186">Harald Koenig</a><ul><li><a href="/lkml/2000/11/17/110">Linus Torvalds</a></li><li><a href="/lkml/2000/11/17/128">Harald Koenig</a><ul><li><a href="/lkml/2000/11/17/208">Linus Torvalds</a></li><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2000/11/17/235/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 17 Nov 2000 15:46:14 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: BUG: isofs broken (2.2 and 2.4)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 17 Nov 2000, Harald Koenig wrote:<br />&gt; <br />&gt; Linus:		0.380u 76.850s 1:19.12 97.6%    0+0k 0+0io 113pf+0w<br />&gt; Andries:	0.470u 97.220s 1:40.29 97.4%    0+0k 0+0io 112pf+0w<br /><br />The biggest difference is just the system times and the fact that it's<br />more efficient coding. <br /><br />&gt; BUT: there are some obvious bugs in the output of "du" and "find".<br />&gt; some samples (all file names (should) match the format "xe%03d/xe%03d.%c%c"<br />&gt; with both %03d being the _same_ number and both %c are in [a-z0-9]).<br /><br />Yes. There's a silly bug there, now that I've tested it a bit. Basically<br />the test for stuff that traversed a boundary was wrong.<br /><br />The whole name conversion code is pretty horrible. It's been written over<br />the years, and it was doing the same thing with small modifications in<br />both readdir() and lookup(). I've got a cleaned up version that also<br />should have the above bug fixed.<br /><br />Still ready to test? This time I went over the files rather carefully, and<br />while I've not tested the fixed version I'm getting pretty happy with it.<br /><br />I'll merge some more of the name translation logic, but before I do that<br />here's the newest patch..<br /><br />		Linus<br /><br />-----<br />diff -u --recursive --new-file v2.4.0-test10/linux/fs/isofs/dir.c linux/fs/isofs/dir.c<br />--- v2.4.0-test10/linux/fs/isofs/dir.c	Fri Aug 11 14:29:01 2000<br />+++ linux/fs/isofs/dir.c	Fri Nov 17 15:43:36 2000<br />&#64;&#64; -40,14 +40,17 &#64;&#64;<br /> 	lookup:		isofs_lookup,<br /> };<br /> <br />-static int isofs_name_translate(char * old, int len, char * new)<br />+int isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)<br /> {<br />-	int i, c;<br />+	char * old = de-&gt;name;<br />+	int len = de-&gt;name_len[0];<br />+	int i;<br /> 			<br /> 	for (i = 0; i &lt; len; i++) {<br />-		c = old[i];<br />+		unsigned char c = old[i];<br /> 		if (!c)<br /> 			break;<br />+<br /> 		if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')<br /> 			c |= 0x20;	/* lower case */<br /> <br />&#64;&#64; -74,8 +77,7 &#64;&#64;<br /> {<br /> 	int std;<br /> 	unsigned char * chr;<br />-	int retnamlen = isofs_name_translate(de-&gt;name,<br />-				de-&gt;name_len[0], retname);<br />+	int retnamlen = isofs_name_translate(de, retname, inode);<br /> 	if (retnamlen == 0) return 0;<br /> 	std = sizeof(struct iso_directory_record) + de-&gt;name_len[0];<br /> 	if (std &amp; 1) std++;<br />&#64;&#64; -105,7 +107,7 &#64;&#64;<br /> 	unsigned char bufbits = ISOFS_BUFFER_BITS(inode);<br /> 	unsigned int block, offset;<br /> 	int inode_number = 0;	/* Quiet GCC */<br />-	struct buffer_head *bh;<br />+	struct buffer_head *bh = NULL;<br /> 	int len;<br /> 	int map;<br /> 	int high_sierra;<br />&#64;&#64; -117,46 +119,22 &#64;&#64;<br /> 		return 0;<br />  <br /> 	offset = filp-&gt;f_pos &amp; (bufsize - 1);<br />-	block = isofs_bmap(inode, filp-&gt;f_pos &gt;&gt; bufbits);<br />+	block = filp-&gt;f_pos &gt;&gt; bufbits;<br /> 	high_sierra = inode-&gt;i_sb-&gt;u.isofs_sb.s_high_sierra;<br /> <br />-	if (!block)<br />-		return 0;<br />-<br />-	if (!(bh = breada(inode-&gt;i_dev, block, bufsize, filp-&gt;f_pos, inode-&gt;i_size)))<br />-		return 0;<br />-<br /> 	while (filp-&gt;f_pos &lt; inode-&gt;i_size) {<br /> 		int de_len;<br />-#ifdef DEBUG<br />-		printk("Block, offset, f_pos: %x %x %x\n",<br />-		       block, offset, filp-&gt;f_pos);<br />-	        printk("inode-&gt;i_size = %x\n",inode-&gt;i_size);<br />-#endif<br />-		/* Next directory_record on next CDROM sector */<br />-		if (offset &gt;= bufsize) {<br />-#ifdef DEBUG<br />-			printk("offset &gt;= bufsize\n");<br />-#endif<br />-			brelse(bh);<br />-			offset = 0;<br />-			block = isofs_bmap(inode, (filp-&gt;f_pos) &gt;&gt; bufbits);<br />-			if (!block)<br />-				return 0;<br />-			bh = breada(inode-&gt;i_dev, block, bufsize, filp-&gt;f_pos, inode-&gt;i_size);<br />+<br />+		if (!bh) {<br />+			bh = isofs_bread(inode, bufsize, block);<br /> 			if (!bh)<br /> 				return 0;<br />-			continue;<br /> 		}<br /> <br /> 		de = (struct iso_directory_record *) (bh-&gt;b_data + offset);<br />-		if(first_de) inode_number = (block &lt;&lt; bufbits) + (offset &amp; (bufsize - 1));<br />+		if (first_de) inode_number = (bh-&gt;b_blocknr &lt;&lt; bufbits) + offset;<br /> <br /> 		de_len = *(unsigned char *) de;<br />-#ifdef DEBUG<br />-		printk("de_len = %d\n", de_len);<br />-#endif<br />-	    <br /> <br /> 		/* If the length byte is zero, we should move on to the next<br /> 		   CDROM sector.  If we are at the end of the directory, we<br />&#64;&#64; -164,36 +142,33 &#64;&#64;<br /> <br /> 		if (de_len == 0) {<br /> 			brelse(bh);<br />-			filp-&gt;f_pos = ((filp-&gt;f_pos &amp; ~(ISOFS_BLOCK_SIZE - 1))<br />-				       + ISOFS_BLOCK_SIZE);<br />+			bh = NULL;<br />+			filp-&gt;f_pos = ((filp-&gt;f_pos &amp; ~(ISOFS_BLOCK_SIZE - 1)) + ISOFS_BLOCK_SIZE);<br />+			block = filp-&gt;f_pos &gt;&gt; bufbits;<br /> 			offset = 0;<br />-<br />-			if (filp-&gt;f_pos &gt;= inode-&gt;i_size)<br />-				return 0;<br />-<br />-			block = isofs_bmap(inode, (filp-&gt;f_pos) &gt;&gt; bufbits);<br />-			if (!block)<br />-				return 0;<br />-			bh = breada(inode-&gt;i_dev, block, bufsize, filp-&gt;f_pos, inode-&gt;i_size);<br />-			if (!bh)<br />-				return 0;<br /> 			continue;<br /> 		}<br /> <br />-		offset +=  de_len;<br />-		if (offset &gt; bufsize) {<br />-			/*<br />-			 * This would only normally happen if we had<br />-			 * a buggy cdrom image.  All directory<br />-			 * entries should terminate with a null size<br />-			 * or end exactly at the end of the sector.<br />-			 */<br />-		        printk("next_offset (%x) &gt; bufsize (%lx)\n",<br />-			       offset,bufsize);<br />-			break;<br />+		offset += de_len;<br />+<br />+		/* Make sure we have a full directory entry */<br />+		if (offset &gt;= bufsize) {<br />+			int slop = bufsize - offset + de_len;<br />+			memcpy(tmpde, de, slop);<br />+			offset &amp;= bufsize - 1;<br />+			block++;<br />+			brelse(bh);<br />+			bh = NULL;<br />+			if (offset) {<br />+				bh = isofs_bread(inode, bufsize, block);<br />+				if (!bh)<br />+					return 0;<br />+				memcpy((void *) tmpde + slop, bh-&gt;b_data, de_len - slop);<br />+			}<br />+			de = tmpde;				<br /> 		}<br /> <br />-		if(de-&gt;flags[-high_sierra] &amp; 0x80) {<br />+		if (de-&gt;flags[-high_sierra] &amp; 0x80) {<br /> 			first_de = 0;<br /> 			filp-&gt;f_pos += de_len;<br /> 			continue;<br />&#64;&#64; -240,7 +215,7 &#64;&#64;<br /> 		if (map) {<br /> #ifdef CONFIG_JOLIET<br /> 			if (inode-&gt;i_sb-&gt;u.isofs_sb.s_joliet_level) {<br />-				len = get_joliet_filename(de, inode, tmpname);<br />+				len = get_joliet_filename(de, tmpname, inode);<br /> 				p = tmpname;<br /> 			} else<br /> #endif<br />&#64;&#64; -249,8 +224,7 &#64;&#64;<br /> 				p = tmpname;<br /> 			} else<br /> 			if (inode-&gt;i_sb-&gt;u.isofs_sb.s_mapping == 'n') {<br />-				len = isofs_name_translate(de-&gt;name,<br />-					de-&gt;name_len[0], tmpname);<br />+				len = isofs_name_translate(de, tmpname, inode);<br /> 				p = tmpname;<br /> 			} else {<br /> 				p = de-&gt;name;<br />&#64;&#64; -265,7 +239,7 &#64;&#64;<br /> <br /> 		continue;<br /> 	}<br />-	brelse(bh);<br />+	if (bh) brelse(bh);<br /> 	return 0;<br /> }<br /> <br />diff -u --recursive --new-file v2.4.0-test10/linux/fs/isofs/inode.c linux/fs/isofs/inode.c<br />--- v2.4.0-test10/linux/fs/isofs/inode.c	Tue Jul 18 21:40:47 2000<br />+++ linux/fs/isofs/inode.c	Fri Nov 17 15:15:07 2000<br />&#64;&#64; -972,14 +972,24 &#64;&#64;<br /> 	return 0;<br /> }<br /> <br />+struct buffer_head *isofs_bread(struct inode *inode, unsigned int bufsize, unsigned int block)<br />+{<br />+	unsigned int blknr = isofs_bmap(inode, block);<br />+	if (!blknr)<br />+		return NULL;<br />+	return bread(inode-&gt;i_dev, blknr, bufsize);<br />+}<br />+<br /> static int isofs_readpage(struct file *file, struct page *page)<br /> {<br /> 	return block_read_full_page(page,isofs_get_block);<br /> }<br />+<br /> static int _isofs_bmap(struct address_space *mapping, long block)<br /> {<br /> 	return generic_block_bmap(mapping,block,isofs_get_block);<br /> }<br />+<br /> static struct address_space_operations isofs_aops = {<br /> 	readpage: isofs_readpage,<br /> 	sync_page: block_sync_page,<br />diff -u --recursive --new-file v2.4.0-test10/linux/fs/isofs/joliet.c linux/fs/isofs/joliet.c<br />--- v2.4.0-test10/linux/fs/isofs/joliet.c	Tue Jul 18 22:48:32 2000<br />+++ linux/fs/isofs/joliet.c	Fri Nov 17 15:29:55 2000<br />&#64;&#64; -70,8 +70,7 &#64;&#64;<br /> }<br /> <br /> int<br />-get_joliet_filename(struct iso_directory_record * de, struct inode * inode,<br />-		    unsigned char *outname)<br />+get_joliet_filename(struct iso_directory_record * de, unsigned char *outname, struct inode * inode)<br /> {<br /> 	unsigned char utf8;<br /> 	struct nls_table *nls;<br />diff -u --recursive --new-file v2.4.0-test10/linux/fs/isofs/namei.c linux/fs/isofs/namei.c<br />--- v2.4.0-test10/linux/fs/isofs/namei.c	Mon May 10 14:14:28 1999<br />+++ linux/fs/isofs/namei.c	Fri Nov 17 15:43:19 2000<br />&#64;&#64; -57,147 +57,87 &#64;&#64;<br />  * itself (as an inode number). It does NOT read the inode of the<br />  * entry - you'll have to do that yourself if you want to.<br />  */<br />-static struct buffer_head *<br />-isofs_find_entry(struct inode *dir, struct dentry *dentry, unsigned long *ino)<br />+static unsigned long<br />+isofs_find_entry(struct inode *dir, struct dentry *dentry,<br />+	char * tmpname, struct iso_directory_record * tmpde)<br /> {<br />+	unsigned long inode_number;<br /> 	unsigned long bufsize = ISOFS_BUFFER_SIZE(dir);<br /> 	unsigned char bufbits = ISOFS_BUFFER_BITS(dir);<br />-	unsigned int block, i, f_pos, offset, <br />-		inode_number = 0; /* shut gcc up */<br />-	struct buffer_head * bh , * retval = NULL;<br />-	unsigned int old_offset;<br />-	int dlen, match;<br />-	char * dpnt;<br />-	unsigned char *page = NULL;<br />-	struct iso_directory_record * de = NULL; /* shut gcc up */<br />-	char de_not_in_buf = 0;	  /* true if de is in kmalloc'd memory */<br />-	char c;<br />-<br />-	*ino = 0;<br />-	<br />-	if (!(block = dir-&gt;u.isofs_i.i_first_extent)) return NULL;<br />+	unsigned int block, f_pos, offset;<br />+	struct buffer_head * bh = NULL;<br />+<br />+	if (!dir-&gt;u.isofs_i.i_first_extent)<br />+		return 0;<br />   <br /> 	f_pos = 0;<br />+	offset = 0;<br />+	block = 0;<br /> <br />-	offset = f_pos &amp; (bufsize - 1);<br />-	block = isofs_bmap(dir,f_pos &gt;&gt; bufbits);<br />+	while (f_pos &lt; dir-&gt;i_size) {<br />+		struct iso_directory_record * de;<br />+		int de_len, match, i, dlen;<br />+		char *dpnt;<br /> <br />-	if (!block || !(bh = bread(dir-&gt;i_dev,block,bufsize))) return NULL;<br />+		if (!bh) {<br />+			bh = isofs_bread(dir, bufsize, block);<br />+			if (!bh)<br />+				return 0;<br />+		}<br /> <br />-	while (f_pos &lt; dir-&gt;i_size) {<br />+		de = (struct iso_directory_record *) (bh-&gt;b_data + offset);<br />+		inode_number = (bh-&gt;b_blocknr &lt;&lt; bufbits) + offset;<br /> <br />-		/* if de is in kmalloc'd memory, do not point to the<br />-                   next de, instead we will move to the next sector */<br />-		if(!de_not_in_buf) {<br />-			de = (struct iso_directory_record *) <br />-				(bh-&gt;b_data + offset);<br />-		}<br />-		inode_number = (block &lt;&lt; bufbits) + (offset &amp; (bufsize - 1));<br />-<br />-		/* If byte is zero, or we had to fetch this de past<br />-		   the end of the buffer, this is the end of file, or<br />-		   time to move to the next sector. Usually 2048 byte<br />-		   boundaries. */<br />-		<br />-		if (*((unsigned char *) de) == 0 || de_not_in_buf) {<br />-			if(de_not_in_buf) {<br />-				/* james&#64;bpgc.com: Since we slopped<br />-                                   past the end of the last buffer, we<br />-                                   must start some way into the new<br />-                                   one */<br />-				de_not_in_buf = 0;<br />-				kfree(de);<br />-				f_pos += offset;<br />-			}<br />-			else { <br />-				offset = 0;<br />-				f_pos = ((f_pos &amp; ~(ISOFS_BLOCK_SIZE - 1))<br />-					 + ISOFS_BLOCK_SIZE);<br />-			}<br />+		de_len = *(unsigned char *) de;<br />+		if (!de_len) {<br /> 			brelse(bh);<br /> 			bh = NULL;<br />-<br />-			if (f_pos &gt;= dir-&gt;i_size) <br />-				break;<br />-<br />-			block = isofs_bmap(dir,f_pos&gt;&gt;bufbits);<br />-			if (!block || !(bh = bread(dir-&gt;i_dev,block,bufsize)))<br />-				break;<br />-<br />-			continue; /* Will kick out if past end of directory */<br />+			f_pos = (f_pos + ISOFS_BLOCK_SIZE) &amp; ~(ISOFS_BLOCK_SIZE - 1);<br />+			block = f_pos &gt;&gt; bufbits;<br />+			offset = 0;<br />+			continue;<br /> 		}<br /> <br />-		old_offset = offset;<br />-		offset += *((unsigned char *) de);<br />-		f_pos += *((unsigned char *) de);<br />+		offset += de_len;<br />+		f_pos += de_len;<br /> <br />-		/* james&#64;bpgc.com: new code to handle case where the<br />-		   directory entry spans two blocks.  Usually 1024<br />-		   byte boundaries */<br />+		/* Make sure we have a full directory entry */<br /> 		if (offset &gt;= bufsize) {<br />-			struct buffer_head *bh_next;<br />-<br />-			/* james&#64;bpgc.com: read the next block, and<br />-                           copy the split de into a newly kmalloc'd<br />-                           buffer */<br />-			block = isofs_bmap(dir,f_pos&gt;&gt;bufbits);<br />-			if (!block || <br />-			    !(bh_next = bread(dir-&gt;i_dev,block,bufsize)))<br />-				break;<br />-			<br />-			de = (struct iso_directory_record *)<br />-				kmalloc(offset - old_offset, GFP_KERNEL);<br />-			memcpy((char *)de, bh-&gt;b_data + old_offset, <br />-			       bufsize - old_offset);<br />-			memcpy((char *)de + bufsize - old_offset,<br />-			       bh_next-&gt;b_data, offset - bufsize);<br />-			brelse(bh_next);<br />-			de_not_in_buf = 1;<br />-			offset -= bufsize;<br />+			int slop = bufsize - offset + de_len;<br />+			memcpy(tmpde, de, slop);<br />+			offset &amp;= bufsize - 1;<br />+			block++;<br />+			brelse(bh);<br />+			bh = NULL;<br />+			if (offset) {<br />+				bh = isofs_bread(dir, bufsize, block);<br />+				if (!bh)<br />+					return 0;<br />+				memcpy((void *) tmpde + slop, bh-&gt;b_data, de_len - slop);<br />+			}<br />+			de = tmpde;<br /> 		}<br />+<br /> 		dlen = de-&gt;name_len[0];<br /> 		dpnt = de-&gt;name;<br /> <br />-		if (dir-&gt;i_sb-&gt;u.isofs_sb.s_rock ||<br />-		    dir-&gt;i_sb-&gt;u.isofs_sb.s_joliet_level || <br />-		    dir-&gt;i_sb-&gt;u.isofs_sb.s_mapping == 'n' ||<br />-		    dir-&gt;i_sb-&gt;u.isofs_sb.s_mapping == 'a') {<br />-			if (! page) {<br />-				page = (unsigned char *)<br />-					__get_free_page(GFP_KERNEL);<br />-				if (!page) break;<br />-			}<br />-		}<br /> 		if (dir-&gt;i_sb-&gt;u.isofs_sb.s_rock &amp;&amp;<br />-		    ((i = get_rock_ridge_filename(de, page, dir)))) {<br />+		    ((i = get_rock_ridge_filename(de, tmpname, dir)))) {<br /> 			dlen = i;<br />-			dpnt = page;<br />+			dpnt = tmpname;<br /> #ifdef CONFIG_JOLIET<br /> 		} else if (dir-&gt;i_sb-&gt;u.isofs_sb.s_joliet_level) {<br />-			dlen = get_joliet_filename(de, dir, page);<br />-			dpnt = page;<br />+			dlen = get_joliet_filename(de, dir, tmpname);<br />+			dpnt = tmpname;<br /> #endif<br /> 		} else if (dir-&gt;i_sb-&gt;u.isofs_sb.s_mapping == 'a') {<br />-			dlen = get_acorn_filename(de, page, dir);<br />-			dpnt = page;<br />+			dlen = get_acorn_filename(de, tmpname, dir);<br />+			dpnt = tmpname;<br /> 		} else if (dir-&gt;i_sb-&gt;u.isofs_sb.s_mapping == 'n') {<br />-			for (i = 0; i &lt; dlen; i++) {<br />-				c = dpnt[i];<br />-				/* lower case */<br />-				if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') c |= 0x20;<br />-				if (c == ';' &amp;&amp; i == dlen-2 &amp;&amp; dpnt[i+1] == '1') {<br />-					dlen -= 2;<br />-					break;<br />-				}<br />-				if (c == ';') c = '.';<br />-				page[i] = c;<br />-			}<br />-			/* This allows us to match with and without<br />-			 * a trailing period. */<br />-			if(page[dlen-1] == '.' &amp;&amp; dentry-&gt;d_name.len == dlen-1)<br />-				dlen--;<br />-			dpnt = page;<br />+			dlen = isofs_name_translate(de, tmpname, dir);<br />+			dpnt = tmpname;<br /> 		}<br />+<br /> 		/*<br /> 		 * Skip hidden or associated files unless unhide is set <br /> 		 */<br />&#64;&#64; -208,43 +148,32 &#64;&#64;<br /> 			match = (isofs_cmp(dentry,dpnt,dlen) == 0);<br /> 		}<br /> 		if (match) {<br />-			if(inode_number == -1) {<br />-				/* Should only happen for the '..' entry */<br />-				inode_number = <br />-					isofs_lookup_grandparent(dir,<br />-					   find_rock_ridge_relocation(de,dir));<br />-			}<br />-			*ino = inode_number;<br />-			retval = bh;<br />-			bh = NULL;<br />-			break;<br />+			if (bh) brelse(bh);<br />+			return inode_number;<br /> 		}<br /> 	}<br />-	if (page) free_page((unsigned long) page);<br /> 	if (bh) brelse(bh);<br />-	if(de_not_in_buf) <br />-		kfree(de);<br />-	return retval;<br />+	return 0;<br /> }<br /> <br /> struct dentry *isofs_lookup(struct inode * dir, struct dentry * dentry)<br /> {<br /> 	unsigned long ino;<br />-	struct buffer_head * bh;<br /> 	struct inode *inode;<br />+	struct page *page;<br /> <br /> #ifdef DEBUG<br /> 	printk("lookup: %x %s\n",dir-&gt;i_ino, dentry-&gt;d_name.name);<br /> #endif<br /> 	dentry-&gt;d_op = dir-&gt;i_sb-&gt;s_root-&gt;d_op;<br /> <br />-	bh = isofs_find_entry(dir, dentry, &amp;ino);<br />+	page = alloc_page(GFP_USER);<br />+	ino = isofs_find_entry(dir, dentry, page_address(page), 1024 + page_address(page));<br />+	__free_page(page);<br /> <br /> 	inode = NULL;<br />-	if (bh) {<br />-		brelse(bh);<br />-<br />-		inode = iget(dir-&gt;i_sb,ino);<br />+	if (ino) {<br />+		inode = iget(dir-&gt;i_sb, ino);<br /> 		if (!inode)<br /> 			return ERR_PTR(-EACCES);<br /> 	}<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
