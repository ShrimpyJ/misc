    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/11/17/169">First message in thread</a></li><li><a href="/lkml/2000/11/17/169"> Andries.Brouwer&#64;cwi ...</a><ul><li><a href="/lkml/2000/11/17/186">Harald Koenig</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2000/11/17/128">Harald Koenig</a><ul><li><a href="/lkml/2000/11/17/208">Linus Torvalds</a></li><li><a href="/lkml/2000/11/17/235">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2000/11/17/110/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 17 Nov 2000 14:29:25 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: BUG: isofs broken (2.2 and 2.4)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 17 Nov 2000, Harald Koenig wrote:<br />&gt; <br />&gt; this seems to make things much worse:  starting with ~90M free memory<br />&gt; "du" again started leaking (or maybe just using memory?) down to ~80M free<br />&gt; memory when the system suddently locked up completely, no console switch<br />&gt; was possible anymore (but Sysrq-B did reboot).<br /><br />How about this version (full patch against test10 - it includes a<br />slightly corrected version of my earlier dir.c patch)?<br /><br />It's entirely untested, but it looks good and compiles. Ship it!<br /><br />		Linus<br /><br />-----<br />diff -u --recursive --new-file v2.4.0-test10/linux/fs/isofs/dir.c linux/fs/isofs/dir.c<br />--- v2.4.0-test10/linux/fs/isofs/dir.c	Fri Aug 11 14:29:01 2000<br />+++ linux/fs/isofs/dir.c	Fri Nov 17 13:38:01 2000<br />&#64;&#64; -94,6 +94,14 &#64;&#64;<br /> 	return retnamlen;<br /> }<br /> <br />+static struct buffer_head *isofs_bread(struct inode *inode, unsigned int bufsize, unsigned int block)<br />+{<br />+	unsigned int blknr = isofs_bmap(inode, block);<br />+	if (!blknr)<br />+		return NULL;<br />+	return bread(inode-&gt;i_dev, blknr, bufsize);<br />+}<br />+<br /> /*<br />  * This should _really_ be cleaned up some day..<br />  */<br />&#64;&#64; -105,7 +113,7 &#64;&#64;<br /> 	unsigned char bufbits = ISOFS_BUFFER_BITS(inode);<br /> 	unsigned int block, offset;<br /> 	int inode_number = 0;	/* Quiet GCC */<br />-	struct buffer_head *bh;<br />+	struct buffer_head *bh = NULL;<br /> 	int len;<br /> 	int map;<br /> 	int high_sierra;<br />&#64;&#64; -117,46 +125,25 &#64;&#64;<br /> 		return 0;<br />  <br /> 	offset = filp-&gt;f_pos &amp; (bufsize - 1);<br />-	block = isofs_bmap(inode, filp-&gt;f_pos &gt;&gt; bufbits);<br />+	block = filp-&gt;f_pos &gt;&gt; bufbits;<br /> 	high_sierra = inode-&gt;i_sb-&gt;u.isofs_sb.s_high_sierra;<br /> <br />-	if (!block)<br />-		return 0;<br />-<br />-	if (!(bh = breada(inode-&gt;i_dev, block, bufsize, filp-&gt;f_pos, inode-&gt;i_size)))<br />-		return 0;<br />-<br /> 	while (filp-&gt;f_pos &lt; inode-&gt;i_size) {<br /> 		int de_len;<br />-#ifdef DEBUG<br />-		printk("Block, offset, f_pos: %x %x %x\n",<br />-		       block, offset, filp-&gt;f_pos);<br />-	        printk("inode-&gt;i_size = %x\n",inode-&gt;i_size);<br />-#endif<br />-		/* Next directory_record on next CDROM sector */<br />-		if (offset &gt;= bufsize) {<br />-#ifdef DEBUG<br />-			printk("offset &gt;= bufsize\n");<br />-#endif<br />-			brelse(bh);<br />-			offset = 0;<br />-			block = isofs_bmap(inode, (filp-&gt;f_pos) &gt;&gt; bufbits);<br />-			if (!block)<br />-				return 0;<br />-			bh = breada(inode-&gt;i_dev, block, bufsize, filp-&gt;f_pos, inode-&gt;i_size);<br />+<br />+		if (!bh) {<br />+			bh = isofs_bread(inode, bufsize, block);<br /> 			if (!bh)<br /> 				return 0;<br />-			continue;<br /> 		}<br /> <br /> 		de = (struct iso_directory_record *) (bh-&gt;b_data + offset);<br />-		if(first_de) inode_number = (block &lt;&lt; bufbits) + (offset &amp; (bufsize - 1));<br />+		if (first_de) inode_number = (bh-&gt;b_blocknr &lt;&lt; bufbits) + offset;<br /> <br /> 		de_len = *(unsigned char *) de;<br /> #ifdef DEBUG<br /> 		printk("de_len = %d\n", de_len);<br />-#endif<br />-	    <br />+#endif	    <br /> <br /> 		/* If the length byte is zero, we should move on to the next<br /> 		   CDROM sector.  If we are at the end of the directory, we<br />&#64;&#64; -164,36 +151,33 &#64;&#64;<br /> <br /> 		if (de_len == 0) {<br /> 			brelse(bh);<br />-			filp-&gt;f_pos = ((filp-&gt;f_pos &amp; ~(ISOFS_BLOCK_SIZE - 1))<br />-				       + ISOFS_BLOCK_SIZE);<br />+			bh = NULL;<br />+			filp-&gt;f_pos = ((filp-&gt;f_pos &amp; ~(ISOFS_BLOCK_SIZE - 1)) + ISOFS_BLOCK_SIZE);<br />+			block = filp-&gt;f_pos &gt;&gt; bufbits;<br /> 			offset = 0;<br />-<br />-			if (filp-&gt;f_pos &gt;= inode-&gt;i_size)<br />-				return 0;<br />-<br />-			block = isofs_bmap(inode, (filp-&gt;f_pos) &gt;&gt; bufbits);<br />-			if (!block)<br />-				return 0;<br />-			bh = breada(inode-&gt;i_dev, block, bufsize, filp-&gt;f_pos, inode-&gt;i_size);<br />-			if (!bh)<br />-				return 0;<br /> 			continue;<br /> 		}<br /> <br />-		offset +=  de_len;<br />-		if (offset &gt; bufsize) {<br />-			/*<br />-			 * This would only normally happen if we had<br />-			 * a buggy cdrom image.  All directory<br />-			 * entries should terminate with a null size<br />-			 * or end exactly at the end of the sector.<br />-			 */<br />-		        printk("next_offset (%x) &gt; bufsize (%lx)\n",<br />-			       offset,bufsize);<br />-			break;<br />+		offset += de_len;<br />+<br />+		/* Make sure we have a full directory entry */<br />+		if (offset &gt;= bufsize) {<br />+			int slop = bufsize - offset + de_len;<br />+			memcpy(tmpde, de, slop);<br />+			offset &amp;= bufsize - 1;<br />+			block++;<br />+			brelse(bh);<br />+			bh = NULL;<br />+			if (offset == bufsize) {<br />+				bh = isofs_bread(inode, bufsize, block);<br />+				if (!bh)<br />+					return 0;<br />+				memcpy((void *) tmpde + slop, bh-&gt;b_data, de_len - slop);<br />+			}<br />+			de = tmpde;				<br /> 		}<br /> <br />-		if(de-&gt;flags[-high_sierra] &amp; 0x80) {<br />+		if (de-&gt;flags[-high_sierra] &amp; 0x80) {<br /> 			first_de = 0;<br /> 			filp-&gt;f_pos += de_len;<br /> 			continue;<br />&#64;&#64; -265,7 +249,7 &#64;&#64;<br /> <br /> 		continue;<br /> 	}<br />-	brelse(bh);<br />+	if (bh) brelse(bh);<br /> 	return 0;<br /> }<br /> <br />diff -u --recursive --new-file v2.4.0-test10/linux/fs/isofs/namei.c linux/fs/isofs/namei.c<br />--- v2.4.0-test10/linux/fs/isofs/namei.c	Mon May 10 14:14:28 1999<br />+++ linux/fs/isofs/namei.c	Fri Nov 17 14:22:33 2000<br />&#64;&#64; -49,6 +49,15 &#64;&#64;<br /> 	return dentry-&gt;d_op-&gt;d_compare(dentry, &amp;dentry-&gt;d_name, &amp;qstr);<br /> }<br /> <br />+static struct buffer_head *isofs_bread(struct inode *inode, unsigned int bufsize, unsigned int block)<br />+{<br />+	unsigned int blknr = isofs_bmap(inode, block);<br />+	if (!blknr)<br />+		return NULL;<br />+	return bread(inode-&gt;i_dev, blknr, bufsize);<br />+}<br />+<br />+<br /> /*<br />  *	isofs_find_entry()<br />  *<br />&#64;&#64; -57,129 +66,82 &#64;&#64;<br />  * itself (as an inode number). It does NOT read the inode of the<br />  * entry - you'll have to do that yourself if you want to.<br />  */<br />-static struct buffer_head *<br />-isofs_find_entry(struct inode *dir, struct dentry *dentry, unsigned long *ino)<br />+static unsigned long<br />+isofs_find_entry(struct inode *dir, struct dentry *dentry,<br />+	char * tmpname, struct iso_directory_record * tmpde)<br /> {<br />+	unsigned long inode_number;<br /> 	unsigned long bufsize = ISOFS_BUFFER_SIZE(dir);<br /> 	unsigned char bufbits = ISOFS_BUFFER_BITS(dir);<br />-	unsigned int block, i, f_pos, offset, <br />-		inode_number = 0; /* shut gcc up */<br />-	struct buffer_head * bh , * retval = NULL;<br />-	unsigned int old_offset;<br />-	int dlen, match;<br />-	char * dpnt;<br />-	unsigned char *page = NULL;<br />-	struct iso_directory_record * de = NULL; /* shut gcc up */<br />-	char de_not_in_buf = 0;	  /* true if de is in kmalloc'd memory */<br />-	char c;<br />-<br />-	*ino = 0;<br />-	<br />-	if (!(block = dir-&gt;u.isofs_i.i_first_extent)) return NULL;<br />+	unsigned int block, f_pos, offset;<br />+	struct buffer_head * bh = NULL;<br />+<br />+	if (!dir-&gt;u.isofs_i.i_first_extent)<br />+		return 0;<br />   <br /> 	f_pos = 0;<br />+	offset = 0;<br />+	block = 0;<br /> <br />-	offset = f_pos &amp; (bufsize - 1);<br />-	block = isofs_bmap(dir,f_pos &gt;&gt; bufbits);<br />+	while (f_pos &lt; dir-&gt;i_size) {<br />+		struct iso_directory_record * de;<br />+		int de_len, match, i, dlen;<br />+		char *dpnt, c;<br /> <br />-	if (!block || !(bh = bread(dir-&gt;i_dev,block,bufsize))) return NULL;<br />+		if (!bh) {<br />+			bh = isofs_bread(dir, bufsize, block);<br />+			if (!bh)<br />+				return 0;<br />+		}<br /> <br />-	while (f_pos &lt; dir-&gt;i_size) {<br />+		de = (struct iso_directory_record *) (bh-&gt;b_data + offset);<br />+		inode_number = (bh-&gt;b_blocknr &lt;&lt; bufbits) + offset;<br /> <br />-		/* if de is in kmalloc'd memory, do not point to the<br />-                   next de, instead we will move to the next sector */<br />-		if(!de_not_in_buf) {<br />-			de = (struct iso_directory_record *) <br />-				(bh-&gt;b_data + offset);<br />-		}<br />-		inode_number = (block &lt;&lt; bufbits) + (offset &amp; (bufsize - 1));<br />-<br />-		/* If byte is zero, or we had to fetch this de past<br />-		   the end of the buffer, this is the end of file, or<br />-		   time to move to the next sector. Usually 2048 byte<br />-		   boundaries. */<br />-		<br />-		if (*((unsigned char *) de) == 0 || de_not_in_buf) {<br />-			if(de_not_in_buf) {<br />-				/* james&#64;bpgc.com: Since we slopped<br />-                                   past the end of the last buffer, we<br />-                                   must start some way into the new<br />-                                   one */<br />-				de_not_in_buf = 0;<br />-				kfree(de);<br />-				f_pos += offset;<br />-			}<br />-			else { <br />-				offset = 0;<br />-				f_pos = ((f_pos &amp; ~(ISOFS_BLOCK_SIZE - 1))<br />-					 + ISOFS_BLOCK_SIZE);<br />-			}<br />+		de_len = *(unsigned char *) de;<br />+		if (!de_len) {<br /> 			brelse(bh);<br /> 			bh = NULL;<br />-<br />-			if (f_pos &gt;= dir-&gt;i_size) <br />-				break;<br />-<br />-			block = isofs_bmap(dir,f_pos&gt;&gt;bufbits);<br />-			if (!block || !(bh = bread(dir-&gt;i_dev,block,bufsize)))<br />-				break;<br />-<br />-			continue; /* Will kick out if past end of directory */<br />+			f_pos = (f_pos + ISOFS_BLOCK_SIZE) &amp; ~(ISOFS_BLOCK_SIZE - 1);<br />+			block = f_pos &gt;&gt; bufbits;<br />+			offset = 0;<br />+			continue;<br /> 		}<br /> <br />-		old_offset = offset;<br />-		offset += *((unsigned char *) de);<br />-		f_pos += *((unsigned char *) de);<br />+		offset += de_len;<br />+		f_pos += de_len;<br /> <br />-		/* james&#64;bpgc.com: new code to handle case where the<br />-		   directory entry spans two blocks.  Usually 1024<br />-		   byte boundaries */<br />+		/* Make sure we have a full directory entry */<br /> 		if (offset &gt;= bufsize) {<br />-			struct buffer_head *bh_next;<br />-<br />-			/* james&#64;bpgc.com: read the next block, and<br />-                           copy the split de into a newly kmalloc'd<br />-                           buffer */<br />-			block = isofs_bmap(dir,f_pos&gt;&gt;bufbits);<br />-			if (!block || <br />-			    !(bh_next = bread(dir-&gt;i_dev,block,bufsize)))<br />-				break;<br />-			<br />-			de = (struct iso_directory_record *)<br />-				kmalloc(offset - old_offset, GFP_KERNEL);<br />-			memcpy((char *)de, bh-&gt;b_data + old_offset, <br />-			       bufsize - old_offset);<br />-			memcpy((char *)de + bufsize - old_offset,<br />-			       bh_next-&gt;b_data, offset - bufsize);<br />-			brelse(bh_next);<br />-			de_not_in_buf = 1;<br />-			offset -= bufsize;<br />+			int slop = bufsize - offset + de_len;<br />+			memcpy(tmpde, de, slop);<br />+			offset &amp;= bufsize - 1;<br />+			block++;<br />+			brelse(bh);<br />+			bh = NULL;<br />+			if (offset == bufsize) {<br />+				bh = isofs_bread(dir, bufsize, block);<br />+				if (!bh)<br />+					return 0;<br />+				memcpy((void *) tmpde + slop, bh-&gt;b_data, de_len - slop);<br />+			}<br />+			de = tmpde;<br /> 		}<br />+<br /> 		dlen = de-&gt;name_len[0];<br /> 		dpnt = de-&gt;name;<br /> <br />-		if (dir-&gt;i_sb-&gt;u.isofs_sb.s_rock ||<br />-		    dir-&gt;i_sb-&gt;u.isofs_sb.s_joliet_level || <br />-		    dir-&gt;i_sb-&gt;u.isofs_sb.s_mapping == 'n' ||<br />-		    dir-&gt;i_sb-&gt;u.isofs_sb.s_mapping == 'a') {<br />-			if (! page) {<br />-				page = (unsigned char *)<br />-					__get_free_page(GFP_KERNEL);<br />-				if (!page) break;<br />-			}<br />-		}<br /> 		if (dir-&gt;i_sb-&gt;u.isofs_sb.s_rock &amp;&amp;<br />-		    ((i = get_rock_ridge_filename(de, page, dir)))) {<br />+		    ((i = get_rock_ridge_filename(de, tmpname, dir)))) {<br /> 			dlen = i;<br />-			dpnt = page;<br />+			dpnt = tmpname;<br /> #ifdef CONFIG_JOLIET<br /> 		} else if (dir-&gt;i_sb-&gt;u.isofs_sb.s_joliet_level) {<br />-			dlen = get_joliet_filename(de, dir, page);<br />-			dpnt = page;<br />+			dlen = get_joliet_filename(de, dir, tmpname);<br />+			dpnt = tmpname;<br /> #endif<br /> 		} else if (dir-&gt;i_sb-&gt;u.isofs_sb.s_mapping == 'a') {<br />-			dlen = get_acorn_filename(de, page, dir);<br />-			dpnt = page;<br />+			dlen = get_acorn_filename(de, tmpname, dir);<br />+			dpnt = tmpname;<br /> 		} else if (dir-&gt;i_sb-&gt;u.isofs_sb.s_mapping == 'n') {<br /> 			for (i = 0; i &lt; dlen; i++) {<br /> 				c = dpnt[i];<br />&#64;&#64; -190,13 +152,13 &#64;&#64;<br /> 					break;<br /> 				}<br /> 				if (c == ';') c = '.';<br />-				page[i] = c;<br />+				tmpname[i] = c;<br /> 			}<br /> 			/* This allows us to match with and without<br /> 			 * a trailing period. */<br />-			if(page[dlen-1] == '.' &amp;&amp; dentry-&gt;d_name.len == dlen-1)<br />+			if(tmpname[dlen-1] == '.' &amp;&amp; dentry-&gt;d_name.len == dlen-1)<br /> 				dlen--;<br />-			dpnt = page;<br />+			dpnt = tmpname;<br /> 		}<br /> 		/*<br /> 		 * Skip hidden or associated files unless unhide is set <br />&#64;&#64; -208,43 +170,32 &#64;&#64;<br /> 			match = (isofs_cmp(dentry,dpnt,dlen) == 0);<br /> 		}<br /> 		if (match) {<br />-			if(inode_number == -1) {<br />-				/* Should only happen for the '..' entry */<br />-				inode_number = <br />-					isofs_lookup_grandparent(dir,<br />-					   find_rock_ridge_relocation(de,dir));<br />-			}<br />-			*ino = inode_number;<br />-			retval = bh;<br />-			bh = NULL;<br />-			break;<br />+			if (bh) brelse(bh);<br />+			return inode_number;<br /> 		}<br /> 	}<br />-	if (page) free_page((unsigned long) page);<br /> 	if (bh) brelse(bh);<br />-	if(de_not_in_buf) <br />-		kfree(de);<br />-	return retval;<br />+	return 0;<br /> }<br /> <br /> struct dentry *isofs_lookup(struct inode * dir, struct dentry * dentry)<br /> {<br /> 	unsigned long ino;<br />-	struct buffer_head * bh;<br /> 	struct inode *inode;<br />+	struct page *page;<br /> <br /> #ifdef DEBUG<br /> 	printk("lookup: %x %s\n",dir-&gt;i_ino, dentry-&gt;d_name.name);<br /> #endif<br /> 	dentry-&gt;d_op = dir-&gt;i_sb-&gt;s_root-&gt;d_op;<br /> <br />-	bh = isofs_find_entry(dir, dentry, &amp;ino);<br />+	page = alloc_page(GFP_USER);<br />+	ino = isofs_find_entry(dir, dentry, page_address(page), 1024 + page_address(page));<br />+	__free_page(page);<br /> <br /> 	inode = NULL;<br />-	if (bh) {<br />-		brelse(bh);<br />-<br />-		inode = iget(dir-&gt;i_sb,ino);<br />+	if (ino) {<br />+		inode = iget(dir-&gt;i_sb, ino);<br /> 		if (!inode)<br /> 			return ERR_PTR(-EACCES);<br /> 	}<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
