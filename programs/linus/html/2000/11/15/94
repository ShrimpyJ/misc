    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/11/15/108">First message in thread</a></li><li><a href="/lkml/2000/11/15/108">Harald Koenig</a><ul><li><a href="/lkml/2000/11/15/144">Andries Brouwer</a><ul><li class="origin"><a href="/lkml/2000/11/15/83">Linus Torvalds</a><ul><li><a href="/lkml/2000/11/15/83">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2000/11/15/136">Linus Torvalds</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2000/11/15/94/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 15 Nov 2000 17:16:01 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: BUG: isofs broken (2.2 and 2.4)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />Does this patch fix it for you?<br /><br />Warning: TOTALLY UNTESTED!!! Please test carefully.<br /><br />Also, I'd be interested to know whether somebody really knows if the zero<br />length handling is correct. Should we really round up to 2048, or should<br />we perhaps round up only to the next bufsize?<br /><br />		Linus<br /><br />-----<br />--- v2.4.0-test10/linux/fs/isofs/dir.c	Fri Aug 11 14:29:01 2000<br />+++ linux/fs/isofs/dir.c	Wed Nov 15 17:14:26 2000<br />&#64;&#64; -94,6 +94,14 &#64;&#64;<br /> 	return retnamlen;<br /> }<br /> <br />+static struct buffer_head *isofs_bread(struct inode *inode, unsigned int bufsize, unsigned int block)<br />+{<br />+	unsigned int blknr = isofs_bmap(inode, block);<br />+	if (!blknr)<br />+		return NULL;<br />+	return bread(inode-&gt;i_dev, blknr, bufsize);<br />+}<br />+<br /> /*<br />  * This should _really_ be cleaned up some day..<br />  */<br />&#64;&#64; -105,7 +113,7 &#64;&#64;<br /> 	unsigned char bufbits = ISOFS_BUFFER_BITS(inode);<br /> 	unsigned int block, offset;<br /> 	int inode_number = 0;	/* Quiet GCC */<br />-	struct buffer_head *bh;<br />+	struct buffer_head *bh = NULL;<br /> 	int len;<br /> 	int map;<br /> 	int high_sierra;<br />&#64;&#64; -117,46 +125,25 &#64;&#64;<br /> 		return 0;<br />  <br /> 	offset = filp-&gt;f_pos &amp; (bufsize - 1);<br />-	block = isofs_bmap(inode, filp-&gt;f_pos &gt;&gt; bufbits);<br />+	block = filp-&gt;f_pos &gt;&gt; bufbits;<br /> 	high_sierra = inode-&gt;i_sb-&gt;u.isofs_sb.s_high_sierra;<br /> <br />-	if (!block)<br />-		return 0;<br />-<br />-	if (!(bh = breada(inode-&gt;i_dev, block, bufsize, filp-&gt;f_pos, inode-&gt;i_size)))<br />-		return 0;<br />-<br /> 	while (filp-&gt;f_pos &lt; inode-&gt;i_size) {<br /> 		int de_len;<br />-#ifdef DEBUG<br />-		printk("Block, offset, f_pos: %x %x %x\n",<br />-		       block, offset, filp-&gt;f_pos);<br />-	        printk("inode-&gt;i_size = %x\n",inode-&gt;i_size);<br />-#endif<br />-		/* Next directory_record on next CDROM sector */<br />-		if (offset &gt;= bufsize) {<br />-#ifdef DEBUG<br />-			printk("offset &gt;= bufsize\n");<br />-#endif<br />-			brelse(bh);<br />-			offset = 0;<br />-			block = isofs_bmap(inode, (filp-&gt;f_pos) &gt;&gt; bufbits);<br />-			if (!block)<br />-				return 0;<br />-			bh = breada(inode-&gt;i_dev, block, bufsize, filp-&gt;f_pos, inode-&gt;i_size);<br />+<br />+		if (!bh) {<br />+			bh = isofs_bread(inode, bufsize, block);<br /> 			if (!bh)<br /> 				return 0;<br />-			continue;<br /> 		}<br /> <br /> 		de = (struct iso_directory_record *) (bh-&gt;b_data + offset);<br />-		if(first_de) inode_number = (block &lt;&lt; bufbits) + (offset &amp; (bufsize - 1));<br />+		if (first_de) inode_number = (block &lt;&lt; bufbits) + (offset &amp; (bufsize - 1));<br /> <br /> 		de_len = *(unsigned char *) de;<br /> #ifdef DEBUG<br /> 		printk("de_len = %d\n", de_len);<br />-#endif<br />-	    <br />+#endif	    <br /> <br /> 		/* If the length byte is zero, we should move on to the next<br /> 		   CDROM sector.  If we are at the end of the directory, we<br />&#64;&#64; -164,36 +151,36 &#64;&#64;<br /> <br /> 		if (de_len == 0) {<br /> 			brelse(bh);<br />-			filp-&gt;f_pos = ((filp-&gt;f_pos &amp; ~(ISOFS_BLOCK_SIZE - 1))<br />-				       + ISOFS_BLOCK_SIZE);<br />+			bh = NULL;<br />+			filp-&gt;f_pos = ((filp-&gt;f_pos &amp; ~(ISOFS_BLOCK_SIZE - 1)) + ISOFS_BLOCK_SIZE);<br />+			block = filp-&gt;f_pos &gt;&gt; bufbits;<br /> 			offset = 0;<br />-<br />-			if (filp-&gt;f_pos &gt;= inode-&gt;i_size)<br />-				return 0;<br />-<br />-			block = isofs_bmap(inode, (filp-&gt;f_pos) &gt;&gt; bufbits);<br />-			if (!block)<br />-				return 0;<br />-			bh = breada(inode-&gt;i_dev, block, bufsize, filp-&gt;f_pos, inode-&gt;i_size);<br />-			if (!bh)<br />-				return 0;<br /> 			continue;<br /> 		}<br /> <br />-		offset +=  de_len;<br />+		offset += de_len;<br />+		if (offset == bufsize) {<br />+			offset = 0;<br />+			block++;<br />+			brelse(bh);<br />+			bh = NULL;<br />+		}<br />+<br />+		/* Make sure we have a full directory entry */<br /> 		if (offset &gt; bufsize) {<br />-			/*<br />-			 * This would only normally happen if we had<br />-			 * a buggy cdrom image.  All directory<br />-			 * entries should terminate with a null size<br />-			 * or end exactly at the end of the sector.<br />-			 */<br />-		        printk("next_offset (%x) &gt; bufsize (%lx)\n",<br />-			       offset,bufsize);<br />-			break;<br />+			int slop = bufsize - offset + de_len;<br />+			memcpy(tmpde, de, slop);<br />+			offset &amp;= bufsize - 1;<br />+			block++;<br />+			brelse(bh);<br />+			bh = isofs_bread(inode, bufsize, block);<br />+			if (!bh)<br />+				return 0;<br />+			memcpy((void *) tmpde + slop, bh-&gt;b_data, de_len - slop);<br />+			de = tmpde;<br /> 		}<br /> <br />-		if(de-&gt;flags[-high_sierra] &amp; 0x80) {<br />+		if (de-&gt;flags[-high_sierra] &amp; 0x80) {<br /> 			first_de = 0;<br /> 			filp-&gt;f_pos += de_len;<br /> 			continue;<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
