    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/10/22/3">First message in thread</a></li><li><a href="/lkml/2000/10/23/142">Andi Kleen</a><ul><li><a href="/lkml/2000/10/24/141">Linus Torvalds</a><ul><li><a href="/lkml/2000/10/24/4">Andi Kleen</a></li><li><a href="/lkml/2000/10/24/138">Jordan Mendelson</a><ul><li><a href="/lkml/2000/10/24/116">Alexander Viro</a></li></ul></li><li><a href="/lkml/2000/10/24/139">Lincoln Dale</a></li><li class="origin"><a href="/lkml/2000/10/24/21">Linus Torvalds</a><ul><li><a href="/lkml/2000/10/24/21">Simon Kirby</a><ul><li><a href="/lkml/2000/10/24/20">Linus Torvalds</a></li><li><a href="/lkml/2000/10/24/36">Simon Kirby</a></li></ul></li><li><a href="/lkml/2000/10/24/53">Mitchell Blank Jr</a><ul><li><a href="/lkml/2000/10/24/61">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2000/10/24/69">(Miquel van Smoorenburg)</a></li><li><a href="/lkml/2000/10/24/92">"Dan Maas"</a></li><li><a href="/lkml/2000/10/24/131">Dave Zarzycki</a></li><li><a href="/lkml/2000/10/24/134">"H. Peter Anvin"</a></li><li><a href="/lkml/2000/11/16/32">Ingo Molnar</a></li><li><a href="/lkml/2000/10/25/189">(Kai Henningsen)</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 23 Oct 2000 22:39:36 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 23 Oct 2000, Linus Torvalds wrote:<br />&gt; <br />&gt; &gt; What is your favourite interface then ? <br />&gt; <br />&gt; I suspect a good interface that can easily be done efficiently would<br />&gt; basically be something where the user _does_ do the equivalent of a<br />&gt; read-only mmap() of poll entries - and explicit and controlled<br />&gt; "add_entry()" and "remove_entry()" controls, so that the kernel can<br />&gt; maintain the cache without playing tricks.<br /><br />Actually, forget the mmap, it's not needed.<br /><br />Here's a suggested "good" interface that would certainly be easy to<br />implement, and very easy to use, with none of the scalability issues that<br />many interfaces have.<br /><br />First, let's see what is so nice about "select()" and "poll()". They do<br />have one _huge_ advantage, which is why you want to fall back on poll()<br />once the RT signal interface stops working. What is that?<br /><br />Basically, RT signals or any kind of event queue has a major fundamental<br />queuing theory problem: if you have events happening really quickly, the<br />events pile up, and queuing theory tells you that as you start having<br />queueing problems, your latency increases, which in turn tends to mean<br />that later events are even more likely to queue up, and you end up in a<br />nasty meltdown schenario where your queues get longer and longer. <br /><br />This is why RT signals suck so badly as a generic interface - clearly we<br />cannot keep sending RT signals forever, because we'd run out of memory<br />just keeping the signal queue information around.<br /><br />Neither poll() nor select() have this problem: they don't get more<br />expensive as you have more and more events - their expense is the number<br />of file descriptors, not the number of events per se. In fact, both poll()<br />and select() tend to perform _better_ when you have pending events, as<br />they are both amenable to optimizations when there is no need for waiting,<br />and scanning the arrays can use early-out semantics.<br /><br />So sticky arrays of events are good, while queues are bad. Let's take that<br />as one of the fundamentals.<br /><br />So why do people still like RT signals? They do have one advantage, which<br />is that you do NOT have that silly array traversal when there is nothing<br />to do. Basically, the RT signals kind of approach is really good for the<br />cases where select() and poll() suck: no need to traverse mostly empty and<br />non-changing arrays all the time.<br /><br />It boils down to one very simple rule: dense arrays of sticky status<br />information is good. So let's design a good interface for a dense array.<br /><br />Basically, the perfect interface for events would be<br /><br />	struct event {<br />		unsigned long id;	/* file descriptor ID the event is on */<br />		unsigned long event;	/* bitmask of active events */<br />	};<br /><br />	int get_events(struct event * event_array, int maxnr, struct timeval *tmout);<br /><br />where you say "I want an array of pending events, and I have an array you<br />can fill with up to 'maxnr' events - and if you have no events for me,<br />please sleep until you get one, or until 'tmout'".<br /><br />The above looks like a _really_ simple interface to me. Much simpler than<br />either select() or poll(). Agreed?<br /><br />Now, we still need to inform the kernel of what kind of events we want, ie<br />the "binding" of events. The most straightforward way to do that is to<br />just do a simple "bind_event()" system call:<br /><br />	int bind_event(int fd, struct event *event);<br /><br />which basically says: I'm interested in the events in "event" on the file<br />descriptor "fd". The way to stop being interested in events is to just set<br />the event bitmask to zero.<br /><br />Now, the perfect interface would be the above. Nothing more. Nothing<br />fancy, nothing complicated. Only really simple stuff. Remember the old<br />rule: "keep it simple, stupid".<br /><br />The really nice part of the above is that it's trivial to implement. It's<br />about 50 lines of code, plus some simple logic to various drivers etc to<br />actually inform about the events. The way to do this simply is to limit it<br />in very clear ways, the most notable one being simply that there is only<br />one event queue per process (or rather, per "struct files_struct" - so<br />threads would automatically share the event queue). This keeps the<br />implementation simple, but it's also what keeps the interfaces simple: no<br />queue ID's to pass around etc.<br /><br />Implementation is straightforward: the event queue basically consists of<br /><br /> - a queue head in "struct files_struct", initially empty.<br /><br /> - doing a "bind_event()" basically adds a fasync entry to the file<br />   structure, but rather than cause a signal, it just looks at whether the<br />   fasync entry is already linked into the event queue, and if it isn't<br />   (and the event is one of the ones in the event bitmask), it adds itself<br />   to the event queue.<br /><br /> - get_event() just traverses the event queue and fills in the array,<br />   removing them from the event queue. End of story. If the event queue is<br />   empty, it trivially sees that in a single line of code (+ timeout<br />   handling)<br /><br />Advantage: everything is O(1), except for "get_event()" which is O(n)<br />where 'n' is the number of active events that it fills in. <br /><br />Basically, I can't see that it can be done much simpler, and I don't see<br />that you can have much better performance. <br /><br />Example "server":	<br /><br />#define MAXEV	(32)<br /><br />	struct event ev;<br /><br />	.. create socket.. <br />	listen(sock, 5);<br /><br />	/*<br />	 * start out with only the listening socket <br />	 * as an "event"<br />	 */<br />	ev.id = LISTEN_ID;<br />	ev.event = POLLIN;<br />	bind_event(sock, &amp;ev);<br /><br />	/* Loop forever, handling the events */<br />	for (;;) {<br />		static struct event ev_list[MAXEV];<br />		int events = get_events(ev_list, MAXEV, NULL);<br />		struct event *ev = ev_list;<br /><br />		do {<br />			unsigned long id = ev-&gt;id;<br />			unsigned long mask = ev-&gt;mask;<br />			ev++;<br />			/* Call the event handler */<br />			handle[id](id,mask);<br />		} while (--events);<br />	}<br /><br />The interesting part would be what the "handle[]" function pointer array<br />would do, and for the listen socket it would simply do something like<br />accepting every pending socket and then add an event binding to it:<br /><br />	listen_handle(unsigned long id, unsigned long mask)<br />	{<br />		while ((fd = accept(listen_sock..)) &gt; 0) {<br />			struct event ev;<br />			ev.id = RDEVENT;<br />			ev.mask = ...;<br />			bind_event(fd, &amp;ev);<br />		}<br />	}<br /><br />You get the idea. Very simple, and looks like it should perform quite<br />admirably. With none of the complexities of signal handling, and none of<br />the downsides of select() or poll(). Both of the new system calls would be<br />on the order of 20-30 lines of code (along with the infrastructure to<br />extend the fasync stuff to also be able to handle events)<br /><br />Yes, I'm probably missing something. But this is the kind of thing I think<br />we should look at (and notice that you can _emulate_ this with poll(), so<br />you can use this kind of interface even on systems that wouldn't support<br />these kinds of events natively).<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
