    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/10/13/196">First message in thread</a></li><li><a href="/lkml/2000/10/17/166">Linus Torvalds</a><ul><li><a href="/lkml/2000/10/17/167">Andrea Arcangeli</a><ul><li class="origin"><a href="/lkml/2000/10/18/16">Linus Torvalds</a><ul><li><a href="/lkml/2000/10/18/16">Andrea Arcangeli</a></li><li><a href="/lkml/2000/10/18/30">Andrea Arcangeli</a></li><li><a href="/lkml/2000/10/18/85">Stephen Tweedie</a></li><li><a href="/lkml/2000/10/20/18">Stephen Tweedie</a><ul><li><a href="/lkml/2000/10/20/3">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 17 Oct 2000 21:42:36 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: mapping user space buffer to kernel address space</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 18 Oct 2000, Andrea Arcangeli wrote:<br />&gt; <br />&gt; &gt; Are you suggesting something like: if it is reading from a page (ie<br />&gt; &gt; writing the contents of that page somewhere else), we don't lock it, but<br />&gt; &gt; if it is writing to a page, we lock it so that the dirty bit won't get<br />&gt; &gt; lost.<br />&gt; <br />&gt; That wasn't what I suggested but I like also the the way you describe above.<br />&gt; It makes sense.<br /><br />I don't think it really makes sense - I can see that it works, but I don't<br />like the way it ties in the dirty bit handling with the lock bit handling.<br />I personally think they are (and should be) unrelated.<br /><br />&gt; &gt; Sure, that works (modulo the fact that it still has the issues with<br />&gt; &gt; serializing mmap's and accesses to other areas in the same page). But do<br />&gt; &gt; you really claim that it's the clean solution?<br />&gt; <br />&gt; It looks cleaner than swapping out a page while a device is writing<br />&gt; to it in DMA under the swapout.<br /><br />Note that _that_ is something I'd much rather handle another way entirely:<br />something I've long long wanted to do is to handle all swap-outs from the<br />"struct page *" rather than based on the VM scan.<br /><br />Now, the way I'v ealways envisioned this to work is that the VM scanning<br />function basically always does the equivalent of just<br /><br /> - get PTE entry, clear it out.<br /> - if PTE was dirty, add the page to the swap cache, and mark it dirty,<br />   but DON'T ACTUALLY START THE IO!<br /> - free the page.<br /><br />Basically, we removed the page from the virtual mapping, and it's now in<br />the LRU queues, and marked dirty there.<br /><br />Then, we'd move the "writeout" part into the LRU queue side, and at that<br />point I agree with you 100% that we probably should just delay it until<br />there are no mappings available - is we'd only write out a swap cache<br />entry if the count == 1 (ie it only exists in the swap cache), because<br />before that is true there are other people marking it dirty.<br /><br />What are the advantges of this approach? Never mind the kiobuf issues at<br />this point - I wanted to do this long before kiobuf's happened.<br /><br />Basically, it means that we'd write out shared pages only once, instead of<br />initiating write-back multiple times for each mapping that the page exists<br />in. Right now this isn't actually much of a problem, simply because it's<br />actually fairly hard to get shared dirty pages that would get written out<br />twice, but I think you see what I'm talking about on a conceptual level.<br /><br />It also makes the kiobuf dirty issues a _completely_ separate issue, and<br />makes it very clean to handle: what kiobuf's become is just a kind of<br />virtual "pseudo-address-space". A "kiobuf address space" doesn't have a<br />page table, but it ends up being basically equivalent to a virtual address<br />space without the TLB overhead. Like a "real" address space attached to a<br />process, it has dirty pages in it, and like the real address space it<br />informs the VM layer of that through the page dirty bit.<br /><br />See? THAT, in my opinion, is the clean way to handle this all. <br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
