    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/10/13/196">First message in thread</a></li><li><a href="/lkml/2000/10/16/195">Linus Torvalds</a><ul><li><a href="/lkml/2000/10/17/71">Andrea Arcangeli</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2000/10/17/90">Andrea Arcangeli</a><ul><li><a href="/lkml/2000/10/17/129">Eric Lowe</a></li><li><a href="/lkml/2000/10/17/151">"David S. Miller"</a><ul><li><a href="/lkml/2000/10/17/131">Stephen Tweedie</a></li><li><a href="/lkml/2000/10/17/135">Andrea Arcangeli</a></li></ul></li><li><a href="/lkml/2000/10/17/166">Linus Torvalds</a><ul><li><a href="/lkml/2000/10/17/167">Andrea Arcangeli</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 17 Oct 2000 11:36:22 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: mapping user space buffer to kernel address space</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 17 Oct 2000, Andrea Arcangeli wrote:<br />&gt; <br />&gt; &gt; Andrea, explain to me how pinning _could_ work? Explain to me how you'd<br />&gt; &gt; lock down pages in virtual address space with multiple threads, and how<br />&gt; &gt; you'd handle the cases of:<br />&gt; &gt; <br />&gt; &gt;  - two threads doing direct IO from different parts of the same page<br />&gt; &gt;  - one thread starting IO from a page, another thread unmapping the range<br />&gt; <br />&gt; I don't see the problem with those two cases.<br />&gt; <br />&gt; In the first case the first task will sleep in wait_on_page until the<br />&gt; second task will unmap the kiobuf.<br /><br />Ehh.. Remind me again what the whole _point_ of physical IO was, in the<br />first place?<br /><br />Was it maybe PERFORMANCE?<br /><br />Yeah. I thought so. <br /><br />Bye, bye, performance. You might as well remove the whole thing<br />completely.<br /><br />Also, note that one of my requirements to accept the direct IO patches in<br />the first place from Stephen was that I wanted them to NOT mess at all<br />with virtual memory mappings. Basically, the way kio buffers work is that<br />they are 100% based on only physical pages. There are no virtual issues at<br />all in the IO, and that's exactly how I want it. There is no reason to<br />confuse virtual addresses into this, because the thing should be usable<br />even in the complete absense of virtual mappings (ie the kernel can do<br />direct IO purely based on pages - think sendfile() etc).<br /><br />What does this mean? It means that the notion of writing directly from<br />user space doesn't actually exist in the Linux implementation of direct IO<br />at all. What Linux direct IO does is really a two-phase operation:<br /><br /> - look up the physical pages. <br /> - do IO based on physical pages<br /><br />The two are completely and entirely unrelated. Think "good design". Think<br />"modularity". Think "containment".<br /><br />Which means, btw, that "virtual pinning" does not make sense from a<br />conceptual standpoint at all. Because the "virtual" part does not even<br />_exist_ by the time we do IO.<br /><br />&gt; The only "problematic" case that I can see is the one mentioned by SCT that is<br />&gt; the same physical page present in two entries of the maplist in the kiobuf (in<br />&gt; my patch the user_map_kiobuf will return -EINVAL gracefully in that case and<br />&gt; that behaviour doesn't look horribly wrong to me). And that case can be<br />&gt; trivially handled by checking the list backwards in the trylock slowpath as I<br />&gt; just said.<br /><br />And WHY do you want to pin the damn things virtually in the first place?<br /><br />Your bug is a non-issue: it can obviously be fixed other ways, and has<br />nothing to do with virtually pinning the page. Yes, pinning the page in<br />the virtual map would also fix it,  but at the cost of completely breaking<br />the whole idea of what direct IO is all about.<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
