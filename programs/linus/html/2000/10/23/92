    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/10/22/3">First message in thread</a></li><li><a href="/lkml/2000/10/22/3">Dan Kegel</a><ul><li class="origin"><a href="/lkml/2000/10/23/111">(Linus Torvalds)</a><ul><li><a href="/lkml/2000/10/23/111">Andi Kleen</a><ul><li><a href="/lkml/2000/10/24/12">Felix von Leitner</a></li><li><a href="/lkml/2000/10/23/58">Andi Kleen</a><ul><li><a href="/lkml/2000/10/23/113">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2000/10/23/103">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2000/10/23/116">Tobias Ringstrom</a><ul><li><a href="/lkml/2000/10/23/98">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2000/10/23/109">Dan Kegel</a><ul><li><a href="/lkml/2000/10/23/37">"David Schwartz"</a><ul><li><a href="/lkml/2000/10/24/122">Dan Kegel</a></li><li><a href="/lkml/2000/10/24/126">Dan Kegel</a></li></ul></li><li><a href="/lkml/2000/10/23/133">"Nick Piggin"</a></li><li><a href="/lkml/2000/10/23/148">Jordan Mendelson</a><ul><li><a href="/lkml/2000/10/24/137">Dan Kegel</a><ul><li><a href="/lkml/2000/10/24/125">Dan Kegel</a></li><li><a href="/lkml/2000/10/24/133">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2000/10/23/183">"David Schwartz"</a><ul><li><a href="/lkml/2000/10/23/193">"David S. Miller"</a><ul><li><a href="/lkml/2000/10/23/72">"David Schwartz"</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">(Linus Torvalds)</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">23 Oct 2000 11:14:35 -0700</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">[ Small treatize on "scalability" included. People obviously do not<br />  understand what "scalability" really means. ]<br /><br />In article &lt;39F28A86.1D07DBFF&#64;alumni.caltech.edu&gt;,<br />Dan Kegel  &lt;dank&#64;alumni.caltech.edu&gt; wrote:<br />&gt;I ran a benchmark to see how long a call to poll() takes<br />&gt;as you increase the number of idle fd's it has to wade through.<br />&gt;I used socketpair() to generate the fd's.<br />&gt;<br />&gt;Under Solaris 7, when the number of idle sockets was increased from <br />&gt;100 to 10000, the time to check for active sockets with poll() <br />&gt;increased by a factor of only 6.5.  That's a sublinear increase in time, <br />&gt;pretty spiffy.<br /><br />Yeah. It's pretty spiffy.<br /><br />Basically, poll() is _fundamentally_ a O(n) interface. There is no way<br />to avoid it - you have an array, and there simply is _no_ known<br />algorithm to scan an array in faster than O(n) time. Sorry.<br /><br />(Yeah, you could parallellize it.  I know, I know.  Put one CPU on each<br />entry, and you can get it down to O(1).  Somehow I doubt Solaris does<br />that.  In fact, I'll bet you a dollar that it doesn't). <br /><br />So what does this mean?<br /><br />Either <br /><br /> (a) Solaris has solved the faster-than-light problem, and Sun engineers<br />     should get a Nobel price in physics or something.<br /><br /> (b) Solaris "scales" by being optimized for 10000 entries, and not<br />     speeding up sufficiently for a small number of entries.<br /><br />You make the call. <br /><br />Basically, for poll(), perfect scalability is that poll() scales by a<br />factor of 100 when you go from 100 to 10000 entries. Anybody who does<br />NOT scale by a factor of 100 is not scaling right - and claiming that<br />6.5 is a "good" scale factor only shows that you've bought into<br />marketing hype.<br /><br />In short, a 6.5 scale factor STINKS. The only thing it means is that<br />Solaris is slow as hell on the 100 descriptor case.<br /><br />&gt;Under Linux 2.2.14 [or 2.4.0-test1-pre4], when the number of idle sockets <br />&gt;was increased from  100 to 10000, the time to check for active sockets <br />&gt;with poll() increased by a factor of 493 [or 300, respectively].<br /><br />So, what you're showing is that Linux actually is _closer_ to the<br />perfect scaling (Linux is off by a factor of 5, while Solaris is off by<br />a factor of 15 from the perfect scaling line, and scales down really<br />badly). <br /><br />Now, that factor of 5 (or 3, for 2.4.0) is still bad.  I'd love to see<br />Linux scale perfectly (which in this case means that 10000 fd's should<br />take exactly 100 times as long to poll() as 100 entries take).  But I<br />suspect that there are a few things going on, one of the main ones<br />probably being that the kernel data working set for 100 entries fits in<br />the cache or something like that.<br /><br />&gt;Please, somebody point out my mistake.  Linux can't be this bad!<br /><br />I suspect we could improve Linux in this area, but I hope that I pointed<br />out the most fundamental mistake you did, which was thinking that<br />"scalability" equals "speed".  It doesn't. <br /><br />Scalability really means that the effort to handle a problem grows<br />reasonably with the hardness of the problem. And _deviations_ from that<br />are indications of something being wrong.<br /><br />Some people think that super-linear improvements in scalability are<br />signs of "goodness".  They aren't.  For example, the classical reason<br />for super-linear SMP improvement (with number of CPU's) that people get<br />so excited about really means that something is wrong on the low end. <br />Often the "wrongness" is lack of cache - some problems will scale better<br />than perfectly simply because with multiple CPU's you have more cache.<br /><br />The "wrongess" is often also selecting the wrong algorithm: something<br />that "scales well" by just being horribly slow for the small case, and<br />being "less bad" for the big cases.<br /><br />In the end, the notion of "scalability" is meaningless. The only<br />meaningful thing is how quickly something happens for the load you have.<br />That's something called "performance", and unlike "scalability", it<br />actually has real-life meaning.<br /><br />Under Linux, I'm personally more worried about the performance of X etc,<br />and small poll()'s are actually common. So I would argue that the<br />Solaris scalability is going the wrong way. But as performance really<br />depends on the load, and maybe that 10000 entry load is what you<br />consider "real life", you are of course free to disagree (and you'd be<br />equally right ;)<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
