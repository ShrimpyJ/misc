    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/8/24/132">First message in thread</a></li><li><a href="/lkml/2000/8/27/84">(Linus Torvalds)</a><ul><li><a href="/lkml/2000/8/28/59">Mitchell Blank Jr</a><ul><li class="origin"><a href="">(Linus Torvalds)</a></li><li><a href="/lkml/2000/8/28/146">Mitchell Blank Jr</a></li></ul></li><li><a href="/lkml/2000/8/28/145">Horst von Brand</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">(Linus Torvalds)</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: SCO: "thread creation is about a thousand times faster than on</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">27 Aug 2000 23:20:27 -0700</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">In article &lt;20000827220921.E65631&#64;sfgoth.com&gt;,<br />Mitchell Blank Jr  &lt;mitch&#64;sfgoth.com&gt; wrote:<br />&gt;Linus Torvalds wrote:<br />&gt;<br />&gt;&gt; Now, if the question is "Ok, I'm a POSIX thread, and I want the stupid<br />&gt;&gt; POSIX behaviour where an execve() kills all other threads", then you<br />&gt;&gt; have to do it by hand. Something like "kill all other threads, and then<br />&gt;&gt; do the execve". It's not rocket science.<br />&gt;<br />&gt;Yes, but:<br />&gt;  * If we're going to give POSIX threads the illusion of a shared PID then<br />&gt;    to be strictly correct the exec'ed process needs to have that PID too.<br />&gt;    If we want to do this, then an execve from any random thread won't<br />&gt;    do.<br /><br />Ahh. But this is exactly where I think your analogy is broken.<br /><br />You need the illusion of a shared pid for _threads_.  But we've already<br />agreed that a thread that does an execve() breaks apart from the other<br />threads, if for no other reason than the fact that it obviously doesn't<br />share the same VM. So we have a phase transition..<br /><br />More importantly, once you approach the problem from the clone/rfork<br />approach, you understand that threads and processes are really the same<br />thing on a fundamental level.  So you realize that the notion of a<br />"process ID" as separate from a "thread ID" is not a sensible notion.  A<br />thread is a process is a thread, and it has a well-defined ID.  It's not<br />"thread or process".  It's both. <br /><br />So rather, you could have the notion of a _grouping_ of these<br />threads/processes.  UNIX had that notion long before threads came to be. <br />Sessions and process groups, with process group leadership and all that<br />entails.  A grouping of lightweight processes isn't that different, now<br />is it? It's not the _same_ group, but it's the same concept. <br /><br />So we realize that the whole notion of a "shared PID" is a broken<br />notion.  It's not really a shared pid AT ALL, because obviously the<br />different lightweight processes have identities of their own.  It's<br />purely a _grouping_ of identities, and as we already saw, execve()<br />already breaks the grouping by virtue of obviously breaking the VM<br />sharing. <br /><br />So it's entirely and utterly internally consistent to just say that a<br />process breaks away from the thread grouping when it does an execve().<br />And it's entirely and utterly consistent to say that the _traditional_<br />"shared thread ID" is really nothing more than the group ID.<br /><br />Very logical. Internally consistent. And not very confusing at all.<br /><br />But the above only gives a "feeling" for what the right answer might be.<br /><br />Now, if you also take into account how process group leadership in UNIX<br />has always worked (well, "always" obviously means since process groups<br />were introduced, which is however long ago), you also see the details.<br />It becomes clear that the thread leader pid is the one that becomes the<br />"thread group ID".<br /><br />Which means that when "execve()" breaks apart into its own "group of<br />one", what really happens is that it suddenly gets its own unique thread<br />group ID - which is obviously the same as the unique pid it got when it<br />was created.<br /><br />How do we reconcile this with "execve() doesn't change the pid"?<br /><br />We don't.  We don't have to.  You'll see that the historical UNIX<br />behaviour wrt execve() not changing the process pid is just a special<br />case of the above: it's the special case of the thread group leader<br />doing the execve() - because each traditional "process" is nothing but<br />its own thread group leader (a rather lonely leader, admittedly, as<br />there's nobody else to actually lead ;). <br /><br />Final piece of the puzzle: we use the (n+1) native threads approach to<br />do the n pthreads thing, so that none of the threads that a threaded<br />pthreads program will see is actually the process group leader (that<br />single thread is the hidden administrator - the puppet master - created<br />at the first thread creation). <br /><br />That way pthreads execve() will always reliably break the connection,<br />because the execve() will never be the historical special case of<br />"thread group == pid".  Which is what you want to have, because you've<br />already broken the symmetry (and execve was so badly defined in pthreads<br />that changing that detail shouldn't be a big issue). <br /><br />Well-defined? Yes.  Surprising? I don't think so.  I think it follows<br />fairly naturally from just two assumptions: "threads and processes are<br />fundamentally the same thing" and "we want to be close to 'historical<br />UNIX' in spirit". <br /><br />[ Alternative details: regular UNIX process group leadership also<br />  implies the notion of "orphaned" processes without a group leader. <br />  I'd rather not get into that when it comes to thread groups, but<br />  there's nothing wrong with the notion per se.  I just don't think the<br />  need is there, like it is for process group leadership.  But this<br />  issue is more of "a detail in the implementation" than a big design<br />  question.  I don't care all that much either way, myself.  ]<br /><br />&gt;  * What happens if the execve fails?  I suspect POSIX would want us to<br />&gt;    return an error code to that thread without interfering with the<br />&gt;    existing threads.  But wait, we've already "kill -9"'ed them all.<br />&gt;    To get this right would definately require kernel support.  The<br />&gt;    kernel must atomically end all the other threads when it knows the<br />&gt;    execve isn't going to return an error.<br /><br />Actually, I'd personally just prefer trying to find a loophole in POSIX. <br />Or do it in the loader process, so that the newly executed process<br />automatically kills any remnant threads before doing anything else.  I<br />agree that it's a nasty thing to emulate - but it's also one of the<br />worst horrors of the pthreads process notion, and potentially a good<br />candidate for just saying "ok, you'd better learn the new rules". <br /><br />Or you could have the master kernel thread and add some simple kernel<br />extensions - we already have "child died" signals and "parent died"<br />signals, we could have a "child executed" signal too and just be done<br />with it: the puppet master thread would get the "child executed"<br />notification and would just kill off all its threads.<br /><br />Or you could extend a bit on the logic we already have for "vfork()",<br />which has some of the same notification issues (ie the vfork() parent<br />needs to be aware of when its child has released the VM space back to<br />it). <br /><br />So there are tons of solutions to this kind of backwards compatibility<br />that don't require the actual braindead semantics of pthreads - but they<br />may require some creativity. <br /><br />But no question about it: some of the pthreads semantics are not pretty<br />in a truly threaded environment. pthreads does tend to assume a fairly<br />strictly ordered life (which is natural considering the origins of it,<br />but it makes it painful when you have truly independent threads that<br />aren't all that strongly synchronized).<br /><br />			Linus<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
