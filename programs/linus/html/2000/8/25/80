    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/8/23/120">First message in thread</a></li><li><a href="/lkml/2000/8/23/176">Linus Torvalds</a><ul><li><a href="/lkml/2000/8/23/193">"Andi Kleen"</a><ul><li><a href="/lkml/2000/8/23/172"> yodaiken&#64;fsmlabs ...</a></li><li><a href="/lkml/2000/8/23/173">Alan Cox</a></li><li><a href="/lkml/2000/8/23/175">"Michael H. Warfield"</a></li><li><a href="/lkml/2000/8/23/183">Michael Rothwell</a></li><li><a href="/lkml/2000/8/24/125">(Kai Henningsen)</a><ul><li><a href="/lkml/2000/8/24/131">Matthew Wilcox</a><ul><li><a href="/lkml/2000/8/27/6">(Kai Henningsen)</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2000/8/25/36">Jamie Lokier</a><ul><li class="origin"><a href="/lkml/2000/8/25/106">Linus Torvalds</a><ul><li><a href="/lkml/2000/8/25/106">Jamie Lokier</a><ul><li><a href="/lkml/2000/8/25/132">Linus Torvalds</a></li><li><a href="/lkml/2000/8/26/101">dean gaudet</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 25 Aug 2000 09:48:48 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: SCO: "thread creation is about a thousand times faster than onnative</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 25 Aug 2000, Jamie Lokier wrote:<br />&gt; <br />&gt; A stack page is _not_ required for a kernel thread, except when that<br />&gt; thread is blocked.  A sleeping but runnable task doesn't require a stack.<br /><br />Wrong.<br /><br />A stack page _is_ required for a thread, basically always:<br /> - when it is running (either in user or kernel space): interrupts happen.<br />   You can't share the stack page sanely with other processes, because the<br />   interrupt can (and often does) cause a task-switch to another<br />   completely unrelated process. And you have to save the register state<br />   somewhere.<br /><br />   NOTE! Linux does NOT save the register state in the task struct. Saving<br />   state in the task struct is a horrible waste of time when it has been<br />   already saved on the stack for other reasons (ie the stack contains not<br />   just the register state, but the instructions about how to unwind it<br />   from recursive faults etc).<br /><br /> - when it is sleeping in kernel space: the stack contains the full path<br />   to where it slept, we _need_ it.<br /><br />Basically, the _only_ time you don't need a kernel stack is when the<br />process is completely idle, ie it has been scheduled away because its<br />time-slice ended, and it wasn't in kernel mode when this happened. And<br />Linux doesn't consider this a special state at all - as far as the kernel<br />is concerned, that sleeping state is the same as sleeping in kernel mode.<br /><br />Quite frankly, the stack _is_ part of the "struct task_struct". It's not<br />just a performance optimization to allocate them together. Sure, the fact<br />that we allocate them together means one less allocation, and it allows<br />the clever "current" games we play with the stack pointer, but those are<br />details. Fundamentally, the two are part of the same thing.<br /><br />Yes, you could do it differently. In fact, other OS's _do_ do it<br />differently. But take a look at our process timings (ignoring wild claims<br />by disgruntled SCO employees that can probably be filed under "L" for<br />"Lies, Outright"). Think about WHY our system call latency beats everybody<br />else on the planet. Think about WHY Linux is fast. It's because it's<br />designed right.<br /><br />Continuations and other crap only add overhead. 8kB of storage for the<br />whole thread state (including the kernel stack) is _incredibly_ tiny.<br /><br />&gt; The alternative is user space lightweight threads which as we know can<br />&gt; be very light indeed - comparable with procedure calls and event loops.<br /><br />Indeed. They aren't real threads, though. The same way that DOS isn't<br />really a multi-tasking operating system, even if you can create an<br />environment on top of it that looked almost threaded.<br /><br />Yes, you can get lower-latency threads. But they won't be the "real<br />thing". They won't scale on SMP, and they'll have other limitations too<br />(often they require synchronous task-switching, because that allows<br />optimizations like not saving the whole register state: which can be a BIG<br />win when the register state is big or slow to save like the x86 FP state).<br /><br />Trust me. You won't find faster true threads than what Linux offers. And<br />they won't be using less than 8kB of memory.<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
