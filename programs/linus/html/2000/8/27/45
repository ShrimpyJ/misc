    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2000/8/24/132">First message in thread</a></li><li><a href="/lkml/2000/8/24/50">Alan Cox</a><ul><li><a href="/lkml/2000/8/24/29">Alexander Viro</a></li><li><a href="/lkml/2000/8/27/124"> yodaiken&#64;fsmlabs ...</a><ul><li><a href="/lkml/2000/8/27/15">Mark Kettenis</a></li><li><a href="/lkml/2000/8/27/16">Mitchell Blank Jr</a></li><li><a href="/lkml/2000/8/27/36">Mitchell Blank Jr</a><ul><li><a href="/lkml/2000/8/27/80">Horst von Brand</a><ul><li><a href="/lkml/2000/8/27/121"> yodaiken&#64;fsmlabs ...</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2000/8/28/168">(Linus Torvalds)</a><ul><li><a href="/lkml/2000/8/28/168">Martin MaD Douda</a><ul><li><a href="/lkml/2000/8/28/74">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2000/8/27/46"> yodaiken&#64;fsmlabs ...</a></li><li><a href="/lkml/2000/8/27/59">Mark Kettenis</a></li><li><a href="/lkml/2000/8/27/66">Mark Kettenis</a></li><li><a href="/lkml/2000/8/27/76">Mitchell Blank Jr</a><ul><li><a href="/lkml/2000/8/27/84">(Linus Torvalds)</a><ul><li><a href="/lkml/2000/8/28/59">Mitchell Blank Jr</a></li><li><a href="/lkml/2000/8/28/145">Horst von Brand</a></li></ul></li></ul></li><li><a href="/lkml/2000/8/27/111">Mitchell Blank Jr</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2000/8/27/45/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">(Linus Torvalds)</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: SCO: "thread creation is about a thousand times faster than on</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">27 Aug 2000 17:25:07 -0700</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">In article &lt;20000827051241.A24890&#64;hq.fsmlabs.com&gt;,<br /> &lt;yodaiken&#64;fsmlabs.com&gt; wrote:<br />&gt;<br />&gt;POSIX says nothing, as far as I can tell, about the effect of exec on <br />&gt;threads. However, it does say pending signals must be inherited. It's<br />&gt;unclear what should happen in Linux, but it might be good for the new<br />&gt;process to still be a thread in the thread group -- although it won't<br />&gt;be sharing memory anymore.<br /><br />No. Simply for security purposes we _definitely_ need to "de-thread" the<br />process when it does an exec. Otherwise we have "interesting" issues<br />with suid execs that are part of a non-suid thread group.<br /><br />We could choose to just not allow suid execs, but I think they do<br />potentially make sense, and I don't see why Linux shouldn't allow a<br />thread to exec a suid binary (we break the shared VM part automatically,<br />we might as well break the shared thread part). <br /><br />Note that for _pthreads_ this kind of exec is illegal anyway.  Silly<br />POSIX threads standard had to take user-level threading models into<br />account, so under POSIX threads an execve() needs to kill off all other<br />threads.  Another senseless limitation - one that we can _emulate_, of<br />course, but not one that we should consider part of the native thread<br />environment. <br /><br />Btw, here's a simple thread-group patch.  It doesn't actually _do_<br />anything with the thread group part, but this is the kind of frame-work<br />I've envisioned.  Completely untested, of course, but with these kinds<br />of security issues taken into account.<br /><br />Comments? At least it's small and simple..<br /><br />				Linus<br /><br />----<br />diff -u --recursive --new-file penguin/linux/fs/exec.c linux/fs/exec.c<br />--- penguin/linux/fs/exec.c	Mon Aug 14 10:19:55 2000<br />+++ linux/fs/exec.c	Sun Aug 27 17:29:52 2000<br />&#64;&#64; -496,6 +496,25 &#64;&#64;<br /> 	write_unlock(&amp;files-&gt;file_lock);<br /> }<br /> <br />+/*<br />+ * An execve() will automatically "de-thread" the process.<br />+ * Note: we don't have to hold the tasklist_lock to test<br />+ * whether we migth need to do this. If we're not part of<br />+ * a thread group, there is no way we can become one<br />+ * dynamically. And if we are, we only need to protect the<br />+ * unlink - even if we race with the last other thread exit,<br />+ * at worst the list_del_init() might end up being a no-op.<br />+ */<br />+static inline void de_thread(struct task_struct *tsk)<br />+{<br />+	if (!list_empty(&amp;tsk-&gt;thread_group)) {<br />+		write_lock_irq(&amp;tasklist_lock);<br />+		list_del_init(&amp;tsk-&gt;thread_group);<br />+		write_unlock_irq(&amp;tasklist_lock);<br />+	}<br />+	tsk-&gt;tgid = tsk-&gt;pid;<br />+}<br />+<br /> int flush_old_exec(struct linux_binprm * bprm)<br /> {<br /> 	char * name;<br />&#64;&#64; -533,6 +552,8 &#64;&#64;<br /> 	current-&gt;comm[i] = '\0';<br /> <br /> 	flush_thread();<br />+<br />+	de_thread(current);<br /> <br /> 	if (bprm-&gt;e_uid != current-&gt;euid || bprm-&gt;e_gid != current-&gt;egid || <br /> 	    permission(bprm-&gt;file-&gt;f_dentry-&gt;d_inode,MAY_READ))<br />diff -u --recursive --new-file penguin/linux/include/linux/sched.h linux/include/linux/sched.h<br />--- penguin/linux/include/linux/sched.h	Wed Aug 23 11:35:07 2000<br />+++ linux/include/linux/sched.h	Sun Aug 27 17:31:18 2000<br />&#64;&#64; -38,6 +38,7 &#64;&#64;<br /> #define CLONE_PTRACE	0x00002000	/* set if we want to let tracing continue on the child too */<br /> #define CLONE_VFORK	0x00004000	/* set if the parent wants the child to wake it up on mm_release */<br /> #define CLONE_PARENT	0x00008000	/* set if we want to have the same parent as the cloner */<br />+#define CLONE_THREAD	0x00010000	/* set if we want to clone the "thread group" */<br /> <br /> /*<br />  * These are the constant used to fake the fixed-point load-average<br />&#64;&#64; -311,6 +312,7 &#64;&#64;<br /> 	pid_t pgrp;<br /> 	pid_t tty_old_pgrp;<br /> 	pid_t session;<br />+	pid_t tgid;<br /> 	/* boolean value for session group leader */<br /> 	int leader;<br /> 	/* <br />&#64;&#64; -319,6 +321,7 &#64;&#64;<br /> 	 * p-&gt;p_pptr-&gt;pid)<br /> 	 */<br /> 	struct task_struct *p_opptr, *p_pptr, *p_cptr, *p_ysptr, *p_osptr;<br />+	struct list_head thread_group;<br /> <br /> 	/* PID hash table linkage. */<br /> 	struct task_struct *pidhash_next;<br />&#64;&#64; -435,6 +438,7 &#64;&#64;<br />     prev_task:		&amp;tsk,						\<br />     p_opptr:		&amp;tsk,						\<br />     p_pptr:		&amp;tsk,						\<br />+    thread_group:	LIST_HEAD_INIT(tsk.thread_group),		\<br />     wait_chldexit:	__WAIT_QUEUE_HEAD_INITIALIZER(tsk.wait_chldexit),\<br />     real_timer:		{						\<br /> 	function:		it_real_fn				\<br />&#64;&#64; -818,6 +822,7 &#64;&#64;<br /> 	nr_threads--;<br /> 	unhash_pid(p);<br /> 	REMOVE_LINKS(p);<br />+	list_del(&amp;p-&gt;thread_group);<br /> 	write_unlock_irq(&amp;tasklist_lock);<br /> }<br /> <br />diff -u --recursive --new-file penguin/linux/kernel/fork.c linux/kernel/fork.c<br />--- penguin/linux/kernel/fork.c	Wed Aug 23 11:33:48 2000<br />+++ linux/kernel/fork.c	Sun Aug 27 17:32:08 2000<br />&#64;&#64; -661,7 +661,13 &#64;&#64;<br /> 	 * Let it rip!<br /> 	 */<br /> 	retval = p-&gt;pid;<br />+	p-&gt;tgid = retval;<br />+	INIT_LIST_HEAD(&amp;p-&gt;thread_group);<br /> 	write_lock_irq(&amp;tasklist_lock);<br />+	if (clone_flags &amp; CLONE_THREAD) {<br />+		p-&gt;tgid = current-&gt;tgid;<br />+		list_add(&amp;p-&gt;thread_group, &amp;current-&gt;thread_group);<br />+	}<br /> 	SET_LINKS(p);<br /> 	hash_pid(p);<br /> 	nr_threads++;<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />Please read the FAQ at <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
