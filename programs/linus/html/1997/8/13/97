    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1997/8/10/13">First message in thread</a></li><li><a href="/lkml/1997/8/13/87">Peeter Joot</a><ul><li><a href="/lkml/1997/8/13/91">Richard Gooch</a><ul><li class="origin"><a href="/lkml/1997/8/13/99">Linus Torvalds</a><ul><li><a href="/lkml/1997/8/13/99">Richard Gooch</a><ul><li><a href="/lkml/1997/8/14/9"> &lt;wladams&#64;freenet ...</a></li></ul></li><li><a href="/lkml/1997/8/14/7"> mjr&#64;iki ...</a><ul><li><a href="/lkml/1997/8/14/22">Werner Almesberger</a></li></ul></li><li><a href="/lkml/1997/8/15/10">Peeter Joot</a><ul><li><a href="/lkml/1997/8/15/30">Mikko Rauhala</a></li></ul></li><li><a href="/lkml/1997/8/19/95">Teunis Peters</a><ul><li><a href="/lkml/1997/8/20/39">(Alan Cox)</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/1997/8/14/39">Eric Hoeltzel</a></li><li><a href="/lkml/1997/8/14/45">Rob Hagopian</a><ul><li><a href="/lkml/1997/8/14/82">(H. Peter Anvin)</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 13 Aug 1997 21:01:13 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Killing clones</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 14 Aug 1997, Richard Gooch wrote:<br />&gt; &gt;<br />&gt; &gt; About a year ago a least was a a discussion about fixing up the<br />&gt; &gt; CLONE_PID flag so that thread id's would be encoded in the upper bits of<br />&gt; &gt; the pid.  One could have ps list only the proc info for the initial<br />&gt; &gt; thread (or other thread if the initial has exited), and be able to see<br />&gt; &gt; what initial process all the threads are associated with.<br />&gt; <br />&gt; It's a pity nothing ever went into the kernel. Threads under Linux is<br />&gt; still a bit clunky. Bit like IRIX threads, actually... At least we<br />&gt; don't have to contend with arenas!<br /><br />Indeed.<br /><br />My hope for the development of clone() was originally:<br /> - I laid the basic framework (done)<br /> - people started using it, primarily for<br />   - pthreads (pretty much done)<br />   - asynchronous IO (nope)<br />   - interesting new uses that nobody thought about before (nope)<br /> - people started looking at what was missing and add kernel support<br /><br />The basic problem I had was that I had lots of ideas on what I wanted to<br />be possible, but I was also aware that while I wanted a very specific<br />basic design, I was by no means sure exactly which details need to be<br />handled where. <br /><br />For example, the exact bits in the clone() flags field were made up by me<br />not because I wanted those exact bits, but because I imagined that those<br />bits might possibly make sense. For example, I am certain that the<br />CLONE_VM bit makes sense, but does CLONE_FS make sense? I don't know. <br />Maybe it would be better to include the current CLONE_FS information into<br />the CLONE_FILES stuff? <br /><br />Or take a look at the low 8 bits. I decided that to implement aio_xxx() on<br />top of clone() we might be better off not using SIGCHLD, but instead have<br />the death of the clone'd child send SIGIO directly. So now the low eight<br />bits of clone_flags is the signal to be sent at exit time.<br /><br />I still don't know if people actually use this feature - or the feature<br />that when the signal is something else than SIGCHLD, you have to use a<br />special flag to "waitpid()" to get it to recognize the cloned children. <br />Again, this was so that "waitpid()" wouldn't end up waiting for<br />asynchronous IO. <br /><br />In short, I tried to make a basic framework that would fit my ideas of<br />what a light-weight clone() would be good for, but at the same time I<br />didn't want to set the design in stone - the intention was for it to<br />develop as people found new ways of (mis)using the new cool thread<br />feature. <br /><br />&gt; &gt; * modifications to the linuxthreads package for testing all this out<br />&gt; &gt; * other things that may be needed -- linuxthreads needs a little bit of<br />&gt; &gt; help in the kernel in the few places and presumably other more general<br />&gt; &gt; clone based threads need the same sort of stuff.  For example,<br />&gt; &gt; linuxthreads uses SIGUSR1, SIGUSR2, and it also needs a "manager thread"<br />&gt; &gt; to handle things like stack cleanup at termination.<br />&gt; <br />&gt; None of these address the problem of killing child threads. Although<br />&gt; it's all good stuff you mention: nice to see someone thinking about<br />&gt; all this.<br />&gt; What was Linus' view on encoding IDs in the upper pid bits? It's<br />&gt; certainly good for grouping processes together, though it may be more<br />&gt; prone to introducing bugs than a simple CLONE_NO_PROC_ENTRY like I<br />&gt; suggested, by the simple rule that anything more complicated is likely<br />&gt; to have more bugs :-)<br /><br />Encoding the thread ID in the high bits was one of the ideas from the very<br />beginning. That's what CLONE_PID is there for: the _intent_ was that<br />CLONE_PID would change only the high bits, and then you could do a global<br />kill (anything with the high bits zero would send a signal to _all_<br />threads that shared the same low bits). <br /><br />Again, this is still an interesting approach. I'd like to see it done some<br />day. The fact that the /proc fs makes it a bit harder is a misfeature, but<br />that's actually due to bad /proc design (which used to make a lot of sense<br />back when inode numbers was all we had, but we could do better these<br />days). <br /><br />My personal favourite for /proc would be that any CLONE_PID threads would<br />show up _inside_ the original parent (that's kind of the basic idea with<br />CLONE_PID). So you'd have<br /><br />	/proc/155/		"original" process (ie something that was<br />				 created without the CLONE_PID bit)<br />	/proc/155/1		"1st CLONE_PID child"<br />	/proc/155/2		"2nd CLONE_PID child"<br /><br />or something like that.<br /><br />&gt; Can I suggest that, where possible, improvements to thread support in<br />&gt; Linux is made as a set of separate patches? We've seen before that<br />&gt; Linus rejects omnibus patches if he doesn't like some bits, even if<br />&gt; other bits are OK. Giving them as separate (independent) patches makes<br />&gt; life easier for him (and hence more likely that "good" patches are<br />&gt; applied quickly).<br /><br />Indeed.<br /><br />&gt; * new flag to clone() to allow pids to be "grouped" so that part of<br />&gt; the bitrange for pids are shared within a group. Also needs pid<br />&gt; allocation algorithm to change<br /><br />CLONE_PID is that. It currently has a very limited use: the kernel uses it<br />to allocate the SMP idle processes for each task, and those all have to<br />have pid 0 (also high bits). But my real intent was to have something like<br />this:<br /><br />	if (flags &amp; CLONE_PID) {<br />		newpid = current-&gt;pid;<br />		/* zero is special - the idle process */<br />		if (newpid) {<br />			create linked list of processes<br />			sharing the same low 16 bits,<br />			make "newpid" be the largest to<br />			date plus 0x10000 (ie "increment" the<br />			high 16 bit counter on a per-PID basis)<br />		}<br />	} else<br />		newpid = traditional_newpid();<br /><br />&gt; * new flag to clone() to either hide a process in /proc or reflect<br />&gt; that the flag was set (thinking about this more makes me think that<br />&gt; this scheme can give much the same flexibility as the above with less<br />&gt; work in the kernel and possibly a little more work in userspace procps<br />&gt; tools)<br /><br />See above about how I'd like this to work. With the /proc/155/1 setup, the<br />old tools would only ever see the original parent, so to "ps" the threaded<br />application would look like just one process. <br /><br />Additionally note that "kill -1 155" would send SIGHUP to _all_ the<br />threads, and if you wanted to kill just one subthread you'd have to name<br />it completely in 32 bits (ie "kill -1 $((0x10000+155))" would kill 155/1,<br />and we'd probably make an extension to bash so that you can say just that:<br />"kill -1 155/1" would do the math for you). <br /><br />Yes, this does imply that the first thread is special, but I don't see<br />anything really wrong with that. If you don't want the first thread to be<br />special, just don't use CLONE_PID - then all threads will have a full life<br />of their own. <br /><br />&gt; * new signals for LinuxThreads support (no more stealing of SIGUSR1<br />&gt; and SIGUSR2)<br /><br />Yes. This is separate from threads, though. We need this for RT signals<br />anyway. <br /><br />&gt; * new flag to clone() or new syscall prctl() so that when a processes'<br />&gt; parent dies, it is sent a signal<br /><br />Agreed. It's actually technically very easy to send a SIGPARENT (just do<br />it in "forget_original_parent()", I think), and it needs another bit in<br />the clone flags. <br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
