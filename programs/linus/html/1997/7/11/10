    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1997/7/11/10">First message in thread</a></li><li class="origin"><a href="/lkml/1997/8/10/48">Linus Torvalds</a><ul><li><a href="/lkml/1997/8/10/48">Andrea Arcangeli</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 10 Jul 1997 22:24:19 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: PATCH to pre-patch-2.1.45: clean_inode needs to reset i_writecount</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 11 Jul 1997, Theodore Y. Ts'o wrote:<br />&gt; <br />&gt; You have to write out an ext2 inode after deleting it anyway, to<br />&gt; decrement the link count to zero.  Otherwise, e2fsck, when recovering<br />&gt; the filesystem, will see a inode which is disconnected from the<br />&gt; filesystem and assume it was caused by a directory getting smashed, and<br />&gt; restore the inode to /lost+found.<br /><br />I think it should at least look at the inode bitmap too: if it can't find<br />any reference to the inode in the directory tree, and the bitmap indicates<br />that the inode isn't in use, then the case is pretty clear, imnsho.<br /><br />So in fact the only time when i_nlink makes any difference would be when<br />the inode bitmap was corrupted _and_ the directory structure was<br />corrupted, at which point I don't see all that much reason to trust<br />i_nlink either.. <br /><br />&gt; Now, you could use other methods for determining whether or not an inode<br />&gt; is in use --- for example, you could use the inode bitmap.  However,<br />&gt; this increases the requirement that the inode bitmap field be correct,<br />&gt; which it might not be.  If an inode bitmap block gets zero'ed out, huge<br />&gt; numbers of files would simply disappear.<br /><br />Only if the directory tree also disappeared.<br /><br />&gt; 	Inode is in use IFF (inode is marked in use in the inode bitmap)<br />&gt; 				OR (inode is referenced in the directory<br />&gt; 				subtree directly reachable from the<br />&gt; 				root directory)<br /><br />Right.<br /><br />&gt; This still might cause you to lose precious data in an unclean shutdown<br />&gt; if a directory gets corrupted (so that some files get disconnected from<br />&gt; the root) AND the inode bitmap is somehow corrupted or not written out<br />&gt; to disk before the crash.<br /><br />Sure, you can lose data, but fsck was never meant to be a backup tool. <br />Fsck should do the best it can, but a filesystem that is designed for fsck<br />is a filesystem that is designed to fail. <br /><br />&gt; Worse still, thus hueristic makes a complete hash of e2fsck's current<br />&gt; algorithms, which work by assuming it can determine whether or not an<br />&gt; inode is in use (and therefore what blocks are in use) without reference<br />&gt; to the directory hierarchy.  Making this change would require a major<br />&gt; rewrite of e2fsck, and all existing e2fscks would not be able to handle<br />&gt; ext2 filesystems which had been written to by kernels who were modified<br />&gt; to have the behaviour you proposed.<br /><br />The basic heuristic would still be valid: find out which inodes are in use<br />by looking at the inode bitmap, and start off with that. Algorithm exactly<br />the same as testing "i_link &gt; 0". <br /><br />In fact, the semantic content of the inode bitmap and the test "i_link &gt;<br />0" is _exactly_ the same, so this part of fsck doesn't change at all<br />(except it is speeded up a lot when you have lots of free inodes, because<br />you don't even have to read those inodes in if they aren't marked in the<br />bitmap).<br /><br />Then you do the directory tree walk, same as before. The normal case is<br />that this will match with what you got in the earlier stage, and<br />everything is fine. <br /><br />However, the you _do_ find an inode that doesn't match with the directory<br />tree, that's when things get interesting. Either you find an inode that<br />you haven't seen before, in which case you do roughly:<br /><br /> - read the inode.<br /> - check the inode internal state for consistency. For example:<br />   - check the data blocks it says it has: are they marked in use in the<br />     block bitmap? If the inode is marked unused in the inode bitmap, and<br />     the data blocks it claims to have are _also_ marked unused (or<br />     duplicate from an inode that we've seen) then we can assume that this<br />     inode really was deleted, and it's just the directory entry that is<br />     obsolete. Fix: clear the directory entry. <br />   - if the internal inode state checks out, it's safe to add it back to<br />     the filesystem. <br /><br />or you find an inode that was marked in use, but you never found it in the<br />directory tree, in which case you again check the internal consistency of<br />the inode and if everything checks out you add it to lost+found, otherwise<br />you just clear the in-use bit. <br /><br />&gt; If we were living to live with the consequences of using the above<br />&gt; hueristic (instead of the much simpler and more robust strategy of<br />&gt; depending on the inode link count field), then yes, we could do what you<br />&gt; wanted --- although note that it was always two disk blocks being<br />&gt; updated, since you always had to remove the directory entry.  However,<br />&gt; do file deletions happen often enough that it's really worth the cost of<br />&gt; optimizing for them?<br /><br />Yes. Our current "rm -rf xxx" really sucks performance-wise. I still<br />remember what it was like on the minix filesystem where it was pretty darn<br />instantaneous to delete a full directory tree: it takes _ages_ on ext2fs<br />compared to that. And don't tell me my directories tend to be larger these<br />days: that's certainly true, but my CPU and disks tend to be so much<br />faster that it should more than make up for it. <br /><br />&gt; P.S.  A number of people have found the dtime field very useful for<br />&gt; recovering deleted files after a mistaken "rm -rf" command.<br /><br />Actually, because the minixfs didn't bother to write out the inodes after<br />it deleted them, it was _very_ simple to recover from "rm -rf". I've<br />actually done this once when I removed my linux source directory by<br />mistake once:<br /><br /> - find the inode that was the "linux" directory inode (not very hard: <br />   because the inode was never written out when it was deleted, all the<br />   information was still up-to-date)<br /> - create a new directory entry pointing to the "linux" inode<br /> - run fsck<br /><br />Voila, the _whole_ tree came back. NOTHING was lost. Because the inode<br />wasn't actually written out to disk when it was deleted, all the<br />information was still there: including the full directory tree (because<br />the data blocks were also marked clean when they were deleted, so all the<br />directory entry zeroing that had happened recursively never hit the disk<br />at all). <br /><br />The only thing fsck needed to do was to mark the inodes (and the blocks in<br />the inodes)  in use again when it noticed that they had a pointer to them<br />in the directory tree.<br /><br />In contrast, when you write out the dtime, you also overwrite the old<br />inode information, making it much harder to recreate the file again. All<br />your data block pointers will be zero because the inode was truncated. <br /><br />Now, I'm not claiming that the minix fsck was good: it was a piece of<br />rubbish compared to your fsck.ext2. It wasn't very clever at all: it<br />tended to give up way too easily (no lost+found), and in general it was<br />just a bad parody of what fsck should be like. But that doesn't mean that<br />the basic filesystem strategy was bad ;) <br /><br />Final comment: I actually agree with you somewhat: using i_nlink is an<br />added piece of information, and I can see that you like to use it in fsck.<br />That doesn't change the fact that I _hate_ it that the normal run-time<br />operations are slowed down for a feature that _may_ under some<br />circumstances result in a better fsck. I'd much rather have a faster<br />filesystem. <br /><br />I take the RISC approach: make the default case go fast, and make fsck a<br />bit slower and less reliable. I don't think anybody seriously thinks that<br />fsck is an alternative to backups anyway. <br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
