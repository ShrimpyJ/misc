    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1997/11/12/67">First message in thread</a></li><li><a href="/lkml/1997/11/12/67">Linus Torvalds</a><ul><li><a href="/lkml/1997/11/12/85">"David S. Miller"</a><ul><li><a href="/lkml/1997/11/12/89">Linus Torvalds</a></li></ul></li><li><a href="/lkml/1997/11/12/93">Geoff Hoff</a></li><li><a href="/lkml/1997/11/12/106">Troels Arvin</a><ul><li><a href="/lkml/1997/11/13/28">Ingo Molnar</a></li><li><a href="/lkml/1997/11/13/41">Jimmie Farmer</a></li></ul></li><li><a href="/lkml/1997/11/12/116">"Simon's Mailing List Account"</a><ul><li><a href="/lkml/1997/11/12/118">Linus Torvalds</a><ul><li><a href="/lkml/1997/11/12/119">Adam Wiggins</a></li><li><a href="/lkml/1997/11/13/16">Todd Derr</a><ul><li><a href="/lkml/1997/11/13/30">Ingo Molnar</a></li><li><a href="/lkml/1997/11/13/37">Linus Torvalds</a></li><li><a href="/lkml/1997/11/13/90">Gabriel Paubert</a></li></ul></li><li><a href="/lkml/1997/11/13/18">David Whysong</a><ul><li><a href="/lkml/1997/11/13/32">Ingo Molnar</a></li><li><a href="/lkml/1997/11/13/74">Alex Priem</a></li></ul></li><li><a href="/lkml/1997/11/13/111">Anthony DeStefano</a></li></ul></li><li><a href="/lkml/1997/11/13/47">"Richard B. Johnson"</a></li></ul></li><li><a href="/lkml/1997/11/12/122">Joey Hess</a><ul><li><a href="/lkml/1997/11/13/73">Rik van Riel</a><ul><li><a href="/lkml/1997/11/13/87">Joey Hess</a><ul><li><a href="/lkml/1997/11/14/22">Jimmie Farmer</a></li></ul></li><li><a href="/lkml/1997/11/13/114">Linux Developer</a></li></ul></li></ul></li><li><a href="/lkml/1997/11/12/126">Thomas Wouters</a></li><li><a href="/lkml/1997/11/12/130">"Roel Lascano"</a><ul><li><a href="/lkml/1997/11/13/2">Linus Torvalds</a><ul><li><a href="/lkml/1997/11/13/6">Frank Sweetser</a><ul><li><a href="/lkml/1997/11/13/7">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/1997/11/13/1">linux kernel account</a><ul><li class="origin"><a href="/lkml/1997/11/13/21">Linus Torvalds</a><ul><li><a href="/lkml/1997/11/13/21">Ingo Molnar</a></li></ul></li><li><a href="/lkml/1997/11/13/104">linux kernel account</a></li></ul></li><li><a href="/lkml/1997/11/13/70">Pauline Middelink</a></li><li><a href="/lkml/1997/11/14/41">(Eugene Crosser)</a><ul><li><a href="/lkml/1997/11/14/59"> matthias.johnson&#64;mankato ...</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/1997/11/13/4/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 12 Nov 1997 21:20:25 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Report on 2.1.63 - Pentium bug workaround..</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 13 Nov 1997, linux kernel account wrote:<br />&gt; <br />&gt; Opon execution of the F00F crash program, the computer still crashes.<br />&gt; HOWEVER, the previous crash was a complete hard lock, this one allowed<br />&gt; console interaction.<br />&gt; <br />&gt; Magic-sysrequest showed that the 'bash' that had forked off the 'Process<br />&gt; of Doom' was stuck as 'current' process. <br />&gt; <br />&gt; An improvement, but not quite yet. I would guess that, softdog could have<br />&gt; rebooted the computer in this case..<br />&gt; <br />&gt; Maby some SMP lock isn't being acquired by the handler.<br /><br />I'm re-posting the patches to v2.1.63 that should get it working with SMP<br />too, as too many people seem to have missed them. These pre-64 patches<br />apply to a clean 2.1.63, and _should_ fix the SMP Pentium problem (but<br />while I do have an SMP machine, it's not a Pentium, so again I can't<br />actually test them..) <br /><br />Sorry for the re-post, but I really really want to get this tested..<br /><br />		Linus<br /><br />----<br />diff -u --recursive --new-file v2.1.63/linux/Makefile linux/Makefile<br />--- v2.1.63/linux/Makefile	Wed Nov 12 13:34:25 1997<br />+++ linux/Makefile	Wed Nov 12 12:11:41 1997<br />&#64;&#64; -1,6 +1,6 &#64;&#64;<br /> VERSION = 2<br /> PATCHLEVEL = 1<br />-SUBLEVEL = 63<br />+SUBLEVEL = 64<br /> <br /> ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/)<br /> <br />diff -u --recursive --new-file v2.1.63/linux/arch/i386/mm/fault.c linux/arch/i386/mm/fault.c<br />--- v2.1.63/linux/arch/i386/mm/fault.c	Wed Nov 12 13:34:25 1997<br />+++ linux/arch/i386/mm/fault.c	Wed Nov 12 13:33:48 1997<br />&#64;&#64; -74,14 +74,6 &#64;&#64;<br /> 	return 0;<br /> }<br /> <br />-asmlinkage void divide_error(void);<br />-asmlinkage void debug(void);<br />-asmlinkage void nmi(void);<br />-asmlinkage void int3(void);<br />-asmlinkage void overflow(void);<br />-asmlinkage void bounds(void);<br />-asmlinkage void invalid_op(void);<br />-<br /> asmlinkage void do_divide_error (struct pt_regs *, unsigned long);<br /> asmlinkage void do_debug (struct pt_regs *, unsigned long);<br /> asmlinkage void do_nmi (struct pt_regs *, unsigned long);<br />&#64;&#64; -189,44 +181,27 &#64;&#64;<br /> 		goto out;<br /> 	}<br /> <br />-	printk("&lt;%p/%p&gt;\n", idt2, (void *)address);<br /> 	/*<br /> 	 * Pentium F0 0F C7 C8 bug workaround:<br /> 	 */<br />-	if ( pentium_f00f_bug &amp;&amp; (address &gt;= (unsigned long)idt2) &amp;&amp;<br />-			(address &lt; (unsigned long)idt2+256*8) ) {<br />-<br />-		void (*handler) (void);<br />-		int nr = (address-(unsigned long)idt2)/8;<br />-		unsigned long low, high;<br />-<br />-		low = idt[nr].a;<br />-		high = idt[nr].b;<br />-<br />-		handler = (void (*) (void)) ((low&amp;0x0000ffff) | (high&amp;0xffff0000));<br />-		printk("&lt;handler %p... ", handler);<br />-		unlock_kernel();<br />-<br />-		if (handler==divide_error)<br />-			do_divide_error(regs,error_code);<br />-		else if (handler==debug)<br />-			do_debug(regs,error_code);<br />-		else if (handler==nmi)<br />-			do_nmi(regs,error_code);<br />-		else if (handler==int3)<br />-			do_int3(regs,error_code);<br />-		else if (handler==overflow)<br />-			do_overflow(regs,error_code);<br />-		else if (handler==bounds)<br />-			do_bounds(regs,error_code);<br />-		else if (handler==invalid_op)<br />-			do_invalid_op(regs,error_code);<br />-		else {<br />-			printk("INVALID HANDLER!\n");<br />-			for (;;) __cli();<br />+	if ( pentium_f00f_bug ) {<br />+		unsigned long nr;<br />+		<br />+		nr = (address - (unsigned long) idt2) &gt;&gt; 3;<br />+<br />+		if (nr &lt; 7) {<br />+			static void (*handler[])(struct pt_regs *, unsigned long) = {<br />+				do_divide_error,	/* 0 - divide overflow */<br />+				do_debug,		/* 1 - debug trap */<br />+				do_nmi,			/* 2 - NMI */<br />+				do_int3,		/* 3 - int 3 */<br />+				do_overflow,		/* 4 - overflow */<br />+				do_bounds,		/* 5 - bound range */<br />+				do_invalid_op };	/* 6 - invalid opcode */<br />+			unlock_kernel();<br />+			handler[nr](regs, error_code);<br />+			return;<br /> 		}<br />-		printk("... done&gt;\n");<br />-		goto out;<br /> 	}<br /> <br /> 	/* Are we prepared to handle this kernel fault?  */<br />diff -u --recursive --new-file v2.1.63/linux/drivers/char/atixlmouse.c linux/drivers/char/atixlmouse.c<br />--- v2.1.63/linux/drivers/char/atixlmouse.c	Tue Sep 23 16:48:47 1997<br />+++ linux/drivers/char/atixlmouse.c	Wed Nov 12 20:28:26 1997<br />&#64;&#64; -136,16 +136,16 &#64;&#64;<br /> }<br /> <br /> <br />-static long write_mouse(struct inode * inode, struct file * file,<br />-	const char * buffer, unsigned long count)<br />+static ssize_t write_mouse(struct file * file, const char * buffer,<br />+       size_t count, loff_t *ppos)<br /> {<br /> 	return -EINVAL;<br /> }<br /> <br />-static long read_mouse(struct inode * inode, struct file * file,<br />-	char * buffer, unsigned long count)<br />+static ssize_t read_mouse(struct file * file, char * buffer,<br />+       size_t count, loff_t *ppos)<br /> {<br />-	int i;<br />+       ssize_t i;<br /> <br /> 	if (count &lt; 3)<br /> 		return -EINVAL;<br />diff -u --recursive --new-file v2.1.63/linux/drivers/scsi/psi_chip.h linux/drivers/scsi/psi_chip.h<br />--- v2.1.63/linux/drivers/scsi/psi_chip.h	Wed Nov 12 13:34:26 1997<br />+++ linux/drivers/scsi/psi_chip.h	Wed Nov 12 13:36:53 1997<br />&#64;&#64; -192,3 +192,4 &#64;&#64;<br /> 	}	SETUP, *PSETUP;<br /> <br /> #endif<br />+<br />diff -u --recursive --new-file v2.1.63/linux/drivers/sound/Config.in linux/drivers/sound/Config.in<br />--- v2.1.63/linux/drivers/sound/Config.in	Wed Nov 12 13:34:26 1997<br />+++ linux/drivers/sound/Config.in	Wed Nov 12 13:43:41 1997<br />&#64;&#64; -1,15 +1,311 &#64;&#64;<br />-#<br />-# Sound driver configuration<br />-#<br />-#--------<br />-# There is another confic script which is compatible with rest of<br />-# the kernel. It can be activated by running 'make mkscript' in this<br />-# directory. Please note that this is an _experimental_ feature which<br />-# doesn't work with all cards (PSS, SM Wave, AudioTriX Pro, Maui).<br />-#--------<br />-#<br />-$MAKE -C drivers/sound config || exit 1<br />+bool 'ProAudioSpectrum 16 support' CONFIG_PAS<br />+bool '100%% Sound Blaster compatibles (SB16/32/64, ESS, Jazz16) support' CONFIG_SB<br />+bool 'Generic OPL2/OPL3 FM synthesizer support' CONFIG_ADLIB<br />+bool 'Gravis Ultrasound support' CONFIG_GUS<br />+bool 'MPU-401 support (NOT for SB16)' CONFIG_MPU401<br />+bool 'PSS (ECHO-ADI2111) support' CONFIG_PSS<br />+bool '16 bit sampling option of GUS (_NOT_ GUS MAX)' CONFIG_GUS16<br />+bool 'GUS MAX support' CONFIG_GUSMAX<br />+bool 'Microsoft Sound System support' CONFIG_MSS<br />+bool 'Ensoniq SoundScape support' CONFIG_SSCAPE<br />+bool 'MediaTrix AudioTrix Pro support' CONFIG_TRIX<br />+bool 'Support for OPTi MAD16 and/or Mozart based cards' CONFIG_MAD16<br />+bool 'Support for Crystal CS4232 based (PnP) cards' CONFIG_CS4232<br />+bool 'Support for Turtle Beach Wave Front (Maui, Tropez) synthesizers' CONFIG_MAUI<br />+bool 'Yamaha OPL3-SA1 audio controller' CONFIG_OPL3SA1<br />+bool 'SoftOSS software wave table engine' CONFIG_SOFTOSS<br />+bool 'FM synthesizer (YM3812/OPL-3) support' CONFIG_YM3812<br />+<br />+if [ "$CONFIG_AEDSP16" = "y" ]; then<br />+hex 'I/O base for Audio Excel DSP 16 220 or 240' AEDSP16_BASE 220<br />+fi<br />+<br />+if [ "$CONFIG_SB" = "y" ]; then<br />+hex 'I/O base for SB Check from manual of the card' SBC_BASE 220<br />+fi<br />+<br />+if [ "$CONFIG_SB" = "y" ]; then<br />+int 'Sound Blaster IRQ Check from manual of the card' SBC_IRQ 7<br />+fi<br />+<br />+if [ "$CONFIG_SB" = "y" ]; then<br />+int 'Sound Blaster DMA 0, 1 or 3' SBC_DMA 1<br />+fi<br />+<br />+if [ "$CONFIG_SB" = "y" ]; then<br />+int 'Sound Blaster 16 bit DMA (SB16, Jazz16, SMW) 5, 6 or 7 (use 1 for 8 bit cards)' SB_DMA2 5<br />+fi<br />+<br />+if [ "$CONFIG_SB" = "y" ]; then<br />+hex 'MPU401 I/O base of SB16, Jazz16 and ES1688 Check from manual of the card' SB_MPU_BASE 330<br />+fi<br />+<br />+<br />+if [ "$CONFIG_SB" = "y" ]; then<br />+comment 'MPU401 IRQ is only required with Jazz16, SM Wave and ESS1688.'<br />+fi<br />+<br />+<br />+if [ "$CONFIG_SB" = "y" ]; then<br />+comment 'Enter -1 to the following question if you have something else such as SB16/32.'<br />+fi<br />+<br />+if [ "$CONFIG_SB" = "y" ]; then<br />+int 'SB MPU401 IRQ (Jazz16, SM Wave and ES1688) Check from manual of the card' SB_MPU_IRQ -1<br />+fi<br />+<br />+if [ "$CONFIG_PAS" = "y" ]; then<br />+int 'PAS16 IRQ 3, 4, 5, 7, 9, 10, 11, 12, 14 or 15' PAS_IRQ 10<br />+fi<br />+<br />+if [ "$CONFIG_PAS" = "y" ]; then<br />+int 'PAS16 DMA 0, 1, 3, 5, 6 or 7' PAS_DMA 3<br />+fi<br />+<br />+if [ "$CONFIG_GUS" = "y" ]; then<br />+hex 'I/O base for GUS 210, 220, 230, 240, 250 or 260' GUS_BASE 220<br />+fi<br />+<br />+if [ "$CONFIG_GUS" = "y" ]; then<br />+int 'GUS IRQ 3, 5, 7, 9, 11, 12 or 15' GUS_IRQ 15<br />+fi<br />+<br />+if [ "$CONFIG_GUS" = "y" ]; then<br />+int 'GUS DMA 1, 3, 5, 6 or 7' GUS_DMA 6<br />+fi<br />+<br />+if [ "$CONFIG_GUS" = "y" ]; then<br />+int 'Second DMA channel for GUS 1, 3, 5, 6 or 7' GUS_DMA2 -1<br />+fi<br />+<br />+if [ "$CONFIG_GUS16" = "y" ]; then<br />+hex 'I/O base for the 16 bit daughtercard of GUS 530, 604, E80 or F40' GUS16_BASE 530<br />+fi<br />+<br />+if [ "$CONFIG_GUS16" = "y" ]; then<br />+int 'GUS 16 bit daughtercard IRQ 3, 4, 5, 7, or 9' GUS16_IRQ 7<br />+fi<br />+<br />+if [ "$CONFIG_GUS16" = "y" ]; then<br />+int 'GUS DMA 0, 1 or 3' GUS16_DMA 3<br />+fi<br />+<br />+if [ "$CONFIG_MPU401" = "y" ]; then<br />+hex 'I/O base for MPU401 Check from manual of the card' MPU_BASE 330<br />+fi<br />+<br />+if [ "$CONFIG_MPU401" = "y" ]; then<br />+int 'MPU401 IRQ Check from manual of the card' MPU_IRQ 9<br />+fi<br />+<br />+<br />+if [ "$CONFIG_MAUI" = "y" ]; then<br />+comment 'ERROR! You have to use old sound configuration method with Maui.'<br />+fi<br />+<br />+if [ "$CONFIG_MAUI" = "y" ]; then<br />+hex 'I/O base for Maui 210, 230, 260, 290, 300, 320, 338 or 330' MAUI_BASE 330<br />+fi<br />+<br />+if [ "$CONFIG_MAUI" = "y" ]; then<br />+int 'Maui IRQ 5, 9, 12 or 15' MAUI_IRQ 9<br />+fi<br />+<br />+if [ "$CONFIG_UART6850" = "y" ]; then<br />+hex 'I/O base for UART 6850 MIDI port (Unknown)' U6850_BASE 0<br />+fi<br />+<br />+if [ "$CONFIG_UART6850" = "y" ]; then<br />+int 'UART6850 IRQ (Unknown)' U6850_IRQ -1<br />+fi<br />+<br />+<br />+if [ "$CONFIG_PSS" = "y" ]; then<br />+comment 'ERROR! You have to use old sound configuration method with PSS cards.'<br />+fi<br />+<br />+if [ "$CONFIG_PSS" = "y" ]; then<br />+hex 'PSS I/O base 220 or 240' PSS_BASE 220<br />+fi<br />+<br />+if [ "$CONFIG_PSS" = "y" ]; then<br />+hex 'PSS audio I/O base 530, 604, E80 or F40' PSS_MSS_BASE 530<br />+fi<br />+<br />+if [ "$CONFIG_PSS" = "y" ]; then<br />+int 'PSS audio IRQ 7, 9, 10 or 11' PSS_MSS_IRQ 11<br />+fi<br />+<br />+if [ "$CONFIG_PSS" = "y" ]; then<br />+int 'PSS audio DMA 0, 1 or 3' PSS_MSS_DMA 3<br />+fi<br />+<br />+if [ "$CONFIG_PSS" = "y" ]; then<br />+hex 'PSS MIDI I/O base ' PSS_MPU_BASE 330<br />+fi<br />+<br />+if [ "$CONFIG_PSS" = "y" ]; then<br />+int 'PSS MIDI IRQ 3, 4, 5, 7 or 9' PSS_MPU_IRQ 9<br />+fi<br />+<br />+if [ "$CONFIG_MSS" = "y" ]; then<br />+hex 'MSS/WSS I/O base 530, 604, E80 or F40' MSS_BASE 530<br />+fi<br /> <br />+if [ "$CONFIG_MSS" = "y" ]; then<br />+int 'MSS/WSS IRQ 7, 9, 10 or 11' MSS_IRQ 11<br />+fi<br />+<br />+if [ "$CONFIG_MSS" = "y" ]; then<br />+int 'MSS/WSS DMA 0, 1 or 3' MSS_DMA 3<br />+fi<br />+<br />+if [ "$CONFIG_MSS" = "y" ]; then<br />+int 'MSS/WSS second DMA (if possible) 0, 1 or 3' MSS_DMA2 -1<br />+fi<br />+<br />+if [ "$CONFIG_SSCAPE" = "y" ]; then<br />+hex 'SoundScape MIDI I/O base 320, 330, 340 or 350' SSCAPE_BASE 330<br />+fi<br />+<br />+if [ "$CONFIG_SSCAPE" = "y" ]; then<br />+int 'SoundScape MIDI IRQ ' SSCAPE_IRQ 9<br />+fi<br />+<br />+if [ "$CONFIG_SSCAPE" = "y" ]; then<br />+int 'SoundScape initialization DMA 0, 1 or 3' SSCAPE_DMA 3<br />+fi<br />+<br />+if [ "$CONFIG_SSCAPE" = "y" ]; then<br />+hex 'SoundScape audio I/O base 534, 608, E84 or F44' SSCAPE_MSS_BASE 534<br />+fi<br />+<br />+if [ "$CONFIG_SSCAPE" = "y" ]; then<br />+int 'SoundScape audio IRQ 7, 9, 10 or 11' SSCAPE_MSS_IRQ 11<br />+fi<br />+<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+comment 'ERROR! You have to use old sound configuration method with OPL3-SA1.'<br />+fi<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+hex 'OPL3-SA1 audio I/O base 530, 604, E80 or F40' TRIX_BASE 530<br />+fi<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+int 'OPL3-SA1 audio IRQ 7, 9, 10 or 11' TRIX_IRQ 11<br />+fi<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+int 'OPL3-SA1 audio DMA 0, 1 or 3' TRIX_DMA 0<br />+fi<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+int 'OPL3-SA1 second (duplex) DMA 0, 1 or 3' TRIX_DMA2 3<br />+fi<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+hex 'OPL3-SA1 MIDI I/O base 330, 370, 3B0 or 3F0' TRIX_MPU_BASE 330<br />+fi<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+int 'OPL3-SA1 MIDI IRQ 3, 4, 5, 7 or 9' TRIX_MPU_IRQ 9<br />+fi<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+hex 'OPL3-SA1 SB I/O base 220, 210, 230, 240, 250, 260 or 270' TRIX_SB_BASE 220<br />+fi<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+int 'OPL3-SA1 SB IRQ 3, 4, 5 or 7' TRIX_SB_IRQ 7<br />+fi<br />+<br />+if [ "$CONFIG_TRIX" = "y" ]; then<br />+int 'OPL3-SA1 SB DMA 1 or 3' TRIX_SB_DMA 1<br />+fi<br />+<br />+if [ "$CONFIG_OPL3SA1" = "y" ]; then<br />+hex 'OPL3-SA1 audio I/O base 530, 604, E80 or F40' OPL3SA1_BASE 530<br />+fi<br />+<br />+if [ "$CONFIG_OPL3SA1" = "y" ]; then<br />+int 'OPL3-SA1 audio IRQ 7, 9, 10 or 11' OPL3SA1_IRQ 11<br />+fi<br />+<br />+if [ "$CONFIG_OPL3SA1" = "y" ]; then<br />+int 'OPL3-SA1 audio DMA 0, 1 or 3' OPL3SA1_DMA 0<br />+fi<br />+<br />+if [ "$CONFIG_OPL3SA1" = "y" ]; then<br />+int 'OPL3-SA1 second (duplex) DMA 0, 1 or 3' OPL3SA1_DMA2 3<br />+fi<br />+<br />+if [ "$CONFIG_OPL3SA1" = "y" ]; then<br />+hex 'OPL3-SA1 MIDI I/O base 330, 370, 3B0 or 3F0' OPL3SA1_MPU_BASE 330<br />+fi<br />+<br />+if [ "$CONFIG_OPL3SA1" = "y" ]; then<br />+int 'OPL3-SA1 MIDI IRQ 3, 4, 5, 7 or 9' OPL3SA1_MPU_IRQ 9<br />+fi<br />+<br />+if [ "$CONFIG_CS4232" = "y" ]; then<br />+hex 'CS4232 audio I/O base 530, 604, E80 or F40' CS4232_BASE 530<br />+fi<br />+<br />+if [ "$CONFIG_CS4232" = "y" ]; then<br />+int 'CS4232 audio IRQ 5, 7, 9, 11, 12 or 15' CS4232_IRQ 11<br />+fi<br />+<br />+if [ "$CONFIG_CS4232" = "y" ]; then<br />+int 'CS4232 audio DMA 0, 1 or 3' CS4232_DMA 0<br />+fi<br />+<br />+if [ "$CONFIG_CS4232" = "y" ]; then<br />+int 'CS4232 second (duplex) DMA 0, 1 or 3' CS4232_DMA2 3<br />+fi<br />+<br />+if [ "$CONFIG_CS4232" = "y" ]; then<br />+hex 'CS4232 MIDI I/O base 330, 370, 3B0 or 3F0' CS4232_MPU_BASE 330<br />+fi<br />+<br />+if [ "$CONFIG_CS4232" = "y" ]; then<br />+int 'CS4232 MIDI IRQ 5, 7, 9, 11, 12 or 15' CS4232_MPU_IRQ 9<br />+fi<br />+<br />+if [ "$CONFIG_MAD16" = "y" ]; then<br />+hex 'MAD16 audio I/O base 530, 604, E80 or F40' MAD16_BASE 530<br />+fi<br />+<br />+if [ "$CONFIG_MAD16" = "y" ]; then<br />+int 'MAD16 audio IRQ 7, 9, 10 or 11' MAD16_IRQ 11<br />+fi<br />+<br />+if [ "$CONFIG_MAD16" = "y" ]; then<br />+int 'MAD16 audio DMA 0, 1 or 3' MAD16_DMA 3<br />+fi<br />+<br />+if [ "$CONFIG_MAD16" = "y" ]; then<br />+int 'MAD16 second (duplex) DMA 0, 1 or 3' MAD16_DMA2 0<br />+fi<br />+<br />+if [ "$CONFIG_MAD16" = "y" ]; then<br />+hex 'MAD16 MIDI I/O base 300, 310, 320 or 330 (0 disables)' MAD16_MPU_BASE 330<br />+fi<br />+<br />+if [ "$CONFIG_MAD16" = "y" ]; then<br />+int 'MAD16 MIDI IRQ 5, 7, 9 or 10' MAD16_MPU_IRQ 9<br />+fi<br />+<br />+if [ "$CONFIG_SOFTOSS" = "y" ]; then<br />+int 'Sampling rate for SoftOSS 8000 to 48000' SOFTOSS_RATE 22050<br />+fi<br />+<br />+if [ "$CONFIG_SOFTOSS" = "y" ]; then<br />+int 'Max # of concurrent voices for SoftOSS 4 to 32' SOFTOSS_VOICES 32<br />+fi<br />+#<br />+$MAKE -C drivers/sound kernelconfig || exit 1<br /> bool 'Additional low level drivers' CONFIG_LOWLEVEL_SOUND<br /> <br /> if [ "$CONFIG_LOWLEVEL_SOUND" = "y" ]; then<br />diff -u --recursive --new-file v2.1.63/linux/fs/ext2/fsync.c linux/fs/ext2/fsync.c<br />--- v2.1.63/linux/fs/ext2/fsync.c	Tue Sep 23 16:48:48 1997<br />+++ linux/fs/ext2/fsync.c	Wed Nov 12 13:03:27 1997<br />&#64;&#64; -57,72 +57,6 &#64;&#64;<br /> 	return 0;<br /> }<br /> <br />-#ifndef __LITTLE_ENDIAN<br />-static int sync_block_swab32 (struct inode * inode, u32 * block, int wait)<br />-{<br />-	struct buffer_head * bh;<br />-	<br />-	if (!le32_to_cpu(*block))<br />-		return 0;<br />-	bh = get_hash_table (inode-&gt;i_dev, le32_to_cpu(*block), blocksize);<br />-	if (!bh)<br />-		return 0;<br />-	if (wait &amp;&amp; buffer_req(bh) &amp;&amp; !buffer_uptodate(bh)) {<br />-		brelse (bh);<br />-		return -1;<br />-	}<br />-	if (wait || !buffer_uptodate(bh) || !buffer_dirty(bh)) {<br />-		brelse (bh);<br />-		return 0;<br />-	}<br />-	ll_rw_block (WRITE, 1, &amp;bh);<br />-	bh-&gt;b_count--;<br />-	return 0;<br />-}<br />-#else<br />-#define sync_block_swab32 sync_block<br />-#endif<br />-<br />-<br />-static int sync_iblock (struct inode * inode, u32 * iblock, <br />-			struct buffer_head ** bh, int wait) <br />-{<br />-	int rc, tmp;<br />-	<br />-	*bh = NULL;<br />-	tmp = *iblock;<br />-	if (!tmp)<br />-		return 0;<br />-	rc = sync_block (inode, iblock, wait);<br />-	if (rc)<br />-		return rc;<br />-	*bh = bread (inode-&gt;i_dev, tmp, blocksize);<br />-	if (!*bh)<br />-		return -1;<br />-	return 0;<br />-}<br />-<br />-#ifndef __LITTLE_ENDIAN<br />-static int sync_iblock_swab32 (struct inode * inode, u32 * iblock, <br />-			       struct buffer_head ** bh, int wait) <br />-{<br />-	int rc, tmp;<br />-	<br />-	*bh = NULL;<br />-	tmp = le32_to_cpu(*iblock);<br />-	if (!tmp)<br />-		return 0;<br />-	rc = sync_block_swab32 (inode, iblock, wait);<br />-	if (rc)<br />-		return rc;<br />-	*bh = bread (inode-&gt;i_dev, tmp, blocksize);<br />-	if (!*bh)<br />-		return -1;<br />-	return 0;<br />-}<br />-#else<br />-#define sync_iblock_swab32 sync_iblock<br />-#endif<br /> <br /> static int sync_direct (struct inode * inode, int wait)<br /> {<br />&#64;&#64; -137,122 +71,15 &#64;&#64;<br /> 	return err;<br /> }<br /> <br />-static int sync_indirect (struct inode * inode, u32 * iblock, int wait)<br />-{<br />-	int i;<br />-	struct buffer_head * ind_bh;<br />-	int rc, err = 0;<br />-<br />-	rc = sync_iblock (inode, iblock, &amp;ind_bh, wait);<br />-	if (rc || !ind_bh)<br />-		return rc;<br />-	<br />-	for (i = 0; i &lt; addr_per_block; i++) {<br />-		rc = sync_block_swab32 (inode, <br />-					((u32 *) ind_bh-&gt;b_data) + i,<br />-					wait);<br />-		if (rc)<br />-			err = rc;<br />-	}<br />-	brelse (ind_bh);<br />-	return err;<br />-}<br />-<br />-#ifndef __LITTLE_ENDIAN<br />-static __inline__ int sync_indirect_swab32 (struct inode * inode, u32 * iblock, int wait)<br />-{<br />-	int i;<br />-	struct buffer_head * ind_bh;<br />-	int rc, err = 0;<br />-<br />-	rc = sync_iblock_swab32 (inode, iblock, &amp;ind_bh, wait);<br />-	if (rc || !ind_bh)<br />-		return rc;<br />-	<br />-	for (i = 0; i &lt; addr_per_block; i++) {<br />-		rc = sync_block_swab32 (inode, <br />-					((u32 *) ind_bh-&gt;b_data) + i,<br />-					wait);<br />-		if (rc)<br />-			err = rc;<br />-	}<br />-	brelse (ind_bh);<br />-	return err;<br />-}<br />-#else<br />-#define sync_indirect_swab32 sync_indirect<br />-#endif<br />-<br />-static int sync_dindirect (struct inode * inode, u32 * diblock, int wait)<br />-{<br />-	int i;<br />-	struct buffer_head * dind_bh;<br />-	int rc, err = 0;<br />-<br />-	rc = sync_iblock (inode, diblock, &amp;dind_bh, wait);<br />-	if (rc || !dind_bh)<br />-		return rc;<br />-	<br />-	for (i = 0; i &lt; addr_per_block; i++) {<br />-		rc = sync_indirect_swab32 (inode,<br />-					   ((u32 *) dind_bh-&gt;b_data) + i,<br />-					   wait);<br />-		if (rc)<br />-			err = rc;<br />-	}<br />-	brelse (dind_bh);<br />-	return err;<br />-}<br />-<br />-#ifndef __LITTLE_ENDIAN<br />-static __inline__ int sync_dindirect_swab32 (struct inode * inode, u32 * diblock, int wait)<br />-{<br />-	int i;<br />-	struct buffer_head * dind_bh;<br />-	int rc, err = 0;<br />-<br />-	rc = sync_iblock_swab32 (inode, diblock, &amp;dind_bh, wait);<br />-	if (rc || !dind_bh)<br />-		return rc;<br />-	<br />-	for (i = 0; i &lt; addr_per_block; i++) {<br />-		rc = sync_indirect_swab32 (inode,<br />-					   ((u32 *) dind_bh-&gt;b_data) + i,<br />-					   wait);<br />-		if (rc)<br />-			err = rc;<br />-	}<br />-	brelse (dind_bh);<br />-	return err;<br />-}<br />-#else<br />-#define sync_dindirect_swab32 sync_dindirect<br />-#endif<br />-<br />-static int sync_tindirect (struct inode * inode, u32 * tiblock, int wait)<br />-{<br />-	int i;<br />-	struct buffer_head * tind_bh;<br />-	int rc, err = 0;<br />-<br />-	rc = sync_iblock (inode, tiblock, &amp;tind_bh, wait);<br />-	if (rc || !tind_bh)<br />-		return rc;<br />-	<br />-	for (i = 0; i &lt; addr_per_block; i++) {<br />-		rc = sync_dindirect_swab32 (inode,<br />-					    ((u32 *) tind_bh-&gt;b_data) + i,<br />-					    wait);<br />-		if (rc)<br />-			err = rc;<br />-	}<br />-	brelse (tind_bh);<br />-	return err;<br />-}<br />-<br /> /*<br />  *	File may be NULL when we are called. Perhaps we shouldn't<br />  *	even pass file to fsync ?<br />+ *<br />+ *	This currently falls back to synching the whole device when<br />+ *	the file is larger than can fit directly in the inode. This<br />+ *	is because dirty-buffer handling is indexed by the device<br />+ *	of the buffer, which makes it much faster to sync the whole<br />+ *	device than to sync just one large file.<br />  */<br /> <br /> int ext2_sync_file(struct file * file, struct dentry *dentry)<br />&#64;&#64; -269,18 +96,14 &#64;&#64;<br /> 		 */<br /> 		goto skip;<br /> <br />+	if (inode-&gt;i_size &gt; EXT2_NDIR_BLOCKS*blocksize) {<br />+		err = fsync_dev(inode-&gt;i_dev);<br />+		goto skip;<br />+	}<br />+<br /> 	for (wait=0; wait&lt;=1; wait++)<br /> 	{<br /> 		err |= sync_direct (inode, wait);<br />-		err |= sync_indirect (inode,<br />-				      inode-&gt;u.ext2_i.i_data+EXT2_IND_BLOCK,<br />-				      wait);<br />-		err |= sync_dindirect (inode,<br />-				       inode-&gt;u.ext2_i.i_data+EXT2_DIND_BLOCK, <br />-				       wait);<br />-		err |= sync_tindirect (inode, <br />-				       inode-&gt;u.ext2_i.i_data+EXT2_TIND_BLOCK, <br />-				       wait);<br /> 	}<br /> skip:<br /> 	err |= ext2_sync_inode (inode);<br />diff -u --recursive --new-file v2.1.63/linux/include/asm-i386/bugs.h linux/include/asm-i386/bugs.h<br />--- v2.1.63/linux/include/asm-i386/bugs.h	Wed Nov 12 13:34:27 1997<br />+++ linux/include/asm-i386/bugs.h	Wed Nov 12 17:24:07 1997<br />&#64;&#64; -142,7 +142,7 &#64;&#64;<br /> 	  : "edx" (inp)<br /> 	  : "eax", "ecx", "edx", "edi" );<br /> 	/* If this fails, it means that any user program may lock CPU hard. Too bad. */<br />-	if (res != 12345678) printk( "Bad.\n" );<br />+	if (res != 12345678) printk( "Buggy.\n" );<br /> 		        else printk( "Ok.\n" );<br /> #endif<br /> }<br />&#64;&#64; -172,23 +172,19 &#64;&#64;<br />  */<br /> <br /> extern int pentium_f00f_bug;<br />+extern void trap_init_f00f_bug(void);<br />+<br /> <br /> __initfunc(static void check_pentium_f00f(void))<br /> {<br /> 	/*<br /> 	 * Pentium and Pentium MMX<br /> 	 */<br />-	printk("checking for F00F bug ...");<br />-	if(x86==5 &amp;&amp; !memcmp(x86_vendor_id, "GenuineIntel", 12))<br />-	{<br />-		extern void trap_init_f00f_bug(void);<br />-<br />-		printk(KERN_INFO "\nIntel Pentium/[MMX] F0 0F bug detected - turning on workaround.\n");<br />+	pentium_f00f_bug = 0;<br />+	if (x86==5 &amp;&amp; !memcmp(x86_vendor_id, "GenuineIntel", 12)) {<br />+		printk(KERN_INFO "Intel Pentium with F0 0F bug - workaround enabled.\n");<br /> 		pentium_f00f_bug = 1;<br /> 		trap_init_f00f_bug();<br />-	} else {<br />-		printk(KERN_INFO " no F0 0F bug in this CPU, great!\n");<br />-		pentium_f00f_bug = 0;<br /> 	}<br /> }<br /> <br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
