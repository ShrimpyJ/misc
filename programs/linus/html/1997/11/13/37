    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1997/11/12/67">First message in thread</a></li><li><a href="/lkml/1997/11/12/118">Linus Torvalds</a><ul><li><a href="/lkml/1997/11/12/119">Adam Wiggins</a></li><li><a href="/lkml/1997/11/13/16">Todd Derr</a><ul><li><a href="/lkml/1997/11/13/30">Ingo Molnar</a></li><li class="origin"><a href="/lkml/1997/11/13/91">Linus Torvalds</a><ul><li><a href="/lkml/1997/11/13/91">"David S. Miller"</a><ul><li><a href="/lkml/1997/11/13/71">Linus Torvalds</a></li></ul></li><li><a href="/lkml/1997/11/13/93">Gabriel Paubert</a></li></ul></li><li><a href="/lkml/1997/11/13/90">Gabriel Paubert</a><ul><li><a href="/lkml/1997/11/13/39">Ingo Molnar</a><ul><li><a href="/lkml/1997/11/13/75">Craig Milo Rogers</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/1997/11/13/18">David Whysong</a><ul><li><a href="/lkml/1997/11/13/32">Ingo Molnar</a><ul><li><a href="/lkml/1997/11/14/17">David Whysong</a></li></ul></li><li><a href="/lkml/1997/11/13/74">Alex Priem</a></li></ul></li><li><a href="/lkml/1997/11/13/111">Anthony DeStefano</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 13 Nov 1997 07:19:41 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: 2.1.63 - testing Pentium bug workaround..</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 13 Nov 1997, Todd Derr wrote:<br />&gt;<br />&gt; Even with the fix, the PTE for the first page of the IDT has to be in<br />&gt; the TLB, otherwise we're right back in the same boat, right? (i.e. the<br />&gt; CPU would have to read the PTE from memory...)<br /><br />No. In fact, it cannot be in the TLB, because the page is not present, and<br />the intel TLB doesn't cache non-present pages. <br /><br />The reason the fix works is that the page fault logic on the CPU correctly<br />reset the CPU state, including the internal "lock" bit. This isn't too<br />surprising, because there are _real_ instructions with a lock prefix that<br />can fault with a page fault, so the CPU already has to have the logic to<br />not lock for those. <br /><br />The thing that made the particular illegal instructions so nasty seems to<br />be that the instruction is _almost_ correct, so the illegal instruction<br />fault is noticed much later than usual, and obviously after the lock logic<br />has already gotten primed. <br /><br />Essentially, there are a few kinds of illegal instructions:<br /><br /> - real illegal instructions<br /> - legal instructions that are turned illegal at lower privilege levels or<br />   non-protected mode. For example, some instructions are illegal in real<br />   mode ("lar" and some other protected-mode-segmentation specific stuff). <br /> - legal instructions that have a LOCK prefix, but that cannot be locked.<br /> - instructions that are too long (redundant prefix bytes)<br /> - legal instructions with illegal addressing modes<br /><br />In this case, it was the last one: a legal locked instruction with an<br />illegal addressing mode. I suspect that what happens is that normally the<br />#UD fault is raised by the instruction decode logic, but that the specific<br />instruction (cmpxchg8b) is kind of special. It doesn't have a "normal"<br />memory access pattern for an integer instruction, so it is probably<br />special-cased in the decoding, and passes the checks into microcode. <br /><br />The microcode notices the illegal addressing mode, and raises the fault,<br />but by that time the instruction has already been "accepted" by the decode<br />unit, and the LOCK prefix has already taken effect.<br /><br />And as this cannot happen on previous intel CPU's (that didn't have the<br />instruction), the #UD logic probably doesn't bother with clearing the LOCK<br />state, and nobody noticed the bug... <br /><br />In contrast, when a page fault (or a segment limit overrun, or..) happens,<br />it's quite normal for a locked instruction to have made it past all the<br />other checks, so the page fault logic has always had to deal with the case<br />of a lock prefix fault, and it correctly clears it before actually<br />faulting. <br /><br />The above is pure speculation, and may have nothing at all to do with<br />reality. It explains the fix (and the reason for the bug), but I don't<br />know a transistor from a diode, so take anything I say with a ton of salt. <br />But maybe people should start looking for other complex instructions that<br />are lockable.. (the only other complex instruction I can think of is the<br />bitmap instructions - bt, bts, btc, btr - but they don't actually have an<br />illegal addressing mode). <br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
