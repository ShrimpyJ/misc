    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1997/11/15/21">First message in thread</a></li><li><a href="/lkml/1997/11/15/21">Steffen Zahn</a><ul><li><a href="/lkml/1997/11/15/48">Hans Lermen</a><ul><li class="origin"><a href="/lkml/1997/11/15/80">Linus Torvalds</a><ul><li><a href="/lkml/1997/11/15/80">(Alan Cox)</a></li></ul></li></ul></li><li><a href="/lkml/1997/11/15/91">"Richard B. Johnson"</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/1997/11/15/64/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 15 Nov 1997 11:38:18 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: 2.1.64: debugging is broken</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sat, 15 Nov 1997, Hans Lermen wrote:<br />&gt; <br />&gt; Yup, sideeffect of the f00f workaround. As Linus stated, this workaround<br />&gt; needs 'fine tuning' now:-)<br />&gt; <br />&gt; For the record: With the f00f workaround, after INT3, eip now points<br />&gt; _to_ the instruction instead of _behind_ it as it should.<br />&gt; Please try the below patch, which should fix the INT3. Though its a patch<br />&gt; for pre-2.0.32-4, it should fit into 2.1.64 as well.<br /><br />Note that this is a very partial fix - "int 3" can be generated not only<br />with the single-byte "int3" instruction, it can be generated with a<br />two-byte "int $3" instruction too, and there can be a large number of<br />prefix bytes so that essentially we can't know whether the instruction is<br />1 or 15 bytes long. <br /><br />Admittedly, debugging tends to always use the single-byte instruction, and<br />it may be that this simple fix is thus acceptable. <br /><br />However, there are other cases too, and many of these are actually handled<br />in a patch made by Intel. I'm appending the Intel-made patch to plain<br />2.0.31, which is actually reversed (so you have to use "patch -R -p0" to<br />apply it. It would be good if somebody would look into trying to integrate<br />as much as possible of the Intel patch. <br /><br />Note that the intel patch too is not very good: it doesn't really take<br />"special" segments into account, which can happen with Wine. That's why<br />I'd suggest doing it all in C code rather than assembly as the Intel patch<br />does it - by the time we notice that it's supposed to be a debug trap<br />we're no longer very timing-critical so there isn't much point in trying<br />to optimize that path. <br /><br />Note that intel got a lot of bad publicity here, but they actually did<br />mostly do the right thing. They had this stupid NDA thing for a few days,<br />but that's probably some generic Intel policy. So don't beat up on them<br />too much. They had a bug, but they also had engineers working hard on<br />making a Linux patch available. It's different from the one we came up<br />with ourselves, but its more sophisticated in some ways (and more broken<br />in other ways - you can confuse the Intel patch badly by loading code<br />segments into the LDT and executing debug instructions from strange places<br />in non-zero-base segments). <br /><br />I really hope that there are x86 wizards out there that would be<br />interested in cleaning up the current 2.0.32-4 patch and the 2.1.64 stuff<br />to be more complete. I tried to make 2.1.64 a bit easier to work with wrt<br />this patch. <br /><br />Note that the way to avoid taking any hit at all for page faults on<br />non-Pentium processors is to have a _different_ page fault handler in the<br />original IDT (one that doesn't care about this bug), and then have a<br />"pentium_bug_page_fault_handler" for the case when we have copied the IDT<br />to vmalloc'ed memory. <br /><br />		Linus<br /><br />----- Intel reversed patch to 2.0.x -----<br />diff -r -u f00f_fix/arch/i386/kernel/entry.S linux/arch/i386/kernel/entry.S<br />--- f00f_fix/arch/i386/kernel/entry.S	Fri Nov 14 08:10:00 1997<br />+++ linux/arch/i386/kernel/entry.S	Fri Nov 14 09:14:22 1997<br />&#64;&#64; -389,7 +389,6 &#64;&#64;<br /> 	decl %eax			# eax = -1<br /> 	pushl %ecx<br /> 	pushl %ebx<br />-error_code1:<br /> 	cld<br /> 	xorl %ebx,%ebx			# zero ebx<br /> 	xchgl %eax, ORIG_EAX(%esp)	# orig_eax (get the error code. )<br />&#64;&#64; -502,169 +501,7 &#64;&#64;<br /> <br /> ENTRY(page_fault)<br /> 	pushl $ SYMBOL_NAME(do_page_fault)<br />-	push %fs<br />-	push %es<br />-	push %ds<br />-	pushl %eax<br />-	pushl %ebp<br />-	pushl %edi<br />-	pushl %esi<br />-	pushl %edx<br />-	pushl %ecx<br />-	pushl %ebx<br />-	movl  $(KERNEL_DS),%edx<br />-	mov   %dx,%ds<br />-	movl  %cr2,%eax<br />-	movl  %eax,%ecx<br />-	movl  SYMBOL_NAME(idt),%ebx<br />-	orl   $0xc0000000,%ebx<br />-	andl  $0xfffff000,%ebx<br />-	andl  $0xfffff000,%eax<br />-	cmpl  %eax,%ebx<br />-	jz    trap_perrata<br />-go_error:<br />-	xorl %eax,%eax<br />-	decl %eax			# eax = -1<br />-	jmp   error_code1<br />-<br />-	# This is the pentium locked cmpxchg bug<br />-trap_perrata:<br />-	#<br />-	# check for user access to IDT<br />-	#<br />-	movb	44(%esp),%al<br />-	andb	$4,%al<br />-	jnz	go_error	# user access, do page fault<br />-<br />-	movl	SYMBOL_NAME(idt),%eax<br />-	orl	$0xc0000000,%eax<br />-	subl	%eax,%ecx<br />-	shrl	$3,%ecx		# ivt vector number<br />-	shll	$2,%ecx		# offset into vector table<br />-	movl	%ecx,%ebx	# save it for later<br />-	movl	ivt_handlers(%ebx),%eax<br />-	movl	%eax,40(%esp)<br />-	#<br />-	# skip all prefix bytes preceeding the faulting instruction<br />-	#<br />-	movl	$(USER_DS),%edx<br />-	mov	%dx,%fs<br />-	movl	48(%esp),%eax<br />-	call	skip_prefix<br />-	#<br />-	# check for s/w int opcode, if called from user and interrupt<br />-	# is not 3, 4 or 5 then dispatch the fault to the GP fault handler<br />-	#<br />-	cmpb	$0xcd,%fs:(%eax)<br />-	je	2f		# int instr. with immediate data<br />-	cmpb	$0xce,%fs:(%eax)<br />-	jne	4f		# not INT n or INTO<br />-2:<br />-	#<br />-	# check for user/V86 mode access<br />-	#<br />-	testl	$0x20000,56(%esp)	# check VM flag<br />-	jz	prot_mode<br />-	cmpb	$0xcc,%fs:(%eax)	# is it and INT3 instr?<br />-	je	5f<br />-	movl	56(%esp),%ecx<br />-	andl	$0x3000,%ecx	# check IOPL<br />-	cmpl	$0x3000,%ecx<br />-	je	7f<br />-	jmp	gp_fault<br />-<br />-prot_mode:<br />-	cmpw	$(KERNEL_CS),52(%esp)	# check if fault happend in kernel mode<br />-	je	3f<br />-	cmpb	$3*4,%bl	# check if it was INT3<br />-	je	7f<br />-	cmpb	$4*4,%bl	# check if it was INTO<br />-	je	7f<br />-	cmpb	$5*4,%bl	# check if it was BOUNDS<br />-	je	7f<br />-gp_fault:<br />-	movl	$0,44(%esp)<br />-	movl	$SYMBOL_NAME(do_general_protection),40(%esp)<br />-	jmp	go_error<br />-<br />-	#<br />-	# Increment EIP as appropriate<br />-	#<br />-3:<br />-	cmpb	$0xce,%fs:(%eax)	# check if it was INTO<br />-	je	5f<br />-7:<br />-	incl	%eax<br />-5:<br />-	incl	%eax<br />-	movl	%eax,48(%esp)	# update EIP<br />-	jmp	go_error<br />-<br />-	#<br />-	# Increment EIP and update EFLAGS as needed<br />-	#<br />-4:<br />-	cmpb	$3*4,%bl	# check if DEBUG fault<br />-	je	5f<br />-	cmpb	$4*4,%bl	# check if INTO fault<br />-	je	5f<br />-	cmpb	$1*4,%bl	# check if TRACE trap<br />-	je	6f<br />-	cmpb	$2*4,%bl	# check if NMI<br />-	jne	go_error<br />-	cmpb	$0xf4,%fs:(%eax)	# check for HALT<br />-	jne	go_error<br />-5:<br />-	incl	%eax<br />-	movl	%eax,48(%esp)	# update EIP<br />-6:<br />-	andl	$~0x10000,56(%esp)	# clear RF flag<br />-	jmp	go_error<br />-<br />-#<br />-# Examine the code space and increment the EIP<br />-# past any prefix bytes that might be present<br />-# <br />-skip_prefix:<br />-	xorl	%ecx, %ecx<br />-	movb	%fs:(%eax), %cl<br />-	cmpb	$0xF2, %cl<br />-	jne	1f<br />-	incl	%eax<br />-	jmp	skip_prefix<br />-1:	<br />-	cmpb	$0xF3, %cl<br />-	jne	2f<br />-	incl	%eax<br />-	jmp	skip_prefix<br />-2:	<br />-	cmpb	$0x2E, %cl<br />-	jne	3f<br />-	incl	%eax<br />-	jmp	skip_prefix<br />-3:	<br />-	cmpb	$0x36, %cl<br />-	jne	4f<br />-	incl	%eax<br />-	jmp	skip_prefix<br />-4:	<br />-	cmpb	$0x3E, %cl<br />-	jne	5f<br />-	incl	%eax<br />-	jmp	skip_prefix<br />-5:	<br />-	cmpb	$0x26, %cl<br />-	jne	6f<br />-	incl	%eax<br />-	jmp	skip_prefix<br />-6:	<br />-	andb	$0xFC, %cl			/* prefix 64, 65, 66, 67 */<br />-	cmpb	$0x64, %cl<br />-	jne	7f<br />-	incl	%eax<br />-	jmp	skip_prefix<br />-7:	<br />-	ret					/* no more prefix bytes */<br />+	jmp error_code<br /> <br /> ENTRY(spurious_interrupt_bug)<br /> 	pushl $0<br />&#64;&#64; -840,12 +677,3 &#64;&#64;<br /> 	.long 0,0<br /> 	.long SYMBOL_NAME(sys_vm86)<br /> 	.space (NR_syscalls-166)*4<br />-<br />-	ivt_handlers:<br />-	.long	SYMBOL_NAME(do_divide_error)<br />-	.long	SYMBOL_NAME(do_debug)<br />-	.long	SYMBOL_NAME(do_nmi)<br />-	.long	SYMBOL_NAME(do_int3)<br />-	.long	SYMBOL_NAME(do_overflow)<br />-	.long	SYMBOL_NAME(do_bounds)<br />-	.long	SYMBOL_NAME(do_invalid_op)<br />diff -r -u f00f_fix/arch/i386/kernel/head.S linux/arch/i386/kernel/head.S<br />--- f00f_fix/arch/i386/kernel/head.S	Fri Nov 14 08:10:01 1997<br />+++ linux/arch/i386/kernel/head.S	Fri Nov 14 09:14:08 1997<br />&#64;&#64; -260,7 +260,7 &#64;&#64;<br /> 	movw %dx,%ax		/* selector = 0x0010 = cs */<br /> 	movw $0x8E00,%dx	/* interrupt gate - dpl=0, present */<br /> <br />-	lea SYMBOL_NAME(idt_table),%edi<br />+	lea SYMBOL_NAME(idt),%edi<br /> 	mov $256,%ecx<br /> rp_sidt:<br /> 	movl %eax,(%edi)<br />&#64;&#64; -376,12 +376,9 &#64;&#64;<br /> .word 0<br /> idt_descr:<br /> 	.word 256*8-1		# idt contains 256 entries<br />-	.long 0xc0000000+SYMBOL_NAME(idt_table)<br />+	.long 0xc0000000+SYMBOL_NAME(idt)<br /> <br /> ENTRY(idt)<br />-	.long	SYMBOL_NAME(idt_table)<br />-	<br />-ENTRY(idt_table)<br /> 	.fill 256,8,0		# idt is uninitialized<br /> <br /> 	ALIGN<br />diff -r -u f00f_fix/arch/i386/mm/init.c linux/arch/i386/mm/init.c<br />--- f00f_fix/arch/i386/mm/init.c	Fri Nov 14 08:10:34 1997<br />+++ linux/arch/i386/mm/init.c	Fri Nov 14 09:14:41 1997<br />&#64;&#64; -281,7 +281,6 &#64;&#64;<br /> 		if (wp_works_ok &lt; 0)<br /> 			wp_works_ok = 0;<br /> 	}<br />-	fix_illop();<br /> 	return;<br /> }<br /> <br />&#64;&#64; -304,49 +303,5 &#64;&#64;<br /> 	}<br /> 	val-&gt;totalram &lt;&lt;= PAGE_SHIFT;<br /> 	val-&gt;sharedram &lt;&lt;= PAGE_SHIFT;<br />-	return;<br />-}<br />-<br />-#include &lt;linux/malloc.h&gt;<br />-<br />-	void<br />-fix_illop(void)<br />-{<br />-	extern desc_table *idt, idt_table[];<br />-	extern void bcopy(void *, void *, int);<br />-	short idt_descr[3];<br />-	int *ip;<br />-	pgd_t *pgd;<br />-	pmd_t *pmd;<br />-	pte_t *pte;<br />-<br />-	idt = (desc_table *)vmalloc(2 * 4096);<br />-	idt = (desc_table *)(PAGE_ALIGN((int)idt + 1) - (7*8));<br />-	printk("New IDT - %x\n", (int)idt);<br />-	bcopy(idt_table, idt, 256*8);<br />-	pgd = pgd_offset(current-&gt;mm, 0xc0000000 | (int)idt);<br />-	if (pgd_none(*pgd)) {<br />-		printk("set_idt0:no pgd\n");<br />-		return;<br />-	}<br />-	if (pgd_bad(*pgd)) {<br />-		printk("set_idt0:bad pgd %x\n", pgd_val(*pgd));<br />-		return;<br />-	}<br />-	pmd = pmd_offset(pgd, 0xc0000000 | (int)idt);<br />-	if (pmd_none(*pmd)) {<br />-		printk("set_idt0:no pmd\n");<br />-		return;<br />-	}<br />-	if (pmd_bad(*pmd)) {<br />-		printk("set_idt0:bad pmd %x\n", pmd_val(*pmd));<br />-		return;<br />-	}<br />-	pte = pte_offset(pmd, 0xc0000000 | (int)idt);<br />-	pte-&gt;pte &amp;= ~_PAGE_PRESENT;<br />-	ip = (int *)(&amp;idt_descr[1]);<br />-	*ip = 0xc0000000 | (int)idt;<br />-	idt_descr[0] = (256*8) - 1;<br />-	__asm__ __volatile__("\tlidt %0": "=m" (idt_descr));<br /> 	return;<br /> }<br />diff -r -u f00f_fix/include/linux/head.h linux/include/linux/head.h<br />--- f00f_fix/include/linux/head.h	Fri Nov 14 08:11:37 1997<br />+++ linux/include/linux/head.h	Fri Nov 14 09:15:01 1997<br />&#64;&#64; -3,10 +3,9 &#64;&#64;<br /> <br /> typedef struct desc_struct {<br /> 	unsigned long a,b;<br />-} desc_table;<br />+} desc_table[256];<br /> <br />-extern desc_table gdt[256];<br />-extern desc_table *idt;<br />+extern desc_table idt,gdt;<br /> <br /> #define GDT_NUL 0<br /> #define GDT_CODE 1<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
