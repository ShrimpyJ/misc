    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1997/12/22/33">First message in thread</a></li><li><a href="/lkml/1997/12/22/33">"Stephen R. van den Berg"</a><ul><li><a href="/lkml/1997/12/22/46">Bill Hawes</a><ul><li><a href="/lkml/1997/12/22/50">"Stephen R. van den Berg"</a><ul><li><a href="/lkml/1997/12/22/55">Bill Hawes</a></li></ul></li></ul></li><li class="origin"><a href="">(Linus Torvalds)</a></li><li><a href="/lkml/1997/12/22/57">"Stephen R. van den Berg"</a><ul><li><a href="/lkml/1997/12/22/59">Linus Torvalds</a><ul><li><a href="/lkml/1997/12/22/76">"Stephen R. van den Berg"</a><ul><li><a href="/lkml/1997/12/22/79">(Linus Torvalds)</a></li><li><a href="/lkml/1997/12/22/103">"Stephen R. van den Berg"</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">(Linus Torvalds)</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Race conditions galore (2.0.33 and possibly 2.1.x)</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">22 Dec 1997 17:02:54 GMT</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">In article &lt;19971222151656.32023&#64;cuci.nl&gt;,<br />Stephen R. van den Berg &lt;srb&#64;cuci.nl&gt; wrote:<br />&gt;Could someone who created these wait-queue loops (there are several of them<br />&gt;in the kernel, potentially all of them are race conditions waiting to<br />&gt;happen) confirm if I'm reading this correctly?  Maybe I still overlooked<br />&gt;possible problems, but it seems like this is the minimally-correct change.<br /><br />No, your patch should be unnecessary as far as I can see.<br /><br />Anyway, the basic race-free wait loop looks like this (there are<br />variations, but this is one of the basic versions that you find in<br />various places):<br /><br />	if (should_wait_condition) {<br />		add_wait_queue(..);<br />	repeat:<br />		current-&gt;state = TASK_UNINTERRUPTIBLE;<br />		if (should_wait_condition) {<br />			schedule();<br />			goto repeat;<br />		}<br />		remove_wait_queue(..);<br />		current-&gt;state = TASK_RUNNING;<br />	}<br /><br />There are only two important rules:<br /> - you have to add yourself to the wait queue _before_ testing for the<br />   condition.<br /> - you have to mark yourself asleep _before_ testing for the condition.<br /><br />The rest is essentially just "fluff".  For example, above we test for<br />the condition twice: first we have the common case where the condition<br />isn't true, and for that case we don't even bother with the wait-queues<br />at all because we know we won't be sleeping.  Then we add ourselves to<br />the wait-queue, but because of the two rules above we now have to<br />re-test the condition. <br /><br />The above may look complex, but it's really fairly straight-forward, and<br />the really important thing is that you don't have to do any locking at<br />all (well, the wait queue manipulation and the scheduling will do their<br />own locking, but basically nothing else needs to do so).<br /><br />Anyway, the reason the two simple rules are needed is that _if_ you mark<br />yourself asleep _and_ have added yourself to the wait queue before<br />testing for any wake-up condition, then you know that if something<br />happens to change that condition (and does a "wake_up()", then it will<br />also have marked you as being awake (and thus the "schedule()" will not<br />sleep, and we'll catch the condition the second time around). <br /><br />Now, admittedly the above does depend on a few ordering constraints, and<br />those ordering constraints are not necessarily true in all SMP systems. <br />Maybe this was what you alluded to? The rules in question are really<br />only valid on something that guarantees fairly strict memory ordering<br />(UP in particular as the obvious case), and a memory barrier might be a<br />good idea for a truly SMP-safe version.  The sleeping scheme was really<br />designed for UP, I have to admit. <br /><br />Could you explain what kind of race you were thinking of?<br /><br />			Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
