    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1997/12/22/33">First message in thread</a></li><li><a href="/lkml/1997/12/22/33">"Stephen R. van den Berg"</a><ul><li><a href="/lkml/1997/12/22/46">Bill Hawes</a><ul><li><a href="/lkml/1997/12/22/50">"Stephen R. van den Berg"</a><ul><li><a href="/lkml/1997/12/22/55">Bill Hawes</a></li></ul></li></ul></li><li><a href="/lkml/1997/12/22/52">(Linus Torvalds)</a></li><li><a href="/lkml/1997/12/22/57">"Stephen R. van den Berg"</a><ul><li class="origin"><a href="/lkml/1997/12/22/76">Linus Torvalds</a><ul><li><a href="/lkml/1997/12/22/76">"Stephen R. van den Berg"</a><ul><li><a href="/lkml/1997/12/22/79">(Linus Torvalds)</a></li><li><a href="/lkml/1997/12/22/103">"Stephen R. van den Berg"</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 22 Dec 1997 09:50:54 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Race conditions galore (2.0.33 and possibly 2.1.x)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 22 Dec 1997, Stephen R. van den Berg wrote:<br />&gt; <br />&gt; Well, it *does* fix some hung processes on a newsserver of mine.<br />&gt; First, several processes hung in buffer.c (very reproducable).<br />&gt; I patched it (using the described patch).<br />&gt; Now, a process hung in filemap.c (same construct).  So I patched that<br />&gt; as well.<br /><br />Ok, something is definitely going on here. But as you don't even have an<br />SMP setup, I don't see exactly what..<br /><br />&gt; This happened within 15 minutes uptime, almost every time.<br />&gt; The machine has been running for 17 hours now, no hangs anymore.<br />&gt; I'm running with ECC, and the kernel did and does *not* generate any warnings<br />&gt; or errors.  So hardware failures are very unlikely.<br /><br />Your patch looked ok - there was nothing wrong with it. It just shouldn't<br />really have any effect, because the old code should be equally stable.<br />Interesting. <br /><br />Was that the _only_ change you did?<br /><br />&gt; &gt;Anyway, the basic race-free wait loop looks like this (there are<br />&gt; <br />&gt; &gt;		add_wait_queue(..);<br />&gt; &gt;	repeat:<br />&gt; <br />&gt; In buffer.c it runs some queues at this point.  Can these affect the<br />&gt; state of the should_wait_condition?<br /><br />Yes, but the effect should in the end be the same..<br /><br />&gt; E.g. it unlocks the buffer, sets the current state to TASK_RUNNING<br />&gt; (redundant), then locks the buffer again.  What happens to the wait-queue?<br />&gt; Will it still wake up the process even though it has been unlocked, then<br />&gt; locked again?<br /><br />The wait queues will be unaffected - they are only affected by the<br />"add_qait_queue()"/"remove_wait_queue()" thing (ie the act of waking<br />somebody up does _not_ remove the sleeper from a wait queue). <br /><br />&gt; <br />&gt; &gt;		current-&gt;state = TASK_UNINTERRUPTIBLE;<br />&gt; &gt;		if (should_wait_condition) {<br />&gt; <br />&gt; What if the should_wait_condition changes here?<br />&gt; I.e. the buffer is unlocked.  Will the current-&gt;state be affected?<br />&gt; Or will wake_up process avoid touching the current-&gt;state because the<br />&gt; current process is "still running"?<br /><br />The wake_up() will indeed change current-&gt;state - even if the process is<br />really running (it doesn't care, and that's the whole reason why the<br />construct works).<br /><br />I wonder whether gcc might be changing the ordering here. That would<br />explain why your patch would make a difference..<br /><br />In fact, the more I think about it, the more your patch makes sense<br />considering what gcc might do to the sources. Do you by any chance use<br />egcs or a recent snapshot of gcc? <br /><br />&gt; &gt;There are only two important rules:<br />&gt; &gt; - you have to add yourself to the wait queue _before_ testing for the<br />&gt; &gt;   condition.<br />&gt; &gt; - you have to mark yourself asleep _before_ testing for the condition.<br />&gt; <br />&gt; Maybe we need to change the last rule?<br />&gt; <br />&gt;  - You have to mark yourself asleep _before_ adding yourself to the waitqueue.<br /><br />That would be a reasonably ok rule, but in general there are cases where<br />you want to add yourself to the wait-queue just once (outside a larger<br />loop), and mark yourself sleeping inside the loop.<br /><br />IF this is a compiler optimization thing, could you test the original code<br />but just add a "mb()" to after marking yourself as sleeping. Ie<br /><br />	current-&gt;state = TASK_UNINTERRUPTIBLE;<br />+	mb();<br />	if (condition..)<br /><br />The mb() should make sure that gcc cannot move things around, and on some<br />architectures it will also do some other coherency stuff for SMP. If that<br />also fixes it I'll have to think about this some more.. <br /><br />(Your patch essentially did a similar thing to the "mb()" - the wait queue<br />manipulation will also act as a barrier for gcc optimizations. So that<br />might explain the thing). <br /><br />&gt; No, actually.  Unless my system has a cache-coherency problem somewhere;<br />&gt; but it's not an SMP system by any stretch of the imagination.<br /><br />Any coherency issue that would make the code not work on UP has to be<br />serious enough that _nothing_ would work. So I would want a bit more<br />information about this first - if it isn't a compiler thing (not a<br />compiler bug - looking at the thing the compiler might quite reasonably do<br />some things to the code that would defeat the ordering) I want to<br />understand exactly _what_ it is..<br /><br />Anyway, thanks for testing, this looks like a potentially very interesting<br />problem that needs to be solved..<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
