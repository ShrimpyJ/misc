    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/1997/4/24/50">First message in thread</a></li><li><a href="/lkml/1997/4/24/50">(Victor Yodaiken)</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 24 Apr 1997 10:03:59 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: RT-Linux and SMP</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 24 Apr 1997, Victor Yodaiken wrote:<br />&gt; <br />&gt; We need some info  to get RT-Linux SMP working.<br />&gt; <br />&gt; 1. The scheme in .35  for SMP  allows multiple ISRs to run in <br />&gt;    different processors and synchronizes only on a cli. A cli<br />&gt;    only completes when the cli-ing processor has locked further<br />&gt;    ISR invocations and has waited until no other processors are in <br />&gt;    irq code. <br />&gt; <br />&gt;    Question : Why is it not enough to just make sure that no<br />&gt;               other processor is in cli-mode? We already allow<br />&gt;               more than one ISR to be active without CLI.<br /><br />We _have_ to wait for all outstanding interrupt handlers to complete,<br />because otherwise "cli()" would be totally useless. For example:<br /><br />	cli():<br />	.. do critical thing ..<br />	sti():<br /><br />if the cli() only makes sure that this CPU is the only one currently in<br />"cli mode", there could be an interrupt executing on another CPU that<br />started _before_ we did the cli(), and happens to be executing during our<br />critical region. If that interrupt then happens to use or modify the same<br />data that we are using in the critical region, we're dead.<br /><br />In short, unless "cli()" waits for all outstanding (*) interrupts to<br />finish, cli() is meaningless.<br /><br />(*) On other CPU's - we can't wait for our _own_ CPU interrupts to finish,<br />because if we're in an interrupt handler when we do the cli(), we'll be<br />waiting for outself :)<br /><br />If you want less espensive mutual exclusion, you should never use cli(): <br />you should instead use a spinlock. The spinlock will lock only that<br />particular critical region against others who try to enter that critical<br />region, and that can in general be done much faster than disabling<br />interrupts globally. But the global irq disable _has_ to do what we do<br />now.<br /><br />&gt; 2. There was a previous discussion about whether interrupts needed<br />&gt;    to be disabled in the controller. Someone said that level triggered<br />&gt;    devices would cause lock-up unless this were done.<br />&gt; <br />&gt;    Question: Is this correct?<br /><br />This is correct. Essentially, level-triggered devices can be handled in<br />two ways:<br /><br /> - disable interrupts in the interrupt controller before enabling other<br />   interrupts again (which is what Linux currently does)<br /> - disable _all_ interrupts until we have made sure that the device is no<br />   longer enabling the irq line. This can be done either by having the CPU<br />   not accept interrupts, or by not acknowledging the irq to the interrupt<br />   controller.<br /><br />Of the two choices, the current Linux behaviour is obviously the better<br />one. In many cases it can take quite a while before we can be sure that<br />the device is no longer asserting the irq line (in some cases this is just<br />a matter of reading the status register of the device, but in other cases<br />it may be a question of reading all pending data off the device etc). <br /><br />&gt;    Question: What devices need to be level triggered and why?<br /><br />Just about all devices should be level triggered - you can't share<br />interrupts otherwise. For historical reasons the basic ISA devices are<br />_not_ level triggered, but they should really be considered a broken<br />design.<br /><br />(Edge-triggering simplifies some things, and wouldn't result in the<br />deadlock of just spinning on interrupt routine entry, but that does not<br />really excuse some of the other braindamages of edge triggering).<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
