    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/7/29/48">First message in thread</a></li><li><a href="/lkml/2008/7/29/154">Ingo Molnar</a><ul><li><a href="/lkml/2008/7/29/211">Mike Travis</a><ul><li><a href="/lkml/2008/7/29/213">Mike Travis</a></li></ul></li><li><a href="/lkml/2008/7/29/269">Linus Torvalds</a><ul><li><a href="/lkml/2008/7/29/270">Ingo Molnar</a></li><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 29 Jul 2008 09:44:17 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: linux-next: build failure</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 29 Jul 2008, Linus Torvalds wrote:<br />&gt;<br />&gt;   [...]                           since statement expressions are gcc <br />&gt; extensions, and as such the gcc people could make up any semantics they <br />&gt; want to them, including just defining that a statement expression with <br />&gt; an lvalue value is the same lvalue rather than any temporary). <br /><br />In fact, that does seem what gcc-4.x does. The way to tell is to do<br /><br />	const int *x;<br /><br />	({ *x }) = 1;<br /><br />and it's (a) legal (assignments to non-lvalues wouldn't work) and (b) <br />gives a nice warning about assignment to read-only location, which in turn <br />implies that the compiler properly just peeled off the de-reference even <br />though it was inside the statement expression.<br /><br />IOW, at least in gcc-4.3 (and apparently in earlier gcc-4 versions, but <br />not in gcc-3.4.5), a statement expression with an lvalue return value _is_ <br />actually an lvalue.<br /><br />But that also means that there is no difference what-so-ever between (x) <br />and ({ x; }) in gcc-4. And in gcc-3 there is, because apparently in gcc-3 <br />a statement expression is never an lvalue (which is actually the sane <br />thing, imho).<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
