    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/7/24/340">First message in thread</a></li><li><a href="/lkml/2008/7/24/427">Linus Torvalds</a><ul><li><a href="/lkml/2008/7/24/437">Suresh Siddha</a><ul><li class="origin"><a href="/lkml/2008/7/24/444">Linus Torvalds</a><ul><li><a href="/lkml/2008/7/24/444">Suresh Siddha</a></li><li><a href="/lkml/2008/7/24/445">Suresh Siddha</a><ul><li><a href="/lkml/2008/7/24/449">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2008/7/24/476">Suresh Siddha</a><ul><li><a href="/lkml/2008/7/26/114">Ingo Molnar</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2008/7/24/440/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 24 Jul 2008 15:43:44 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [patch] x64, fpu: fix possible FPU leakage in error conditions</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 24 Jul 2008, Suresh Siddha wrote:<br />&gt; &gt; <br />&gt; &gt; but the thing is, the only really valid reason for "restore_i387()" to<br />&gt; &gt; fail is because the read failed.<br />&gt; <br />&gt; Not really. It can cause #GP, if someone sets reserved bits of mxcsr<br />&gt; in the memory image.<br /><br />Ahh, ok, I can imagine that. And I guess we might copy the data from user <br />space into the memory image without validating it at points (signal <br />handler restore and/or ptrace). Do we?<br /><br />&gt; But restore_i387() may be in an insane state (we did clts() but doesn't<br />&gt; have the proper state in its live registers etc) when it failed to restore fpu.<br />&gt; Ideally we should fix this inside restore_i387(). But restore_i387()<br />&gt; is in header file and I have to re-arrange some of the code<br />&gt; in the header file, to call clear_fpu() from restore_i387().<br /><br />Ok, how about we just move restore_i387() out of the header file? I <br />realize that the x86 code plays some games with this whole thing (that <br />whole '#define restore_i387_ia32 restore_i387'), but that is 32-bit <br />specific, and the restore_i387() in the header file is 64-bit specific. <br /><br />Hmm. In fact, I think that x86-64 version is actually only used in a <br />single place - arch/x86/kernel/signal_64.c. So it's actively *wrong* to <br />have that thing in a header file to begin with!<br /><br />So how about this patch as a starting point? This is the RightThing(tm) to <br />do regardless, and if it then makes it easier to do some other cleanups, <br />we should do it first. What do you think?<br /><br />		Linus<br /><br />---<br /> arch/x86/kernel/signal_64.c |   20 ++++++++++++++++++++<br /> include/asm-x86/i387.h      |   21 ---------------------<br /> 2 files changed, 20 insertions(+), 21 deletions(-)<br /><br />diff --git a/arch/x86/kernel/signal_64.c b/arch/x86/kernel/signal_64.c<br />index 47c3d24..c40ddcb 100644<br />--- a/arch/x86/kernel/signal_64.c<br />+++ b/arch/x86/kernel/signal_64.c<br />&#64;&#64; -53,6 +53,26 &#64;&#64; sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss,<br /> 	return do_sigaltstack(uss, uoss, regs-&gt;sp);<br /> }<br /> <br />+/*<br />+ * This restores directly out of user space. Exceptions are handled.<br />+ */<br />+static inline int restore_i387(struct _fpstate __user *buf)<br />+{<br />+	struct task_struct *tsk = current;<br />+	int err;<br />+<br />+	if (!used_math()) {<br />+		err = init_fpu(tsk);<br />+		if (err)<br />+			return err;<br />+	}<br />+<br />+	if (!(task_thread_info(current)-&gt;status &amp; TS_USEDFPU)) {<br />+		clts();<br />+		task_thread_info(current)-&gt;status |= TS_USEDFPU;<br />+	}<br />+	return restore_fpu_checking((__force struct i387_fxsave_struct *)buf);<br />+}<br /> <br /> /*<br />  * Do a signal return; undo the signal stack.<br />diff --git a/include/asm-x86/i387.h b/include/asm-x86/i387.h<br />index 37672f7..a355264 100644<br />--- a/include/asm-x86/i387.h<br />+++ b/include/asm-x86/i387.h<br />&#64;&#64; -170,27 +170,6 &#64;&#64; static inline int save_i387(struct _fpstate __user *buf)<br /> 	return 1;<br /> }<br /> <br />-/*<br />- * This restores directly out of user space. Exceptions are handled.<br />- */<br />-static inline int restore_i387(struct _fpstate __user *buf)<br />-{<br />-	struct task_struct *tsk = current;<br />-	int err;<br />-<br />-	if (!used_math()) {<br />-		err = init_fpu(tsk);<br />-		if (err)<br />-			return err;<br />-	}<br />-<br />-	if (!(task_thread_info(current)-&gt;status &amp; TS_USEDFPU)) {<br />-		clts();<br />-		task_thread_info(current)-&gt;status |= TS_USEDFPU;<br />-	}<br />-	return restore_fpu_checking((__force struct i387_fxsave_struct *)buf);<br />-}<br />-<br /> #else  /* CONFIG_X86_32 */<br /> <br /> extern void finit(void);<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
