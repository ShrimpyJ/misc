    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/7/11/328">First message in thread</a></li><li><a href="/lkml/2008/7/14/386">Linus Torvalds</a><ul><li><a href="/lkml/2008/7/14/398">"Dmitry Adamushko"</a><ul><li class="origin"><a href="/lkml/2008/7/14/457">Linus Torvalds</a><ul><li><a href="/lkml/2008/7/14/457">"Dmitry Adamushko"</a><ul><li><a href="/lkml/2008/7/14/500">Max Krasnyansky</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2008/7/14/511">Steven Rostedt</a><ul><li><a href="/lkml/2008/7/14/514">Linus Torvalds</a><ul><li><a href="/lkml/2008/7/14/516">Steven Rostedt</a><ul><li><a href="/lkml/2008/7/15/2">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 14 Jul 2008 17:23:38 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: current linux-2.6.git: cpusets completely broken</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 15 Jul 2008, Dmitry Adamushko wrote:<br />&gt; <br />&gt; The 'synchronization' point occurs even earlier - when cpu_down() -&gt;<br />&gt; __stop_machine_run() gets called (as I described in my previous mail).<br />&gt; <br />&gt; My point was that if it's ok to have a _delayed_ synchronization<br />&gt; point, having it not immediately after cpu_clear(cpu, cpu_active_map)<br />&gt; but when the "runqueue lock" is taken a bit later (as you pointed out<br />&gt; above) or __stop_machine_run() gets executed (which is a sync point,<br />&gt; scheduling-wise),<br />&gt; <br />&gt; then we can implement the proper synchronization (hotplugging vs.<br />&gt; task-migration) with cpu_online_map (no need for cpu_active_map).<br /><br />Maybe. But what is the point? And more importantly, I think it's wrong.<br /><br />There's really a *difference* between "this CPU is still running, but <br />going down" and "this CPU is running".<br /><br />And it's a valid difference. For example, a process should be able to <br />absolutely DEPEND on being able to depend on cpu_online(current_cpu()) <br />*always* being true. <br /><br />I also don't understand why people are arguing against a single new CPU <br />map (it's _global_ to the whole kernel, for crissake!) when it clearly <br />makes the rules much simpler. Look at the patch I sent out, and tell me it <br />isn't 100% obvious what cpu_active_map does, and what the logic is.<br /><br />In contrast, try to follow the same for cpu_online_map. I dare you. You <br />have to already know that code really really well in order to understand <br />what happens to it, both at bootup _and_ at hotplug events.<br /><br />Dmitry, THIS CODE WAS BUGGY. Not just once. Multiple f*cking times!<br /><br />That should tell you something.<br /><br />In particular, it should tell you that the code is too hard to follow, and <br />too fragile, and a total mess.<br /><br />I do NOT understand why you seem to argue for being "subtle" and "clever", <br />considering the history of this whole setup. Subtle and clever and complex <br />is what got us to the crap situation.<br /><br />So here's the code-word of today: KISS - Keep It Simple Stupid.<br /><br />And I _guarantee_ that the "cpu_active_map" approach is a hell of a lot <br />simpler than the alternatives. Partly because it really matches what we <br />want much more closely: it gives a clear new state for "this CPU is going <br />down, even though things are still running on it".<br /><br />And then it's 100% logical to say: "ok, if it's going down, we agree to <br />not add new processes to it".<br /><br />THAT is the kind of logic we should strive for. Not "let's avoid the <br />obvious and simple code because we can re-use the existing messy code for <br />yet another thing".<br /><br />Dammit, this code should be easier to understand, not harder!<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
