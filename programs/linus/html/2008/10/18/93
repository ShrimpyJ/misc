    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/10/16/511">First message in thread</a></li><li><a href="/lkml/2008/10/17/499">"Luck, Tony"</a><ul><li><a href="/lkml/2008/10/18/87">Mathieu Desnoyers</a><ul><li class="origin"><a href="/lkml/2008/10/18/95">Linus Torvalds</a><ul><li><a href="/lkml/2008/10/18/95">Ingo Molnar</a><ul><li><a href="/lkml/2008/10/22/352">Mathieu Desnoyers</a></li></ul></li><li><a href="/lkml/2008/10/22/335">Mathieu Desnoyers</a></li></ul></li><li><a href="/lkml/2008/10/20/287">"Luck, Tony"</a><ul><li><a href="/lkml/2008/10/22/365">Mathieu Desnoyers</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 18 Oct 2008 10:35:52 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC patch 15/15] LTTng timestamp x86</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sat, 18 Oct 2008, Mathieu Desnoyers wrote:<br />&gt; <br />&gt; So, the conclusion it brings about scalability of those time sources<br />&gt; regarding tracing is :<br />&gt; - local TSC read scales very well when the number of CPU increases<br />&gt;   (constant 50% overhead)<br /><br />You should basically expect it to scale perfectly. Of course the tracing <br />itself adds overhead, and at some point the trace data generation may add <br />so much cache/memory traffic that you start getting worse scaling because <br />of _that_, but just a local TSC access itself will be perfect on any sane <br />setup.<br /><br />&gt; - Comparing the added overhead of both get_cyles+cmpxchg and HPET to<br />&gt;   the local sync TSC :<br />&gt; <br />&gt;   cores    get_cycles+cmpxchg    HPET<br />&gt;       1                  0.8%     10%<br />&gt;       2                  8  %     11%<br />&gt;       8                 12  %     19%<br />&gt; <br />&gt; So, is it me, or HPET scales even more poorly than a cache-line bouncing<br />&gt; cmpxchg ? I find it a bit surprising.<br /><br />I don't think that's strictly true.<br /><br />The cacheline is going to generally be faster than HPET ever will, since <br />caches are really important. But as you can see, the _degradation_ is <br />actually worse for the cacheline, since the cacheline works perfectly in <br />the UP case (not surprising) and starts degrading a lot more when you <br />start getting bouncing.<br /><br />And I'm not sure what the behaviour would be for many-core, but I would <br />not be surprised of the cmpxchg actually ends up losing at some point. The <br />HPET is never fast (you can think of it as "uncached access"), and it's <br />going to degrade too (contention at the IO hub level), but it's actually <br />possible that the contention at some point becomes less than wild <br />bouncing.<br /><br />Many cacheline bouncing issues end up being almost exponential. When you <br />*really* get bouncing, things degrade in a major way. I don't think you've <br />seen the worst of it with 8 cores ;)<br /><br />And that's why I'd really like to see the "only local TSC" access, even if <br />I admit that the code is going to be much more subtle, and I will also <br />admit that especially in the presense of frequency changes *and* hw with <br />unsynchronized TSC's you may be in the situation where you never get <br />exactly what you want.<br /><br />But while you may not like some of the "purely local TSC" issues, I would <br />like to point out that<br /><br /> - In _practice_, it's going to be essentially perfect on a lot of <br />   machines, and under a lot of loads. <br /><br />   For example, yes it's true that frequency changes will make TSC things <br />   less reliable on a number of machines, but people already end up <br />   disabling dynamic cpufreq when doing various benchmark runs, simply <br />   because people want more consistent numbers for benchmarking across <br />   different kernels etc.<br /><br />   So it's entirely possible (and I'd say "likely") that most people are <br />   simply willing to do the same thing for tracing if they are tracing <br />   things at a level where CPU frequency changes might otherwise matter. <br /><br />   So maybe the "local TSC" approach isn't always perfect, but I'd expect <br />   that quite often people who do tracing are willing to work around it. <br />   The people doing tracing are generally not doing so without being aware <br />   of what they are up to..<br /><br /> - While there is certainly a lot of hardware out there with flaky TSC's, <br />   there's also a lot of hardware (especially upcoming) that do *not* have <br />   flaky TSC's. We've been complaining to Intel about TSC behavior for <br />   years, and the thing is, it actually _is_ improving. It just takes some <br />   time.<br /><br /> - So considering that some of the tracing will actually be very important <br />   on machines that have lots of cores, and considering that a lot of the <br />   issues can generally be worked around, I really do think that it's <br />   worth trying to spend a bit of effort on doing the "local TSC + timely <br />   corrections"<br /><br />For example, you mention that interrupts can be disabled for a time, <br />delaying things like regular sync events with some stable external clock <br />(say the HPET). That's true, and it would even be a problem if you'd use <br />the time of the interrupt itself as the source of the sync, but you don't <br />really need to depend on the timing of the interrupt - just that it <br />happens "reasonably often" (and now we're talking _much_ longer timeframes <br />than some interrupt-disabled time - we're talking tenths of seconds or <br />even more).<br /><br />Then, rather than depend on the time of the interrupt, you just purely can <br />check the local TSC against the HPET (or other source), and synchronize <br />just _purely_ based on those. That you can do by basically doing something <br />like<br /><br />	do {<br />		start = read_tsc();<br />		hpet = read_hpet();<br />		end = read_tsc();<br />	} while (end - start &gt; ERROR);<br /><br />and now, even if you have interrupts enabled (or worry about NMI's), you <br />now know that you have a totally _independent_ sync point, ie you know <br />that your hpet read value is withing ERROR cycles of the start/end values, <br />so now you have a good point for doing future linear interpolation based <br />on those kinds of sync points.<br /><br />And if you make all these linear interpolations be per-CPU (so you have <br />per-CPU offsets and frequencies) you never _ever_ need to touch any shared <br />data at all, and you know you can scale basically perfectly.<br /><br />Your linear interpolations may not be _perfect_, but you'll be able to get <br />them pretty damn near. In fact, even if the TSC's aren't synchronized at <br />all, if they are at least _individually_ stable (just running at slightly <br />different frequencies because they are in different clock domains, and/or <br />at different start points), you can basically perfect the precision over <br />time.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
