    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/10/17/465">First message in thread</a></li><li><a href="/lkml/2008/10/17/465">Hugh Dickins</a><ul><li class="origin"><a href="/lkml/2008/10/17/503">Linus Torvalds</a><ul><li><a href="/lkml/2008/10/17/503">Hugh Dickins</a><ul><li><a href="/lkml/2008/10/17/505">Linus Torvalds</a></li><li><a href="/lkml/2008/10/17/519">Nick Piggin</a><ul><li><a href="/lkml/2008/10/17/530">Paul Mackerras</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 17 Oct 2008 16:05:03 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [patch] mm: fix anon_vma races</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 17 Oct 2008, Hugh Dickins wrote:<br />&gt; <br />&gt; My problem is really with the smp_read_barrier_depends() you each<br />&gt; have in anon_vma_prepare().  But the only thing which its CPU<br />&gt; does with the anon_vma is put its address into a struct page<br />&gt; (or am I forgetting more?).  Wouldn't the smp_read_barrier_depends()<br />&gt; need to be, not there in anon_vma_prepare(), but over on the third<br />&gt; CPU, perhaps in page_lock_anon_vma()?<br /><br />I thought about it, but it's a disaster from a maintenance standpoint to <br />put it there, rather than make it all clear in the _one_ function that <br />actually does things optimistically.<br /><br />I agree that it's a bit subtle the way I did it (haven't seen Nick's <br />patch, I assume he was upset at me for shouting at him), but that's part <br />of why I put that comment in there and said things are subtle.<br /><br />Anyway, technically you're right: the smp_read_barrier_depends() really <br />would be more obvious in the place where we actually fetch that "anon_vma" <br />pointer again and actually derefernce it.<br /><br />HOWEVER:<br /><br /> - there are potentially multiple places that do that, and putting it in <br />   the anon_vma_prepare() thing not only matches things with the <br />   smp_wmb(), making that whole pairing much more obvious, but it also <br />   means that we're guaranteed that any anon_vma user will have done the <br />   smp_read_barrier_depends(), since they all have to do that prepare <br />   thing anyway.<br /><br />   So putting it there is simpler and gives better guarantees, and pairs <br />   up the barriers better.<br /><br /> - Now, "simpler" (etc) is no help if it doesn't work, so now I have to <br />   convince you that it's _sufficient_ to do that "read_barrier_depends()" <br />   early, even if we then end up re-doing the first read and thus the <br />   "depends" part doesn't work any more. So "simpler" is all good, but not <br />   if it's incorrect.<br /><br />   And I admit it, here my argument is one of implementation. The fact is, <br />   the only architecture where "read_barrier_depends()" exists at all as <br />   anything but a no-op is alpha, and there it's a full read barrier. On <br />   all other architectures, causality implies a read barrier anyway, so <br />   for them, placement (or non-placement) of the smp_read_barrier_depends <br />   is a total non-issue.<br /><br />   And so, since on the only architecture where it could possibly matter, <br />   that _depends thing turns into a full read barrier, and since <br />   "anon_vma" is actually stable since written, and since the only <br />   ordering constrain is that initial ordering of seeing the "anon_vma" <br />   turn non-NULL, you may as well think of that "read_barrier_depends()" <br />   as a full read barrier between the _original_ read of the anon_vma <br />   pointer and then the read of the lock data we want to protect.<br /><br />   Which it is, on alpha. And that is sufficient. IOW, think of it as a <br />   real read_barrier(), with no dependency thing, but that only happens <br />   when an architecture doesn't already guarantee the causality barrier.<br /><br />   And once you think of it as a "smp_rmb() for alpha", you realize that <br />   it's perfectly ok for it to be where it is.<br /><br />Anyway, lockless is bad. It would certainly be a *lot* simpler to just <br />take the page_table_lock around the whole thing, except I think we really <br />*really* don't want to do that. That thing is solidly in a couple of <br />*very* timing-critical routines. Doing another lock there is just not an <br />option.<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
