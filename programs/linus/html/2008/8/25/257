    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/8/23/105">First message in thread</a></li><li><a href="/lkml/2008/8/25/155">"Alan D. Brunelle"</a><ul><li><a href="/lkml/2008/8/25/163">"Alan D. Brunelle"</a><ul><li class="origin"><a href="/lkml/2008/8/25/262">Linus Torvalds</a><ul><li><a href="/lkml/2008/8/25/262">Linus Torvalds</a><ul><li><a href="/lkml/2008/8/25/312">"Alan D. Brunelle"</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 25 Aug 2008 11:00:19 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [Bug #11342] Linux 2.6.27-rc3: kernel BUG at mm/vmalloc.c - bisected</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 25 Aug 2008, Alan D. Brunelle wrote:<br />&gt;<br />&gt; Before adding any more debugging, this is the status of my kernel boots:<br />&gt; 3 times in a row w/ this same error. (Primary problem is the same,<br />&gt; secondary stacks differ of course.)<br /><br />Ok, so I took a closer look, and the oops really is suggestive..<br /><br />&gt; [    6.482953] busybox used greatest stack depth: 4840 bytes left<br /><br />Ok, 4840 bytes left out of 8kB.<br /><br />&gt; [    6.521876] all_generic_ide used greatest stack depth: 4784 bytes left<br /><br />.. and this one is 4784 bytes left..<br /><br />&gt; Begin: Loading essential drivers... ...<br />&gt; [    6.625509] fuse init (API version 7.9)<br />&gt; [    6.625509] modprobe used greatest stack depth: 1720 bytes left<br /><br />Uhhuh! The previous "modprobe" uses stack like mad.  It could be <br />"fuse_init()" that has done it, but looking at fuse, I seriously doubt it. <br />It doesn't seem to do anything particularly bad.<br /><br />So something has used over 6kB of stack, and it may well be the module <br />loading code itself.<br /><br />The next stage is the actual oops itself:<br /><br />&gt; [    6.644854] ACPI: SSDT CFFD0D0A, 08C4 (r1 HPQOEM  CPU_TM2        1 MSFT  100000E)<br />&gt; [    6.651489] BUG: unable to handle kernel NULL pointer dereference at 0000000000000858<br /><br />This really looks like<br /><br />	ti-&gt;task-&gt;blocked_on = waiter;<br /><br />where "ti-&gt;task" is NULL. You probably have almost everything enabled in <br />order to turn "struct task_struct" that big, but judging by your register <br />state it's really an offset off a NULL pointer, not some small integer.<br /><br />Now, there is no way "ti-&gt;task" can _possibly_ be NULL. No way.<br /><br />Well, except that "ti" is just below the stack, and if you had a stack <br />overflow that overwrote it.<br /><br />So I seriously do believe that you have run out of stack. If that is true, <br />then it's quite likely that with DEBUG_PAGE_ALLOC you'll actually get a <br />double fault, which in turn is fairly hard to debug (you look at it wrong <br />and it turns into a triple fault which is going to just reboot your <br />machine immediately).<br /><br />Now, the stack oveflow probably happened a few calls earlier (and just <br />left your thread_info corrupted), but there is more reason to believe you <br />have stack overflow and thread_info corruption later in your output:<br /><br />&gt; [    7.024992] modprobe used greatest stack depth: 408 bytes left  <br />&gt; [    7.030988] BUG: unable to handle kernel NULL pointer dereference at 0000000000000048<br />&gt; [    7.031053] IP: [&lt;ffffffff8023f39c&gt;] do_exit+0x28c/0xa10<br /><br />Here there is only 408 bytes left, which is _way_ too little, but it's <br />also an optimistic measure. What the stack code usage code does is to just <br />see how many zeroes it can find on the stack. If you have a big stack <br />frame somewhere, it's quite possible that it actually used all your stack <br />and then some, but left a bunch of zeroes around.<br /><br />And the do_exit() oops is simply because once the thread_info is <br />corrupted, all the basic thread data structures are crap, and yes, you're <br />almost guaranteed to oops at that point.<br /><br />Could you make your kernel image available somewhere, and we can take a <br />look at it? Some versions of gcc are total pigs when it comes to stack <br />usage, and your exact configuration matters too.  But yes, module loading <br />is a bad case, for me "sys_init_module()" contains<br /><br />	subq    $392, %rsp      #,<br /><br />which is probably mostly because of the insane inlining gcc does (ie it <br />will likely have inlined every single function in that file that is only <br />called once, and then it will make all local variables of all those <br />functions alive over the whole function and allocate stack-space for them <br />ALL AT THE SAME TIME).<br /><br />Gcc sometimes drives me mad. It's inlining decisions are almost always <br />pure and utter sh*t. But clearly something changed for you to start <br />triggering this, and I think that also explains why you bisected things to <br />the merge commit rather than to any individual change - because it was <br />probably not any individual change that pushed it over the limit, but two <br />different changes that made for bigger stack pressure, and _together_ they <br />pushed you over the limit.<br /><br />So it also explains why the merge you found had no possible merge errors <br />on a source level - there were no actual clashes anywhere. Just a slow <br />growth of stack that combined to something that overflowed.<br /><br />And yes, I bet the change by Arjan to use do_one_initcall() was _part_ of <br />it. It adds roughly 112 bytes of stack pressure to that module loading <br />path, because of the 64-byte array and the extra function call (8 bytes <br />for return address) with at least 5 quad-words saved (40 bytes) for <br />register spills.<br /><br />But there were probably other things happening too that made things worse.<br /><br />So if there is some place where you can upload your 'vmlinux' binary, it <br />would be good.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
