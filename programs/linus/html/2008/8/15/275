    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/8/12/27">First message in thread</a></li><li><a href="/lkml/2008/8/12/391">Al Viro</a><ul><li><a href="/lkml/2008/8/12/418">Linus Torvalds</a><ul><li><a href="/lkml/2008/8/12/445">Al Viro</a><ul><li><a href="/lkml/2008/8/12/453">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2008/8/13/72">Brad Boyer</a><ul><li><a href="/lkml/2008/8/13/267">Al Viro</a></li></ul></li><li><a href="/lkml/2008/8/15/9">Jan Harkes</a><ul><li><a href="/lkml/2008/8/15/12">Al Viro</a></li><li class="origin"><a href="/lkml/2008/8/24/56">Linus Torvalds</a><ul><li><a href="/lkml/2008/8/24/56">Al Viro</a><ul><li><a href="/lkml/2008/8/24/61">Al Viro</a></li><li><a href="/lkml/2008/8/24/106">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2008/8/15/275/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 15 Aug 2008 09:58:31 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC] readdir mess</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Fri, 15 Aug 2008, Jan Harkes wrote:<br />&gt; <br />&gt; If I understood your description, then the following would be the<br />&gt; correct fix. We return 0 as long as we managed to read some entries, and<br />&gt; any non-zero return value from filldir otherwise.<br /><br />This looks fine.<br /><br />On the other hand, you really _should_ be able to just drop "result" <br />entirely, and just do "return ret" at the end.<br /><br />But no, you can't do it right now, becasue the callers are broken crap. <br />But that really isn't your fault.<br /><br />Also, you don't really need to change the<br /><br />	if (ret &lt; 0)<br />		goto out;<br /><br />to<br /><br />	if (ret != 0)<br />		goto out;<br /><br />because the "filldir()" functions should all do the right thing anyway. <br />But there's certainly nothing wrong with doing it either.<br /><br />However, I think the real fix is something like this. This <br /><br /> - fixes all the callers<br /><br /> - removes more lines than it adds<br /><br /> - simplifies and clarifies the code<br /><br /> - avoids pointless goto's<br /><br /> - makes error handling of vfs_readdir() consistent among the callers<br />   (some callers already did the error handling _correctly_ before this <br />   patch - this makes everybody do it the same way)<br /><br />but I didn't actually even try to test this. Al? Jan?<br /><br />(Side note: if this were a commit, I'd fix the _users_ of vfs_readdir() in <br />one patch, and then the fs/coda/dir.c patch would be the next commit, but <br />I'm sending it out as one single patch for comments/testing)<br /><br />		Linus<br /><br />---<br /> arch/alpha/kernel/osf_sys.c     |    8 ++------<br /> arch/ia64/ia32/sys_ia32.c       |    6 ++----<br /> arch/parisc/hpux/fs.c           |    7 ++-----<br /> arch/powerpc/kernel/sys_ppc32.c |    7 ++-----<br /> fs/coda/dir.c                   |    6 +-----<br /> fs/compat.c                     |   21 +++++++--------------<br /> fs/readdir.c                    |   22 +++++++---------------<br /> 7 files changed, 23 insertions(+), 54 deletions(-)<br /><br />diff --git a/arch/alpha/kernel/osf_sys.c b/arch/alpha/kernel/osf_sys.c<br />index 6e94313..869484e 100644<br />--- a/arch/alpha/kernel/osf_sys.c<br />+++ b/arch/alpha/kernel/osf_sys.c<br />&#64;&#64; -160,14 +160,10 &#64;&#64; osf_getdirentries(unsigned int fd, struct osf_dirent __user *dirent,<br /> 	buf.error = 0;<br /> <br /> 	error = vfs_readdir(file, osf_filldir, &amp;buf);<br />-	if (error &lt; 0)<br />-		goto out_putf;<br />-<br />-	error = buf.error;<br />+	if (error &gt;= 0)<br />+		error = buf.error;<br /> 	if (count != buf.count)<br /> 		error = count - buf.count;<br />-<br />- out_putf:<br /> 	fput(file);<br />  out:<br /> 	return error;<br />diff --git a/arch/ia64/ia32/sys_ia32.c b/arch/ia64/ia32/sys_ia32.c<br />index 465116a..e70fb30 100644<br />--- a/arch/ia64/ia32/sys_ia32.c<br />+++ b/arch/ia64/ia32/sys_ia32.c<br />&#64;&#64; -1278,9 +1278,8 &#64;&#64; sys32_getdents (unsigned int fd, struct compat_dirent __user *dirent, unsigned i<br /> 	buf.error = 0;<br /> <br /> 	error = vfs_readdir(file, filldir32, &amp;buf);<br />-	if (error &lt; 0)<br />-		goto out_putf;<br />-	error = buf.error;<br />+	if (error &gt;= 0)<br />+		error = buf.error;<br /> 	lastdirent = buf.previous;<br /> 	if (lastdirent) {<br /> 		if (put_user(file-&gt;f_pos, &amp;lastdirent-&gt;d_off))<br />&#64;&#64; -1289,7 +1288,6 &#64;&#64; sys32_getdents (unsigned int fd, struct compat_dirent __user *dirent, unsigned i<br /> 			error = count - buf.count;<br /> 	}<br /> <br />-out_putf:<br /> 	fput(file);<br /> out:<br /> 	return error;<br />diff --git a/arch/parisc/hpux/fs.c b/arch/parisc/hpux/fs.c<br />index 1263f00..ca0cd1b 100644<br />--- a/arch/parisc/hpux/fs.c<br />+++ b/arch/parisc/hpux/fs.c<br />&#64;&#64; -121,16 +121,13 &#64;&#64; int hpux_getdents(unsigned int fd, struct hpux_dirent __user *dirent, unsigned i<br /> 	buf.error = 0;<br /> <br /> 	error = vfs_readdir(file, filldir, &amp;buf);<br />-	if (error &lt; 0)<br />-		goto out_putf;<br />-	error = buf.error;<br />+	if (error &gt;= 0)<br />+		error = buf.error;<br /> 	lastdirent = buf.previous;<br /> 	if (lastdirent) {<br /> 		put_user(file-&gt;f_pos, &amp;lastdirent-&gt;d_off);<br /> 		error = count - buf.count;<br /> 	}<br />-<br />-out_putf:<br /> 	fput(file);<br /> out:<br /> 	return error;<br />diff --git a/arch/powerpc/kernel/sys_ppc32.c b/arch/powerpc/kernel/sys_ppc32.c<br />index 709f8cb..b2a1634 100644<br />--- a/arch/powerpc/kernel/sys_ppc32.c<br />+++ b/arch/powerpc/kernel/sys_ppc32.c<br />&#64;&#64; -100,11 +100,8 &#64;&#64; asmlinkage int old32_readdir(unsigned int fd, struct old_linux_dirent32 __user *<br /> 	buf.dirent = dirent;<br /> <br /> 	error = vfs_readdir(file, (filldir_t)fillonedir, &amp;buf);<br />-	if (error &lt; 0)<br />-		goto out_putf;<br />-	error = buf.count;<br />-<br />-out_putf:<br />+	if (error &gt;= 0)<br />+		error = buf.count;<br /> 	fput(file);<br /> out:<br /> 	return error;<br />diff --git a/fs/coda/dir.c b/fs/coda/dir.c<br />index c591622..c4b1d58 100644<br />--- a/fs/coda/dir.c<br />+++ b/fs/coda/dir.c<br />&#64;&#64; -488,7 +488,6 &#64;&#64; static inline unsigned int CDT2DT(unsigned char cdt)<br /> static int coda_venus_readdir(struct file *coda_file, void *buf,<br /> 			      filldir_t filldir)<br /> {<br />-	int result = 0; /* # of entries returned */<br /> 	struct coda_file_info *cfi;<br /> 	struct coda_inode_info *cii;<br /> 	struct file *host_file;<br />&#64;&#64; -515,14 +514,12 &#64;&#64; static int coda_venus_readdir(struct file *coda_file, void *buf,<br /> 		ret = filldir(buf, ".", 1, 0, de-&gt;d_inode-&gt;i_ino, DT_DIR);<br /> 		if (ret &lt; 0)<br /> 			goto out;<br />-		result++;<br /> 		coda_file-&gt;f_pos++;<br /> 	}<br /> 	if (coda_file-&gt;f_pos == 1) {<br /> 		ret = filldir(buf, "..", 2, 1, de-&gt;d_parent-&gt;d_inode-&gt;i_ino, DT_DIR);<br /> 		if (ret &lt; 0)<br /> 			goto out;<br />-		result++;<br /> 		coda_file-&gt;f_pos++;<br /> 	}<br /> 	while (1) {<br />&#64;&#64; -573,7 +570,6 &#64;&#64; static int coda_venus_readdir(struct file *coda_file, void *buf,<br /> 				      coda_file-&gt;f_pos, ino, type);<br /> 			/* failure means no space for filling in this round */<br /> 			if (ret &lt; 0) break;<br />-			result++;<br /> 		}<br /> 		/* we'll always have progress because d_reclen is unsigned and<br /> 		 * we've already established it is non-zero. */<br />&#64;&#64; -581,7 +577,7 &#64;&#64; static int coda_venus_readdir(struct file *coda_file, void *buf,<br /> 	}<br /> out:<br /> 	kfree(vdir);<br />-	return result ? result : ret;<br />+	return ret;<br /> }<br /> <br /> /* called when a cache lookup succeeds */<br />diff --git a/fs/compat.c b/fs/compat.c<br />index c9d1472..f4432fc 100644<br />--- a/fs/compat.c<br />+++ b/fs/compat.c<br />&#64;&#64; -913,18 +913,14 &#64;&#64; asmlinkage long compat_sys_getdents(unsigned int fd,<br /> 	buf.error = 0;<br /> <br /> 	error = vfs_readdir(file, compat_filldir, &amp;buf);<br />-	if (error &lt; 0)<br />-		goto out_putf;<br />-	error = buf.error;<br />+	if (error &gt;= 0)<br />+		error = buf.error;<br /> 	lastdirent = buf.previous;<br /> 	if (lastdirent) {<br />+		error = count - buf.count;<br /> 		if (put_user(file-&gt;f_pos, &amp;lastdirent-&gt;d_off))<br /> 			error = -EFAULT;<br />-		else<br />-			error = count - buf.count;<br /> 	}<br />-<br />-out_putf:<br /> 	fput(file);<br /> out:<br /> 	return error;<br />&#64;&#64; -1004,19 +1000,16 &#64;&#64; asmlinkage long compat_sys_getdents64(unsigned int fd,<br /> 	buf.error = 0;<br /> <br /> 	error = vfs_readdir(file, compat_filldir64, &amp;buf);<br />-	if (error &lt; 0)<br />-		goto out_putf;<br />-	error = buf.error;<br />+	if (error &gt;= 0)<br />+		error = buf.error;<br /> 	lastdirent = buf.previous;<br /> 	if (lastdirent) {<br /> 		typeof(lastdirent-&gt;d_off) d_off = file-&gt;f_pos;<br />-		error = -EFAULT;<br />-		if (__put_user_unaligned(d_off, &amp;lastdirent-&gt;d_off))<br />-			goto out_putf;<br /> 		error = count - buf.count;<br />+		if (__put_user_unaligned(d_off, &amp;lastdirent-&gt;d_off))<br />+			error = -EFAULT;<br /> 	}<br /> <br />-out_putf:<br /> 	fput(file);<br /> out:<br /> 	return error;<br />diff --git a/fs/readdir.c b/fs/readdir.c<br />index 4e026e5..f5c02bc 100644<br />--- a/fs/readdir.c<br />+++ b/fs/readdir.c<br />&#64;&#64; -205,18 +205,14 &#64;&#64; asmlinkage long sys_getdents(unsigned int fd, struct linux_dirent __user * diren<br /> 	buf.error = 0;<br /> <br /> 	error = vfs_readdir(file, filldir, &amp;buf);<br />-	if (error &lt; 0)<br />-		goto out_putf;<br />-	error = buf.error;<br />+	if (error &gt;= 0)<br />+		error = buf.error;<br /> 	lastdirent = buf.previous;<br /> 	if (lastdirent) {<br />+		error = count - buf.count;<br /> 		if (put_user(file-&gt;f_pos, &amp;lastdirent-&gt;d_off))<br /> 			error = -EFAULT;<br />-		else<br />-			error = count - buf.count;<br /> 	}<br />-<br />-out_putf:<br /> 	fput(file);<br /> out:<br /> 	return error;<br />&#64;&#64; -289,19 +285,15 &#64;&#64; asmlinkage long sys_getdents64(unsigned int fd, struct linux_dirent64 __user * d<br /> 	buf.error = 0;<br /> <br /> 	error = vfs_readdir(file, filldir64, &amp;buf);<br />-	if (error &lt; 0)<br />-		goto out_putf;<br />-	error = buf.error;<br />+	if (error &gt;= 0)<br />+		error = buf.error;<br /> 	lastdirent = buf.previous;<br /> 	if (lastdirent) {<br /> 		typeof(lastdirent-&gt;d_off) d_off = file-&gt;f_pos;<br />-		error = -EFAULT;<br />-		if (__put_user(d_off, &amp;lastdirent-&gt;d_off))<br />-			goto out_putf;<br /> 		error = count - buf.count;<br />+		if (__put_user(d_off, &amp;lastdirent-&gt;d_off))<br />+			error = -EFAULT;<br /> 	}<br />-<br />-out_putf:<br /> 	fput(file);<br /> out:<br /> 	return error;<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
