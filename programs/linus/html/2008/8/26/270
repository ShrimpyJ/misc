    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/8/23/105">First message in thread</a></li><li><a href="/lkml/2008/8/26/23">Ingo Molnar</a><ul><li><a href="/lkml/2008/8/26/25">David Miller</a><ul><li><a href="/lkml/2008/8/26/26">Ingo Molnar</a><ul><li><a href="/lkml/2008/8/26/40">"Yinghai Lu"</a><ul><li><a href="/lkml/2008/8/26/185">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2008/8/26/255">Mike Travis</a></li></ul></li><li><a href="/lkml/2008/8/26/247">Mike Travis</a><ul><li><a href="/lkml/2008/8/26/312">David Miller</a><ul><li><a href="/lkml/2008/8/29/188">Jes Sorensen</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2008/8/26/243">Mike Travis</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 26 Aug 2008 12:40:26 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [Bug #11342] Linux 2.6.27-rc3: kernel BUG at mm/vmalloc.c - bisected</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 26 Aug 2008, Mike Travis wrote:<br />&gt; <br />&gt; I would be most interested in any tools to analyze call-trees and<br />&gt; accumulated stack usages.  My current method of using kdb is really<br />&gt; time consuming.<br /><br />Well, even just scripts/checkstack.pl is quite relevant.<br /><br />The fact is, anything with a stack footprint of more than a hundred bytes <br />is suspect. We _do_ have a lot of cases of several hundred bytes, and some <br />of them are even very intentional.<br /><br />For an example of _intentional_ and valid large stacks, look at <br />do_sys_poll and do_select. They both have a big stack footprint in a <br />normal kernel, and that's on purpose - it's not pretty, but they are very <br />common and performance-sensitive functions, and using a big stack allows <br />some basic allocations to be much cheaper by default.<br /><br />Same goes for early_printk(), although I don't think the reasons are <br />really very strong in that case.<br /><br />Sadly, while those functions are _fairly_ high up, they aren't at the top, <br />and we do have a lot of other functions that have huge stack footprints <br />for totally bogus reasons. But the intentional ones are at least in the <br />top ten.<br /><br />But the kernel that Alan had problems with was different. The <br />_intentional_ ones were way down in the noise.  do_sys_poll wasn't in the <br />top ten, it was barely even in the top 50! (It was in fact #49, to be <br />exact).<br /><br />So look at the top ten in my kernel:<br /><br />     1  ide_generic_init [vmlinux]:             1384<br />     2  idefloppy_ioctl [vmlinux]:              1208<br />     3  e1000_check_options [vmlinux]:  	1152<br />     4  do_sys_poll [vmlinux]:          	904<br />     5  ide_floppy_get_capacity [vmlinux]:      872<br />     6  do_select [vmlinux]:                    744<br />     7  early_printk [vmlinux]:         	720<br />     8  do_task_stat [vmlinux]:         	680<br />     9  mmc_ioctl [vmlinux]:                    648<br />    10  elf_kcore_store_hdr [vmlinux]:  	576<br /><br />.. and in Alan's kernel:<br /><br />     1  smp_call_function_mask [vmlinux]:       2736<br />     2  __build_sched_domains [vmlinux]:        2232<br />     3  setup_IO_APIC_irq [vmlinux]:            1616<br />     4  arch_setup_ht_irq [vmlinux]:            1600<br />     5  arch_setup_msi_irq [vmlinux]:   	1600<br />     6  __assign_irq_vector [vmlinux]:  	1592<br />     7  move_task_off_dead_cpu [vmlinux]:       1592<br />     8  tick_handle_oneshot_broadcast [vmlinux]:1544<br />     9  store_scaling_governor [vmlinux]:       1376<br />    10  cpuset_write_resmask [vmlinux]:		1360<br /><br />That's a big difference. The top #1 in my kernel would just _barely_ be in <br />the top 10 in Alan's kernel (he doesn't have it at all, because he didn't <br />compile the drives I did into the kernel).<br /><br />And the top three in my kernel are just because of crap code. That <br />"e1000_check_options" thing is there just because it creates multiple <br />"struct e1000_option" structures. I wrote an ugly but totally trivial <br />patch to get it down to ~600 bytes, and it would be less if I had bothered <br />to waste any more time on it.<br /><br />The others are similar issues of "people just didn't think".<br /><br />But look at the top ones in Alan's kernel. Not only are they _much_ bigger <br />than the top ones in a sane kernel, they are _all_ due to cpumask_t, I <br />think.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
