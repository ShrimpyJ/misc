    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/9/19/275">First message in thread</a></li><li><a href="/lkml/2008/9/22/405">"Martin Bligh"</a><ul><li><a href="/lkml/2008/9/22/422">Masami Hiramatsu</a><ul><li><a href="/lkml/2008/9/22/423">"Martin Bligh"</a><ul><li><a href="/lkml/2008/9/23/202">Masami Hiramatsu</a><ul><li><a href="/lkml/2008/9/23/204">Mathieu Desnoyers</a></li><li><a href="/lkml/2008/9/23/214">Linus Torvalds</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2008/9/22/437">Linus Torvalds</a><ul><li><a href="/lkml/2008/9/22/437">Roland Dreier</a><ul><li><a href="/lkml/2008/9/22/439">Steven Rostedt</a></li><li><a href="/lkml/2008/9/22/448">Mathieu Desnoyers</a></li><li><a href="/lkml/2008/9/22/468">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2008/9/22/457">Mathieu Desnoyers</a></li><li><a href="/lkml/2008/9/22/463">Masami Hiramatsu</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 22 Sep 2008 17:39:29 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Unified tracing buffer</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 22 Sep 2008, Masami Hiramatsu wrote:<br />&gt; <br />&gt; Sure, atomic counter might be more expensive but accurate for ordering.<br /><br />Don't be silly.<br /><br />An atomic counter is no more accurate for ordering than anything else.<br /><br />Why?<br /><br />Because all it tells you is the ordering of the atomic increment, not of <br />the caller. The atomic increment is not related to all the other ops that <br />the code that you trace actually does in any shape or form, and so the <br />ordering of the trace doesn't actually imply anything for the ordering of <br />the operations you are tracing!<br /><br />Except for a single CPU, of course, but for that case you don't need a <br />sequence number either, since the ordering is entirely determined by the <br />ring buffer itself.<br /><br />So the counter will be more expensive (cross-cpu cache bouncing for EVERY <br />SINGLE EVENT), less useful (no real meaning for people who DO want to have <br />a timestamp), and it's really no more "ordered" than anything that bases <br />itself on a TSC.<br /><br />The fact is, you cannot order operations based on log messages unless you <br />have a lock around the whole caller - absolutely _no_ amount of locking or <br />atomic accesses in the log itself will guarantee ordering of the upper <br />layers.<br /><br />And sure, if you have locking at a higher layer, then a sequence number is <br />sufficient, but on the other hand, so is a well-synchronized TSC.<br /><br />So personally, I think that the optimal solution is:<br /><br /> - let each ring buffer be associated with a "gettimestamp()" function, so <br />   that everybody _can_ set it to something of their own. But default to <br />   something sane, namely a raw TSC thing.<br /><br /> - Add synchronization events to the ring buffer often enough that you can <br />   make do with a _raw_ (ie unscaled) 32-bit timestamp. Possibly by simply <br />   noticing when the upper 32 bits change, although you could possibly do <br />   it with a heartbeat too.<br /><br /> - Similarly, add a synchronization event when the TSC frequency changes.<br /><br /> - Make the synchronization packet contain the full 64-bit TSC base, in <br />   addition to TSC frequency info _and_ the timebase.<br /><br /> - From those synchronization events, you should be able to get a very <br />   accurate timestamp *after* the fact from the raw TSC numbers (ie do all <br />   the scaling not when you gather the info, but when you present it), <br />   even if you only spent 32 bits of TSC info on 99% of all events (an <br />   just had a overflow log occasionally to get the rest of the info)<br /><br /> - Most people will be _way_ happier with a timestamp that has enough <br />   precision to also show ordering (assuming that the caller holds a <br />   lock over the operation _including_ the tracing) than they would ever <br />   be with a sequence number.<br /><br /> - people who really want to can consider the incrementing counter a TSC, <br />   but it will suck in so many ways that I bet it will not be very popular <br />   at all. But having the option to set a special timestamp function will<br />   give people the option (on a per-buffer level) to make the "TSC" be a <br />   simple incrementing 32-bit counter using xaddl and the upper bits <br />   incrementing from a timer, but keep that as a "ok, the TSC is really <br />   broken, or this architecture doesn't support any fast cycle counters at <br />   all, or I really don't care about time, just sequence, and I guarantee <br />   I have a single lock in all callers that makes things unambiguous"<br /><br />Note the "single lock" part. It's not enough that you make any trace thing <br />under a lock. They must be under the _same_ lock for all relevant events <br />for you to be able to say anything about ordering. And that's actually <br />pretty rare for any complex behavior.<br /><br />The timestamping, btw, is likely the most important part of the whole <br />logging thing. So we need to get it right. But by "right" I mean really <br />really low-latency so that it's acceptable to everybody, real-time enough <br />that you can tell how far apart events were, and precise enough that you <br />really _can_ see ordering.<br /><br />The "raw TSC value with correction information" should be able to give you <br />all of that. At least on x86. On some platforms, the TSC may not give you <br />enough resolution to get reasonable guesses on event ordering.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
