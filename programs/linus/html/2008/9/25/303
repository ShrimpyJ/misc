    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/9/25/267">First message in thread</a></li><li><a href="/lkml/2008/9/25/267">Steven Rostedt</a><ul><li><a href="/lkml/2008/9/25/266">Steven Rostedt</a></li><li><a href="/lkml/2008/9/25/268">Steven Rostedt</a><ul><li class="origin"><a href="/lkml/2008/9/25/311">Linus Torvalds</a><ul><li><a href="/lkml/2008/9/25/311">Steven Rostedt</a><ul><li><a href="/lkml/2008/9/25/319">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2008/9/25/322">Mathieu Desnoyers</a><ul><li><a href="/lkml/2008/9/25/328">Steven Rostedt</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 25 Sep 2008 10:02:02 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC PATCH 1/2 v2] Unified trace buffer</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 25 Sep 2008, Steven Rostedt wrote:<br />&gt; +<br />&gt; +/**<br />&gt; + * ring_buffer_event_length - return the length of the event<br />&gt; + * &#64;event: the event to get the length of<br />&gt; + *<br />&gt; + * Note, if the event is bigger than 256 bytes, the length<br />&gt; + * can not be held in the shifted 5 bits. The length is then<br />&gt; + * added as a short (unshifted) in the body.<br /><br />The comment seems stale ;)<br /><br />&gt; +<br />&gt; +/**<br />&gt; + * ring_buffer_peek - peek at the next event to be read<br />&gt; + * &#64;iter: The ring buffer iterator<br />&gt; + * &#64;iter_next_cpu: The CPU that the next event belongs on<br />&gt; + *<br />&gt; + * This will return the event that will be read next, but does<br />&gt; + * not increment the iterator.<br />&gt; + */<br />&gt; +struct ring_buffer_event *<br />&gt; +ring_buffer_peek(struct ring_buffer *buffer, int cpu, u64 *ts)<br />&gt; +{<br />&gt; +	struct ring_buffer_per_cpu *cpu_buffer;<br />&gt; +	struct ring_buffer_event *event;<br />&gt; +	u64 delta;<br />&gt; +<br />&gt; +	cpu_buffer = buffer-&gt;buffers[cpu];<br />&gt; +<br />&gt; + again:<br />&gt; +	if (ring_buffer_per_cpu_empty(cpu_buffer))<br />&gt; +		return NULL;<br />&gt; +<br />&gt; +	event = ring_buffer_head_event(cpu_buffer);<br />&gt; +<br />&gt; +	switch (event-&gt;type) {<br />&gt; +	case RB_TYPE_PADDING:<br />&gt; +		ring_buffer_inc_page(buffer, &amp;cpu_buffer-&gt;head_page);<br />&gt; +		rb_reset_read_page(cpu_buffer);<br />&gt; +		goto again;<br />&gt; +<br />&gt; +	case RB_TYPE_TIME_EXTENT:<br />&gt; +		delta = event-&gt;data;<br />&gt; +		delta &lt;&lt;= TS_SHIFT;<br />&gt; +		delta += event-&gt;time_delta;<br />&gt; +		cpu_buffer-&gt;read_stamp += delta;<br />&gt; +		goto again;<br />&gt; +<br />&gt; +	case RB_TYPE_TIME_STAMP:<br />&gt; +		/* FIXME: not implemented */<br />&gt; +		goto again;<br />&gt; +<br />&gt; +	case RB_TYPE_SMALL_DATA:<br />&gt; +	case RB_TYPE_LARGE_DATA:<br />&gt; +	case RB_TYPE_STRING:<br />&gt; +		if (ts)<br />&gt; +			*ts = cpu_buffer-&gt;read_stamp + event-&gt;time_delta;<br />&gt; +		return event;<br /><br />Your timestamp handling seems odd. You do it per-event, but I think it <br />should happen for all events, ie just do<br /><br />	*ts += event-&gt;time_delta;<br /><br />_outside_ the case statement, and then in RB_TYPE_TIME_EXTENT you'd do <br />either<br /><br /> - relative:<br />	*ts += event-&gt;data &lt;&lt; TS_SHIFT;<br /><br /> - absolute timestamp events:<br />	*ts = (event-&gt;data &lt;&lt; TS_SHIFT) + event-&gt;time_delta;<br /><br />but the bigger issue is that I think the timestamp should be relative to <br />the _previous_ event, not relative to the page start. IOW, you really <br />should accumulate them. <br /><br />IOW, the base timestamp cannot be in the cpu_buffer, it needs to be in the <br />iterator data structure, since it updates as you walk over it.<br /><br />Otherwise the extended TSC format will be _horrible_. You don't want to <br />add it in front of every event in the page just because you had a pause at <br />the beginning of the page. You want to have a running update, so that you <br />only need to add it after there was a pause.<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
