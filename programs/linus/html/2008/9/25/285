    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2008/9/24/13">First message in thread</a></li><li><a href="/lkml/2008/9/25/245">"Martin Bligh"</a><ul><li><a href="/lkml/2008/9/25/254">Ingo Molnar</a><ul><li><a href="/lkml/2008/9/25/275">Mathieu Desnoyers</a><ul><li><a href="/lkml/2008/9/25/279">Steven Rostedt</a><ul><li><a href="/lkml/2008/9/25/313">Mathieu Desnoyers</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2008/9/25/295">Linus Torvalds</a><ul><li><a href="/lkml/2008/9/25/295">Steven Rostedt</a><ul><li><a href="/lkml/2008/9/25/308">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2008/9/25/418">Jeremy Fitzhardinge</a><ul><li><a href="/lkml/2008/9/25/447">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 25 Sep 2008 09:40:42 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC PATCH 1/3] Unified trace buffer</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 25 Sep 2008, Ingo Molnar wrote:<br />&gt;<br />&gt; ... which is exactly what sched_clock() does, combined with a <br />&gt; multiplication. (which is about as expensive as normal linear <br />&gt; arithmetics on most CPUs - i.e. in the 1 cycle range)<br /><br />First off, that's simply not true.<br /><br />Yes, it happens to be true on modern x86-64 CPU's. But in very few other <br />places. Doing even just 64-bit multiples is _expensive_. It's not even <br />_near_ single-cycle.<br /><br />But more importantly:<br /><br />&gt; Normalizing has the advantage that we dont have to worry about it ever <br />&gt; again. Not about a changing scale due to cpufreq, slowing down or <br />&gt; speeding up TSCs due to C2/C3. We have so much TSC breakage all across <br />&gt; the spectrum that post-processing it is a nightmare in practice.<br /><br />Total and utter bullshit, all of it.<br /><br />Have you forgotten all the oopses due to divide-by-zero because <br />sched_clock() was called early? All that early code that we might well <br />want to trace through?<br /><br />Not only that, but have you forgotten about FTRACE and -pg? Which means <br />that every single C function calls into tracing code, and that can <br />basically only be disabled on a per-file basis? <br /><br />As for C2/C3 - that's just an argument for *not* doing anything at trace <br />time. What do you think happens when you try to trace through those <br />things? You're much better off trying to sort out the problems later, when <br />you don't hold critical locks and are possibly deep down in some buggy <br />ACPI code, and you're trying to trace it exactly _because_ it is buggy.<br /><br />The thing is, the trace timestamp generation should be at least capable of <br />being just a couple of versions of assembly language. If you cannot write <br />it in asm, you lose. You cannot (and MUST NOT) use things like a <br />virtualized TSC by mistake. If the CPU doesn't natively support 'rdtsc' in <br />hardware on x86, for example, you have to have another function altogether <br />for the trace timestamp.<br /><br />And no way in hell do we want to call complex indirection chains that take <br />us all over the map and have fragile dependencies that we have already hit <br />several times wrt things like cpufreq.<br /><br />WE ARE MUCH BETTER OFF WITH EVEN _INCORRECT_ TIME THAN WE ARE WITH FRAGILE <br />TRACE INFRASTUCTURE.<br /><br />&gt; Plus we want sched_clock() to be fast anyway.<br /><br />Yeah. And we want system calls to be _really_ fast, because they are even <br />more critical than the scheduler. So maybe we can use a "gettime()" system <br />call.<br /><br />IOW, your argument is a non-argument. No way in HELL do we want to mix up <br />sched_clock() in tracing. Quite the reverse. We want to have the ability <br />to trace _into_ sched_clock() and never even have to think about it!<br /><br />TSC is not pefect, but (a) it's getting better (as you yourself point <br />out), and in fact most other architectures already have the better <br />version. And (b) it's the kind of simplicity that we absolutely want.<br /><br />Do you realize, for example, that a lot of architectures really only have <br />a 32-bit TSC, and they have to emulate a 64-bit one (in addition to <br />conveting it to nanoseconds using divides) for the sched_clock()? They'd <br />almost certainly be much better off able to just use their native one <br />directly.<br /><br />Yeah, it would probably cause some code duplication, but the low-leel <br />trace infrastructure really is special. It can't afford to call other <br />subsystems helper functions, because people want to trace _those_.<br /><br />				Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
