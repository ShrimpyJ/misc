    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2003/12/13/113">First message in thread</a></li><li><a href="/lkml/2003/12/13/113">Anton Blanchard</a><ul><li><a href="/lkml/2003/12/13/114">Anton Blanchard</a><ul><li class="origin"><a href="/lkml/2003/12/14/4">Linus Torvalds</a><ul><li><a href="/lkml/2003/12/14/4">Anton Blanchard</a><ul><li><a href="/lkml/2003/12/14/6">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2003/12/14/1/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 13 Dec 2003 21:02:30 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: prepare_to_wait/waitqueue_active issues in 2.6</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Sun, 14 Dec 2003, Anton Blanchard wrote:<br />&gt;<br />&gt; &gt; End result is waitqueue_active returns 0 and buffer_locked returns 1.<br />&gt; &gt; We miss a wakeup. Game over. Ive attached a patch that forces the check<br />&gt; &gt; to happen after we are put on the waitqueue. Thanks to Brian Twichell<br />&gt; &gt; for the analysis and suggested fix for this.<br />&gt;<br />&gt; This time for sure.<br /><br />Pardon my French, but this patch sure looks like crap.<br /><br />Wouldn't it be better to just make sure "prepare_to_wait()" has the proper<br />barriers in it?  If you have problems with fs/buffer.c, then you should<br />have problems with the page_unlock() path in mm/filemap.c too, which has<br />_exactly_ the same logic.<br /><br />In fact, pretty much any use of "prepare_to_wait()" has the potential of<br />moving a subsequent test upwards to before the wait-queue addition, so<br />we'd have this bug for _any_ use of "waitqueue_active()". The spinlocks<br />protect from criticial data moving outside the critical region, but not<br />against movement in_to_ the critical region.<br /><br />In short - as-is, your patch looks to be right, but it only solves a small<br />part of what appears to be the larger problem.<br /><br />So my preference would be to add the barrier into prepare_to_wait(), along<br />with a comment on why it is sometimes needed.  Something like the<br />appended.. (which just uses "set_current_state()", since that's what it<br />exists for).<br /><br />Does this work for you? I'd much prefer to see a fix that fixes _all_ the<br />cases, and is just two lines (plus the comment, which is much more ;)<br /><br />		Linus<br /><br />----<br />--- 1.147/kernel/fork.c	Fri Dec 12 14:20:03 2003<br />+++ edited/kernel/fork.c	Sat Dec 13 20:59:29 2003<br />&#64;&#64; -125,15 +125,28 &#64;&#64;<br /><br /> EXPORT_SYMBOL(remove_wait_queue);<br /><br />+<br />+/*<br />+ * Note: we use "set_current_state()" _after_ the wait-queue add,<br />+ * because we need a memory barrier there on SMP, so that any<br />+ * wake-function that tests for the wait-queue being active<br />+ * will be guaranteed to see waitqueue addition _or_ subsequent<br />+ * tests in this thread will see the wakeup having taken place.<br />+ *<br />+ * The spin_unlock() itself is semi-permeable and only protects<br />+ * one way (it only protects stuff inside the critical region and<br />+ * stops them from bleeding out - it would still allow subsequent<br />+ * loads to move into the the critical region).<br />+ */<br /> void prepare_to_wait(wait_queue_head_t *q, wait_queue_t *wait, int state)<br /> {<br /> 	unsigned long flags;<br /><br />-	__set_current_state(state);<br /> 	wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;<br /> 	spin_lock_irqsave(&amp;q-&gt;lock, flags);<br /> 	if (list_empty(&amp;wait-&gt;task_list))<br /> 		__add_wait_queue(q, wait);<br />+	set_current_state(state);<br /> 	spin_unlock_irqrestore(&amp;q-&gt;lock, flags);<br /> }<br /><br />&#64;&#64; -144,11 +157,11 &#64;&#64;<br /> {<br /> 	unsigned long flags;<br /><br />-	__set_current_state(state);<br /> 	wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;<br /> 	spin_lock_irqsave(&amp;q-&gt;lock, flags);<br /> 	if (list_empty(&amp;wait-&gt;task_list))<br /> 		__add_wait_queue_tail(q, wait);<br />+	set_current_state(state);<br /> 	spin_unlock_irqrestore(&amp;q-&gt;lock, flags);<br /> }<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
