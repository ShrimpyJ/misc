    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2003/12/22/118">First message in thread</a></li><li><a href="/lkml/2003/12/22/118">John Dee</a><ul><li class="origin"><a href="/lkml/2003/12/22/165">Linus Torvalds</a><ul><li><a href="/lkml/2003/12/22/165">bert hubert</a></li><li><a href="/lkml/2003/12/22/200">Felipe Alfaro Solana</a></li><li><a href="/lkml/2003/12/31/12"> Valdis.Kletnieks&#64;vt ...</a><ul><li><a href="/lkml/2003/12/31/16">Linus Torvalds</a></li><li><a href="/lkml/2003/12/31/85"> viro&#64;parcelfa ...</a></li></ul></li></ul></li><li><a href="/lkml/2003/12/22/164">Gene Heskett</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 22 Dec 2003 13:31:51 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: hmm..</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 22 Dec 2003, John Dee wrote:<br />&gt;<br />&gt; I know you guys have already probably seen this.. figured I'd share with <br />&gt; the class, so the big kids can tear it apart.<br />&gt; <a href="https://lwn.net/Articles/64052/">http://lwn.net/Articles/64052/</a><br /><br />I spent half an hour tearing part of it apart for some journalists. No<br />guarantees for the full accuracy of this write-up, and in particular I<br />don't actually have "original UNIX" code to compare against, but the files<br />I checked (ctype.[ch]) definitely do not have any UNIX history to them.<br /><br />The rest of the files are mostly errno.h/signal.h/ioctl.h (and they are <br />apparently the 2.4.x versions, before we moved some common constants into <br />"asm-generic/errno.h"), and while I haven't analyzed them, I know for a <br />fact that<br /><br /> - the original errno.h used different error numbers than "original UNIX"<br /><br />   I know this because I cursed it later when it meant that doing things <br />   like binary emulation wasn't as trivial - you had to translate the <br />   error numbers.<br /><br /> - same goes for "signal.h": while a lot of the standard signals are well <br />   documented (ie "SIGKILL is 9"), historically we had lots of confusion <br />   (ie I think "real UNIX" has SIGBUS at 10, while Linux didn't originally <br />   have any SIGBUS at all, and later put it at 7 which was originally <br />   SIGUNUSED.<br /><br />So to me it looks like <br /><br /> - yes, Linux obviously has the same signal names and error number names <br />   that UNIX has (so the files certainly have a lot of the same <br />   identifiers)<br /><br /> - but equally clearly they weren't copied from any "real UNIX". <br /><br />(Later, non-x86 architectures have tried harder to be binary-compatible <br />with their "real UNIX" counter-parts, and as a result we have different <br />errno header files for different architectures - and on non-x86 <br />architectures the numbers will usually match traditional UNIX).<br /><br />For example, doing a "grep" for SIGBUS on the kernel shows that most<br />architectures still have SIGBUS at 7 (original Linux value), while alpha,<br />sparc, parisc and mips have it at 10 (to match "real UNIX").<br /><br />What this tells me is that the original code never came from UNIX, but<br />some architectures later were made to use the same values as UNIX for<br />binary compatibility (I know this is true for alpha, for example: being<br />compatible with OSF/1 was one of my very early goals in that port).<br /><br />In other words, I think we can totally _demolish_ the SCO claim that these <br />65 files were somehow "copied". They clearly are not.<br /><br />Which should come as no surprise to people. But I think it's nice to see <br />just _how_ clearly we can show that SCO is - yet again - totally <br />incorrect.<br /><br />		Linus<br /><br />----<br /><br />For example, SCO lists the files "include/linux/ctype.h" and<br />"lib/ctype.h", and some trivial digging shows that those files are<br />actually there in the original 0.01 distribution of Linux (ie September of<br />1991). And I can state <br /><br /> - I wrote them (and looking at the original ones, I'm a bit ashamed: <br />   the "toupper()" and "tolower()" macros are so horribly ugly that I <br />   wouldn't admit to writing them if it wasn't because somebody else <br />   claimed to have done so ;)<br /><br /> - writing them is no more than five minutes of work (you can verify that <br />   with any C programmer, so you don't have to take my word for it)<br /><br /> - the details in them aren't even the same as in the BSD/UNIX files (the <br />   approach is the same, but if you look at actual implementation details <br />   you will notice that it's not just that my original "tolower/toupper"  <br />   were embarrassingly ugly, a number of other details differ too).<br /><br />In short: for the files where I personally checked the history, I can<br />definitely say that those files are trivially written by me personally,<br />with no copying from any UNIX code _ever_.<br /><br />So it's definitely not a question of "all derivative branches". It's a<br />question of the fact that I can show (and SCO should have been able to<br />see) that the list they show clearly shows original work, not "copied".<br /><br /><br />	Analysis of "lib/ctype.c" and "include/linux/ctype.h".<br /><br /><br />First, some background: the "ctype" name comes "character type", and the<br />whole point of "ctype.h" and "ctype.c" is to test what kind of character<br />we're dealing with. In other words, those files implement tests for doing<br />things like asking "is this character a digit" or "is this character an<br />uppercase letter" etc. So you can write thing like<br /><br />	if (isdigit(c)) {<br />		.. we do something with the digit ..<br /><br />and the ctype files implement that logic.<br /><br />Those files exist (in very similar form) in the original Linux-0.01 <br />release under the names "lib/ctype.c" and "include/ctype.h". That kernel <br />was released in September of 1991, and contains no code except for mine <br />(and Lars Wirzenius, who co-wrote "kernel/vsprintf.c").<br /><br />In fact, you can look at the files today and 12 years ago, and you can see <br />clearly that they are largely the same: the modern files have been cleaned <br />up and fix a number of really ugly things (tolower/toupper works <br />properly), but they are clearly incremental improvement on the original <br />one.<br /><br />And the original one does NOT look like the unix source one. It has <br />several similarities, but they are clearly due to:<br /><br /> - the "ctype" interfaces are defined by the C standard library.<br /><br /> - the C standard also specifies what kinds of names a system library <br />   interface can use internally. In particular, the C standard specifies <br />   that names that start with an underscore and a capital letter are <br />   "internal" to the library. This is important, because it explains why<br />   both the Linux implementation _and_ the UNIX implementation used a<br />   particular naming scheme for the flags.<br /><br /> - algorithmically, there aren't that many ways to test whether a <br />   character is a number or not. That's _especially_ true in<br />   C, where a macro must not use it's argument more than once. So for <br />   example, the "obvious" implementation of "isdigit()" (which tests for <br />   whether a character is a digit or not) would be<br /><br />	#define isdigit(x) ((x) &gt;= '0' &amp;&amp; (x) &lt;= '9')<br /><br />   but this is not actually allowed by the C standard (because 'x' is used <br />   twice).<br /><br />   This explains why both Linux and traditional UNIX use the "other" <br />   obvious implementation: having an array that describes what each of the <br />   possible 256 characters are, and testing the contents of that array<br />   (indexed by the character) instead. That way the macro argument is only <br />   used once.<br /><br />The above things basically explain the similarities. There simply aren't<br />that many ways to do a standard C "ctype" implementation, in other words.<br /><br />Now, let's look at the _differences_ in Linux and traditional UNIX:<br /><br /> - both Linux and traditional unix use a naming scheme of "underscore and <br />   a capital letter" for the flag names. There are flags for "is upper <br />   case" (_U) and "is lower case" (_L), and surprise surprise, both UNIX <br />   and Linux use the same name. But think about it - if you wanted to use <br />   a short flag name, and you were limited by the C standard naming, what <br />   names _would_ you use? Maybe you'd select "U" for "Upper case" and "L" <br />   for "Lower case"?<br /><br />   Looking at the other flags, Linux uses "_D" for "Digit", while<br />   traditional UNIX instead uses "_N" for "Number". Both make sense, but <br />   they are different. I personally think that the Linux naming makes more <br />   sense (the function that tests for a digit is called "isdigit()", not<br />   "isnumber()"), but on the other hand I can certainly understand why <br />   UNIX uses "_N" - the function that checs for whether a character is <br />   "alphanumeric" is called "isalnum()", and that checks whether the <br />   character is a upper case letter, a lower-case letter _or_ a digit (aka <br />   "number").<br /><br />   In short: there aren't that many ways you can choose the names, and <br />   there is lots of overlap, but it's clearly not 100%.<br /><br /> - The original Linux ctype.h/ctype.c file has obvious deficiencies, which <br />   pretty much point to somebody new to C making mistakes (me) rather than <br />   any old and respected source. For example, the "toupper()/tolower()"  <br />   macros are just totally broken, and nobody would write the "isascii()" <br />   and "toascii()" the way they were written in that original Linux. And<br />   you can see that they got fixed later on in Linux development, even <br />   though you can also see that the files otherwise didn't change.<br /><br />   For example: remember how C macros must only use their argument once <br />   (never mind why - you really don't care, so just take it on faith, for<br />   now). So let's say that you wanted to change an upper case character <br />   into a lower case one, which is what "tolower()" does. Normal use is <br />   just a fairly obvious<br /><br />	newchar = tolower(oldchar);<br /><br />   and the original Linux code does<br /><br />	extern char _ctmp;<br />	#define tolower(c) (_ctmp=c,isupper(_ctmp)?_ctmp+('a'+'A'):_ctmp)<br /><br />   which is not very pretty, but notice how we have a "temporary <br />   character" _ctmp (remember that internal header names should start with<br />   an underscore and an upper case character - this is already slightly <br />   broken in itself). That's there so that we can use the argument "c" <br />   only once - to assign it to the new temporary - and then later on we <br />   use that temporary several times.<br /><br />   Now, the reason this is broken is <br /><br />    - it's not thread-safe (if two different threads try to do this at <br />      once, they will stomp on each others temporary variable)<br /><br />    - the argument (c) might be a complex expression, and as such it<br />      should really be parenthesized. The above gets several valid <br />      (but unusual) expressions wrong.<br /><br />Basically, the above is _exactly_ the kinds of mistakes a young programmer <br />would make. It's classic.<br /><br />And I bet it's _not_ what the UNIX code looked like, even in 1991. UNIX by<br />then was 20 years old, and I _think_ that it uses a simple table lookup<br />(which makes a lot more sense anyway and solves all problems). I'd be very<br />susprised if it had those kinds of "beginner mistakes" in it, but I don't <br />actually have access to the code, so what do I know? (I can look up some <br />BSD code on the web, it definitely does _not_ do anythign like the above).<br /><br />The lack of proper parenthesis exists in other places of the original <br />Linux ctype.h file too: isascii() and toascii() are similarly broken.<br /><br />In other words: there are _lots_ of indications that the code was not <br />copied, but was written from scratch. Bugs and all.<br /><br />Oh, another detail: try searching the web (google is your friend) for <br />"_ctmp". It's unique enough that you'll notice that all the returned hits <br />are all Linux-related. No UNIX hits anywhere. Doing a google for<br /><br />	_ctmp -linux<br /><br />shows more Linux pages (that just don't happen to have "linux" in them),<br />except for one which is the L4 microkernel, and that one shows that they<br />used the Linux header file (it still says "_LINUX_CTYPE_H" in it).<br /><br />So there is definitely a lot of proof that my ctype.h is original work.<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
