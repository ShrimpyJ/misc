    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2003/11/24/124">First message in thread</a></li><li><a href="/lkml/2003/11/24/180">Bradley Chapman</a><ul><li><a href="/lkml/2003/11/24/183">Linus Torvalds</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2003/11/24/196/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 24 Nov 2003 15:45:24 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: What exactly are the issues with 2.6.0-test10 preempt?</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Mon, 24 Nov 2003, Linus Torvalds wrote:<br />&gt;<br />&gt; The PAGEFREE debug option works well for page allocations, but the slab<br />&gt; cache is not very amenable to it. For slab debugging, it would be<br />&gt; wonderful if somebody made a _truly_ debugging slab allocator that didn't<br />&gt; use the slab cache at all, but used the page allocator (and screw the fact<br />&gt; that you use too much memory ;) instead.<br /><br />Ok, this is quite possibly the ugliest patch I've ever made, but it might<br />catch some of the "use-after-free" issues with slab.<br /><br />IT WILL NOT WORK IN GENERAL! In particular, you'll need to have tons of<br />memory free for this patch to work, since it basically scrapes off all the<br />regular slab code, and replaces it with some really nasty crud. I was<br />lazy. Whatever. It means that the slab memory balancing won't work etc,<br />but maybe somebody else can integrate my quick hack better.<br /><br />It boots for me, but I won't say anything beyond that (oh, do NOT enable<br />slab debugging if you want to test this out - I pretty much guarantee it<br />won't work with this hack. You should enable DEBUG_PAGEALLOC instead,<br />and see if you get anything interesting out of that..).<br /><br />		Linus<br /><br />-----<br />--- 1.110/mm/slab.c	Tue Oct 21 22:10:10 2003<br />+++ edited/mm/slab.c	Mon Nov 24 15:34:23 2003<br />&#64;&#64; -1906,6 +1906,21 &#64;&#64;<br /><br /> static inline void * __cache_alloc (kmem_cache_t *cachep, int flags)<br /> {<br />+#if 1<br />+	void *ptr = (void*)__get_free_pages(flags, cachep-&gt;gfporder);<br />+	if (ptr) {<br />+		struct page *page = virt_to_page(ptr);<br />+		SET_PAGE_CACHE(page, cachep);<br />+		SET_PAGE_SLAB(page, 0x01020304);<br />+		if (cachep-&gt;ctor) {<br />+			unsigned long ctor_flags = SLAB_CTOR_CONSTRUCTOR;<br />+			if (!(flags &amp; __GFP_WAIT))<br />+				ctor_flags |= SLAB_CTOR_ATOMIC;<br />+			cachep-&gt;ctor(ptr, cachep, ctor_flags);<br />+		}<br />+	}<br />+	return ptr;<br />+#else<br /> 	unsigned long save_flags;<br /> 	void* objp;<br /> 	struct array_cache *ac;<br />&#64;&#64; -1925,6 +1940,7 &#64;&#64;<br /> 	local_irq_restore(save_flags);<br /> 	objp = cache_alloc_debugcheck_after(cachep, flags, objp, __builtin_return_address(0));<br /> 	return objp;<br />+#endif<br /> }<br /><br /> /*<br />&#64;&#64; -2043,10 +2059,20 &#64;&#64;<br /> static inline void __cache_free (kmem_cache_t *cachep, void* objp)<br /> {<br /> 	struct array_cache *ac = ac_data(cachep);<br />+<br /><br /> 	check_irq_off();<br /> 	objp = cache_free_debugcheck(cachep, objp, __builtin_return_address(0));<br /><br />+#if 1<br />+	{<br />+		struct page *page = virt_to_page(objp);<br />+		int order = cachep-&gt;gfporder;<br />+		if (cachep-&gt;dtor)<br />+			cachep-&gt;dtor(objp, cachep, 0);<br />+		__free_pages(page, order);<br />+	}<br />+#else<br /> 	if (likely(ac-&gt;avail &lt; ac-&gt;limit)) {<br /> 		STATS_INC_FREEHIT(cachep);<br /> 		ac_entry(ac)[ac-&gt;avail++] = objp;<br />&#64;&#64; -2056,6 +2082,7 &#64;&#64;<br /> 		cache_flusharray(cachep, ac);<br /> 		ac_entry(ac)[ac-&gt;avail++] = objp;<br /> 	}<br />+#endif<br /> }<br /><br /> /**<br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
