    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2003/8/22/104">First message in thread</a></li><li><a href="/lkml/2003/8/22/104">David Howells</a><ul><li class="origin"><a href="/lkml/2003/8/22/138">Linus Torvalds</a><ul><li><a href="/lkml/2003/8/22/138">David Howells</a><ul><li><a href="/lkml/2003/8/22/158">Linus Torvalds</a><ul><li><a href="/lkml/2003/8/26/67">David Howells</a></li><li><a href="/lkml/2003/8/27/126">David Howells</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 22 Aug 2003 09:19:27 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: authentication / encryption key retention</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Fri, 22 Aug 2003, David Howells wrote:<br />&gt; <br />&gt; I think the best way is to have a stack of "personae" attached to a<br />&gt; process. Each persona would then have an identity (UID) and a sequence of keys.<br /><br />I don't know if UID helps much. What would you use it for?<br /><br />The UID is already used to index into the "struct user" thing, and that<br />can (and probably should) contain a set of keys associated with that user.  <br />That implies that we _already_ have a UID -&gt; set-of-key translation,<br />without actually mixing the UID with the keys themselves.<br /><br />&gt; The top persona on the stack would define what the process looked like to other<br />&gt; processes - controlling access to the process by signal and ptrace.<br /><br />This is what we do have UID's for, and changing that would break a lot of <br />existing security-conscious programs potentially very badly. Another <br />reason not to mix up the uid/key concepts.<br /><br />&gt; One of the personae on the stack would be elected to be the "effective" one -<br />&gt; the one that gets attached to newly opened files, and is used to specify access<br />&gt; to other processes for signal and ptrace.<br /><br />You really want the "file open" part to be the thing that decides which <br />key or bunch of keys are relevant to that file open. And I don't think it <br />would have anything to do with a persona: a file open will care about the <br />particular keys needed for that connection/filesystem/file, not about <br />"persons".<br /><br />While a person will want to have keys associated with multiple _different_ <br />filesystems or connections. <br /><br />So there is no 1:1 relationship there.<br /><br />So my suggestion boils down to:<br /><br /> - do _not_ mix up current uid/gid issues with key management. It will <br />   only cause untold pain for programs that expect to care only about <br />   uids. <br /><br />   So uid/group changes would happen exactly like they do now: and they <br />   would result only in _purely_ uid/gid-related security elevation. <br /><br />   Of course, since we can have uid/gid-specific key bunches (ie the <br />   "struct user" thing), when you have a setuid program that switches to <br />   another user, you may implicitly get access to that users keys. But <br />   that is only a direct result of the setuid itself, and doesn't change <br />   the security model of setuid. It's 100% equivalent.<br /><br /> - For "group of key management", I do think you want to have your <br />   "persona", but not because you want to associate them directly with <br />   uid/gid issues, but because you would need to have some mechanism to <br />   pass many unrelated keys around, without having to pass around _all_ <br />   your own keys.<br /><br />   And also, probably more importantly, it would also be the way to<br />   invalidate a bunch of keys (ie the security deamon that gave you a <br />   particular bucket because you identified yourself to it can invalidate<br />   the whole bucket without actually having to invalidate each key <br />   separately).<br /><br />   So it would be just a "bucket of keys" you got from somewhere. Maybe <br />   you get a couple of buckets as part of your login, and maybe you have <br />   to do some strong authentication to a security server to get another<br />   "bucket".<br /><br />   But "two buckets" would not make "one larger bucket".<br /><br />My personal favourite would actually be to allow "buckets of buckets of <br />[buckets of] keys". The reason you may want this is:<br /><br /> - it must _not_ be possible to read out a key just because you have <br />   access to it. In networked filesystems, keys don't have any specific <br />   relevance (they're just random bits), but in many other cases they _do_ <br />   have special relevance (ie they could be somebody's private key that he<br />   gave you temporary access to).<br /><br /> - this means that once you get a key or a "bucket of keys", you can't <br />   just re-create it. The only thing you can do is to create another <br />   reference to it. So if you want to pass off the keys you got to some <br />   third party, together with a few new keys of your own, you'd really <br />   need to create a new "bucket" that contains a pointer to the old bucket<br />   along with the new keys.<br /><br />(disallowing recursive buckets is an issue, but is pretty trivial)<br /><br />So the data structures could be something really trivial, like<br /><br />	struct key_bucket {<br />		int type;	/* bucket or individual key */<br />		atomic_t count;	/* reference count */<br />		int valid;<br />		char *name;	/* identifier of creator of this bucket */<br />		union {<br />			struct key *key;<br />			struct bucket *bucket;<br />		}<br />	};<br /><br />	struct key {<br />		int type;<br />		atomic_t count;<br />		const char *description;<br />		const char *blob;<br />	};<br /><br />	struct bucket {<br />		int entries;<br />		struct key_bucket *list[];<br />	};<br /><br />and now "struct key_bucket" can be just a single key, or it can be a <br />bucket of single keys, or it can be a bucket of mixed keys/buckets.<br /><br />(Yeah, the contents of "struct key" are totally made-up. The "blob" is the <br />content-dependent part of the key, but they will obviusly depend on what <br />kind of key it is, so you need some higher-level description of the key so <br />that the _users_ of the key can search for a key they are interested in.)<br /><br />And notice how you can invalidate an arbitrary bucket by just marking it<br />"invalid" - that doesn't invalidate any of the keys contained within, but<br />it just means that the key_bucket cannot be searched/looked up any more,<br />and thus it's effectively disabled.<br /><br />What I really care about is:<br /><br /> - the data structure/mechanism should be totally agnostic about the kind <br />   of keys you hide in there. The only thing that should be contained in <br />   the keys/buckets (apart from the key blob itself) is enough meta-data <br />   that we can have an a sane "look up keys of type xxx" operation. <br /><br /> - you do _not_ depend on "read the keys, duplicate them, write them out <br />   again as a new bunch" as a maintenance operation. That does _not_work_ <br />   for keys that are supposed to be private. If I give somebody else my <br />   key, that does not mean that he can read it. He can use it, but he <br />   can't make a copy.<br /><br />With the straw-man bucket-of-buckets proposals, you can now endow _any_ <br />data structure with any random collection of keys by just adding a<br /><br />	struct key_bucket *keys;<br /><br />entry to it.<br /><br />(And I'm carefully staying out of guessing what functions we want to have <br />to iterate over all keys of a specific type. But it doesn't look <br />impossible).<br /><br />		Linus<br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
