    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2003/8/22/104">First message in thread</a></li><li><a href="/lkml/2003/8/22/120">Linus Torvalds</a><ul><li><a href="/lkml/2003/8/22/138">David Howells</a><ul><li class="origin"><a href="/lkml/2003/8/26/67">Linus Torvalds</a><ul><li><a href="/lkml/2003/8/26/67">David Howells</a><ul><li><a href="/lkml/2003/8/26/157">Alan Cox</a></li><li><a href="/lkml/2003/8/26/173">Stephen Smalley</a></li></ul></li><li><a href="/lkml/2003/8/27/126">David Howells</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 22 Aug 2003 11:38:34 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: authentication / encryption key retention</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br />On Fri, 22 Aug 2003, David Howells wrote:<br />&gt; <br />&gt; &gt; You really want the "file open" part to be the thing that decides which <br />&gt; &gt; key or bunch of keys are relevant to that file open.<br />&gt; <br />&gt; Agreed. But there are some issues:<br />&gt; <br />&gt;  (1) Which key does it pick? There needs to be some ordering on the keys<br />&gt;      attached to a process, and it must be possible for the process to either<br />&gt;      rearrange these keys or to have a say in which key file-&gt;open() selects.<br /><br />I would think we can do this by just having a well-known search order. For<br />example, if we just end up with a "tree of buckets", we just make the<br />search order be depth-first, and you can this pick and choose which<br />buckets you access first by just ordering how you add a new bucket.<br /><br />But I think it ends up being a secondary issue, because _most_ of the time <br />you're likely to have just one key that "fits the lock".<br /><br />So I wouldn't worry about it _too_ much, at least until we have code that <br />works and is used by multiple subsystems.<br /><br />&gt;  (2) Key retirement. If file-&gt;open() selects a key that subsequently gets<br />&gt;      retired, should the filesystem be able to select another key from the<br />&gt;      original set of keyrings? Or should it thenceforth return an error?<br /><br />I think you have to return an error in the general case. You may have done <br />actions with the key that are hard to just move over to another one.<br /><br />Again, if that ends up being a real problem, maybe the solution is just <br />"don't do that then". Or maybe the solution ends up being to have <br />infrastructure to switch keys on the fly. <br /><br />But don't overdesign. Start from a small set of basic requirments, and <br />make a simple implementation. Go from there.<br /><br />&gt;  (3) Memory. You've only got so much. Do you want every open() call to go and<br />&gt;      build a keyring containing a subset of a process's keys.<br /><br />No, usually it would just search the keyring, and increment the reference<br />count for the key it finds (or the whole bucket. Or a sub-bucket. Some<br />subsystems might want to just say "I want it all" - it's the only sane<br />thing to do if the subsystem really decides that it wants to be able to<br />switch keys around on failure, I suspect).<br /><br />&gt; Except that the UID is also a key for some filesystems.<br /><br />Yes, but those filesystems will NOT use the "extended key" functionality <br />at all.<br /><br />It would be silly to make existing ext2 users use the new keys. They'll <br />just use "uid" and "gid" like they always have been.<br /><br />Purists go "hey, that's having two totally different mechanisms for the <br />same thing - security". But sane people go "why complicate the issue <br />unnecessarily".<br /><br />&gt; How about this? Taking your suggestion for nested keyrings, a process has a<br />&gt; ring of private keyrings labelled uniquely within that process that define all<br />&gt; the keys it currently has access to:<br />&gt; <br />&gt;   Keyring "_process.11374"<br />&gt;     Keyring "_uid.4043"		# UID default keyring<br />&gt;     Keyring "_gid.100"		# GID default keyring<br />&gt;     Keyring "_groups"		# GROUPS keyring<br />&gt;     Keyring "_leant.0"		# keyring acquired from another program<br />&gt;     Keyring "KDE-dhowells1"	# user specified keyring<br />&gt;     Keyring "AFS-dhowells"	# user specified keyring<br /><br />I'd actually suggest keeping the uid/gid keyrings off the "process <br />keyring".<br /><br />So each process would have a a few different keyrings:<br /><br /> - the process-local one: "current-&gt;keyring"<br /><br /> - the UID-local one: either "current-&gt;fsuid-&gt;keyring" (ie maintaining a <br />   "fsuid" structure pointer over fsuid changes) or just having a hash <br />   function from "uid" -&gt; "keyring"<br /><br /> - the group-local one: "current-&gt;group-&gt;keyring" or "gid" -&gt; "keyring" <br />   hash function.<br /><br />and they'd be all separate (they could have overlap, of course, but the<br />difference is that this makes it very easy to change groups and uid's:  <br />such changes would _not_ touch the "process-local" keys at all).<br /><br />So part of the search order would be the order these are used in looking <br />stuff up. My "obvious" order would be to do process-local first, then <br />user-local, and finally group-local.<br /><br />But some parts of the kernel might look at only the process-local keys <br />("does this process have rights to do that?") or look at other localities <br />("does this socket have the keys to do that?") entirely.<br /><br />&gt; &gt;  - it must _not_ be possible to read out a key just because you have <br />&gt; &gt;    access to it.<br />&gt; <br />&gt; Agreed (from userspace at least). However, you might want to be able to see<br />&gt; the key descriptions if not the payload.<br /><br />Yes. You definitely want to have an extended "id" program that allows you <br />to see the descriptions and types.<br /><br />&gt; The problem with that is you can't pass a subset, only a complete<br />&gt; set. Hmmm... I think it ought to be possible to filter on description, but<br />&gt; that the data should not ever return to userspace.<br /><br />No, you can certainly pass subsets too, by just having a "create a new <br />bucket that contains these other buckets" (which you got from the lookup <br />operation). You never see what the actual keys are, but each bucket and <br />each key do have an ID field, so you can create buckets by reference that <br />way.<br /><br />&gt; I think an ACL is a must (as I've said before). The ACL should provide the<br />&gt; following rights:<br /><br />Who not just make ACL's part of the "bucket of keys", but make them<br />basically "conditional keys" (in the "type field", the same way we<br />distinguish between buckets and keys). A conditional key is a key in<br />itself, but it's a requirement thing: you can do this operation on the<br />tree of keys only if you also have access to the non-conditional version<br />of this key.<br /><br />I think it would be a mistake to have _another_ level of keys/ACL's just<br />to keep track of what keys you can modify. "Quid custodiet ipsos<br />custodies?". Where would it end?<br /><br />Having the tree-of-keys have branches that can be conditional on another <br />key solves the problem. It would be a "you can only add this keyring to <br />your tree if you already have that other key" kind of thing. All <br />self-contained within the architecture.<br /><br />&gt; &gt;  - you do _not_ depend on "read the keys, duplicate them, write them out <br />&gt; &gt;    again as a new bunch" as a maintenance operation. That does _not_work_ <br />&gt; &gt;    for keys that are supposed to be private. If I give somebody else my <br />&gt; &gt;    key, that does not mean that he can read it. He can use it, but he <br />&gt; &gt;    can't make a copy.<br />&gt; <br />&gt; I wasn't advocating that userspace _should_ necessarily be allowed to read the<br />&gt; payload of a key. If at all possible, then it should strictly be under the<br />&gt; control of an ACL.<br /><br />Well, that was how the previous key management approach worked. I just <br />wanted to make clear that this was one reason I considered it unusable.<br /><br />		Linus<br /><br /><br />-<br />To unsubscribe from this list: send the line "unsubscribe linux-kernel" in<br />the body of a message to majordomo&#64;vger.kernel.org<br />More majordomo info at  <a href="http://vger.kernel.org/majordomo-info.html">http://vger.kernel.org/majordomo-info.html</a><br />Please read the FAQ at  <a href="http://www.tux.org/lkml/">http://www.tux.org/lkml/</a><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
