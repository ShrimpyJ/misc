    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2014/11/14/656">First message in thread</a></li><li><a href="/lkml/2014/12/21/205">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/21/208">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/21/209">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/21/210">Dave Jones</a></li><li><a href="/lkml/2014/12/21/246">"Paul E. McKenney"</a></li></ul></li><li class="origin"><a href="/lkml/2014/12/22/400">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/22/400">Linus Torvalds</a></li><li><a href="/lkml/2014/12/22/459">Dave Jones</a><ul><li><a href="/lkml/2014/12/22/478">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2014/12/22/479">John Stultz</a><ul><li><a href="/lkml/2014/12/22/489">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2015/1/12/173">Thomas Gleixner</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2014/12/22/392/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 22 Dec 2014 11:47:37 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: frequent lockups in 3.18rc4</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Dec 21, 2014 at 4:41 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; This is *not* to say that this is the bug you're hitting. But it does show that<br />&gt;<br />&gt;  (a) a flaky HPET can do some seriously bad stuff<br />&gt;  (b) the kernel is very fragile wrt time going backwards.<br />&gt;<br />&gt; and maybe we can use this test program to at least try to alleviate problem (b).<br /><br />Ok, so after several false starts (ktime_get() is really really<br />fragile - called in scheduler things, and doing magic things at<br />bootup), here is something that seems to alleviate the problem for me.<br /><br />I still get a lot of RCU  messages like "self-detected stall" etc, but<br />that's to be expected. When the clock does odd things, crap *will*<br />happen.<br /><br />But what this does is:<br /><br /> (a) make the error more visible as a clock error rather than various<br />random downstream users<br /><br />     IOW, it prints things out when it looks like we're getting odd<br />clock read errors (arbitrary cut-off: we expect clock read-outs to be<br />withing 1/8th of the range of the expected clock value)<br /><br /> (b) try to alleviate the horrible things that happen when the clock<br />error is big<br /><br />     The patch tries to "correct" for the huge time jump by basically<br />undoing it. We'll still see time jumps (there really is no way to<br />avoid it), but we limit the range of them.<br /><br />With the attached patch, my machine seems to survive me writing to the<br />HPET master counter register. It spews warnings, and it is noisy about<br />the odd clock reads:<br /><br />    ...<br />    Clocksource hpet had cycles off by 642817751<br />    Cutting it too close for hpet in in update_wall_time (offset = 4034102337)<br />    INFO: rcu_sched self-detected stall on CPU { 0}  (t=281743 jiffies<br />g=4722 c=4721 q=14)<br />    ...<br /><br />and there may still be situations where it does horrible horrible<br />things due to the (smaller) time leaps, but it does seem a lot more<br />robust.<br /><br />NOTE! There's an (intentional) difference in how we handle the time<br />leaps at time read time vs write (wall-clock update).<br /><br />At time read time, we just refuse to believe the big delta, and we set<br />the "cycle_error" value so that future time reads will be relative to<br />the error we just got. We also don't print anything out, because we're<br />possibly deep in the scheduler or in tracing, and we do not want to<br />spam the console about our fixup.<br /><br />At time *write* time, we first report about any read-time errors, and<br />then we report (but believe in) overlarge clocksource delta errors as<br />we update the time.<br /><br />This seems to be the best way to limit the damage.<br /><br />Also note that the patch is entirely clock-agnostic. It's just that I<br />can trivially screw up my HPET, I didn't look at other clocks.<br /><br />One note: my current limit of clocksource delta errors is based on the<br />range of the clock (1/8th of the range). I actually think that's<br />bogus, and it should instead be based on the expected frequency of the<br />clock (ie "we are guaranteed to update the wall clock at least once<br />every second, so if the clock source delta read is larger than one<br />second, we've done something wrong"). So this patch is meant very much<br />as an RFC, rather than anything else. It's pretty hacky. But it does<br />actually make a huge difference for me wrt the "mess up HPET time on<br />purpose". That used to crash my machine pretty hard, and pretty<br />reliably. With this patch, I've done it ten+ times, and while it spews<br />a lot of garbage, the machine stays up and _works_.<br /><br />Making the sanity check tighter (ie the "one second" band rather than<br />"1/8th of the clock range") would probably just improve it further.<br /><br />Thomas, what do you think? Hate it? Any better ideas?<br /><br />And again: this is not trying to make the kernel clock not jump. There<br />is no way I can come up with even in theory to try to really *fix* a<br />fundamentally broken clock.<br /><br />So this is not meant to be a real "fix" for anything, but is meant to<br />make sure that if the clock is unreliable, we pinpoint the clock<br />itself, and it mitigates the absolutely horrendously bad behavior we<br />currently with bad clocks. So think of this as debug and band-aid<br />rather than "this makes clocks magically reliable".<br /><br />.. and we might still lock up under some circumstances. But at least<br />from my limited testing, it is infinitely much better, even if it<br />might not be perfect. Also note that my "testing" has been writing<br />zero to the HPET lock (so the HPET clock difference tends to be pretty<br />specific), while my next step is to see what happens when I write<br />random values (and a lot of them).<br /><br />Since I expect that to cause more problems, I thought I'd send this<br />RFC out before I start killing my machine again ;)<br /><br />                             Linus<br /> include/linux/timekeeper_internal.h |  1 +<br /> kernel/time/timekeeping.c           | 25 ++++++++++++++++++++++++-<br /> 2 files changed, 25 insertions(+), 1 deletion(-)<br /><br />diff --git a/include/linux/timekeeper_internal.h b/include/linux/timekeeper_internal.h<br />index 05af9a334893..0fcb60d77079 100644<br />--- a/include/linux/timekeeper_internal.h<br />+++ b/include/linux/timekeeper_internal.h<br />&#64;&#64; -32,6 +32,7 &#64;&#64; struct tk_read_base {<br /> 	cycle_t			(*read)(struct clocksource *cs);<br /> 	cycle_t			mask;<br /> 	cycle_t			cycle_last;<br />+	cycle_t			cycle_error;<br /> 	u32			mult;<br /> 	u32			shift;<br /> 	u64			xtime_nsec;<br />diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c<br />index 6a931852082f..1c842ddd567f 100644<br />--- a/kernel/time/timekeeping.c<br />+++ b/kernel/time/timekeeping.c<br />&#64;&#64; -140,6 +140,7 &#64;&#64; static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)<br /> 	tk-&gt;tkr.read = clock-&gt;read;<br /> 	tk-&gt;tkr.mask = clock-&gt;mask;<br /> 	tk-&gt;tkr.cycle_last = tk-&gt;tkr.read(clock);<br />+	tk-&gt;tkr.cycle_error = 0;<br /> <br /> 	/* Do the ns -&gt; cycle conversion first, using original mult */<br /> 	tmp = NTP_INTERVAL_LENGTH;<br />&#64;&#64; -197,11 +198,17 &#64;&#64; static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)<br /> 	s64 nsec;<br /> <br /> 	/* read clocksource: */<br />-	cycle_now = tkr-&gt;read(tkr-&gt;clock);<br />+	cycle_now = tkr-&gt;read(tkr-&gt;clock) + tkr-&gt;cycle_error;<br /> <br /> 	/* calculate the delta since the last update_wall_time: */<br /> 	delta = clocksource_delta(cycle_now, tkr-&gt;cycle_last, tkr-&gt;mask);<br /> <br />+	/* Hmm? This is really not good, we're too close to overflowing */<br />+	if (unlikely(delta &gt; (tkr-&gt;mask &gt;&gt; 3))) {<br />+		tkr-&gt;cycle_error = delta;<br />+		delta = 0;<br />+	}<br />+<br /> 	nsec = delta * tkr-&gt;mult + tkr-&gt;xtime_nsec;<br /> 	nsec &gt;&gt;= tkr-&gt;shift;<br /> <br />&#64;&#64; -465,6 +472,16 &#64;&#64; static void timekeeping_update(struct timekeeper *tk, unsigned int action)<br /> 	update_fast_timekeeper(tk);<br /> }<br /> <br />+static void check_cycle_error(struct tk_read_base *tkr)<br />+{<br />+	cycle_t error = tkr-&gt;cycle_error;<br />+<br />+	if (unlikely(error)) {<br />+		tkr-&gt;cycle_error = 0;<br />+		pr_err("Clocksource %s had cycles off by %llu\n", tkr-&gt;clock-&gt;name, error);<br />+	}<br />+}<br />+<br /> /**<br />  * timekeeping_forward_now - update clock to the current time<br />  *<br />&#64;&#64; -481,6 +498,7 &#64;&#64; static void timekeeping_forward_now(struct timekeeper *tk)<br /> 	cycle_now = tk-&gt;tkr.read(clock);<br /> 	delta = clocksource_delta(cycle_now, tk-&gt;tkr.cycle_last, tk-&gt;tkr.mask);<br /> 	tk-&gt;tkr.cycle_last = cycle_now;<br />+	check_cycle_error(&amp;tk-&gt;tkr);<br /> <br /> 	tk-&gt;tkr.xtime_nsec += delta * tk-&gt;tkr.mult;<br /> <br />&#64;&#64; -1237,6 +1255,7 &#64;&#64; static void timekeeping_resume(void)<br /> <br /> 	/* Re-base the last cycle value */<br /> 	tk-&gt;tkr.cycle_last = cycle_now;<br />+	tk-&gt;tkr.cycle_error = 0;<br /> 	tk-&gt;ntp_error = 0;<br /> 	timekeeping_suspended = 0;<br /> 	timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);<br />&#64;&#64; -1591,11 +1610,15 &#64;&#64; void update_wall_time(void)<br /> 	if (unlikely(timekeeping_suspended))<br /> 		goto out;<br /> <br />+	check_cycle_error(&amp;real_tk-&gt;tkr);<br />+<br /> #ifdef CONFIG_ARCH_USES_GETTIMEOFFSET<br /> 	offset = real_tk-&gt;cycle_interval;<br /> #else<br /> 	offset = clocksource_delta(tk-&gt;tkr.read(tk-&gt;tkr.clock),<br /> 				   tk-&gt;tkr.cycle_last, tk-&gt;tkr.mask);<br />+	if (unlikely(offset &gt; (tk-&gt;tkr.mask &gt;&gt; 3)))<br />+		pr_err("Cutting it too close for %s in in update_wall_time (offset = %llu)\n", tk-&gt;tkr.clock-&gt;name, offset);<br /> #endif<br /> <br /> 	/* Check if there's really nothing to do */</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
