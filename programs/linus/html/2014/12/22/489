    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2014/11/14/656">First message in thread</a></li><li><a href="/lkml/2014/12/22/392">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/22/400">Linus Torvalds</a></li><li><a href="/lkml/2014/12/22/459">Dave Jones</a><ul><li><a href="/lkml/2014/12/22/478">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/23/266">Dave Jones</a><ul><li><a href="/lkml/2014/12/24/203">Sasha Levin</a></li></ul></li><li><a href="/lkml/2014/12/23/460">Dave Jones</a><ul><li><a href="/lkml/2014/12/26/140">Dave Jones</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2014/12/22/479">John Stultz</a><ul><li class="origin"><a href="/lkml/2014/12/28/103">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/28/103">"Paul E. McKenney"</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 22 Dec 2014 16:46:42 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: frequent lockups in 3.18rc4</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Dec 22, 2014 at 3:59 PM, John Stultz &lt;john.stultz&#64;linaro.org&gt; wrote:<br />&gt;<br />&gt; * So 1/8th of the interval seems way too short, as there's<br />&gt; clocksources like the ACP PM, which wrap every 2.5 seconds or so.<br /><br />Ugh. At the same time, 1/8th of a range is actually bigger than I'd<br />like, since if there is some timer corruption, it means that we only<br />catch it when it's in really big.<br /><br />But as I said, I'd actually prefer it to be time-based, because it<br />would be good if this approach worked on things like the TSC which is<br />a 64-bit counter..<br /><br />So yes, that capping was very much arbitrary, and was mostly a case of<br />"this works with the one timer source that I can easily trigger"<br /><br />&gt; * I suspect something closer to the clocksource_max_deferment() value<br />&gt; (which I think is max interval before multiplication overflows could<br />&gt; happen - ~12%) which we use in the scheduler would make more sense.<br />&gt; Especially since the timer scheduler uses that to calculate how long<br />&gt; we can idle for.<br /><br />I'd rather not be anywhere *close* to any overflow problems. Even for<br />the scheduler all-idle case, I'd argue that there is rather quickly<br />diminishing returns. Yes, a thousand timer interrupts per second are<br />expensive and a noticeable power draw. The difference between "one<br />timer interrupt every two seconds" and "every 20 seconds" is rather<br />less noticeable.<br /><br />Of course, reasonable clock sources have *much* longer periods than a<br />second (yeah, the acpi pm timer really isn't a good one), so there are<br />probably good middle grounds, The 1/8th was a hack, and one that was<br />aware of teh 300s cycle of the HPET at that..<br /><br />&gt; * Nulling out delta in timekeeping_get_ns() seems like it could cause<br />&gt; problems since time would then possibly go backwards compared to<br />&gt; previous reads (as you mentioned, resulting in smaller time jumps).<br />&gt; Instead it would probably make more sense to cap the delta at the<br />&gt; maximum value (though this assumes the clock doesn't jump back in the<br />&gt; interval before the next call to update_wall_time).<br /><br />So part of the nulling was that it was simpler, and part of it was<br />that I expected to get backwards jumps (see the other email to Dave<br />about the inherent races). And with the whole timer mask modulo<br />arithmetic, those backwards jumps just look like biggish positive<br />numbers, not even negative. So it ends up being things like "is it an<br />unsigned number larger than half the mask? Consider it negative" etc.<br /><br />The "zero it out" was simple, and it worked for my test-case, which<br />was "ok, my machine no longer locks up when I mess with the timer".<br /><br />And I didn't post the earlier versions of that patch that didn't even *boot*.<br /><br />I started out trying to do it at a higher level (not on a clock read<br />level, but outside the whole 'convert-to-ns and do the sequence  value<br />check'), but during bootup we play a lot of games with initializing<br />the timer sources etc.<br /><br />So that explains the approach of doing it at that<br /><br />   cycle_now = tkr-&gt;read(tkr-&gt;clock);<br /><br />level, and keeping it very low-level.<br /><br />But as I already explained in the email that crossed, that low-level<br />thing also results in some fundamental races.<br /><br />&gt; * Also, as you note, this would just cause the big time jump to only<br />&gt; happen at the next update, since there's no logic in<br />&gt; update_wall_time() to limit the jump. I'm not sure if "believing" the<br />&gt; large jump at write time make that much more sense, though.<br /><br />So I considered just capping it there (to a single interval or<br />something). Again, just ignoring - like the read side does - it would<br />have been easier, but at the same time I *really* wanted to make time<br />go forward, so just taking the big value seemed safest.<br /><br />But yes. this was very much a RFC patch. It's not even ready for real<br />use, as DaveJ found out (although it might be good enough in practice,<br />despite its flaws)<br /><br />&gt; * Finally, you're writing to error while only holding a read lock, but<br />&gt; that's sort of a minor thing.<br /><br />It's not a minor thing, but the alternatives looked worse.<br /><br />I really wanted to make it per-cpu, and do this with interrupts<br />disabled or something. But that then pushes a big problem to the write<br />time to go over all cpu's and see if there are errors.<br /><br />So it's not right. But .. It's a hacky patch to get discussion<br />started, and it's actually hard to do "right" when this code has to be<br />basically lockless.<br /><br />&gt; * Checking the accumulation interval isn't beyond the<br />&gt; clocksource_max_deferment() value seems like a very good check to have<br />&gt; in update_wall_time().<br /><br />Sounds like a good idea. Also, quite frankly, reading all the code I<br />wasn't ever really able to figure out that things don't overflow. The<br />overflow protection is a bit ad-hoc (that maxshift thing in<br />update_wall_time() really makes baby Jesus cry, despite the season,<br />and it wasn't at all obvious that ntp_tick_length() is fundamentally<br />bigger than xtime_interval, for example).<br /><br />It's also not clear that the complicated and frankly not-very-obvious<br />shift-loop is any faster than just using a divide - possibly with the<br />"single interval" case being a special case to avoid dividing then.<br /><br />I was a bit nervous that the whole update of tkr.cycle_last in there<br />could just overrun the actual *read* value of 'tk-&gt;tkr.clock'. With<br />the whole offset logic split between update_wall_time() and<br />logarithmic_accumulation(), the code isn't exactly self-explanatory.<br /><br />Heh.<br /><br />&gt; * Maybe when we schedule the next timekeeping update, the tick<br />&gt; scheduler could store the expected time for that to fire, and then we<br />&gt; could validate that we're relatively close after that value when we do<br />&gt; accumulate time (warning if we're running too early or far too late -<br />&gt; though with virtualziation, defining a "reasonable" late value is<br />&gt; difficult).<br /><br />In general, it would be really nice to know what the expected limits<br />are. It was hard to impossible to figure out the interaction between<br />the timer subsystem and the scheduler tick. It's pretty incestuous,<br />and if there's an explanation for it, I missed it.<br /><br />&gt; * This "expected next tick" time could be used to try to cap read-time<br />&gt; intervals in a similar fashion as done here. (Of course, again, we'd<br />&gt; have to be careful, since if that expected next tick ends up somehow<br />&gt; being before the actual hrtimer expiration value, we could end up<br />&gt; stopping time - and the system).<br /><br />I don't think you can cap them to exactly the expected value anyway,<br />since the wall time update *will* get delayed by locking and just<br />interrupts being off etc. And virtual environments will obviously make<br />it much worse. So the capping needs to be somewhat loose anyway.<br /><br />The patch I posted was actually sloppy by design, exactly because I<br />had so much trouble with trying to be strict. My first patch was a<br />percpu thing that just limited ktime_get() from ever going backwards<br />on that particular cpu (really simple, real;ly stupid), and it got<br />*nowhere*.<br /><br />                        Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
