    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2014/11/14/656">First message in thread</a></li><li><a href="/lkml/2014/12/19/439">Thomas Gleixner</a><ul><li><a href="/lkml/2014/12/19/451">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2014/12/20/169">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/20/169">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/20/217">"Paul E. McKenney"</a></li><li><a href="/lkml/2014/12/21/182">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 20 Dec 2014 10:25:40 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: frequent lockups in 3.18rc4</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Dec 19, 2014 at 5:57 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; I'm claiming that the race happened *once*. And it then corrupted some<br />&gt; data structure or similar sufficiently that CPU0 keeps looping.<br />&gt;<br />&gt; Perhaps something keeps re-adding itself to the head of the timerqueue<br />&gt; due to the race.<br /><br />So tick_sched_timer() does<br /><br />        ktime_t now = ktime_get();<br />        ...<br />        hrtimer_forward(timer, now, tick_period);<br />        return HRTIMER_RESTART;<br /><br />and then __run_hrtimer does<br /><br />        enqueue_hrtimer(timer, base);<br /><br />which just adds the timer back on the tiemr heap.<br /><br />So all you need to get an infinite loop (as far as I can see) is that<br />hrtimer_forward() doesn't actually move the timer forward.<br /><br />The most likely reason would seem to be this:<br /><br />        delta = ktime_sub(now, hrtimer_get_expires(timer));<br /><br />        if (delta.tv64 &lt; 0)<br />                return 0;<br /><br />and clearly it *should* return a positive number, since the timer has<br />expired, so the expiry time _should_ be smaller than "now". So it<br />should never trigger, and this bug is clearly impossible.<br /><br />HOWEVER.<br /><br />It turns out that while tick_sched_timer() does "ktime_get()" to get<br />the current time, the actual timer machinery does *not* do that at<br />all. The actual timer machinery does<br /><br />        entry_time = now = hrtimer_update_base(cpu_base);<br /><br />                base = cpu_base-&gt;clock_base + i;<br />                basenow = ktime_add(now, base-&gt;offset);<br /><br />_once_ per hrtimer_clock_base. And then it iterates using that<br />"basenow" thing, and  compares it to the timer expiry.<br /><br />So we have two different times. Now, let's think about what happens if<br />those clocks aren't quote in sync.<br /><br />We know (since __run_hrtimer was called) that<br /><br />        basenow.tv64 &gt; hrtimer_get_softexpires_tv64(timer)<br /><br />but here we have "basenow" - which is not that ktime_get(), and we<br />have "hrtimer_get_softexpires_tv64()" (which is not<br />hrtimer_get_expires() in general - we have all that "delta" range<br />handling, but for the scheduling tick it *should* be the same).<br /><br />So I can see at least one lockup:<br /><br /> - if "expires &lt; basenow" hrtimer_interrupt() will run the timer<br /> - if "now &lt; expires" hrtimer_forward() will not do anything, and will<br />just reschedule the timer with the same expiration<br /><br />iow, all you need for a re-arming of the same timer is:<br /><br />   now &lt; expires &lt; basenow<br /><br />now, the two clocks (now and basenow) are not the same, but they do<br />have the same *base*. So they are related, but even the base time was<br />gotten under two different sequence locks, so even the base could have<br />been updated in between the hrtimer_update_base() time and the<br />ktime_get(). And even though they have the same base, they have<br />different offsets: basenow does that "base-&gt;offset" thing (and<br />ktime_get_update_offsets_now() does timekeeping_get_ns()<br /><br /> - now = ktime_get() does<br /><br />                base = tk-&gt;tkr.base_mono;<br />                nsecs = timekeeping_get_ns(&amp;tk-&gt;tkr);<br /><br /> - basenow = ktime_get_update_offsets_now() does<br /><br />                base = tk-&gt;tkr.base_mono;<br />                nsecs = timekeeping_get_ns(&amp;tk-&gt;tkr);<br />          .. and then ..<br />                ktime_add(.., base-&gt;offset);<br /><br />and if I read the thing right, the ktime_add() should be a no-op,<br />because base-&gt;offset should be 0 for the normal monotonic clock.<br />Right?<br /><br />So the two times (now and basenow) *should* be the same time, and the<br />whole "now &lt; expires &lt; basenow" situation can never happen. Right?<br /><br />Potentially wrong.<br /><br />Because that's where the whole "different sequence locks" comes in.<br />The one-time race could be something that updates the base in between<br />the (one-time) ktime_get_update_offsets_now() and the (then as a<br />result pseudo-infinitely repeating) ktime_get.<br /><br />Hmm? If "base" ever goes backwards, or if "base" does *not* update<br />atomically with the HPET timer overflows, I can see that happening. Of<br />course, that would imply that ktime_get() is not monotonic. But we do<br />know that we've had odd time issues on that machine.<br /><br />I think you already had DaveJ check clock monotonicity. But that was<br />with the TSC, wasn't it? I'm claiming maybe the HPET isn't monotonic,<br />and there is some HPET clocksource issue with overflow in 32 bits.<br /><br />(I think the HPET *should* be 64-bit, and just the comparators for<br />interrupts may be 32-bit, but we use a "readl()" and only use the low<br />32-bits even if the upper 32 bits *might* be ok).<br /><br />I keep harping on that HPET overflow, because we actually have the 6<br />"locked up" HPET traces, and then we have a seventh without that<br />lockup, and there definitely was a overflow in 32 bits:<br /><br />  [torvalds&#64;i7 linux]$ grep -3 read_hpet+0x16 ~/dj-1.txt | grep RAX<br />   RAX: 0000000061fece8a RBX: 0000000000510792 RCX: 0000000000000000<br />   RAX: 0000000079e588fc RBX: 0000000000511d6e RCX: 0000000000000000<br />   RAX: 0000000091ca7f65 RBX: 0000000000513346 RCX: 0000000000000000<br />   RAX: 00000000a9afbd0d RBX: 000000000051491e RCX: 0000000000000000<br />   RAX: 00000000cbd1340c RBX: 000000000051684a RCX: 0000000000000000<br />   RAX: 00000000fb9d303f RBX: 00000000005193fc RCX: 0000000000000000<br />   RAX: 000000002b67efe4 RBX: 000000000051c224 RCX: 0000000000000004<br /><br />and I have just gotten hung up on that small detail.<br /><br />How/where is the HPET overflow case handled? I don't know the code enough.<br /><br />(Also, maybe I shouldn't be so hung up on this *one* long trace from<br />DaveJ. There's been a lot of crazy traces from that machine. We've had<br />some time-handling questions about it before, but *most* of the traces<br />have not been implicating the HPET like this one, so..)<br /><br />                            Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
