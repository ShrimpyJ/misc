    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2014/11/14/656">First message in thread</a></li><li><a href="/lkml/2014/12/15/18">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/15/20">Dave Jones</a><ul><li class="origin"><a href="/lkml/2014/12/15/873">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/15/873">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/17/508">Sasha Levin</a></li><li><a href="/lkml/2014/12/18/3">Dave Jones</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2014/12/15/279">Borislav Petkov</a></li><li><a href="/lkml/2014/12/18/447">Andy Lutomirski</a><ul><li><a href="/lkml/2014/12/18/458">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/18/464">Andy Lutomirski</a></li></ul></li><li><a href="/lkml/2014/12/18/459">Dave Jones</a></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2014/12/15/651/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 15 Dec 2014 10:21:56 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: frequent lockups in 3.18rc4</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Dec 14, 2014 at 9:57 PM, Dave Jones &lt;davej&#64;redhat.com&gt; wrote:<br />&gt;<br />&gt; We had a flashback to that old bug last month too.<br />&gt; See this mail &amp; your followup. : <a href="https://lkml.org/lkml/2014/11/25/1171">https://lkml.org/lkml/2014/11/25/1171</a><br />&gt; That was during a bisect though, so may have been something<br />&gt; entirely different, but it is a spooky coincidence.<br /><br />Yeah, there's something funny going on there.<br /><br />Anyway, I've looked at the page fault patch, and I mentioned this last<br />time it came up: there's a nasty possible kernel loop in the "retry"<br />case if there's also a fatal signal pending, and we're returning to<br />kernel mode rather than returning to user mode.<br /><br />If we return to user mode, the return will handle signals, and we'll<br />kill the process due to the fatal pending signal and everything is<br />fine.<br /><br />But if we're returning to kernel mode, we'll just take the page fault<br />again. And again. And again. Until the condition that caused the retry<br />is finally cleared.<br /><br />Now, normally finishing IO on the page or whatever should get things<br />done, but whatever. Us busy-looping on it in kernel space might end up<br />delaying that too forever.<br /><br />So let's just fix it. Here's a completely untested patch. It looks<br />bigger than it really is: it moves the "up_read()" up a bit in<br />__do_page_fault(), so that all the logic is saner. This is "tested" in<br />the sense that I am running a kernel with this patch, but I could<br />easily have screwed up some fault handling case.<br /><br />Anyway, at least CPU1 in your traces was actually going through that<br />__lock_page_or_retry() code that could trigger this, so...<br /><br />                               Linus<br /> arch/x86/mm/fault.c | 65 +++++++++++++++++++++++++----------------------------<br /> 1 file changed, 30 insertions(+), 35 deletions(-)<br /><br />diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c<br />index d973e61e450d..b38adc1cd39f 100644<br />--- a/arch/x86/mm/fault.c<br />+++ b/arch/x86/mm/fault.c<br />&#64;&#64; -844,11 +844,8 &#64;&#64; do_sigbus(struct pt_regs *regs, unsigned long error_code, unsigned long address,<br /> 	  unsigned int fault)<br /> {<br /> 	struct task_struct *tsk = current;<br />-	struct mm_struct *mm = tsk-&gt;mm;<br /> 	int code = BUS_ADRERR;<br /> <br />-	up_read(&amp;mm-&gt;mmap_sem);<br />-<br /> 	/* Kernel mode? Handle exceptions or die: */<br /> 	if (!(error_code &amp; PF_USER)) {<br /> 		no_context(regs, error_code, address, SIGBUS, BUS_ADRERR);<br />&#64;&#64; -879,7 +876,6 &#64;&#64; mm_fault_error(struct pt_regs *regs, unsigned long error_code,<br /> 	       unsigned long address, unsigned int fault)<br /> {<br /> 	if (fatal_signal_pending(current) &amp;&amp; !(error_code &amp; PF_USER)) {<br />-		up_read(&amp;current-&gt;mm-&gt;mmap_sem);<br /> 		no_context(regs, error_code, address, 0, 0);<br /> 		return;<br /> 	}<br />&#64;&#64; -887,14 +883,11 &#64;&#64; mm_fault_error(struct pt_regs *regs, unsigned long error_code,<br /> 	if (fault &amp; VM_FAULT_OOM) {<br /> 		/* Kernel mode? Handle exceptions or die: */<br /> 		if (!(error_code &amp; PF_USER)) {<br />-			up_read(&amp;current-&gt;mm-&gt;mmap_sem);<br /> 			no_context(regs, error_code, address,<br /> 				   SIGSEGV, SEGV_MAPERR);<br /> 			return;<br /> 		}<br /> <br />-		up_read(&amp;current-&gt;mm-&gt;mmap_sem);<br />-<br /> 		/*<br /> 		 * We ran out of memory, call the OOM killer, and return the<br /> 		 * userspace (which will retry the fault, or kill us if we got<br />&#64;&#64; -1062,7 +1055,7 &#64;&#64; __do_page_fault(struct pt_regs *regs, unsigned long error_code,<br /> 	struct vm_area_struct *vma;<br /> 	struct task_struct *tsk;<br /> 	struct mm_struct *mm;<br />-	int fault;<br />+	int fault, major = 0;<br /> 	unsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;<br /> <br /> 	tsk = current;<br />&#64;&#64; -1237,14 +1230,31 &#64;&#64; good_area:<br /> 	 * we get VM_FAULT_RETRY back, the mmap_sem has been unlocked.<br /> 	 */<br /> 	fault = handle_mm_fault(mm, vma, address, flags);<br />+	major |= fault &amp; VM_FAULT_MAJOR;<br /> <br /> 	/*<br />-	 * If we need to retry but a fatal signal is pending, handle the<br />-	 * signal first. We do not need to release the mmap_sem because it<br />-	 * would already be released in __lock_page_or_retry in mm/filemap.c.<br />+	 * If we need to retry the mmap_sem has already been released,<br />+	 * and if there is a fatal signal pending there is no guarantee<br />+	 * that we made any progress. Handle this case first.<br /> 	 */<br />-	if (unlikely((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current)))<br />+	if (unlikely(fault &amp; VM_FAULT_RETRY)) {<br />+		if ((flags &amp; FAULT_FLAG_ALLOW_RETRY) &amp;&amp; !fatal_signal_pending(current)) {<br />+			/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk<br />+			 * of starvation. */<br />+			flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;<br />+			flags |= FAULT_FLAG_TRIED;<br />+			goto retry;<br />+		}<br />+<br />+		/* Not returning to user mode? Handle exceptions or die: */<br />+		if (!(fault &amp; FAULT_FLAG_USER))<br />+			no_context(regs, error_code, address, SIGBUS, BUS_ADRERR);<br />+<br />+		/* User mode? Just return to handle the fatal exception */<br /> 		return;<br />+	}<br />+<br />+	up_read(&amp;mm-&gt;mmap_sem);<br /> <br /> 	if (unlikely(fault &amp; VM_FAULT_ERROR)) {<br /> 		mm_fault_error(regs, error_code, address, fault);<br />&#64;&#64; -1252,32 +1262,17 &#64;&#64; good_area:<br /> 	}<br /> <br /> 	/*<br />-	 * Major/minor page fault accounting is only done on the<br />-	 * initial attempt. If we go through a retry, it is extremely<br />-	 * likely that the page will be found in page cache at that point.<br />+	 * Major/minor page fault accounting. If any of the events<br />+	 * returned VM_FAULT_MAJOR, we account it as a major fault.<br /> 	 */<br />-	if (flags &amp; FAULT_FLAG_ALLOW_RETRY) {<br />-		if (fault &amp; VM_FAULT_MAJOR) {<br />-			tsk-&gt;maj_flt++;<br />-			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,<br />-				      regs, address);<br />-		} else {<br />-			tsk-&gt;min_flt++;<br />-			perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,<br />-				      regs, address);<br />-		}<br />-		if (fault &amp; VM_FAULT_RETRY) {<br />-			/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk<br />-			 * of starvation. */<br />-			flags &amp;= ~FAULT_FLAG_ALLOW_RETRY;<br />-			flags |= FAULT_FLAG_TRIED;<br />-			goto retry;<br />-		}<br />+	if (major) {<br />+		tsk-&gt;maj_flt++;<br />+		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);<br />+	} else {<br />+		tsk-&gt;min_flt++;<br />+		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);<br /> 	}<br />-<br /> 	check_v8086_mode(regs, address, tsk);<br />-<br />-	up_read(&amp;mm-&gt;mmap_sem);<br /> }<br /> NOKPROBE_SYMBOL(__do_page_fault);<br /> </pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
