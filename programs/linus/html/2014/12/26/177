    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2014/11/14/656">First message in thread</a></li><li><a href="/lkml/2014/12/26/140">Dave Jones</a><ul><li><a href="/lkml/2014/12/26/158">Dave Jones</a><ul><li class="origin"><a href="/lkml/2014/12/26/181">Linus Torvalds</a><ul><li><a href="/lkml/2014/12/26/181">Dave Jones</a></li><li><a href="/lkml/2014/12/26/194">Dave Jones</a><ul><li><a href="/lkml/2014/12/26/198">Linus Torvalds</a></li><li><a href="/lkml/2014/12/26/202">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2015/1/2/319">John Stultz</a><ul><li><a href="/lkml/2015/1/3/58">Sasha Levin</a></li><li><a href="/lkml/2015/1/4/144">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2014/12/26/177/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 26 Dec 2014 12:57:07 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: frequent lockups in 3.18rc4</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Dec 26, 2014 at 10:12 AM, Dave Jones &lt;davej&#64;codemonkey.org.uk&gt; wrote:<br />&gt; On Fri, Dec 26, 2014 at 11:34:10AM -0500, Dave Jones wrote:<br />&gt;<br />&gt;  &gt; One thing I think I'll try is to try and narrow down which<br />&gt;  &gt; syscalls are triggering those "Clocksource hpet had cycles off"<br />&gt;  &gt; messages.  I'm still unclear on exactly what is doing<br />&gt;  &gt; the stomping on the hpet.<br />&gt;<br />&gt; First I ran trinity with "-g vm" which limits it to use just<br />&gt; a subset of syscalls, specifically VM related ones.<br />&gt; That triggered the messages. Further experiments revealed:<br /><br />So I can trigger the false positives with my original patch quite<br />easily by just putting my box under some load. My numbers are nowhere<br />near as bad as yours, but then, I didn't put it under as much load<br />anyway. Just a regular "make -j64" of the kernel.<br /><br />I suspect your false positives are bigger partly because of the load,<br />but mostly because you presumably have preemption enabled too. I don't<br />do preemption in my normal kernels, and that limits the damage of the<br />race a bit.<br /><br />I have a newer version of the patch that gets rid of the false<br />positives with some ordering rules instead, and just for you I hacked<br />it up to say where the problem happens too, but it's likely too late.<br /><br />The fact that the original racy patch seems to make a difference for<br />you does say that yes, we seem to be zeroing in on the right area<br />here, but I'm not seeing what's wrong. I was hoping for big jumps from<br />your HPET, since your "TSC unstable" messages do kind of imply that<br />such really big jumps can happen.<br /><br />I'm attaching my updated hacky patch, although I assume it's much too<br />late for that machine. Don't look too closely at the backtrace<br />generation part, that's just a quick hack, and only works with frame<br />pointers enabled anyway.<br /><br />So I'm still a bit unhappy about not figuring out *what* is wrong. And<br />I'd still like the dmidecode from that machine, just for posterity. In<br />case we can figure out some pattern.<br /><br />So right now I can imagine several reasons:<br /><br /> - actual hardware bug.<br /><br />   This is *really* unlikely, though. It should hit everybody. The<br />HPET is in the core intel chipset, we're not talking random unusual<br />hardware by fly-by-night vendors here.<br /><br /> - some SMM/BIOS "power management" feature.<br /><br />   We've seen this before, where the SMM saves/restores the TSC on<br />entry/exit in order to hide itself from the system. I could imagine<br />similar code for the HPET counter. SMM writers use some bad drugs to<br />dull their pain.<br /><br />   And with the HPET counter, since it's not even per-CPU, the "save<br />and restore HPET" will actually show up as "HPET went backwards" to<br />the other non-SMM CPU's if it happens<br /><br /> - a bug in our own clocksource handling.<br /><br />   I'm not seeing it. But maybe my patch hides it for some magical reason.<br /><br /> - gremlins.<br /><br />So I dunno. I hope more people will look at this after the holidays,<br />even if your machine is gone. My test-program to do bad things to the<br />HPET shows *something*, and works on any machine.<br /><br />                    Linus<br /> arch/x86/kernel/entry_64.S          |  5 +++<br /> include/linux/timekeeper_internal.h |  1 +<br /> kernel/time/timekeeping.c           | 78 +++++++++++++++++++++++++++++++++++--<br /> 3 files changed, 81 insertions(+), 3 deletions(-)<br /><br />diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S<br />index 9ebaf63ba182..0a4c34b4658e 100644<br />--- a/arch/x86/kernel/entry_64.S<br />+++ b/arch/x86/kernel/entry_64.S<br />&#64;&#64; -312,6 +312,11 &#64;&#64; ENTRY(save_paranoid)<br /> 	CFI_ENDPROC<br /> END(save_paranoid)<br /> <br />+ENTRY(save_back_trace)<br />+	movq %rbp,%rdi<br />+	jmp do_save_back_trace<br />+END(save_back_trace)<br />+<br /> /*<br />  * A newly forked process directly context switches into this address.<br />  *<br />diff --git a/include/linux/timekeeper_internal.h b/include/linux/timekeeper_internal.h<br />index 05af9a334893..0fcb60d77079 100644<br />--- a/include/linux/timekeeper_internal.h<br />+++ b/include/linux/timekeeper_internal.h<br />&#64;&#64; -32,6 +32,7 &#64;&#64; struct tk_read_base {<br /> 	cycle_t			(*read)(struct clocksource *cs);<br /> 	cycle_t			mask;<br /> 	cycle_t			cycle_last;<br />+	cycle_t			cycle_error;<br /> 	u32			mult;<br /> 	u32			shift;<br /> 	u64			xtime_nsec;<br />diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c<br />index 6a931852082f..1c924c80b462 100644<br />--- a/kernel/time/timekeeping.c<br />+++ b/kernel/time/timekeeping.c<br />&#64;&#64; -140,6 +140,7 &#64;&#64; static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)<br /> 	tk-&gt;tkr.read = clock-&gt;read;<br /> 	tk-&gt;tkr.mask = clock-&gt;mask;<br /> 	tk-&gt;tkr.cycle_last = tk-&gt;tkr.read(clock);<br />+	tk-&gt;tkr.cycle_error = 0;<br /> <br /> 	/* Do the ns -&gt; cycle conversion first, using original mult */<br /> 	tmp = NTP_INTERVAL_LENGTH;<br />&#64;&#64; -191,16 +192,59 &#64;&#64; u32 (*arch_gettimeoffset)(void) = default_arch_gettimeoffset;<br /> static inline u32 arch_gettimeoffset(void) { return 0; }<br /> #endif<br /> <br />+unsigned long tracebuffer[16];<br />+<br />+extern void save_back_trace(long dummy, void *ptr);<br />+<br />+void do_save_back_trace(long rbp, void *ptr)<br />+{<br />+	int i;<br />+	unsigned long frame = rbp;<br />+<br />+	for (i = 0; i &lt; 15; i++) {<br />+		unsigned long nextframe = ((unsigned long *)frame)[0];<br />+		unsigned long rip = ((unsigned long *)frame)[1];<br />+		tracebuffer[i] = rip;<br />+		if ((nextframe ^ frame) &gt;&gt; 13)<br />+			break;<br />+		if (nextframe &lt;= frame)<br />+			break;<br />+		frame = nextframe;<br />+	}<br />+	tracebuffer[i] = 0;<br />+}<br />+<br />+/*<br />+ * At read time, we read "cycle_last" *before* we read<br />+ * the clock.<br />+ *<br />+ * At write time, we read the clock before we update<br />+ * 'cycle_last'.<br />+ *<br />+ * Thus, any 'cycle_last' value read here *must* be smaller<br />+ * than the clock read. Unless the clock is buggy.<br />+ */<br /> static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)<br /> {<br />-	cycle_t cycle_now, delta;<br />+	cycle_t cycle_last, cycle_now, delta;<br /> 	s64 nsec;<br /> <br />+	/* Read previous cycle - *before* reading clocksource */<br />+	cycle_last = smp_load_acquire(&amp;tkr-&gt;cycle_last);<br />+<br /> 	/* read clocksource: */<br />-	cycle_now = tkr-&gt;read(tkr-&gt;clock);<br />+	cycle_now = smp_load_acquire(&amp;tkr-&gt;cycle_error);<br />+	cycle_now += tkr-&gt;read(tkr-&gt;clock);<br /> <br /> 	/* calculate the delta since the last update_wall_time: */<br />-	delta = clocksource_delta(cycle_now, tkr-&gt;cycle_last, tkr-&gt;mask);<br />+	delta = clocksource_delta(cycle_now, cycle_last, tkr-&gt;mask);<br />+<br />+	/* Hmm? This is really not good, we're too close to overflowing */<br />+	if (unlikely(delta &gt; (tkr-&gt;mask &gt;&gt; 3))) {<br />+		smp_store_release(&amp;tkr-&gt;cycle_error, delta);<br />+		delta = 0;<br />+		save_back_trace(0, tracebuffer);<br />+	}<br /> <br /> 	nsec = delta * tkr-&gt;mult + tkr-&gt;xtime_nsec;<br /> 	nsec &gt;&gt;= tkr-&gt;shift;<br />&#64;&#64; -465,6 +509,28 &#64;&#64; static void timekeeping_update(struct timekeeper *tk, unsigned int action)<br /> 	update_fast_timekeeper(tk);<br /> }<br /> <br />+static void check_cycle_error(struct tk_read_base *tkr)<br />+{<br />+	cycle_t error = tkr-&gt;cycle_error;<br />+<br />+	if (unlikely(error)) {<br />+		int i;<br />+		const char *sign = "";<br />+		tkr-&gt;cycle_error = 0;<br />+		if (error &gt; tkr-&gt;mask/2) {<br />+			error = tkr-&gt;mask - error + 1;<br />+			sign = "-";<br />+		}<br />+		pr_err("Clocksource %s had cycles off by %s%llu\n", tkr-&gt;clock-&gt;name, sign, error);<br />+		for (i = 0; i &lt; 16; i++) {<br />+			unsigned long rip = tracebuffer[i];<br />+			if (!rip)<br />+				break;<br />+			printk("  %pS\n", (void *)rip);<br />+		}<br />+	}<br />+}<br />+<br /> /**<br />  * timekeeping_forward_now - update clock to the current time<br />  *<br />&#64;&#64; -481,6 +547,7 &#64;&#64; static void timekeeping_forward_now(struct timekeeper *tk)<br /> 	cycle_now = tk-&gt;tkr.read(clock);<br /> 	delta = clocksource_delta(cycle_now, tk-&gt;tkr.cycle_last, tk-&gt;tkr.mask);<br /> 	tk-&gt;tkr.cycle_last = cycle_now;<br />+	check_cycle_error(&amp;tk-&gt;tkr);<br /> <br /> 	tk-&gt;tkr.xtime_nsec += delta * tk-&gt;tkr.mult;<br /> <br />&#64;&#64; -1237,6 +1304,7 &#64;&#64; static void timekeeping_resume(void)<br /> <br /> 	/* Re-base the last cycle value */<br /> 	tk-&gt;tkr.cycle_last = cycle_now;<br />+	tk-&gt;tkr.cycle_error = 0;<br /> 	tk-&gt;ntp_error = 0;<br /> 	timekeeping_suspended = 0;<br /> 	timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET);<br />&#64;&#64; -1591,11 +1659,15 &#64;&#64; void update_wall_time(void)<br /> 	if (unlikely(timekeeping_suspended))<br /> 		goto out;<br /> <br />+	check_cycle_error(&amp;real_tk-&gt;tkr);<br />+<br /> #ifdef CONFIG_ARCH_USES_GETTIMEOFFSET<br /> 	offset = real_tk-&gt;cycle_interval;<br /> #else<br /> 	offset = clocksource_delta(tk-&gt;tkr.read(tk-&gt;tkr.clock),<br /> 				   tk-&gt;tkr.cycle_last, tk-&gt;tkr.mask);<br />+	if (unlikely(offset &gt; (tk-&gt;tkr.mask &gt;&gt; 3)))<br />+		pr_err("Cutting it too close for %s in in update_wall_time (offset = %llu)\n", tk-&gt;tkr.clock-&gt;name, offset);<br /> #endif<br /> <br /> 	/* Check if there's really nothing to do */</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
