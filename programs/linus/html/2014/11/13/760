    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2014/11/10/574">First message in thread</a></li><li><a href="/lkml/2014/11/10/760">Jerome Glisse</a><ul><li><a href="/lkml/2014/11/10/781">Linus Torvalds</a><ul><li><a href="/lkml/2014/11/10/844">Jerome Glisse</a><ul><li><a href="/lkml/2014/11/10/851">Linus Torvalds</a><ul><li><a href="/lkml/2014/11/10/875">Jerome Glisse</a></li><li><a href="/lkml/2014/11/10/881">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2014/11/11/157">Peter Zijlstra</a><ul><li><a href="/lkml/2014/11/11/506">Jerome Glisse</a></li><li><a href="/lkml/2014/11/11/861">David Airlie</a></li></ul></li></ul></li><li class="origin"><a href="/lkml/2014/11/13/858">Linus Torvalds</a><ul><li><a href="/lkml/2014/11/13/858">"Kirill A. Shutemov"</a><ul><li><a href="/lkml/2014/11/13/800">Linus Torvalds</a></li><li><a href="/lkml/2014/11/13/841">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2014/11/13/760/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 13 Nov 2014 15:50:02 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 3/5] lib: lockless generic and arch independent page table (gpt) v2.</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Nov 10, 2014 at 3:53 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; So I am fine with that, it's the details that confuse me. The thing<br />&gt; doesn't seem to be generic enough to be used for arbitrary page<br />&gt; tables, with (for example) the shifts fixed by the VM page size and<br />&gt; the size of the pte entry type. Also, the levels seem to be very<br />&gt; infexible, with the page table entries being the simple case, but then<br />&gt; you have that "pdep" thing that seems to be just _one_ level of page<br />&gt; directory.<br /><br />Ok, so let me just put my money where my mouth is, and show some<br />example code of a tree walker that I think is actually more generic.<br />Sorry for the delay, I got distracted by other things, and I wanted to<br />write something to show what I think might be a better approach.<br /><br />NOTE NOTE NOTE! I'm not saying you have to do it this way. But before<br />I even show the patch, let me show you the "tree descriptor" from my<br />stupid test-program that uses it, and hopefully that will show what<br />I'm really aiming for:<br /><br />    struct tree_walker_definition x86_64_def = {<br />        .total_bits = 48,<br />        .start = 0,<br />        .end = 0x7fffffffffff,<br />        .levels = {<br />            { .level_bits = 9, .lookup = pgd_lookup },<br />            { .level_bits = 9, .lookup = pud_lookup },<br />            { .level_bits = 9, .lookup = pmd_lookup },<br />            { .level_bits = 9, .walker = pte_walker }<br />        }<br />    };<br /><br />so basically, the *concept* is that you can describe a real page table<br />by actually *describing* it. What the above does is tell you:<br /><br /> - the amount of bits the tables can cover (48 is four levels of 9<br />bits each, leaving 12 bits - 4096 bytes - for the actual pages)<br /><br /> - limit the range that can be walked (this isn't really all that<br />important, but it does, for example, mean that the walker will<br />fundamentally refuse to give access to the kernel mapping)<br /><br /> - show how the different levels work, and what their sizes are and<br />how you look them up or walk them, starting from the top-most.<br /><br />Anyway, I think a descriptor like the above looks *understandable*. It<br />kind of stands on its own, even without showing the actual code.<br /><br />Now, the code to actually *walk* the above tree looks like this:<br /><br />       struct tree_walker walk = {<br />               .first = 4096,<br />               .last = 4096*512*3,<br />               .walk = show_walk,<br />               .hole = show_hole,<br />               .pre_walk = show_pre_walk,<br />               .post_walk = show_post_walk,<br />       };<br /><br />       walk_tree((struct tree_entry *)pgd, &amp;x86_64_def, &amp;walk);<br /><br />ie you use the "walk_tree()" function to walk a particular tree (in<br />this case it's a fake page table directory in "pgd", see the details<br />in the stupid test-application), giving it the tree definition and the<br />"walk" parameters that show what should happen for particular details<br />(quite often hole/pre-walk/post-walk may be NULL, my test app just<br />shows them being called).<br /><br />Now,. in addition to that, each tree description obviously needs the<br />functions to show how to look up the different levels ("lookup" for<br />moving from one level to another, and "walker" for actually walking<br />the last level page table knowing how "present" bits etc work.<br /><br />Now, your code had a "uint64_t mask" for the present bits, which<br />probably works reasonably well in practice, but I really prefer to<br />just have that "walker" callback instead. That way the page tables can<br />look like *anything*, and you can walk them, without having magic<br />rules that there has to be a particular bit pattern that says it's<br />"present".<br /><br />Also, my walker actually does super-pages - ie one of the mid-level<br />page tables could map one big area. I didn't much test it, but the<br />code is actually fairly straightforward, the way it's all been set up.<br />So it might be buggy, but it's *close*.<br /><br />Now, one place we differ is on locking. I actually think that the<br />person who asks to walk the tree should just do the locking<br />themselves. You can't really walk the tree without knowing what kind<br />of tree it is, and so I think the caller should just do the locking.<br />Obviously, the tree walker itself may have some locking in the<br />"pre_walk/post_walk" thing and in its lookup routines, so the<br />description of the tree can contain some locking of its own, but I did<br />*not* want to make the infrastructure itself force any particular<br />locking strategy.<br /><br />So this does something quite different from what your patch actually<br />did, and does that different thing very differently. It may not really<br />match what you are aiming for, but I'd *really* like the first<br />implementation of HMM that gets merged to not over-design the locking<br />(which I think yours did), and I want it to make *sense* (which I<br />don't think your patch did).<br /><br />Also, please note that this *is* just an example. It has an example<br />user (that is just a stupid user-level toy app to show how it all is<br />put together), but it's not necessarily all that featureful, and it's<br />definitely not very tested.<br /><br />But the code is actually fairly simple. But judge for yourself.<br /><br />                         Linus<br />diff --git a/include/linux/walk_tables.h b/include/linux/walk_tables.h<br />new file mode 100644<br />index 000000000000..398be60e854a<br />--- /dev/null<br />+++ b/include/linux/walk_tables.h<br />&#64;&#64; -0,0 +1,88 &#64;&#64;<br />+/*<br />+ * Copyright 2014 Linus Torvalds<br />+ *<br />+ * This code is distrubuted under the GPLv2<br />+ */<br />+#ifndef __LINUX_WALK_TABLE_H<br />+#define __LINUX_WALK_TABLE_H<br />+<br />+struct tree_entry;<br />+struct tree_walker_definition;<br />+<br />+/*<br />+ * The 'tree_level' data only describes one particular level<br />+ * of the tree. The upper levels are totally invisible to the<br />+ * user of the tree walker, since the tree walker will walk<br />+ * those using the tree definitions.<br />+ *<br />+ * NOTE! "struct tree_entry" is an opaque type, and is just a<br />+ * used as a pointer to the particular level. You can figure<br />+ * out which level you are at by looking at the "tree_level",<br />+ * but even better is to just use different "lookup()"<br />+ * functions for different levels, at which point the<br />+ * function is inherent to the level.<br />+ *<br />+ * NOTE 2! Some trees are fixed-depth, others are not. Each level<br />+ * has a lookup function, and can specify whether they are a<br />+ * terminal level. It should also fill in the "start" field of<br />+ * the tree_level information to point to the next level (or<br />+ * to the data). A NULL start is considered to be a hole.<br />+ *<br />+ * You won't see this hole in the "walk()" callback, but holes do get<br />+ * the pre-walk callback so that you can track holes too.<br />+ *<br />+ * If a "lookup()" function returns that it's a terminal entry and<br />+ * has a non-NULL "start", we'll call the "walk()" function with that<br />+ * tree-entry _once_, assuming it's a "superpage" that looks like<br />+ * a normal final tree-entry but is just much larger. The walk function<br />+ * can tell from the size we give it.<br />+ *<br />+ * NOTE 3! The last level normally doesn't have a (*lookup)()<br />+ * function at all, just a "walk" function. For that case, we'll<br />+ * call the tree definition "walker()" function instead of<br />+ * trying to look anything up, and it is supposed to call the<br />+ * "walk()' callback for each entry.<br />+ */<br />+struct tree_level {<br />+	unsigned int entry_level;<br />+	unsigned int nr_entries;<br />+	unsigned int entry_coverage;<br />+	unsigned long start, end;<br />+	struct tree_entry *entry;<br />+};<br />+<br />+struct tree_walker {<br />+	unsigned long first, last;<br />+	const void *data;<br />+	const struct tree_walker_definition *def;<br />+	int (*walk)(const struct tree_walker *, struct tree_entry *, unsigned long, unsigned int);<br />+	int (*hole)(const struct tree_walker *, const struct tree_level *);<br />+	int (*pre_walk)(const struct tree_walker *, const struct tree_level *);<br />+	int (*post_walk)(const struct tree_walker *, const struct tree_level *);<br />+};<br />+<br />+/*<br />+ * The "lookup()" function needs to return whether this is a terminal<br />+ * level or not.<br />+ */<br />+enum walk_tree_lookup {<br />+	WALK_TREE_DESCEND,<br />+	WALK_TREE_HOLE,<br />+	WALK_TREE_SUPERENTRY,<br />+};<br />+<br />+struct tree_walker_level_definition {<br />+	unsigned int level_bits;<br />+	enum walk_tree_lookup (*lookup)(struct tree_entry *, unsigned int, struct tree_level *);<br />+	int (*walker)(const struct tree_walker *, const struct tree_level *);<br />+};<br />+<br />+struct tree_walker_definition {<br />+	unsigned int total_bits;<br />+	unsigned long start, end;<br />+	struct tree_walker_level_definition levels[];<br />+};<br />+<br />+int walk_tree(struct tree_entry *root, const struct tree_walker_definition *, struct tree_walker *);<br />+<br />+#endif /* __LINUX_WALK_TABLE_H */<br />diff --git a/lib/walk_tables.c b/lib/walk_tables.c<br />new file mode 100644<br />index 000000000000..f63ac83f91d7<br />--- /dev/null<br />+++ b/lib/walk_tables.c<br />&#64;&#64; -0,0 +1,68 &#64;&#64;<br />+/*<br />+ * Copyright 2014 Linus Torvalds<br />+ *<br />+ * This code is distrubuted under the GPLv2<br />+ */<br />+#include &lt;linux/walk_tables.h&gt;<br />+<br />+int walk_tree(struct tree_entry *root, const struct tree_walker_definition *def, struct tree_walker *walk)<br />+{<br />+	walk-&gt;def = def;<br />+	if (walk-&gt;first &lt; def-&gt;start)<br />+		walk-&gt;first = def-&gt;start;<br />+	if (walk-&gt;last &gt; def-&gt;end)<br />+		walk-&gt;last = def-&gt;end;<br />+	while (walk-&gt;first &lt; walk-&gt;last) {<br />+		const struct tree_walker_level_definition *ldef = def-&gt;levels;<br />+		unsigned int shift = def-&gt;total_bits;<br />+		struct tree_level level;<br />+		struct tree_entry *tree = root;<br />+<br />+		for (level.entry_level = 0; ; level.entry_level++) {<br />+			unsigned long mask = (1ul &lt;&lt; shift)-1;<br />+<br />+			/* Fill in the level description */<br />+			level.nr_entries = 1u &lt;&lt; ldef-&gt;level_bits;<br />+			level.entry_coverage = 1ul &lt;&lt; (shift - ldef-&gt;level_bits);<br />+			level.start = walk-&gt;first;<br />+			level.end = (level.start | mask)+1;<br />+			if (level.end &gt; walk-&gt;last)<br />+				level.end = walk-&gt;last;<br />+<br />+			if (ldef-&gt;lookup) {<br />+				unsigned int index = level.start &gt;&gt; (shift - ldef-&gt;level_bits);<br />+				index &amp;= level.nr_entries-1;<br />+<br />+				switch (ldef-&gt;lookup(tree, index, &amp;level)) {<br />+				case WALK_TREE_DESCEND:<br />+					tree = level.entry;<br />+					shift -= ldef-&gt;level_bits;<br />+					ldef++;<br />+					continue;<br />+<br />+				case WALK_TREE_HOLE:<br />+					if (walk-&gt;hole)<br />+						walk-&gt;hole(walk, &amp;level);<br />+					break;<br />+<br />+				case WALK_TREE_SUPERENTRY:<br />+					if (walk-&gt;walk)<br />+						walk-&gt;walk(walk, level.entry, level.start, level.end - level.start);<br />+					break;<br />+				}<br />+			} else {<br />+				if (walk-&gt;pre_walk)<br />+					walk-&gt;pre_walk(walk, &amp;level);<br />+				if (walk-&gt;walk)<br />+					ldef-&gt;walker(walk, &amp;level);<br />+				if (walk-&gt;post_walk)<br />+					walk-&gt;post_walk(walk, &amp;level);<br />+			}<br />+<br />+			/* Ok, done with this level */<br />+			walk-&gt;first = level.end;<br />+			break;<br />+		}<br />+	}<br />+	return 0;<br />+}<br />diff --git a/test_tables.c b/test_tables.c<br />new file mode 100644<br />index 000000000000..b50ce33807ff<br />--- /dev/null<br />+++ b/test_tables.c<br />&#64;&#64; -0,0 +1,101 &#64;&#64;<br />+#include &lt;stdio.h&gt;<br />+#include "include/linux/walk_tables.h"<br />+<br />+/* Fake x86-64-like definitions */<br />+#define PRESENT		(1ul &lt;&lt; 0)<br />+#define HUGEPAGE	(1ul &lt;&lt; 7)<br />+enum walk_tree_lookup pgd_lookup(struct tree_entry *root, unsigned int index, struct tree_level *level)<br />+{<br />+	unsigned long entry = ((unsigned long *)root)[index];<br />+<br />+	level-&gt;entry = (void *)(entry &amp; ~0xffful);<br />+	if (!(entry * PRESENT))<br />+		return WALK_TREE_HOLE;<br />+	return (entry &amp; HUGEPAGE) ? WALK_TREE_SUPERENTRY: WALK_TREE_DESCEND;<br />+}<br />+<br />+/* For x86-64, the different levels are the same, so we can reuse the pgd walker */<br />+#define pud_lookup pgd_lookup<br />+#define pmd_lookup pgd_lookup<br />+<br />+int pte_walker(const struct tree_walker *walk, const struct tree_level *level)<br />+{<br />+	unsigned long start = level-&gt;start;<br />+	unsigned long end = level-&gt;end;<br />+	unsigned int idx = (start &gt;&gt; 12) &amp; 511;<br />+	unsigned long *ptep = idx + (unsigned long *)level-&gt;entry;<br />+<br />+	while (start &lt; end) {<br />+		unsigned long pte = *ptep;<br />+		if (pte &amp; PRESENT)<br />+			walk-&gt;walk(walk, (struct tree_entry *)ptep, start, level-&gt;entry_coverage);<br />+		ptep++;<br />+		start += level-&gt;entry_coverage;<br />+	}<br />+}<br />+<br />+struct tree_walker_definition x86_64_def = {<br />+	.total_bits = 48,<br />+	.start = 0,<br />+	.end = 0x7fffffffffff,<br />+	.levels = {<br />+		{ .level_bits = 9, .lookup = pgd_lookup },<br />+		{ .level_bits = 9, .lookup = pud_lookup },<br />+		{ .level_bits = 9, .lookup = pmd_lookup },<br />+		{ .level_bits = 9, .walker = pte_walker }<br />+	}<br />+};<br />+<br />+/*<br />+ * And this is a fake walker.<br />+ *<br />+ * NOTE! The definitions and the walker are separate entities, but the walker<br />+ * obviously knows what it is walking, so it can look at the data<br />+ */<br />+static int show_walk(const struct tree_walker *walk, struct tree_entry *pte, unsigned long address, unsigned int size)<br />+{<br />+	unsigned long entry = *(unsigned long *)pte;<br />+	printf("%08lx: %08lx (%d)\n", address, entry, size);<br />+	return 0;<br />+}<br />+<br />+static int show_hole(const struct tree_walker *walk, const struct tree_level *level)<br />+{<br />+	printf("hole at %08lx (%d)\n", level-&gt;start, level-&gt;end - level-&gt;start);<br />+}<br />+<br />+static int show_pre_walk(const struct tree_walker *walk, const struct tree_level *level)<br />+{<br />+	printf("pre_walk %p at %08lx (%d)\n", level-&gt;start, level-&gt;entry, level-&gt;end - level-&gt;start);<br />+}<br />+<br />+static int show_post_walk(const struct tree_walker *walk, const struct tree_level *level)<br />+{<br />+	printf("post_walk %p at %08lx (%d)\n", level-&gt;start, level-&gt;entry, level-&gt;end - level-&gt;start);<br />+}<br />+<br />+<br />+/*<br />+ * initial 1:1 mapping in fake test page tables for the first 8 pages,<br />+ * with page index 5 missing.<br />+ *<br />+ * And mostly empty page tables.<br />+ */<br />+unsigned long pte[512] __attribute__ ((aligned (4096))) = { 0x0001, 0x1001, 0x2001, 0x3001, 0x4001, 0, 0x6001, 0x7001 };<br />+unsigned long pmd[512] __attribute__ ((aligned (4096))) = { 1 + (unsigned long) pte, 0, 1 + (unsigned long) pte, };<br />+unsigned long pud[512] __attribute__ ((aligned (4096))) = { 1 + (unsigned long) pmd, 0, 1 + (unsigned long) pmd, };<br />+unsigned long pgd[512] __attribute__ ((aligned (4096))) = { 1 + (unsigned long) pud, 0, 1 + (unsigned long) pud, };<br />+<br />+int main(int argc, char **argv)<br />+{<br />+	struct tree_walker walk = {<br />+		.first = 4096,<br />+		.last = 4096*512*3,<br />+		.walk = show_walk,<br />+		.hole = show_hole,<br />+		.pre_walk = show_pre_walk,<br />+		.post_walk = show_post_walk,<br />+	};<br />+<br />+	walk_tree((struct tree_entry *)pgd, &amp;x86_64_def, &amp;walk);<br />+}</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
