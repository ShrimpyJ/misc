    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2014/11/14/656">First message in thread</a></li><li><a href="/lkml/2014/11/14/705">Thomas Gleixner</a><ul><li><a href="/lkml/2014/11/14/728">Dave Jones</a><ul><li><a href="/lkml/2014/11/14/747">Thomas Gleixner</a><ul><li><a href="/lkml/2014/11/14/773">Dave Jones</a><ul><li><a href="/lkml/2014/11/16/71">Thomas Gleixner</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2014/11/14/767">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2014/11/17/651">Linus Torvalds</a><ul><li><a href="/lkml/2014/11/17/651">Thomas Gleixner</a><ul><li><a href="/lkml/2014/11/17/659">Thomas Gleixner</a></li></ul></li><li><a href="/lkml/2014/11/17/684">Jens Axboe</a><ul><li><a href="/lkml/2014/11/17/695">Thomas Gleixner</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2014/11/17/614/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 17 Nov 2014 13:22:09 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: frequent lockups in 3.18rc4</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Nov 14, 2014 at 5:59 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; Judging by the code disassembly, it's the "csd_lock_wait(csd)" at the<br />&gt; end.<br /><br />Btw, looking at this, I grew really suspicious of this code in csd_unlock():<br /><br />        WARN_ON((csd-&gt;flags &amp; CSD_FLAG_WAIT) &amp;&amp; !(csd-&gt;flags &amp; CSD_FLAG_LOCK));<br /><br />because that makes no sense at all. It basically removes a sanity<br />check, yet that sanity check makes a hell of a lot of sense. Unlocking<br />a CSD that is not locked is *wrong*.<br /><br />The crazy code code comes from commit c84a83e2aaab ("smp: don't warn<br />about csd-&gt;flags having CSD_FLAG_LOCK cleared for !wait") by Jens, but<br />the explanation and the code is pure crap.<br /><br />There is no way in hell that it is ever correct to unlock an entry<br />that isn't locked, so that whole CSD_FLAG_WAIT thing is buggy as hell.<br /><br />The explanation in commit c84a83e2aaab says that  "blk-mq reuses the<br />request potentially immediately" and claims that that is somehow ok,<br />but that's utter BS. Even if you don't ever wait for it, the CSD lock<br />bit fundamentally also protects the "csd-&gt;llist" pointer. So what that<br />commit actually does is to just remove a safety check, and do so in a<br />very unsafe manner. And apparently block-mq re-uses something THAT IS<br />STILL ACTIVELY IN USE. That's just horrible.<br /><br />Now, I think we might do this differently, by doing the "csd_unlock()"<br />after we have loaded everything from the csd, but *before* actually<br />calling the callback function. That would seem to be equivalent<br />(interrupts are disabled, so this will not result in the func()<br />possibly called twice), more efficient, _and_  not remove a useful<br />check.<br /><br />Hmm? Completely untested patch attached. Jens, does this still work for you?<br /><br />Am I missing something?<br /><br />                    Linus<br /> kernel/smp.c | 11 +++++------<br /> 1 file changed, 5 insertions(+), 6 deletions(-)<br /><br />diff --git a/kernel/smp.c b/kernel/smp.c<br />index f38a1e692259..fbeb9827bdae 100644<br />--- a/kernel/smp.c<br />+++ b/kernel/smp.c<br />&#64;&#64; -19,7 +19,6 &#64;&#64;<br /> <br /> enum {<br /> 	CSD_FLAG_LOCK		= 0x01,<br />-	CSD_FLAG_WAIT		= 0x02,<br /> };<br /> <br /> struct call_function_data {<br />&#64;&#64; -126,7 +125,7 &#64;&#64; static void csd_lock(struct call_single_data *csd)<br /> <br /> static void csd_unlock(struct call_single_data *csd)<br /> {<br />-	WARN_ON((csd-&gt;flags &amp; CSD_FLAG_WAIT) &amp;&amp; !(csd-&gt;flags &amp; CSD_FLAG_LOCK));<br />+	WARN_ON(!(csd-&gt;flags &amp; CSD_FLAG_LOCK));<br /> <br /> 	/*<br /> 	 * ensure we're all done before releasing data:<br />&#64;&#64; -173,9 +172,6 &#64;&#64; static int generic_exec_single(int cpu, struct call_single_data *csd,<br /> 	csd-&gt;func = func;<br /> 	csd-&gt;info = info;<br /> <br />-	if (wait)<br />-		csd-&gt;flags |= CSD_FLAG_WAIT;<br />-<br /> 	/*<br /> 	 * The list addition should be visible before sending the IPI<br /> 	 * handler locks the list to pull the entry off it because of<br />&#64;&#64; -250,8 +246,11 &#64;&#64; static void flush_smp_call_function_queue(bool warn_cpu_offline)<br /> 	}<br /> <br /> 	llist_for_each_entry_safe(csd, csd_next, entry, llist) {<br />-		csd-&gt;func(csd-&gt;info);<br />+		smp_call_func_t func = csd-&gt;func;<br />+		void *info = csd-&gt;info;<br /> 		csd_unlock(csd);<br />+<br />+		func(info);<br /> 	}<br /> <br /> 	/*</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
