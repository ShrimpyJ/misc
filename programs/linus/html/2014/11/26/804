    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2014/11/26/741">First message in thread</a></li><li><a href="/lkml/2014/11/26/752">Linus Torvalds</a><ul><li><a href="/lkml/2014/11/26/770">Sasha Levin</a><ul><li class="origin"><a href="/lkml/2014/11/29/54">Linus Torvalds</a><ul><li><a href="/lkml/2014/11/29/54">Sasha Levin</a><ul><li><a href="/lkml/2014/11/29/118">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 26 Nov 2014 19:13:21 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC v2 1/2] compiler: use compiler to detect integer overflows</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Nov 26, 2014 at 5:37 PM, Sasha Levin &lt;sasha.levin&#64;oracle.com&gt; wrote:<br />&gt;<br />&gt; #define IS_UNSIGNED(A) (((typeof(A))-1) &gt;= 0)<br />&gt; #define TYPE_MAX(A) ((typeof(A))(~0U&gt;&gt;1))<br />&gt; #define TYPE_MIN(A) (-TYPE_MAX(A) - 1)<br />&gt; #define check_add_overflow(A, B)                                        \<br />&gt; ({                                                                      \<br />&gt;         typeof(A) __a = (A);                                            \<br />&gt;         typeof(B) __b = (B);                                            \<br />&gt;         typeof(sizeof(__a) &gt; sizeof(__b) ? __a : __b) __min, __max;     \<br /><br />That doesn't do what you think it does. The "typeof()" on a ternary<br />operator will not pick the type of the selected side, it will pick the<br />normal C integer promotion type of the right-hand sides. The actual<br />_conditional_ matters not at all for the final type.<br /><br />Which actually ends up being the thing you want in this case, but the<br />thing is, it's much better written as<br /><br />    typeof(__a + __b) __min, __max;<br /><br />and leave it at that. That way __min and __max have the type of the<br />integer promotion of A and B.<br /><br />&gt;         if (IS_UNSIGNED(__a) || IS_UNSIGNED(__b))                       \<br />&gt;                 0;                                                      \<br /><br />And again, that's wrong for two reasons. I think you're trying to<br />"return" 0 from the statement expression, but that's not how it works.<br /><br />Also, the logic itself is also wrong. If the smaller type is unsigned,<br />that doesn't help.<br /><br />But once again, the C integer type promotion DTRT, and you should just then do<br /><br />      if (IS_UNSIGNED(__a+__b))<br /><br />but as mentioned, that "if (x) 0;" is not how you'd return 0 anyway.<br />You'd have to make it part of the next expression.<br /><br /><br />&gt;         __min = TYPE_MIN(__min);                                        \<br />&gt;         __max = TYPE_MAX(__max);                                        \<br />&gt;         (((__a &gt; 0) &amp;&amp; (typeof(__max))__b &gt; (__max - ((typeof(__max))__a)))  ||\<br />&gt;                 ((__a &lt; 0) &amp;&amp; (typeof(__max))__b &lt; (__min - ((typeof(__max))__a))));\<br />&gt; })<br /><br />.. which I didn't actually validate. And I suspect gcc won't be good<br />enough to optimize, so it probably generates horrendous code.<br /><br />And the thing is, I think it's just *wrong* to do "overflow in signed<br />type". The code that does it shouldn't be helped to do it, it should<br />be fixed to use an unsigned type.<br /><br />In other words - in this case, the lofft_t should probably just be a u64.<br /><br />                   Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
