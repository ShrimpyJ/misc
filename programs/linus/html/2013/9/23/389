    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2013/9/15/155">First message in thread</a></li><li><a href="/lkml/2013/9/21/109">Linus Torvalds</a><ul><li><a href="/lkml/2013/9/23/36">Davidlohr Bueso</a><ul><li class="origin"><a href="/lkml/2013/9/23/666">Linus Torvalds</a><ul><li><a href="/lkml/2013/9/23/666">Davidlohr Bueso</a><ul><li><a href="/lkml/2013/9/23/687">Linus Torvalds</a></li><li><a href="/lkml/2013/9/24/116">Manfred Spraul</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 23 Sep 2013 09:54:37 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 0/4] ipc: shm and msg fixes</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Sep 22, 2013 at 11:42 PM, Davidlohr Bueso &lt;davidlohr&#64;hp.com&gt; wrote:<br />&gt;&gt;<br />&gt;&gt; More importantly, it's wrong. You do the call_rcu() unconditionally,<br />&gt;&gt; but it might not be the last use! You need to do it with the same<br />&gt;&gt; logic ipc_rcu_putref(), namely at the dropping of the last reference.<br />&gt;<br />&gt; This is the way IPC has handled things for a long time, no? Security<br />&gt; does not depend on the reference counter, as we unconditionally free<br />&gt; security structs.<br /><br />Yes, but that was ok back when the logic was idem-potent and you could<br />call it multiple times. Modulo races (I didn't check if we held a<br />lock).<br /><br />You can't do "call_rcu()" more than once, because you'll corrupt the<br />rcu list if you do another call_rcu() while the first one is still<br />active (and that's a pretty big race window to hit).<br /><br />That said, the old behavior was suspect for another reason too: having<br />the security blob go away from under a user sounds like it could cause<br />various other problems anyway, so I think the old code was at least<br />_prone_ to bugs even if it didn't have catastrophic behavior.<br /><br />(In reality, I suspect the reference count is never elevated in<br />practice, so there is only one case that calls the security freeing<br />thing, so this may all be pretty much theoretical, but at least from a<br />logic standpoint the code clearly makes a big deal about the whole<br />refcount and "last user turns off the lights").<br /><br />&gt; What you're suggesting, is (i) freeing security will now depend on the<br />&gt; refcount (wouldn't this cause cases where we actually never end up<br />&gt; freeing?)<br /><br />The security layer better not have any refcounted backpointers to the<br />shm, so I don't see why that would be a new issue.<br /><br />&gt;  and (ii) in the scenarios we actually need to free the<br />&gt; security, delay it along with freeing the actual ipc_rcu stuff.<br /><br />Well, that's the whole point. The security blob should have the same<br />lifetime as the ipc blob it is associated with.<br /><br />Getting rid of the security blob before the thing it is supposed to<br />protect sounds like  a bug to me. In fact, it's the bug that this<br />whole thread has been about. No?<br /><br />&gt; If I understand correctly, then we'd have:<br />&gt;<br />&gt; void ipc_rcu_putref(void *ptr, void (*func)(struct rcu_head *head))<br />&gt; {<br />&gt;         struct ipc_rcu *p = ((struct ipc_rcu *)ptr) - 1;<br />&gt;<br />&gt;         if (!atomic_dec_and_test(&amp;p-&gt;refcount))<br />&gt;                 return;<br />&gt;<br />&gt;         call_rcu(&amp;p-&gt;rcu, func);<br />&gt; }<br /><br />Exactly.<br /><br />            Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
