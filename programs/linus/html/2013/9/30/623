    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2013/9/30/491">First message in thread</a></li><li><a href="/lkml/2013/9/30/594">Benjamin Herrenschmidt</a><ul><li><a href="/lkml/2013/9/30/622">Michael Neuling</a><ul><li class="origin"><a href="/lkml/2013/9/30/636">Linus Torvalds</a><ul><li><a href="/lkml/2013/9/30/636">Benjamin Herrenschmidt</a><ul><li><a href="/lkml/2013/9/30/645">"Paul E. McKenney"</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 30 Sep 2013 17:56:15 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Avoiding the dentry d_lock on final dput(), part deux: transactional memory</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Sep 30, 2013 at 5:36 PM, Michael Neuling &lt;mikey&#64;neuling.org&gt; wrote:<br />&gt;<br />&gt; The scary part is that we to make all register volatile.  You were not<br />&gt; that keen on doing this as there are a lot of places in exception<br />&gt; entry/exit where we only save/restore a subset of the registers.  We'd<br />&gt; need to catch all these.<br /><br />Ugh. It's very possible it's not worth using for the kernel then. The<br />example I posted is normally fine *without* any transactional support,<br />since it's a very local per-dentry lock, and since we only take that<br />lock when the last reference drops (so it's not some common directory<br />dentry, it's a end-point file dentry). In fact, on ARM they just made<br />the cmpxchg much faster by making it entirely non-serializing (since<br />it only updates a reference count, there is no locking involved apart<br />from checking that the lock state is unlocked)<br /><br />So there is basically never any contention, and the transaction needs<br />to basically be pretty much the same cost as a "cmpxchg". It's not<br />clear if the intel TSX is good enough for that, and if you have to<br />save a lot of registers in order to use transactions on POWER8, I<br />doubt it's worthwhile.<br /><br />We have very few - if any - locks where contention or even cache<br />bouncing is common or normal. Sure, we have a few particular loads<br />that can trigger it, but even that is becoming rare. So from a<br />performance standpoint, the target always needs to be "comparable to<br />hot spinlock in local cache".<br /><br />&gt;&gt; They also have interesting ordering semantics vs. locks, we need to be<br />&gt;&gt; a tad careful (as long as we don't access a lock variable<br />&gt;&gt; transactionally we should be ok. If we do, then spin_unlock needs a<br />&gt;&gt; stronger barrier).<br />&gt;<br />&gt; Yep.<br /><br />Well, just about any kernel transaction will at least read the state<br />of a lock. Without that, it's generally totally useless. My dput()<br />example sequence very much verified that the lock was not held, for<br />example.<br /><br />I'm not sure how that affects anything. The actual transaction had<br />better not be visible inside the locked region (ie as far as any lock<br />users go, transactions better all happen fully before or after the<br />lock, if they read the lock and see it being unlocked).<br /><br />That said, I cannot see how POWER8 could possibly violate that rule.<br />The whole "transactions are atomic" is kind of the whole and only<br />point of a transaction. So I'm not sure what odd lock restrictions<br />POWER8 could have.<br /><br />&gt; FWIW eg.<br />&gt;<br />&gt;      tbegin<br />&gt;      beq abort /* passes first time through */<br />&gt;      ....<br />&gt;      transactional stuff<br />&gt;      ....<br />&gt;      tend<br />&gt;      b pass<br />&gt;<br />&gt; abort:<br />&gt;<br />&gt; pass:<br /><br />That's fine, and matches the x86 semantics fairly closely, except<br />"xbegin" kind of "contains" that "jump to abort address". But we could<br />definitely use the same models. Call it<br />"transaction_begin/abort/end()", and it should be architecture-neutral<br />naming-wise.<br /><br />Of course, if tbegin then acts basically like some crazy<br />assembly-level setjmp (I'm guessing it does exactly, and presumably<br />precisely that kind of compiler support - ie a function with<br />"__attribute((returns_twice))" in gcc-speak), the overhead of doing it<br />may kill it.<br /><br />            Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
