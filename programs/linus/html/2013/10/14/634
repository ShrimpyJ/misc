    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2013/10/14/353">First message in thread</a></li><li><a href="/lkml/2013/10/14/353">Dave Jones</a><ul><li><a href="/lkml/2013/10/14/424">Linus Torvalds</a><ul><li><a href="/lkml/2013/10/14/503">Oleg Nesterov</a></li><li class="origin"><a href="/lkml/2013/10/15/507">Linus Torvalds</a><ul><li><a href="/lkml/2013/10/15/507">Oleg Nesterov</a><ul><li><a href="/lkml/2013/10/15/673">Dave Jones</a></li><li><a href="/lkml/2013/10/16/842">Eric Wong</a></li></ul></li><li><a href="/lkml/2013/10/23/109">Pekka Enberg</a></li><li><a href="/lkml/2013/10/23/298">Peter Hurley</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 14 Oct 2013 13:57:45 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: epoll oops.</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">[ Adding Pekka to verify the SLAB_DESTROY_BY_RCU semantics, and Peter<br />Hurley due to the possible tty association ]<br /><br />On Mon, Oct 14, 2013 at 10:31 AM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; Oleg, does this trigger any memory for you? Commit 971316f0503a<br />&gt; ("epoll: ep_unregister_pollwait() can use the freed pwq-&gt;whead") just<br />&gt; makes me go "Hmm, this is *exactly* that that commit is talking<br />&gt; about.."<br /><br />Ok, Oleg, going back to that whole thread, I think that old bug went like this:<br /><br /> (a) normally all the wait-queues that epoll accesses are associated<br />with files, and as such they cannot go away for any normal file<br />activity. If the file exists, the waitqueue used for poll() on that<br />file must exist.<br /><br /> (b) signalfd is special, and it does a<br /><br />        poll_wait(file, &amp;current-&gt;sighand-&gt;signalfd_wqh);<br /><br />     which means that the wait-queue isn't associated with the file<br />lifetime at all. It cleans it up with signalfd_cleanup() if the signal<br />handlers are removed. Normal (non-epoll) handling is safe, because<br />"current-&gt;sighand" obviously cannot go away as long as the current<br />thread (doing the polling) is in its poll/select handling.<br /><br /> (c) as a result, epoll and exit() can race, since the normal epoll<br />cleanup() is serialized by the file being closed, and we're missing<br />that for the case of sighand going away.<br /><br /> (d) we have this magic POLLFREE protocol to make signal handling<br />cleanup inform the epoll logic that "oops, this is going away", and we<br />depend on the underlying sighand data not going away thanks to the<br />eventual destruction of the slab being delayed by RCU.<br /><br /> (e) we are also very careful to only ever initialize the signalfd_wqh<br />entry in the SLAB *constructor*, because we cannot do it at every<br />allocation: it might still be in reused as long as it exists in the<br />slab cache: the SLAB_DESTROY_BY_RCU flag does *not* delay individual<br />slab entries, it only delays the final free of the underlying memory<br />allocation.<br /><br /> (f) to make things even more exciting, the SLAB_DESTROY_BY_RCU depend<br />on the slab implementation: slub and slob seem to delay each<br />individual allocation (and do ctor/dtor on every allocation), while<br />slab does that "delay only the underlying big page allocator" thing.<br /><br />Agreed so far? Ugly, ugly, ugly, and I think there's exactly one<br />person who understands all of this. Namely you.<br /><br />Anyway, so we protect the magic wait_queue_head_t from going away from<br />under us. We even make sure that we are very careful about only<br />initializing the sighand spinlock and this magic signalfd_wqh only<br />once per RCU lifetime. We're going to a lot of trouble to make this<br />all work. And it looks like it should work.<br /><br />BUT.<br /><br />It's enough that *one* other user of "poll_wait()" does something<br />similar to signalfd, and *doesn't* go through all this effort to make<br />it ok.<br /><br />And I see a few worrisome cases. For example, look at "tty_poll()". It<br />ends up doing something very similar, except it uses the tty instead<br />of sighand. And exactly like the sighand struct, the tty allocation<br />lifespan can - thanks to hangup() - be shorter than the file<br />allocation lifespan.<br /><br />Peter? Does a tty hangup end up actually possibly freeing the tty<br />struct? Looking at it, I'm starting to think that it only affects<br />f_op, and the "struct tty" stays around, in which case this is all<br />fine.<br /><br />Hmm? There might be other cases..<br /><br />                    Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
