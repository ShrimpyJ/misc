    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2013/7/11/709">First message in thread</a></li><li><a href="/lkml/2013/8/13/540">Linus Torvalds</a><ul><li><a href="/lkml/2013/8/13/550">"H. Peter Anvin"</a></li><li><a href="/lkml/2013/8/13/558">Mike Travis</a><ul><li class="origin"><a href="/lkml/2013/8/13/573">Linus Torvalds</a><ul><li><a href="/lkml/2013/8/13/573">Mike Travis</a></li><li><a href="/lkml/2013/8/13/619">Mike Travis</a><ul><li><a href="/lkml/2013/8/13/853">Yinghai Lu</a></li></ul></li><li><a href="/lkml/2013/8/13/704">Nathan Zimmer</a></li><li><a href="/lkml/2013/8/13/751">Nathan Zimmer</a><ul><li><a href="/lkml/2013/8/13/771">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2013/8/14/187">Ingo Molnar</a><ul><li><a href="/lkml/2013/8/14/648">Nathan Zimmer</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 13 Aug 2013 10:51:37 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC v3 0/5] Transparent on-demand struct page initialization embedded in the buddy allocator</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Aug 13, 2013 at 10:33 AM, Mike Travis &lt;travis&#64;sgi.com&gt; wrote:<br />&gt;<br />&gt; Initially this patch set consisted of diverting a major portion of the<br />&gt; memory to an "absent" list during e820 processing.  A very late initcall<br />&gt; was then used to dispatch a cpu per node to add that nodes's absent<br />&gt; memory.  By nature these ran in parallel so Nathan did the work to<br />&gt; "parallelize" various global resource locks to become per node locks.<br /><br />So quite frankly, I'm not sure how worthwhile it even is to<br />parallelize the thing. I realize that some environments may care about<br />getting up to full memory population very quicky, but I think it would<br />be very rare and specialized, and shouldn't necessarily be part of the<br />initial patches.<br /><br />And it really doesn't have to be an initcall at all - at least not a<br />synchronous one. A late initcall to get the process *started*, but the<br />process itself could easily be done with a separate thread<br />asynchronously, and let the machine boot up while that thread is<br />going.<br /><br />And in fact, I'd argue that instead of trying to make it fast and<br />parallelize things excessively, you might want to make the memory<br />initialization *slow*, and make all the rest of the bootup have higher<br />priority.<br /><br />At that point, who cares if it takes 400 seconds to get all memory<br />initialized? In fact, who cares if it takes twice that? Let's assume<br />that the rest of the boot takes 30s (which is pretty aggressive for<br />some big server with terabytes of memory), even if the memory<br />initialization was running in the background and only during idle time<br />for probing, I'm sure you'd have a few hundred gigs of RAM initialized<br />by the time you can log in. And if it then takes another ten minutes<br />until you have the full 16TB initialized, and some things might be a<br />tad slower early on, does anybody really care?  The machine will be up<br />and running with plenty of memory, even if it may not be *all* the<br />memory yet.<br /><br />I realize that benchmarking cares, and yes, I also realize that some<br />benchmarks actually want to reboot the machine between some runs just<br />to get repeatability, but if you're benchmarking a 16TB machine I'm<br />guessing any serious benchmark that actually uses that much memory is<br />going to take many hours to a few days to run anyway? Having some way<br />to wait until the memory is all done (which might even be just a silly<br />shell script that does "ps" and waits for the kernel threads to all go<br />away) isn't going to kill the benchmark - and the benchmark itself<br />will then not have to worry about hittinf the "oops, I need to<br />initialize 2GB of RAM now because I hit an uninitialized page".<br /><br />Ok, so I don't know all the issues, and in many ways I don't even<br />really care. You could do it other ways, I don't think this is a big<br />deal. The part I hate is the runtime hook into the core MM page<br />allocation code, so I'm just throwing out any random thing that comes<br />to my mind that could be used to avoid that part.<br /><br />                    Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
