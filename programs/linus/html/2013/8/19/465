    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2013/7/5/410">First message in thread</a></li><li><a href="/lkml/2013/8/19/435">Simon Kirby</a><ul><li><a href="/lkml/2013/8/19/444">Christoph Lameter</a><ul><li class="origin"><a href="/lkml/2013/8/19/471">Linus Torvalds</a><ul><li><a href="/lkml/2013/8/19/471">Chris Mason</a><ul><li><a href="/lkml/2013/8/19/532">Simon Kirby</a></li></ul></li><li><a href="/lkml/2013/8/20/4">Al Viro</a><ul><li><a href="/lkml/2013/8/20/74">Ian Applegate</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 19 Aug 2013 14:16:36 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [3.10] Oopses in kmem_cache_allocate() via prepare_creds()</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Aug 19, 2013 at 1:29 PM, Christoph Lameter &lt;cl&#64;gentwo.org&gt; wrote:<br />&gt; On Mon, 19 Aug 2013, Simon Kirby wrote:<br />&gt;<br />&gt;&gt;    [... ]  The<br />&gt;&gt; alloc/free traces are always the same -- always alloc_pipe_info and<br />&gt;&gt; free_pipe_info. This is seen on 3.10 and (now) 3.11-rc4:<br />&gt;&gt;<br />&gt;&gt; Object ffff880090f19e78: 6b 6b 6b 6b 6c 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkklkkkkkkkkkkk<br />&gt;<br />&gt; This looks like an increment after free in the second 32 bit value of the<br />&gt; structure. First 32 bit value's poison is unchanged.<br /><br />Ugh. If that is "struct pipe_inode_info" and I read it right, that's<br />the "wait_lock" spinlock that is part of the mutex.<br /><br />Doing a "spin_lock()" could indeed cause an increment operation. But<br />it still sounds like a very odd case. And even for some wild pointer<br />I'd then expect the spin_unlock to also happen, and to then increment<br />the next byte (or word) too. More importantly, for a mutex, I'd expect<br />the *other* fields to be corrupted too (the "waiter" field etc). That<br />is, unless we're still spinning waiting for the mutex, but with that<br />value we shouldn't, as far as I can see.<br /><br />But it kind of does match at least one of your oopses that you had<br />before using slab debugging: one of them had a pointer that should<br />have been NULL that was 0000000100000000. Which again is "increment<br />the second 32-bit word", and could be explained by the slab entry<br />being re-used for another allocation that just happened to have a<br />pointer in the first 8 bytes instead.<br /><br />And I think the timing is interesting, and there is data to back up<br />the fact that it is that mutex field: the field was introduced by<br />commit 72b0d9aacb89 ("pipe: don't use -&gt;i_mutex"), which was merged<br />into 3.10-rc1. So it matches the timing Simon sees. So while I think<br />the pipe mutex spinlock field is a bit odd,<br /><br />Al Viro added to the participants list. Because that<br />pipe-&gt;mutex-&gt;mutex_lock corruption doesn't really make sense to me,<br />but there are certainly interesting coincidences wrt timing.<br /><br />Simon - it *might* be interesting to do this with DEBUG_PAGEALLOC, and<br />make the pipe_inode_info allocations use a full page instead of a<br />kmalloc() in order to trigger that way. So now it uses<br /><br />    pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);<br /><br />and<br /><br />    kfree(pipe);<br /><br />in alloc_pipe_info/free_pipe_info respectively, could you make it use<br /><br />    pipe = (void *)get_zeroed_page(GFP_KERNEL);<br /><br />and<br /><br />    free_page((unsigned long)pipe);<br /><br />instead respectively, and then enable DEBUG_PAGEALLOC? That *should*<br />trigger an exception on the actual bad access, if it really is this<br />pipe_inode_info that is having problems..<br /><br />                  Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
