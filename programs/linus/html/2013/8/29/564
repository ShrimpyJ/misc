    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2013/8/5/722">First message in thread</a></li><li><a href="/lkml/2013/8/29/504">Linus Torvalds</a><ul><li><a href="/lkml/2013/8/29/574">Waiman Long</a><ul><li><a href="/lkml/2013/8/29/594">Linus Torvalds</a><ul><li><a href="/lkml/2013/8/30/78">Sedat Dilek</a><ul><li><a href="/lkml/2013/8/30/81">Sedat Dilek</a></li><li><a href="/lkml/2013/8/30/117">Sedat Dilek</a></li></ul></li><li><a href="/lkml/2013/8/30/448">Waiman Long</a><ul><li><a href="/lkml/2013/8/30/453">Linus Torvalds</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2013/8/29/597">Benjamin Herrenschmidt</a><ul><li><a href="/lkml/2013/8/29/529">Linus Torvalds</a></li><li><a href="/lkml/2013/8/29/555">Michael Neuling</a></li><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2013/8/29/565">Benjamin Herrenschmidt</a></li><li><a href="/lkml/2013/8/29/566">Linus Torvalds</a></li><li><a href="/lkml/2013/8/29/568">Benjamin Herrenschmidt</a></li><li><a href="/lkml/2013/8/29/569">Benjamin Herrenschmidt</a></li><li><a href="/lkml/2013/8/30/63">Ingo Molnar</a><ul><li><a href="/lkml/2013/8/30/340">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2013/9/8/158">Linus Torvalds</a><ul><li><a href="/lkml/2013/9/8/169">Al Viro</a><ul><li><a href="/lkml/2013/9/8/172">Linus Torvalds</a><ul><li><a href="/lkml/2013/9/8/176">Al Viro</a></li><li><a href="/lkml/2013/9/8/192">Ramkumar Ramachandra</a></li></ul></li><li><a href="/lkml/2013/9/8/175">Al Viro</a></li><li><a href="/lkml/2013/9/8/231">Linus Torvalds</a><ul><li><a href="/lkml/2013/9/9/5">Ramkumar Ramachandra</a></li><li><a href="/lkml/2013/9/9/32">Al Viro</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 29 Aug 2013 19:31:23 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH v7 1/4] spinlock: A new lockref structure for lockless update of refcount</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Thu, Aug 29, 2013 at 7:06 PM, Michael Neuling &lt;mikey&#64;neuling.org&gt; wrote:<br />&gt;<br />&gt; Running on a POWER7 here with 32 threads (8 cores x 4 threads) I'm<br />&gt; getting some good improvements:<br /><br />That's *much* better than I get. But I literally just have a single<br />socket with two cores (and HT, so four threads) in my test machine, so<br />I really have a hard time getting any real contention. And the main<br />advantage of the patch should be when you actually have CPU's spinning<br />on that dentry d_lock.<br /><br />Also, on x86, there are no advantages to cmpxchg over a spinlock -<br />they are both exactly one equally serializing instruction. If<br />anything, cmpxchg is worse due to having a cache read before the<br />write, and a few cycles slower anyway. So I actually expect the x86<br />code to slow down a tiny bit for the single-threaded case, although<br />that should be hopefully unmeasurable.<br /><br />On POWER, you may have much less serialization for the cmpxchg. That<br />may sadly be something we'll need to fix - the serialization between<br />getting a lockref and checking sequence counts etc may need some extra<br />work.<br /><br />So it may be that you are seeing unrealistically good numbers, and<br />that we will need to add a memory barrier or two. On x86, due to the<br />locked instruction semantics, that just isn't an issue.<br /><br />&gt; The numbers move around about 10% from run to run.<br /><br />Please note that the whole "dentry hash chains may be better" for one<br />run vs another, and that's something that will _persist_ between<br />subsequent runs, so you may see "only 10% variability", but there may<br />be a bigger picture variability that you're not noticing because you<br />had to reboot in between.<br /><br />To be really comparable, you should really run the stupid benchmark<br />after fairly equal boot up sequences. If the machine had been up for<br />several days for one set of numbers, and freshly rebooted for the<br />other, it can be a very unfair comparison.<br /><br />(I long ago had a nice "L1 dentry cache" patch that helped with the<br />fact that the dentry chains *can* get long especially if you have tons<br />of memory, and that helped with this kind of variability a lot - and<br />improved performance too. It was slightly racy, though, which is why<br />it never got merged).<br /><br />&gt; powerpc patch below. I'm using arch_spin_is_locked() to implement<br />&gt; arch_spin_value_unlocked().<br /><br />Your "slock" is of type "volatile unsigned int slock", so it may well<br />cause those temporaries to be written to memory.<br /><br />It probably doesn't matter, but you may want to check that the result<br />of "make lib/lockref.s" looks ok.<br /><br />                 Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
