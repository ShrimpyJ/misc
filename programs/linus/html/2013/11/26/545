    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2013/7/5/410">First message in thread</a></li><li><a href="/lkml/2013/11/25/804">Simon Kirby</a><ul><li><a href="/lkml/2013/11/26/621">Linus Torvalds</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2013/11/30/15">Simon Kirby</a><ul><li><a href="/lkml/2013/11/30/130">Linus Torvalds</a><ul><li><a href="/lkml/2013/11/30/152">Simon Kirby</a></li></ul></li><li><a href="/lkml/2013/11/30/153">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2013/11/26/545/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 26 Nov 2013 15:44:26 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [3.10] Oopses in kmem_cache_allocate() via prepare_creds()</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Tue, Nov 26, 2013 at 3:16 PM, Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; I'm really not very happy with the whole pipe locking logic (or the<br />&gt; refcounting we do, separately from the "struct inode"), and in that<br />&gt; sense I'm perfectly willing to blame that code for doing bad things.<br />&gt; But the fact that it all goes away with debugging makes me very very<br />&gt; unhappy.<br /><br />Al, I really hate the "pipe_lock()" function that tests for<br />"pipe-&gt;files" being non-zero. I don't think there are any valid cases<br />where pipe-&gt;file ever *could* be zero, and if there are, they are<br />fundamentally racy.<br /><br />Is there really any reason for that test? It used to test for<br />"pipe-&gt;inode" and that kind of made sense as the pipe didn't even have<br />a lock (it re-used the inode one). But these days that test makes zero<br />sense, except as a "don't even bother locking if this is some fake<br />internal pipe", but is that even valid?<br /><br />Also, why does "pipe_release()" still use i_pipe. I'd much rather it<br />used "file-&gt;private_data" like everything else (and then it<br />unconditionally clear it). We are, after all, talking about releasing<br />the *file*, and we shouldn't be mixing up that inode in there.<br /><br />IOW, what is wrong with the attached patch? Then we could/should<br /><br /> - make the free_pipe_info() happen from the drop_inode()<br /><br /> - delete pipe-&gt;files counter entirely because it has no valid use<br /><br />Hmm?<br /><br />                 Linus<br /> fs/pipe.c | 11 ++++++-----<br /> 1 file changed, 6 insertions(+), 5 deletions(-)<br /><br />diff --git a/fs/pipe.c b/fs/pipe.c<br />index d2c45e14e6d8..719214ed5e5e 100644<br />--- a/fs/pipe.c<br />+++ b/fs/pipe.c<br />&#64;&#64; -56,8 +56,8 &#64;&#64; unsigned int pipe_min_size = PAGE_SIZE;<br /> <br /> static void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)<br /> {<br />-	if (pipe-&gt;files)<br />-		mutex_lock_nested(&amp;pipe-&gt;mutex, subclass);<br />+	WARN_ON_ONCE(!pipe-&gt;files);<br />+	mutex_lock_nested(&amp;pipe-&gt;mutex, subclass);<br /> }<br /> <br /> void pipe_lock(struct pipe_inode_info *pipe)<br />&#64;&#64; -71,8 +71,8 &#64;&#64; EXPORT_SYMBOL(pipe_lock);<br /> <br /> void pipe_unlock(struct pipe_inode_info *pipe)<br /> {<br />-	if (pipe-&gt;files)<br />-		mutex_unlock(&amp;pipe-&gt;mutex);<br />+	WARN_ON_ONCE(!pipe-&gt;files);<br />+	mutex_unlock(&amp;pipe-&gt;mutex);<br /> }<br /> EXPORT_SYMBOL(pipe_unlock);<br /> <br />&#64;&#64; -729,9 +729,10 &#64;&#64; pipe_poll(struct file *filp, poll_table *wait)<br /> static int<br /> pipe_release(struct inode *inode, struct file *file)<br /> {<br />-	struct pipe_inode_info *pipe = inode-&gt;i_pipe;<br />+	struct pipe_inode_info *pipe = file-&gt;private_data;<br /> 	int kill = 0;<br /> <br />+	file-&gt;private_data = NULL;<br /> 	__pipe_lock(pipe);<br /> 	if (file-&gt;f_mode &amp; FMODE_READ)<br /> 		pipe-&gt;readers--;</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
