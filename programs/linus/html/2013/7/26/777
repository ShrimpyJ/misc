    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2013/7/26/810">First message in thread</a></li><li><a href="/lkml/2013/7/26/810">"Paul E. McKenney"</a><ul><li class="origin"><a href="">Linus Torvalds</a></li><li><a href="/lkml/2013/7/26/798">"Paul E. McKenney"</a></li><li><a href="/lkml/2013/7/26/814">Dave Chinner</a><ul><li><a href="/lkml/2013/7/27/1">"Paul E. McKenney"</a><ul><li><a href="/lkml/2013/7/27/12">Dave Chinner</a><ul><li><a href="/lkml/2013/7/27/55">"Paul E. McKenney"</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Fri, 26 Jul 2013 17:29:44 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH RFC fs] v2 Make sync() satisfy many requests with one invocation</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Jul 26, 2013 at 4:28 PM, Paul E. McKenney<br />&lt;paulmck&#64;linux.vnet.ibm.com&gt; wrote:<br />&gt; +<br />&gt; +       snap = ACCESS_ONCE(sync_seq);<br />&gt; +       smp_mb();  /* Prevent above from bleeding into critical section. */<br />&gt; +       mutex_lock(&amp;sync_mutex);<br />&gt; +       snap_done = ACCESS_ONCE(sync_seq);<br />&gt; +       if (ULONG_CMP_GE(snap_done, ((snap + 1) &amp; ~0x1) + 2)) {<br /><br />Ugh. I dislike this RCU'ism. It's bad code. It doesn't just look ugly<br />and complex, it's also not even clever.<br /><br />It is possible that the compiler can fix up this horrible stuff and<br />turn it into the nice clever stuff, but I dunno.<br /><br />The two things that make me go "Eww":<br /><br /> - "((snap + 1) &amp; ~0x1) + 2" just isn't the smart way of doing things.<br />Afaik, "(snap+3)&amp;~1" gives the same answer with a simpler arithmetic.<br /><br /> - that ULONG_CMP_GE() macro is disgusting. What's wrong with doing it<br />the sane way, which is how (for example) the time comparison functions<br />do it (see time_before() and friends): Just do it<br /><br />     ((long)(a-b) &gt;= 0)<br /><br />   which doesn't need large constants.<br /><br />And yeah, a smart compiler will hopefully do one or both of those, but<br />what annoys me about the source code is that it actually isn't even<br />any more readable despite being more complicated and needing more<br />compiler tricks for good code generation.<br /><br />So that one line is (a) totally undocumented, (b) not obvious and (c)<br />not very clever.<br /><br />I'm also not a huge believer in those two WARN_ON_ONCE's you have. The<br />sequence count is *only* updated in this place, it is *only* updated<br />inside a lock, and dammit, if those tests ever trigger, we have bigger<br />problems than that piece of code. Those warnings may make sense in<br />code when you write it the first time (because you're thinking things<br />through), but they do *not* make sense at the point where that code is<br />actually committed to the project. I notice that you have those<br />warnings in the RCU code itself, and I don't really think they make<br />sense there either.<br /><br />Finally, the ACCESS_ONCE() is also only correct in the one place where<br />you do the access speculatively outside the lock. Inside the lock,<br />there is no excuse/reason for them, since the value is stable, and you<br />need the memory barriers anyway, so there's no way the compiler could<br />migrate things regardless. So the other two ACCESS_ONCE calls are<br />actually misleading and wrong, and only likely to make the compiler<br />generate much worse code.<br /><br />In fact, the ACCESS_ONCE() is pretty much *guaranteed* to cause the<br />compiler to unnecessarily generate worse code, since there is<br />absolutely no reason why the compiler couldn't reuse the "snap_done"<br />value it reads when it then does the "sync_seq++". There's no way the<br />value could possible have changed from the "snap_done" value earlier,<br />since we're inside the lock, so why force the compiler to reload it?<br /><br />In short, I think the code does too much. I'm sure it works, but I<br />think it might make people believe that the extra work (like those<br />later ACCESS_ONCE ones) is meaningful, when it isn't. It's just<br />make-believe, afaik.<br /><br />But maybe I'm missing something, and there actually *is* reason for<br />the extra work/complexity?<br /><br />                 Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
