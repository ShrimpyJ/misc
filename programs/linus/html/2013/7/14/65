    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2013/7/14/29">First message in thread</a></li><li><a href="/lkml/2013/7/14/52">Linus Torvalds</a><ul><li><a href="/lkml/2013/7/14/57">Ramkumar Ramachandra</a><ul><li><a href="/lkml/2013/7/14/60">Linus Torvalds</a><ul><li><a href="/lkml/2013/7/14/62">Ramkumar Ramachandra</a></li></ul></li></ul></li><li><a href="/lkml/2013/7/14/61">Tim Northover</a><ul><li class="origin"><a href="/lkml/2013/7/14/68">Linus Torvalds</a><ul><li><a href="/lkml/2013/7/14/68">Tim Northover</a><ul><li><a href="/lkml/2013/7/14/70">Linus Torvalds</a></li><li><a href="/lkml/2013/7/14/72">Jeremy Fitzhardinge</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2013/7/14/73">Jeremy Fitzhardinge</a><ul><li><a href="/lkml/2013/7/14/74">Linus Torvalds</a></li><li><a href="/lkml/2013/7/15/425">"H. Peter Anvin"</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 14 Jul 2013 12:09:21 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [LLVMdev] [PATCH] x86/asm: avoid mnemonics without type suffix</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sun, Jul 14, 2013 at 11:35 AM, Tim Northover &lt;t.p.northover&#64;gmail.com&gt; wrote:<br />&gt;<br />&gt; I'm coming at this from the compiler side, where the register form is<br />&gt; unambiguous and not questioned. The discussion we're having involves<br />&gt; only the immediate form of the instruction. GNU as interprets:<br />&gt;<br />&gt;     bt $63, mem<br />&gt;<br />&gt; as<br />&gt;     btl $63, mem<br />&gt;<br />&gt; which may or may not be what the user intended, but is not the same as<br />&gt; "btq $63, mem".<br /><br />Umm. The user doesn't care. The user wants the best code without<br />having to worry about it.<br /><br />Think of it this way: the whole and ONLY point of an assembler is to<br />make machine code reasonably easy to write, by not having to worry<br />about the exact encoding details. We don't want the users specifying<br />the hex representation of the instructions, do we? Or even details<br />like "what is the most efficient form of this instruction". For<br />example, think about branch offsets and immediates. Most architectures<br />have some limits about how long branch offsets or immediates are, and<br />a short branch offset may use TOTALLY DIFFERENT instruction encoding<br />than a long branch offset.<br /><br />Do you really expect that the user says "jnel" for the long form of<br />the "jne" instruction? And "jnes" if you want the<br />smaller/faster/simpler 8-bit version?<br /><br />No sane person actually wants that, and no modern assembler does that<br />(although I can remember ones that did - ugh). You write "jne target"<br />and depend on the assembler doing the right thing. Or you write "add<br />$5,%eax", and depend on the fact that the assembler will use the much<br />shorter version of the "add" instruction that just takes a 8-bit<br />signed value instead of the full 32-bit immediate. Or any number of<br />details like this ("there are special versions that only work on %eax"<br />etc rules)<br /><br />And that is why I think you should just consider "bt $x,y" to be<br />trivially the same thing and not at all ambiguous. Because there is<br />ABSOLUTELY ZERO ambiguity when people write<br /><br />   bt $63, mem<br /><br />Zero. Nada. None. The semantics are *exactly* the same for btl and btq<br />in this case, so why would you want the user to specify one or the<br />other? The user may be knowledgeable about the architecture, and know<br />that "btl" is one byte shorter than "btq", and use "btl" for that<br />reason. You seem to argue that that is the "right thing"(tm) to do,<br />since that's what the instruction encoding will be. But if that's the<br />case, then you are arguing that "jne target" is "ambiguous" because<br />there are two different ways to encode that too? Do you seriously<br />argue that?<br /><br />So I'm arguing that that is wrong for an assembler to not just do the<br />right thing, because the user isn't *supposed* to have to know about<br />things like "one byte shorter encoding format". And there really is no<br />semantic difference between the two forms. So making the user specify<br />the size is just going to cause problems (in particular, it might well<br />make users go "this is an array of 64-bit entities, so I should use<br />btq", even though that is actually incorrect).<br /><br />Now, I obviously think that the user should have the choice to<br />*override* the default thing, so sometimes you might have<br /><br />   /* We use a 64-bit btsq to encourage the CPU to do it as a 64-bit<br />read-modify-write, since we will do a 64-bit read of the result later,<br />and otherwise we'll get a partial write buffer stall */<br /><br />   btsq $63, mem<br /><br />and then the assembler had obviously better use the size information<br />the user gave it. But the thing is, this is basically never a concern<br />in practice, and when it is, the assembler really cannot know (it<br />could go either way: maybe the bts is following a 32-bit write, and<br />you want the 32-bit version - and I suspect that the likelihood of<br />most users getting this right by hand is quite low too).<br /><br />(Side note: I'm not even going to guarantee that the actual CPU uses<br />the operand size for the memory access size. The manuals imply they<br />do, but since there are no real semantic reasons to enforce that, I<br />could imagine that some microarchitecture doesn't actually care).<br /><br />                    Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
