    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2021/7/21/524">First message in thread</a></li><li><a href="/lkml/2021/7/21/787">Linus Torvalds</a><ul><li><a href="/lkml/2021/7/21/799">Nikolay Borisov</a><ul><li class="origin"><a href="/lkml/2021/7/21/849">Linus Torvalds</a><ul><li><a href="/lkml/2021/7/21/849">Linus Torvalds</a></li><li><a href="/lkml/2021/7/21/871">Linus Torvalds</a><ul><li><a href="/lkml/2021/7/22/517">Nikolay Borisov</a></li></ul></li><li><a href="/lkml/2021/7/22/180">Nikolay Borisov</a></li><li><a href="/lkml/2021/7/23/492">David Laight</a></li></ul></li></ul></li><li><a href="/lkml/2021/7/21/914">David Sterba</a><ul><li><a href="/lkml/2021/7/21/945">Linus Torvalds</a><ul><li><a href="/lkml/2021/7/22/46">Nikolay Borisov</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2021/7/21/846/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 21 Jul 2021 11:45:36 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] lib/string: Bring optimized memcmp from glibc</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Jul 21, 2021 at 11:17 AM Nikolay Borisov &lt;nborisov&#64;suse.com&gt; wrote:<br />&gt;<br />&gt; I find it somewhat arbitrary that we choose to align the 2nd pointer and<br />&gt; not the first.<br /><br />Yeah, that's a bit odd, but I don't think it matters.<br /><br />The hope is obviously that they are mutually aligned, and in that case<br />it doesn't matter which one you aim to align.<br /><br />&gt; So you are saying that the current memcmp could indeed use improvement<br />&gt; but you don't want it to be based on the glibc's code due to the ugly<br />&gt; misalignment handling?<br /><br />Yeah. I suspect that this (very simple) patch gives you the same<br />performance improvement that the glibc code does.<br /><br />NOTE! I'm not saying this patch is perfect. This one doesn't even<br />_try_ to do the mutual alignment, because it's really silly. But I'm<br />throwing this out here for discussion, because<br /><br /> - it's really simple<br /><br /> - I suspect it gets you 99% of the way there<br /><br /> - the code generation is actually quite good with both gcc and clang.<br />This is gcc:<br /><br />        memcmp:<br />                jmp     .L60<br />        .L52:<br />                movq    (%rsi), %rax<br />                cmpq    %rax, (%rdi)<br />                jne     .L53<br />                addq    $8, %rdi<br />                addq    $8, %rsi<br />                subq    $8, %rdx<br />        .L60:<br />                cmpq    $7, %rdx<br />                ja      .L52<br />                testq   %rdx, %rdx<br />                je      .L61<br />        .L53:<br />                xorl    %ecx, %ecx<br />                jmp     .L56<br />        .L62:<br />                addq    $1, %rcx<br />                cmpq    %rcx, %rdx<br />                je      .L51<br />        .L56:<br />                movzbl  (%rdi,%rcx), %eax<br />                movzbl  (%rsi,%rcx), %r8d<br />                subl    %r8d, %eax<br />                je      .L62<br />        .L51:<br />                ret<br />        .L61:<br />                xorl    %eax, %eax<br />                ret<br /><br />and notice how there are no spills, no extra garbage, just simple and<br />straightforward code.<br /><br />Those things ends mattering too - it's good for I$, it's good for the<br />small cases, and it's good for debugging and reading the code.<br /><br />If this is "good enough" for your test-case, I really would prefer<br />something like this. "Make it as simple as possible, but no simpler"<br /><br />I can do the mutual alignment too, but I'd actually prefer to do it as<br />a separate patch, for when there are numbers for that.<br /><br />And I wouldn't do it as a byte-by-byte case, because that's just stupid.<br /><br />I'd do it using a separate first single "get unaligned word from both<br />sources, compare them for equality, and then only add enough bytes to<br />align"<br /><br />                  Linus<br /> lib/string.c | 16 ++++++++++++++++<br /> 1 file changed, 16 insertions(+)<br /><br />diff --git a/lib/string.c b/lib/string.c<br />index 77bd0b1d3296..b2de45a581f4 100644<br />--- a/lib/string.c<br />+++ b/lib/string.c<br />&#64;&#64; -29,6 +29,7 &#64;&#64;<br /> #include &lt;linux/errno.h&gt;<br /> #include &lt;linux/slab.h&gt;<br /> <br />+#include &lt;asm/unaligned.h&gt;<br /> #include &lt;asm/byteorder.h&gt;<br /> #include &lt;asm/word-at-a-time.h&gt;<br /> #include &lt;asm/page.h&gt;<br />&#64;&#64; -935,6 +936,21 &#64;&#64; __visible int memcmp(const void *cs, const void *ct, size_t count)<br /> 	const unsigned char *su1, *su2;<br /> 	int res = 0;<br /> <br />+#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS<br />+	if (count &gt;= sizeof(unsigned long)) {<br />+		const unsigned long *u1 = cs;<br />+		const unsigned long *u2 = ct;<br />+		do {<br />+			if (get_unaligned(u1) != get_unaligned(u2))<br />+				break;<br />+			u1++;<br />+			u2++;<br />+			count -= sizeof(unsigned long);<br />+		} while (count &gt;= sizeof(unsigned long));<br />+		cs = u1;<br />+		ct = u2;<br />+	}<br />+#endif<br /> 	for (su1 = cs, su2 = ct; 0 &lt; count; ++su1, ++su2, count--)<br /> 		if ((res = *su1 - *su2) != 0)<br /> 			break;</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
