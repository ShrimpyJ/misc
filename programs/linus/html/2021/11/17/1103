    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2021/11/17/1089">First message in thread</a></li><li><a href="/lkml/2021/11/17/1089">Steven Rostedt</a><ul><li class="origin"><a href="/lkml/2021/11/17/1117">Linus Torvalds</a><ul><li><a href="/lkml/2021/11/17/1117">Steven Rostedt</a><ul><li><a href="/lkml/2021/11/17/1128">Kalesh Singh</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2021/11/17/1103/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 17 Nov 2021 15:38:59 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [GIT PULL] tracing: Fix double free bug</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Nov 17, 2021 at 3:19 PM Steven Rostedt &lt;rostedt&#64;goodmis.org&gt; wrote:<br />&gt;<br />&gt; On error, the operands and the histogram expression are destroyed,<br />&gt; but since the destruction is recursive, do not destroy the operands<br />&gt; if they already belong to the expression that is about to be destroyed.<br /><br />Honestly, this seems horribly ugly.<br /><br />The problem seems to be that the "goto error" cases are simply just wrong.<br /><br />Why isn't the fix to make the error cases be the right ones, instead<br />of having one odd error case that then has to do some magic things to<br />not free the wrong things?<br /><br />The patch ends up a bit bigger, mainly because I renamed the different<br />"free" cases, and because I made the non-freeing ones just return the<br />error directly.<br /><br />Something like this (UNTESTED!) patch, IOW?<br /><br />          Linus<br /> kernel/trace/trace_events_hist.c | 40 ++++++++++++++++++++++------------------<br /> 1 file changed, 22 insertions(+), 18 deletions(-)<br /><br />diff --git a/kernel/trace/trace_events_hist.c b/kernel/trace/trace_events_hist.c<br />index 5ea2c9ec54a6..42ee3e95deb7 100644<br />--- a/kernel/trace/trace_events_hist.c<br />+++ b/kernel/trace/trace_events_hist.c<br />&#64;&#64; -2576,28 +2576,27 &#64;&#64; static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,<br /> <br /> 	/* Split the expression string at the root operator */<br /> 	if (!sep)<br />-		goto free;<br />+		return ERR_PTR(-EINVAL);<br />+<br /> 	*sep = '\0';<br /> 	operand1_str = str;<br /> 	str = sep+1;<br /> <br /> 	/* Binary operator requires both operands */<br /> 	if (*operand1_str == '\0' || *str == '\0')<br />-		goto free;<br />+		return ERR_PTR(-EINVAL);<br /> <br /> 	operand_flags = 0;<br /> <br /> 	/* LHS of string is an expression e.g. a+b in a+b+c */<br /> 	operand1 = parse_expr(hist_data, file, operand1_str, operand_flags, NULL, n_subexprs);<br />-	if (IS_ERR(operand1)) {<br />-		ret = PTR_ERR(operand1);<br />-		operand1 = NULL;<br />-		goto free;<br />-	}<br />+	if (IS_ERR(operand1))<br />+		return ERR_CAST(operand1);<br />+<br /> 	if (operand1-&gt;flags &amp; HIST_FIELD_FL_STRING) {<br /> 		hist_err(file-&gt;tr, HIST_ERR_INVALID_STR_OPERAND, errpos(operand1_str));<br /> 		ret = -EINVAL;<br />-		goto free;<br />+		goto free_op1;<br /> 	}<br /> <br /> 	/* RHS of string is another expression e.g. c in a+b+c */<br />&#64;&#64; -2606,12 +2605,12 &#64;&#64; static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,<br /> 	if (IS_ERR(operand2)) {<br /> 		ret = PTR_ERR(operand2);<br /> 		operand2 = NULL;<br />-		goto free;<br />+		goto free_op1;<br /> 	}<br /> 	if (operand2-&gt;flags &amp; HIST_FIELD_FL_STRING) {<br /> 		hist_err(file-&gt;tr, HIST_ERR_INVALID_STR_OPERAND, errpos(str));<br /> 		ret = -EINVAL;<br />-		goto free;<br />+		goto free_operands;<br /> 	}<br /> <br /> 	switch (field_op) {<br />&#64;&#64; -2629,12 +2628,12 &#64;&#64; static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,<br /> 		break;<br /> 	default:<br /> 		ret = -EINVAL;<br />-		goto free;<br />+		goto free_operands;<br /> 	}<br /> <br /> 	ret = check_expr_operands(file-&gt;tr, operand1, operand2, &amp;var1, &amp;var2);<br /> 	if (ret)<br />-		goto free;<br />+		goto free_operands;<br /> <br /> 	operand_flags = var1 ? var1-&gt;flags : operand1-&gt;flags;<br /> 	operand2_flags = var2 ? var2-&gt;flags : operand2-&gt;flags;<br />&#64;&#64; -2653,12 +2652,13 &#64;&#64; static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,<br /> 	expr = create_hist_field(hist_data, NULL, flags, var_name);<br /> 	if (!expr) {<br /> 		ret = -ENOMEM;<br />-		goto free;<br />+		goto free_operands;<br /> 	}<br /> <br /> 	operand1-&gt;read_once = true;<br /> 	operand2-&gt;read_once = true;<br /> <br />+	/* The operands are now owned and free'd by 'expr' */<br /> 	expr-&gt;operands[0] = operand1;<br /> 	expr-&gt;operands[1] = operand2;<br /> <br />&#64;&#64; -2669,7 +2669,7 &#64;&#64; static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,<br /> 		if (!divisor) {<br /> 			hist_err(file-&gt;tr, HIST_ERR_DIVISION_BY_ZERO, errpos(str));<br /> 			ret = -EDOM;<br />-			goto free;<br />+			goto free_expr;<br /> 		}<br /> <br /> 		/*<br />&#64;&#64; -2709,18 +2709,22 &#64;&#64; static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,<br /> 		expr-&gt;type = kstrdup_const(operand1-&gt;type, GFP_KERNEL);<br /> 		if (!expr-&gt;type) {<br /> 			ret = -ENOMEM;<br />-			goto free;<br />+			goto free_expr;<br /> 		}<br /> <br /> 		expr-&gt;name = expr_str(expr, 0);<br /> 	}<br /> <br /> 	return expr;<br />-free:<br />-	destroy_hist_field(operand1, 0);<br />+<br />+free_operands:<br /> 	destroy_hist_field(operand2, 0);<br />-	destroy_hist_field(expr, 0);<br />+free_op1:<br />+	destroy_hist_field(operand1, 0);<br />+	return ERR_PTR(ret);<br /> <br />+free_expr:<br />+	destroy_hist_field(expr, 0);<br /> 	return ERR_PTR(ret);<br /> }<br /> </pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
