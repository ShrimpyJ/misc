    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2021/9/21/996">First message in thread</a></li><li><a href="/lkml/2021/9/22/1034">Linus Torvalds</a><ul><li><a href="/lkml/2021/9/23/14">Joe Perches</a></li><li><a href="/lkml/2021/9/25/229">David Laight</a><ul><li class="origin"><a href="/lkml/2021/9/27/128">Linus Torvalds</a><ul><li><a href="/lkml/2021/9/27/128">David Laight</a><ul><li><a href="/lkml/2021/9/27/182">Willy Tarreau</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sun, 26 Sep 2021 14:03:56 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: function prototype element ordering</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sat, Sep 25, 2021 at 12:40 PM David Laight &lt;David.Laight&#64;aculab.com&gt; wrote:<br />&gt;<br />&gt; If the function name starts at the beginning of a line it is<br />&gt; much easier to grep for the definition.<br /><br />That has always been a completely bogus argument. I grep to look up<br />the type as often as I grep for the function definition, plus it's not<br />at all unlikely that the "function" is actually a macro wrapper, so<br />grepping for the beginning of line is just completely wrong.<br /><br />It's completely wrong for another reason too: it assumes a style of<br />programming that has never actually been all that common. It's a very<br />specific pattern to very specific projects, and anybody who learnt<br />that pattern for their project is going to be completely lost anywhere<br />else. So don't do it. It's just a bad idea.<br /><br />So a broken "easier to grep for" is not an excuse for "make the code<br />harder to read" particularly when it just makes another type of<br />grepping harder, and it's not actually nearly universal enough to<br />actually be a useful pattern in the first place.<br /><br />It's not only never been the pattern in the kernel, but it's generally<br />not been the pattern anywhere else either. It's literally one of the<br />broken GNU coding standards - and the fact that almost every other<br />part of the GNU coding standards were wrong (indentation, placement of<br />braces, you name it) should give you a hint about how good _that_ one<br />was.<br /><br />Here's an exercise for you: go search for C coding examples on the<br />web, and see how many of them do<br /><br />    int main(int argc, char **argv)<br /><br />vs how many of them do<br /><br />    int<br />    main(int argc, char **argv)<br /><br />and then realize that in order for the "grep for ^main" pattern to be<br />useful, the second version has to not just be more common, it has to<br />be practically *universal*.<br /><br />Hint: it isn't even remotely more common, much less universal. In<br />Debian code search, I had to go to the third page to find any example<br />at all of people putting the "int" and the "main" on different lines,<br />and even that one didn't place the "main()" at the beginning of the<br />line - they had been separated because of other reasons and looked<br />like this:<br /><br />int<br />#ifdef _WIN32<br />    __cdecl<br />#endif // _WIN32<br />    main(int argc, char** argv)<br /><br />instead.<br /><br />Maybe Dbian code search isn't the place to go, but I think it proves<br />my case: the "function name at beginning of line" story is pure<br />make-believe, and has absolutely no relevance in the real world.<br /><br />It's a bad straightjacket. Just get over it, and stop perpetuating the<br />idiotic myth.<br /><br />If you care so much about grepping for function declarations, and you<br />use that old-fashioned GNU coding standard policy as an argument, just<br />be *properly* old-fashioned instead, and use etags or something.<br /><br />Don't make the rest of us suffer.<br /><br />Because I grep for functions all the time, and I'd rather have useful<br />output - which very much includes the type of the function. That's<br />often one reason _why_ I grep for things in the first place.<br /><br />Other grep tricks for when the function really is used everywhere, and<br />you are having trouble finding the definition vs the use:<br /><br /> - grep in the headers for the type, and actually use the type (either<br />of the function, or the first argument) as part of the pattern.<br /><br />   If you really have no idea where it might be, you'll want to start<br />off with the header grep anyway, to find the macro case (or the inline<br />case)<br /><br />   Yeah, splitting the declaration will screw the type information up.<br />So don't do that, then.<br /><br /> - if it's so widely used that you find it all over, it's probably<br />exported. grep for 'EXPORT.*fnname' to see where it is defined.<br /><br />   We used to (brokenly) export things separately from the definition.<br />If you find cases of that, let's fix them.<br /><br />Of course, usually I know roughly where it is defined, so I just limit<br />the pathnames for 'git grep'.<br /><br />But the 'add the type of the return value or first argument to the<br />pattern' is often my second go-to (particularly for the cases where<br />you might be looking for _multiple_ definitions because it's some<br />architecture-specific thing, or you have some partial pattern because<br />every filesystem does their own thing).<br /><br />Other 'git grep' patterns that often work for kernel sources:<br /><br /> - looking for a structure declaration? Use<br /><br />      git grep 'struct name {'<br /><br />   which mostly works, but obviously depends on coding style so it's<br />not guaranteed. Good first thing to try, though.<br /><br /> - use<br /><br />        git grep '\t\.name\&gt;.*='<br /><br />   to find things like particular inode operations.<br /><br />That second case is because we have almost universally converted our<br />filesystem operation initializers to use that named format (and really<br />strive to have a policy of constant structures of function pointers<br />only), and it's really convenient if you are doing VFS changes and<br />need to find all the places that use a particular VFS interface (eg<br />".get_acl" or similar).<br /><br />It used to be a nightmare to find those things back when most of our<br />initializers were using the traditional unnamed ordered structure<br />initializers, so this is one area where we've introduced coding style<br />policies to make it really easy to grep for things (but also much<br />easier to add new fields and not have to add pointless NULL<br />initializer elements, of course).<br /><br />             Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
