    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2021/9/19/298">First message in thread</a></li><li><a href="/lkml/2021/9/19/298">Linus Torvalds</a><ul><li><a href="/lkml/2021/9/20/444">Guenter Roeck</a><ul><li class="origin"><a href="/lkml/2021/9/20/2038">Linus Torvalds</a><ul><li><a href="/lkml/2021/9/20/2038">Linus Torvalds</a><ul><li><a href="/lkml/2021/9/20/2126">John Paul Adrian Glaubitz</a></li><li><a href="/lkml/2021/9/20/2384">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 20 Sep 2021 09:18:30 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Linux 5.15-rc2</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Sep 20, 2021 at 6:44 AM Guenter Roeck &lt;linux&#64;roeck-us.net&gt; wrote:<br />&gt;<br />&gt; Details for build failures below. Several improvements since last week,<br />&gt; but it looks like the alpha related pci_iounmap patches still need some<br />&gt; tweaking (see error log at the very end).<br /><br />Bah.<br /><br />I thought I had tested sparc64, but I was wrong.<br /><br />Silly me, I had only tested the 32-bit case.<br /><br />That sparc64 thing is being particularly stupid: sparc64 uses<br />GENERIC_PCI_IOMAP, but declares its own empty pci_iounmap() because it<br />didn't use GENERIC_IOMAP that does this all right.<br /><br />And because it didn't use the generic iomap code, it's all actually<br />entirely buggy, in that it seems to think that pci_iounmap() is about<br />unmapping ports (like ioport_unmap) and thus a no-op. But no,<br />pci_iounmap() is supposed to unmap anything that pci_iomap() mapped,<br />which includes the actual MMIO range too.<br /><br />Basically, the whole idea of "pci_iomap()" is that you give it a PCI<br />device and the index to the BAR in that device, and it maps that BAR -<br />whether it is MMIO or PIO. And then you can use that __iomem pointer<br />for ioread*() and friends (or you can use readl()/writel() if you know<br />it was MMIO).<br /><br />You can give it a maximum length if you want, but by default it just<br />maps the whole PCI BAR, so the default usage would just be<br /><br />    void __iomem *map = pci_iomap(pdev, bar, 0);<br /><br />And then you do whatever IO using that 'map' base pointer, and once<br />you're done you do "pci_iounmap()" on it all.<br /><br />And then the trick most cases use is that they know that the PIO case<br />is just always a fixed map, so for PIO that "map/unmap" part os a<br />no-op. But generally ONLY for the PIO case.<br /><br />And the sparc64 code seems to think it's only used for PIO, and makes<br />pci_iounmap() a no-op in general. Which is all kinds of completely<br />broken.<br /><br />This is the same bug that the broken inline function in<br />&lt;asm-generic/io.h&gt; had, and that I added a big comment about in commit<br />316e8d79a095 ("pci_iounmap'2: Electric Boogaloo: try to make sense of<br />it all"):<br /><br />+ * This code is odd, and the ARCH_HAS/ARCH_WANTS #define logic comes<br />+ * from legacy &lt;asm-generic/io.h&gt; header file behavior. In particular,<br />+ * it would seem to make sense to do the iounmap(p) for the non-IO-space<br />+ * case here regardless, but that's not what the old header file code<br />+ * did. Probably incorrectly, but this is meant to be bug-for-bug<br />+ * compatible.<br /><br />but I intentionally didn't fix the bug in that commit, because I<br />wanted to just try to keep the odd old logic as closely as possible.<br /><br />It looks like a big part of the "people do their own pci_iounmap()"<br />thing is that they do it badly and with bugs.<br /><br />This was all meant to uncover and fix warnings, but it seems to be<br />uncovering bigger issues.<br /><br />Of course, most of the time the "pci_iounmap()" only happens at driver<br />unload time, so it's basically only a kernel virtual memory mapping<br />leak, which may be why people didn't realize how buggy their own<br />implementations were.<br /><br />What the normal GENERIC_IOMAP code does is:<br /><br /> - it "fake maps" the PIO space at an invalid fixed virtual address<br /><br />   Since we know that a PIO address on PCI is just a 16-bit number,<br />this fake virtual window is small and easy to do:<br /><br />        /*<br />         * We encode the physical PIO addresses (0-0xffff) into the<br />         * pointer by offsetting them with a constant (0x10000) and<br />         * assuming that all the low addresses are always PIO. That means<br />         * we can do some sanity checks on the low bits, and don't<br />         * need to just take things for granted.<br />         */<br />        #define PIO_OFFSET      0x10000UL<br />        #define PIO_MASK        0x0ffffUL<br />        #define PIO_RESERVED    0x40000UL<br /><br />   so the logic is basically that we can trivially test whether a<br />"void __iomem *" pointer is a PIO pointer or not: if the pointer value<br />is in that range of PIO_OFFSET..PIO_OFFSET+PIO_MASK range, it's PIO,<br />otherwise it's mmio.<br /><br /> - the MMIO space acts using all the normal ioremap() logic, and we<br />can tell the end result apart from PIO with the above trivial thing.<br /><br /> - the GENERIC_IOMAP code internally just has a IO_COND(adds, is_pio,<br />is_mmio) helper macro, which sets "port" for the is_pio case, and<br />"addr" for the is_mmio case, so you can do trivial things like this:<br /><br />        unsigned int ioread8(const void __iomem *addr)<br />        {<br />                IO_COND(addr, return inb(port), return readb(addr));<br />                return 0xff;<br />        }<br /><br />   which does the "inb(port)" for the PIO case, and the "readb(addr)"<br />for the MMIO case.<br /><br /> - and lookie here what the GENERIC_IOMAP code for pci_iounmap() is:<br /><br />        void pci_iounmap(struct pci_dev *dev, void __iomem * addr)<br />        {<br />                IO_COND(addr, /* nothing */, iounmap(addr));<br />        }<br /><br />  IOW, for the "is_pio" case it does nothing, and for the "is_mmio"<br />case it does "iounmap()".<br /><br />So the GENERIC_IOMAP code is actually really simple and should just<br />work for pretty much everybody. All it requires is that fake kernel<br />virtual address range at PIO_OFFSET (you can override the default<br />values if you want - maybe your architecture really wants to put MMIO<br />in those virtual addresses, but I don't think there's a lot of reason<br />to generally want to do it)<br /><br />But despite that, people think they should implement their own code,<br />and then they clearly get it HORRIBLY WRONG.<br /><br />Anyway, this email ended up being a long explanation of what the code<br />_should_ do, in the hope that some enterprising kernel developer<br />decides "Oh, this sounds like an easy thing to fix". But you do need<br />to be able to test the end result at least a tiny bit.<br /><br />Because I suspect that the real fix for sparc64 is to just get rid of<br />its broken non-GENERIC_IOMAP code, and just do "select GENERIC_IOMAP"<br /><br />And I don't think sparc64 is the only architecture that should go "Oh,<br />I should just use GENERIC_IOMAP instead of implementing it badly by<br />hand".<br /><br />Anyone?<br /><br />               Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
