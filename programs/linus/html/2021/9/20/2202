    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2021/9/20/303">First message in thread</a></li><li><a href="/lkml/2021/9/20/303">Arnd Bergmann</a><ul><li class="origin"><a href="/lkml/2021/9/21/152">Linus Torvalds</a><ul><li><a href="/lkml/2021/9/21/152">Arnd Bergmann</a><ul><li><a href="/lkml/2021/9/21/528">Anders Larsen</a><ul><li><a href="/lkml/2021/9/21/556">Linus Torvalds</a></li><li><a href="/lkml/2021/9/21/660">Arnd Bergmann</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2021/9/20/2202/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 20 Sep 2021 10:26:21 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] [RFC v2] qnx: avoid -Wstringop-overread warning, again</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Sep 20, 2021 at 5:12 AM Arnd Bergmann &lt;arnd&#64;kernel.org&gt; wrote:<br />&gt;<br />&gt; +               /*<br />&gt; +                * work around gcc-11.x using the first field it observes<br />&gt; +                * to determing the actual length<br />&gt; +                * <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=99578">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=99578</a><br />&gt; +                */<br />&gt; +               char __empty[0];<br />&gt; +               char de_name[];<br /><br />Ugh. That looks _really_ hacky.<br /><br />It sounds like we can avoid the gcc bug if we just always use<br />"de-&gt;de_name[]". Then we don't need to depend on magical behavior<br />about one particular gcc version and a strange empty array in front of<br />it.<br /><br />IOW, something like the attached simpler thing that just does that<br />"always use de_name[]" and has a comment about why we don't do the<br />natural thing<br /><br />Also, just what version of gcc is the broken one? You say "gcc-11",<br />but I certainly don't see it with _my_ version of gcc-11, so can we<br />(just for that comment) document more precisely what version you have<br />(or possibly what config you use to trigger it).<br /><br />                Linus<br /> fs/qnx4/dir.c | 27 ++++++++++++++++++---------<br /> 1 file changed, 18 insertions(+), 9 deletions(-)<br /><br />diff --git a/fs/qnx4/dir.c b/fs/qnx4/dir.c<br />index 2a66844b7ff8..d60806efe090 100644<br />--- a/fs/qnx4/dir.c<br />+++ b/fs/qnx4/dir.c<br />&#64;&#64; -20,12 +20,24 &#64;&#64;<br />  * depending on the status field in the last byte. The<br />  * first byte is where the name start either way, and a<br />  * zero means it's empty.<br />+ *<br />+ * Also, due to a bug in gcc, we don't want to use the<br />+ * real (differently sized) name arrays in the inode and<br />+ * link entries, but always the 'de_name[]' one in the<br />+ * fake struct entry.<br />+ *<br />+ * See<br />+ *<br />+ *   <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=99578#c6">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=99578#c6</a><br />+ *<br />+ * for details - but basically gcc will take the size of<br />+ * the 'name' array from one of the used entries randomly.<br />  */<br /> union qnx4_directory_entry {<br /> 	struct {<br />-		char de_name;<br />-		char de_pad[62];<br />-		char de_status;<br />+		const char de_name[48];<br />+		u8 de_pad[15];<br />+		u8 de_status;<br /> 	};<br /> 	struct qnx4_inode_entry inode;<br /> 	struct qnx4_link_info link;<br />&#64;&#64; -53,29 +65,26 &#64;&#64; static int qnx4_readdir(struct file *file, struct dir_context *ctx)<br /> 		ix = (ctx-&gt;pos &gt;&gt; QNX4_DIR_ENTRY_SIZE_BITS) % QNX4_INODES_PER_BLOCK;<br /> 		for (; ix &lt; QNX4_INODES_PER_BLOCK; ix++, ctx-&gt;pos += QNX4_DIR_ENTRY_SIZE) {<br /> 			union qnx4_directory_entry *de;<br />-			const char *name;<br /> <br /> 			offset = ix * QNX4_DIR_ENTRY_SIZE;<br /> 			de = (union qnx4_directory_entry *) (bh-&gt;b_data + offset);<br /> <br />-			if (!de-&gt;de_name)<br />+			if (!de-&gt;de_name[0])<br /> 				continue;<br /> 			if (!(de-&gt;de_status &amp; (QNX4_FILE_USED|QNX4_FILE_LINK)))<br /> 				continue;<br /> 			if (!(de-&gt;de_status &amp; QNX4_FILE_LINK)) {<br /> 				size = sizeof(de-&gt;inode.di_fname);<br />-				name = de-&gt;inode.di_fname;<br /> 				ino = blknum * QNX4_INODES_PER_BLOCK + ix - 1;<br /> 			} else {<br /> 				size = sizeof(de-&gt;link.dl_fname);<br />-				name = de-&gt;link.dl_fname;<br /> 				ino = ( le32_to_cpu(de-&gt;link.dl_inode_blk) - 1 ) *<br /> 					QNX4_INODES_PER_BLOCK +<br /> 					de-&gt;link.dl_inode_ndx;<br /> 			}<br />-			size = strnlen(name, size);<br />+			size = strnlen(de-&gt;de_name, size);<br /> 			QNX4DEBUG((KERN_INFO "qnx4_readdir:%.*s\n", size, name));<br />-			if (!dir_emit(ctx, name, size, ino, DT_UNKNOWN)) {<br />+			if (!dir_emit(ctx, de-&gt;de_name, size, ino, DT_UNKNOWN)) {<br /> 				brelse(bh);<br /> 				return 0;<br /> 			}</pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
