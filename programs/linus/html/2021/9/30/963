    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2021/9/29/1031">First message in thread</a></li><li><a href="/lkml/2021/9/29/1057">Linus Torvalds</a><ul><li><a href="/lkml/2021/9/29/1088">Nick Desaulniers</a><ul><li><a href="/lkml/2021/9/30/187">Rasmus Villemoes</a></li><li><a href="/lkml/2021/9/30/500">Masahiro Yamada</a></li><li class="origin"><a href="/lkml/2021/9/30/978">Linus Torvalds</a><ul><li><a href="/lkml/2021/9/30/978">Linus Torvalds</a></li><li><a href="/lkml/2021/10/1/527">Nick Desaulniers</a></li></ul></li><li><a href="/lkml/2021/9/30/1123">Nick Desaulniers</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 30 Sep 2021 11:54:13 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] modpost: add allow list for llvm IPSCCP</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Wed, Sep 29, 2021 at 5:19 PM Nick Desaulniers<br />&lt;ndesaulniers&#64;google.com&gt; wrote:<br />&gt; ...<br />&gt; arch/x86/mm/amdtopology.c:110:7: remark: 'test_bit' not inlined into<br />&gt; 'amd_numa_init' because too costly to inline (cost=115, threshold=45)<br />&gt; [-Rpass-missed=inline]<br />&gt;                 if (node_isset(nodeid, numa_nodes_parsed)) {<br /><br />Yeah, I think that we should just do the __always_inline thing.<br /><br />I'd rather have the stupid debug code overhead in the caller - that<br />may end up knowing that the pointer actually is so that the debug code<br />goes away - than have "test_bit()" uninlined because there's so much<br />crazy debug code in it.<br /><br />I also happen to believe that we have too much crazy "instrumentation" crap.<br /><br />Why is that test_bit() word read so magical that it merits a<br />"instrument_atomic_read()"?<br /><br />But I absolutely detest how KCSAN and some other tooling seems to get<br />a free pass on doing stupid things, just because they generated bad<br />warnings so then they can freely generate these much more fundamental<br />problems because the result is a f*cking mess.<br /><br />&gt; Though for the defconfig case...somehow the cost is more than with the<br />&gt; sanitizers...<br /><br />Maybe the solution is that if you have some of the crazy sanitizers,<br />we just say "the end result is not worth even checking". And stop<br />checking all the section mismatches, and all the stack size things.<br /><br />Because it looks like this is more of a real issue:<br /><br />&gt; arch/x86/mm/amdtopology.c:157:7: remark: '__nodes_weight' not inlined<br />&gt; into 'amd_numa_init' because too costly to inline (cost=930,<br />&gt; threshold=45) [-Rpass-missed=inline]<br />&gt;         if (!nodes_weight(numa_nodes_parsed))<br />&gt;              ^<br /><br />Hmm. That's just a "bitmap_weight()", and that function in turn is<br />__always_inline.<br /><br />And the *reason* it is __always_inline is that it really wants to act<br />as a macro, and look at the second argument and do special things if<br />it is a small constant value.<br /><br />And it looks like clang messes things up by simply not doing enough<br />simplification before inlining decisions, so it all looks very<br />complicated to clang, even though when you actually generate code, you<br />have one (of two) very simple code sequences.<br /><br />&gt; &gt; Wouldn't it be better to make<br />&gt; &gt; them always-inline?<br />&gt;<br />&gt; Perhaps, see what that might look like:<br />&gt; <a href="https://github.com/ClangBuiltLinux/linux/issues/1302#issuecomment-807260475">https://github.com/ClangBuiltLinux/linux/issues/1302#issuecomment-807260475</a><br />&gt; Does that look better?<br /><br />I suspect that in this case, because of clang deficiencies, that<br />__always_inline actually is the right thing to do at least on<br />__nodes_weight.<br /><br />Looking at your comment lower down<br /><br />  <a href="https://github.com/ClangBuiltLinux/linux/issues/1302#issuecomment-807757878">https://github.com/ClangBuiltLinux/linux/issues/1302#issuecomment-807757878</a><br /><br />I really think this is a clang bug, and that you need to do certain<br />simplifications both before _and_ after inlining.<br /><br />Before, because of the inlining cost decisions particularly wrt<br />constant arguments.<br /><br />After, because successful inlining changes things completely.<br /><br />Marking __nodes_weight() be __always_inline just works around clang<br />being broken in this regard.<br /><br />It is _possible_ that it might help to make bitmap_weight() be a macro<br />instead of an inline function, but it's a kind of sad state of affairs<br />if that is required.<br /><br />And it might well fail - if you don't do the constant propagation<br />before making inlining decisions, you'll _still_ end up thinking that<br />bitmap_weight() is very costly because you don't do that<br />__builtin_constant_p() lowering.<br /><br />And then you end up using the (much more expensive) generic function<br />instead of the cheap "look, for single words this is a trivial" thing.<br /><br />&gt; Part of me feels like modpost not warning on those is permitting a<br />&gt; "memory leak," in so far as code that's only called from .init callers<br />&gt; is never reclaimed. Or leaving behind gadgets...<br /><br />I think we can just treat modpost as a "good heuristic".  If it<br />catches all the normal cases, it's fine - but it must not have false<br />positives.<br /><br />That's basically true of all warnings. False positive warnings make a<br />warning worthless. That's just *basic*.<br /><br />So the gcc thing is a "ok, we know compilers mess this up if they do<br />partial inlining with constant propagation, so we will suppress what<br />is quite likely a false positive for that case".<br /><br />That clang patch, in comparison? That's just a hack enumerating random<br />cases. TRhere is no logic to it, and there is absolutely zero<br />maintainability. It will cause us to forever just add other random<br />cases to the list, making the whole tooling entirely pointless.<br /><br />See the difference?<br /><br />Maybe clang should just adopt the gcc naming convention, so that we<br />can just use the gcc heuristic.<br /><br />&gt; &gt; clear case of "this inlining failed". This ad-hoc list has cases of<br />&gt; &gt; things that are clearly wrong in general ("test_bit()" must not use<br />&gt; &gt; initdata), and that "ok, the function just doesn't have the right<br />&gt; &gt; section marker.<br />&gt;<br />&gt; Sorry, what do you mean "test_bit() must not use initdata?" Because it<br />&gt; can lead to problems like this? Or...?<br /><br />No, I mean that it is completely unacceptable to add some crazy rule<br />like "you can access this init-data  from any context, as long as you<br />use test_bit to do so".<br /><br />That's basically what your rule does. And it's a FUNDAMENTALLY invalid<br />rule. It's simply not true.  The rule is invalid, it's just that clang<br />has made such a mess of it that in one particular case it happens to<br />be true.<br /><br />The gcc "rule" is much more reasonable: it's *not* saying "it's ok to<br />access this init-data from test_bit". The gcc rule says "we know gcc<br />messes up our heuristics when out-of-lining with constprop, so we just<br />won't warn because false positives are bad, bad, bad.<br /><br />One rule is fundamentally garbage and wrong. The other rule is a<br />generic "we know this situation cannot be tested for". Very different.<br /><br />                  Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
