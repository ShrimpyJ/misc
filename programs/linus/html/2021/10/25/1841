    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2021/10/25/1035">First message in thread</a></li><li><a href="/lkml/2021/10/25/1708">Linus Torvalds</a><ul><li><a href="/lkml/2021/10/25/1760">Kees Cook</a><ul><li class="origin"><a href="/lkml/2021/10/25/1891">Linus Torvalds</a><ul><li><a href="/lkml/2021/10/25/1891">Linus Torvalds</a></li><li><a href="/lkml/2021/10/25/1894">Kees Cook</a><ul><li><a href="/lkml/2021/10/25/1920">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2021/10/25/1932">Matthew Wilcox</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 25 Oct 2021 16:37:01 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] secretmem: Prevent secretmem_users from wrapping to zero</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Mon, Oct 25, 2021 at 3:30 PM Kees Cook &lt;keescook&#64;chromium.org&gt; wrote:<br />&gt;<br />&gt; &gt; A refcount being zero means that the data it referenced no longer exists.<br />&gt;<br />&gt; I don't disagree with this definition, but I would like to understand how<br />&gt; some other use-cases fit into this.<br /><br />I certainly hope that there are no other use-cases for 'recount_t',<br />because that "zero is invalid" is very much part of the semantics.<br /><br />If we want other semantics, it should be a new type.<br /><br />&gt;      What about the case of what<br />&gt; I see that is more like a "shared resource usage count" where the shared<br />&gt; resource doesn't necessarily disappear when we reach "no users"?<br /><br />So I think that's really "atomic_t".<br /><br />And instead of saturating, people should always check such shared<br />resources for limits.<br /><br />&gt; i.e. there is some resource, and it starts its life with no one using it<br />&gt; (count = 1).<br /><br />You are already going off into the weeds.<br /><br />That's not a natural thing to do. It's already confusing. Really. Read<br />that sentence yourself, and read it like an outsider.<br /><br />"No one is using it, so count == 1" is a nonsensican statement on the<br />face of it.<br /><br />You are thinking of a refcount_t trick, not some sane semantics.<br /><br />Yes, we have played off-by-one games in the kernel before. We've done<br />it for various subtle reasons.<br /><br />For example, traditionally, on x86, with atomic counting there are<br />three special situations: negative, 0 and positive. So if you use the<br />traditional x86 counting atomics (just add/sub/inc/dec, no xadd) then<br />there are situations where you can get more information about the<br />result in %eflags if you don't use zero as the initial value, but -1.<br /><br />Because then you can do "inc", and if ZF is set, you know you were the<br />_first_ person to increment it. And when you use "dec", and SF is set<br />afterwards, you know you are the _last_ person to decrement it.<br /><br />That was useful when things like "xadd" weren't available, and cmpxchg<br />loops are expensive. So we used to have counters where -1 was that<br />"zero point". Very similar to your "1 is the zero point".<br /><br />But was it _logical_? No. It was an implementation trick. I think<br />we've removed all those cases because it was so subtle and confusing<br />(but maybe we still have it somewhere - I did not check).<br /><br />So we've certainly played those kinds of games. But it had better be<br />for a really good reason.<br /><br />&gt; I don't see as clear a distinction between secretmem and the above<br />&gt; examples.<br /><br />I really don't see what's wrong with 'atomic_t', and just checking for limits.<br /><br />Saturating counters are EVIL AND BAD. They are a DoS waiting to<br />happen. Once you saturate, the machine is basically dead. You may have<br />"protected" against some attack, but you did so by killing the machine<br />and making the resource accounting no longer work.<br /><br />So if a user can ever trigger a saturating counter, that's a big big<br />problem in itself.<br /><br />In contrast, an 'atomic_t' with a simple limit? It just works.<br /><br />And it doesn't need illogical tricks to work.<br /><br />Stop thinking that refcount_t is a good type. Start realizing the<br />downsides. Start understanding that saturation is a HORRENDOUSLY BAD<br />solution, and horrible QoI.<br /><br />              Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
