    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2021/8/27/204">First message in thread</a></li><li><a href="/lkml/2021/8/27/273">Rasmus Villemoes</a><ul><li><a href="/lkml/2021/8/27/319">Helge Deller</a><ul><li class="origin"><a href="/lkml/2021/8/28/279">Linus Torvalds</a><ul><li><a href="/lkml/2021/8/28/279">Helge Deller</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 28 Aug 2021 10:39:51 -0700</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] Fix prctl(PR_GET_NAME) to not leak random trailing bytes</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Fri, Aug 27, 2021 at 5:19 AM Helge Deller &lt;deller&#64;gmx.de&gt; wrote:<br />&gt;<br />&gt; Oh, the parisc strncpy() asm does NOT zero-fill the target address !!<br />&gt; That's the bug.<br />&gt; I thought strncpy would just copy up to given number of chars.<br /><br />Yeah, strncpy() is a horrible horrible function.<br /><br />It doesn't copy any NUL character at all if the source length was<br />longer than the 'n', so it doesn't necessarily result in a<br />NUL-terminated string.<br /><br />And it fills the target with NUL characters at the end, which is<br />usually horribly inefficient and means that you should never ever use<br />it with big destination buffers. So it can be a surprisingly bad<br />function to use for the - not all that unusual situation - where you<br />have lots of space in the destination buffer, and use the 'n' version<br />of strcpy() just to be safe for odd situations. It will zero-fill all<br />that space, usually for no good reason.<br /><br />Very different from the other 'n' functions like snprintf() and<br />friends that people use for that same "destination buffer safety"<br />reason.<br /><br />So it's almost never the right thing to use, even if it's the most<br />traditional, most common and - by name - most obvious "copy string of<br />at most length 'n'" function.<br /><br />It so happens that "comm[]" is probably one of *very* few situations<br />in the kernel where we really do want to use strncpy(), and where we<br />don't just NUL-terminate, but NUL-fill the buffer.<br /><br />Of course, that "comm[]" behavior is unusual these days, but I think<br />it was a lot more usual back in the early 70's, when that whole<br />"small, fixed-size string buffer" model was much much more common than<br />it is today.<br /><br />It is, after all, the exact same reason why the C language linker<br />rules for identifiers were historically "only the first 7 letters are<br />necessarily significant". Because "use a fixed 8-byte buffer for a<br />string" made sense at the time in ways it doesn't necessarily make all<br />that much sense today.<br /><br />So that odd and nasty behavior of strncpy() makes a lot more sense in<br />the historical context - it's just that that context is 50 years ago.<br /><br />While mentioning all the oddities of 'strncpy()', it's also worth<br />noting that despite the similarities in the name,<br />"strncpy_from_user()" does *not* fill the end of the destination<br />buffer with NUL characters, and does *not* act like strncpy(). The<br />user string copy function obviously also has a very very different<br />return value, which hopefully makes it more obvious that it's a very<br />different beast.<br /><br />Most of the time, if you actually want to copy a string, and have a<br />limited destination buffer, you should use 'strscpy()'. Of the<br />"limited size string" routines, it's pretty much the only sane one,<br />and it guarantees - as long as the target size is non-zero - that the<br />target is NUL-terminated without doing the NUL filling.<br /><br />(The BSD 'strlcpy()' is horribly broken because the return value<br />semantics means that it will have to find the terminating NUL of the<br />*source* string, even if the source string is horribly long, or<br />untrusted and unterminated).<br /><br />&gt; Interestingly the kernel runs quite well and we don't see any bigger breakage.<br /><br />Yeah, almost nothing actually cares about the odd NUL filling that -<br />as you - few people realize is even part of strncpy().<br /><br />&gt; Anyway, the function needs fixing.<br /><br />I'd suggest you just use the default one in lib/string.c and not<br />override it with __HAVE_ARCH_STRNCPY.<br /><br />For example, on x86, we for purely historical reasons do that<br />__HAVE_ARCH_STRNCPY thing, but only for the legacy 32-bit code. x86-64<br />uses that generic lib/string.c version (and honestly, the 32-bit<br />arch-specific x86 one is almost certainly much worse, but hey, it<br />really exists purely due to hysterical raisins).<br /><br />That generic thing is a slow byte-per-byte implementation, but I don't<br />think we have ever had a situation where it really matters.<br /><br />It's also slightly oddly implemented - notice how the way it does that<br />zero fill is by simply not incrementing the source pointer once it<br />finds a NUL character. Simple and effective (even if perhaps not<br />_efficient_), but it can make people miss what is going on because<br />it's an unusual pattern.<br /><br />                Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
