    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2021/12/17/298">First message in thread</a></li><li><a href="/lkml/2021/12/18/59">David Hildenbrand</a><ul><li><a href="/lkml/2021/12/18/218">Linus Torvalds</a><ul><li class="origin"><a href="/lkml/2021/12/19/13">Linus Torvalds</a><ul><li><a href="/lkml/2021/12/19/13">David Hildenbrand</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Sat, 18 Dec 2021 11:52:41 -0800</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH v1 06/11] mm: support GUP-triggered unsharing via FAULT_FLAG_UNSHARE (!hugetlb)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody">On Sat, Dec 18, 2021 at 11:21 AM Linus Torvalds<br />&lt;torvalds&#64;linux-foundation.org&gt; wrote:<br />&gt;<br />&gt; To recap:<br />&gt;  (1) is important, and page_count() is the only thing that guarantees<br />&gt; "you get full access to a page only when it's *obviously* exclusively<br />&gt; yours".<br />&gt;  (2) is NOT important, but could be a performance issue, but we have<br />&gt; real data from the past year that it isn't.<br />&gt;  (3) is important, and has a really spectacularly simple conceptual<br />&gt; fix with quite simple code too.<br />&gt;<br />&gt; In contrast, with the "mapcount" games you can't even explain why they<br />&gt; should work, and the patches I see are actively buggy because<br />&gt; everything is so subtle.<br /><br />So to challenge you, please explain exactly how mapcount works to<br />solve (1) and (3), and how it incidentally guarantees that (2) doesn't<br />happen.<br /><br />And that really involves explaining the actual code too. I can explain<br />the high-level concepts in literally a couple of sentences.<br /><br />For (1), "the page_count()==1 guarantees you are the only owner, so a<br />COW event can re-use the page" really explains it. And the code is<br />pretty simple too. There's nothing subtle about "goto copy" when<br />pagecount is not 1. And even the locking is simple: "we hold the page<br />table lock, we found a page, it has only one ref to it, we own it"<br /><br />Our VM is *incredibly* complicated. There really are serious<br />advantages to having simple rules in place.<br /><br />And for (2), the simple rule is "yeah, we can cause spurious cow<br />events". That's not only simple to explain, it's simple to code for.<br />Suddenly you don't need to worry. "Copying the page is always safe".<br />That's a really really powerful statement.<br /><br />Now, admittedly (3) is the one that ends up being more complicated,<br />but the *concept* sure is simple. "If you don't want to COW this page,<br />then don't mark it for COW".<br /><br />The *code* for (3) is admittedly a bit more complicated. The "don't<br />mark it for COW" is simple to say, but we do have that fairly odd<br />locking thing with fork() doing a seqcount_write_begin/end, and then<br />GIP does the read-seqcount thing with retry. So it's a bit unusual,<br />and I don't think we have that particular pattern anywhere else, but<br />it's one well-defined lock and while unusual it's not *complicated* as<br />far as kernel locking rules go. It's unusual and perhaps not trivial,<br />but in the end those seqcount code sequences are maybe 10 lines total,<br />and they don't interact with anything else.<br /><br />And yes, the "don't mark it for COW" means that write-protecting<br />something is special, mainly because we sadly do not have extra bits<br />in the page tables. It would be *really* easy if we could just hide<br />this "don't COW this page" in the page table. Truly trivial. We don't,<br />because of portability across different architectures ;(<br /><br />So I'll freely give you that my (3) is somewhat painful, but it's<br />painful with a really simple concept.<br /><br />And the places that get (3) wrong are generally places that nobody has<br />been able to care about. I didn't realize the problem with creating a<br />swap page after the fact for a while, so that commit feb889fb40fa<br />("mm: don't put pinned pages into the swap cache") came later, but<br />it's literally a very simple two-liner.<br /><br />The commit message for commit feb889fb40fa may be worth reading. It<br />very much explains the spirit of the thing, and is much longer than<br />the trivial patch itself.<br /><br />Simple and clear concepts matter. Code gets complicated even then, but<br />complex code with complex concepts is a bad combination.<br /><br />              Linus<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
