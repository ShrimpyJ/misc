    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/12/24/130">First message in thread</a></li><li><a href="/lkml/2009/12/30/292">Linus Torvalds</a><ul><li><a href="/lkml/2009/12/31/21">(Eric W. Biederman)</a><ul><li class="origin"><a href="/lkml/2010/1/1/14">Linus Torvalds</a><ul><li><a href="/lkml/2010/1/1/14">(Eric W. Biederman)</a><ul><li><a href="/lkml/2010/1/1/35">Borislav Petkov</a></li><li><a href="/lkml/2010/1/1/58">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2010/1/1/32">(Eric W. Biederman)</a><ul><li><a href="/lkml/2010/1/1/104">Tejun Heo</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2009/12/31/22">(Eric W. Biederman)</a></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2009/12/31/122/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 31 Dec 2009 11:04:48 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: drm_vm.c:drm_mmap: possible circular locking dependency detected (was: Re: Linux 2.6.33-rc2 - Merry Christmas ...)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 31 Dec 2009, Eric W. Biederman wrote:<br />&gt; &gt;<br />&gt; &gt;  - hibernate ends up with the sequence: _cpu_down (cpu_hotplug.lock) -&gt;  ..<br />&gt; &gt;    kref_put .. -&gt; sysfs_addrm_start (sysfs_mutex)<br />&gt; &gt;<br />&gt; &gt;    Again, nothing suspicious or "bad", and this part of the dependency <br />&gt; &gt;    chain has nothing to do with the DRM code itself.<br />&gt; <br />&gt; kobject_del with a lock held scares me.<br /><br />I would not object at _all_ if sysfs fixed the locking here instead of in <br />filldir.<br /><br />The problem is that releasing objects (with kref_put() and friends) is <br />something that is _commonly_ done with various locks held.<br /><br />Btw, that "cpu_down()" is by no means the only case. I would suggest you <br />just google for<br /><br />	sysfs_mutex lockdep<br /><br />and you'll find a _lot_ of cases, most of them not involving drm at all, <br />but ext4 and btrfs.<br /><br />(Side note: almost all of them tend to _also_ have mmap_sem in the chain: <br />that's usually the thing that "closes the deal").<br /><br />&gt; There is a possible deadlock (that lockdep is ignorant of) if you hold<br />&gt; a lock over sysfs_deactivate() and if any sysfs file takes that lock.<br />&gt; <br />&gt; I won't argue with a claim of inconvenient locking semantics here, and<br />&gt; this is different to the problem you are seeing (except that fixing this<br />&gt; problem would happen to fix the filldir issue).<br /><br />I suspect that filldir is almost always implicated because mmap_sem is so <br />hard to do just one way: both page faulting and mmap have it held, and so <br />a lot of locks need to be gotten _after_ it, while filldir very often has <br />the exact reverse requirement. <br /><br />So that's why filldir is kind of special (and the fundamental _reason_ it <br />is special is exactly because pretty much all other VFS operations work <br />with generic caches, and the actual filesystem only fills in the caches, <br />it doesn't copy to user space directly while holding any locks - although <br />ioctl's sometimes have the same issue as filldir for all the same <br />reasons).<br /><br />Anyway, I'm in _no_ way saying that you need to break it at filldir: the <br />reason I pick on filldir is because I hate it, and think that it's a <br />really annoying special case at the VFS level. But from a sysfs <br />standpoint, I could well see that there are worse problems than that kind <br />of annoying VFS problem.<br /><br />So if you can break it at that kref_put layer (which leads to releasing a <br />sysfs object etc), then that would be great. In fact, it would be better, <br />since kref_put and friends are in many ways "more fundamental" than some <br />filldir special case that we _could_ fix in other ways.<br /><br />&gt; The cheap fix here is mostly a matter of grabbing a reference to the<br />&gt; sysfs_dirent and then revalidating that the reference is still useful<br />&gt; after we reacquire the sysfs_mutex.  If not we already have the code for<br />&gt; restarting from just an offset.  We just don't want to use it too much as<br />&gt; that will give us O(n^2) times for sysfs readdir.<br /><br />Well, the _trivial_ fix is to just move the mutex_lock/unlock _inside_ the <br />loop instead of of outside. Something like the appended might just work, <br />and is the really stupid approach.<br /><br />Totally untested. And it will do a _lot_ more sysfs mutex accesses, since <br />now it will lock/unlock around each entry we return.<br /><br />A smarter thing to do would probably be to rewrite the 's_sibling' search <br />to instead insert a fake entry in the list, so that we don't have to <br />traverse the s_sibling list every time for each entry (which is O(n**2) in <br />size of the directory, and just generally horribly evil and crap code).<br /><br />		Linus<br /><br />---<br /> fs/sysfs/dir.c |   34 +++++++++++++++++++---------------<br /> 1 files changed, 19 insertions(+), 15 deletions(-)<br /><br />diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c<br />index f05f230..2d0fd42 100644<br />--- a/fs/sysfs/dir.c<br />+++ b/fs/sysfs/dir.c<br />&#64;&#64; -847,29 +847,33 &#64;&#64; static int sysfs_readdir(struct file * filp, void * dirent, filldir_t filldir)<br /> 		if (filldir(dirent, "..", 2, filp-&gt;f_pos, ino, DT_DIR) == 0)<br /> 			filp-&gt;f_pos++;<br /> 	}<br />-	if ((filp-&gt;f_pos &gt; 1) &amp;&amp; (filp-&gt;f_pos &lt; INT_MAX)) {<br />-		mutex_lock(&amp;sysfs_mutex);<br />+	while ((filp-&gt;f_pos &gt; 1) &amp;&amp; (filp-&gt;f_pos &lt; INT_MAX)) {<br />+		const char * name;<br />+		int len, err;<br /> <br />+		mutex_lock(&amp;sysfs_mutex);<br /> 		/* Skip the dentries we have already reported */<br /> 		pos = parent_sd-&gt;s_dir.children;<br /> 		while (pos &amp;&amp; (filp-&gt;f_pos &gt; pos-&gt;s_ino))<br /> 			pos = pos-&gt;s_sibling;<br /> <br />-		for ( ; pos; pos = pos-&gt;s_sibling) {<br />-			const char * name;<br />-			int len;<br />+		/* This is ok even with 'pos == NULL' */<br />+		sysfs_get_active(pos);<br />+		mutex_unlock(&amp;sysfs_mutex);<br />+		if (!pos) {<br />+			filp-&gt;f_pos = INT_MAX;<br />+			break;<br />+		}<br /> <br />-			name = pos-&gt;s_name;<br />-			len = strlen(name);<br />-			filp-&gt;f_pos = ino = pos-&gt;s_ino;<br />+		name = pos-&gt;s_name;<br />+		len = strlen(name);<br />+		filp-&gt;f_pos = ino = pos-&gt;s_ino;<br /> <br />-			if (filldir(dirent, name, len, filp-&gt;f_pos, ino,<br />-					 dt_type(pos)) &lt; 0)<br />-				break;<br />-		}<br />-		if (!pos)<br />-			filp-&gt;f_pos = INT_MAX;<br />-		mutex_unlock(&amp;sysfs_mutex);<br />+		err = filldir(dirent, name, len, filp-&gt;f_pos, ino, dt_type(pos));<br />+		sysfs_put_active(pos);<br />+<br />+		if (err &lt; 0)<br />+			break;<br /> 	}<br /> 	return 0;<br /> }<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
