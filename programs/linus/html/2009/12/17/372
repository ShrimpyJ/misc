    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/12/17/243">First message in thread</a></li><li><a href="/lkml/2009/12/17/262">Linus Torvalds</a><ul><li><a href="/lkml/2009/12/17/293">Krzysztof Halasa</a></li><li><a href="/lkml/2009/12/17/367">Alain Knaff</a><ul><li class="origin"><a href="/lkml/2009/12/17/390">Linus Torvalds</a><ul><li><a href="/lkml/2009/12/17/390">Alain Knaff</a><ul><li><a href="/lkml/2009/12/17/399">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Thu, 17 Dec 2009 13:14:43 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: DMA cache consistency bug introduced in 2.6.28 (Was: Re: [Fdutils] Cannot format floppies under kernel 2.6.*?)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Thu, 17 Dec 2009, Alain Knaff wrote:<br />&gt; <br />&gt; For the moment, I have a very small sample of hardware:<br />&gt; 1. One machine which works (my own): Athlon XP 1800+ processor<br />&gt; 2. One which doesn't work (Mark's)<br /><br />Ok. I don't think I even have any machines with floppy drives any more <br />(one external USB drive somewhere gathering dust just in case I ever <br />encounter a floppy again).<br /><br />&gt; I might get access to a wider sample of boxen in a week or so, in order<br />&gt; to do some stats.<br /><br />Ok, I was more thinking "we have a bugzilla with ten different people <br />reporting this". If it's just a single machine, that's not going to be <br />relevant.<br /><br />&gt; What's the easiest way to find out the chipset?<br />&gt; <br />&gt; Here's already the output of lspci from my machine (works):<br />&gt; <br />&gt; 00:00.0 Host bridge: VIA Technologies, Inc. VT8377 [KT400/KT600 AGP] Host Bridge<br />&gt; 00:01.0 PCI bridge: VIA Technologies, Inc. VT8235 PCI Bridge<br />&gt; 00:11.0 ISA bridge: VIA Technologies, Inc. VT8235 ISA Bridge<br /><br />Yeah, lspci (and generally only the northbridge and southbridge matters, <br />the "ISA bridge" might technically be relevant, but since it's universally <br />on the same die as the southbridge, I left it in there just for kicks).<br /><br />&gt; (It happens during formatting the floppy drive: here the first byte<br />&gt; happens to be the trackid of the first physical sector of the track, and<br />&gt; it always ends up being the track of the *previously* formatted track).<br /><br />I guess it could simply be a floppy controller bug too, triggered by some <br />random timing difference or innocuous-looking change.<br /><br />&gt; &gt; But I think we'd like to see a list of hardware where this can be <br />&gt; &gt; triggered,<br />&gt; <br />&gt; We'll get a list of 2 machines relatively quickly (unless other people<br />&gt; would like to chime in: the test is easy, just fdformat a floppy disk),<br />&gt; and more in a week or so.<br /><br />Only the "it doesn't work on xyz" is likely interesting. The machines it <br />works on are probably uninteresting statistically.<br /><br />&gt; &gt; and quite frankly, a 'git bisect' would be absolutely wonderful <br />&gt; <br />&gt; How exactly would I use this (command line sample)?<br /><br />You'd need a git tree that contains both the working and non-working <br />versions, and then literally just do<br /><br />	git bisect start<br />	git bisect good &lt;known good version number here&gt;<br />	git bisect bad &lt;known bad version here&gt;<br /><br />and it will give you a commit to try. Compile, test, see if it's good or <br />bad, and do<br /><br />	git bisect [good|bad]<br /><br />depending on the result. Rinse and repeat (depending on how tight the <br />initial good/bad commits were, it will need 10-15 kernel tests).<br /><br />So in this case, since apparently 2.6.27.41 is good, and 2.6.28 is not, it <br />would be something like this:<br /><br />	# clone hpa's tree that has all the stable releases in one place<br />	git clone git://git.kernel.org/pub/scm/linux/kernel/git/hpa/linux-2.6-allstable.git<br /><br />	cd linux-2.6-allstable<br />	git bisect start<br />	git bisect bad v2.6.28<br />	git bisect good v2.6.27.41<br /><br />and off you go.<br /><br />NOTE! Bisection depends very much on the bug being 100% reproducible. If <br />you ever mark a good kernel bad (because you messed up) or a bad kernel <br />good (because the bug wasn't 100% reproducible, so you _thought_ it was <br />good even though the bug was present and just happened to hide), the end <br />result of the bisect will be totally unreliable and seriously screwed up.<br /><br />So after a successful bisect, it is usually a good idea to try to go back <br />to the original known-bad kernel, and then revert the commit that was <br />indicated as the bad one (assuming the revert works - it could be that the <br />bad one ends up being fundamental to other commits after it), and test <br />that yes, that really fixes the bug.<br /><br />It gets more complicated if the bisect hits kernels that you can't test <br />because they have _unrelated_ issues on that machine (compile failures or <br />just other bugs that hide the actual floppy behavior), but generally <br />bisection is pretty simple. "man git-bisect" does have some extra <br />pointers.<br /><br />So git bisect may be somewhat time-consuming and mindless, but for <br />reliably triggering bugs where nobody really knows what caused the bug it <br />is a _really_ convenient thing to do. The only thing you need is a <br />reliably triggering test-case, and some time.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
