    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/12/24/130">First message in thread</a></li><li><a href="/lkml/2009/12/30/262">Linus Torvalds</a><ul><li><a href="/lkml/2009/12/30/278">(Eric W. Biederman)</a><ul><li class="origin"><a href="/lkml/2009/12/31/21">Linus Torvalds</a><ul><li><a href="/lkml/2009/12/31/21">(Eric W. Biederman)</a><ul><li><a href="/lkml/2009/12/31/122">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2009/12/31/22">(Eric W. Biederman)</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 30 Dec 2009 14:03:25 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: drm_vm.c:drm_mmap: possible circular locking dependency detected (was: Re: Linux 2.6.33-rc2 - Merry Christmas ...)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 30 Dec 2009, Eric W. Biederman wrote:<br /><br />&gt; Linus Torvalds &lt;torvalds&#64;linux-foundation.org&gt; writes:<br />&gt; <br />&gt; &gt; We've seen it several times (yes, mostly with drm, but it's been seen with <br />&gt; &gt; others too), and it's very annoying. It can be fixed by having very <br />&gt; &gt; careful readdir implementations, but I really would blame sysfs in <br />&gt; &gt; particular for having a very annoying lock reversal issue when used <br />&gt; &gt; reasonably.<br />&gt; <br />&gt; Maybe.  The mnmap_sem has some interesting issues all of it's own.<br />&gt; What reasonable thing is the drm doing that is causing problems?<br /><br />The details are in the original thread on lkml, but it boils down to <br />basically (the below may not be the exact sequence, but it's close)<br /><br /> - drm_mmap (called with mmap_sem) takes 'dev-&gt;struct_mutex' to protect <br />   it's own device data (very reasonable)<br /><br /> - drm_release takes 'dev-&gt;struct_mutex' again to protect its own data, <br />   and calls "mtrr_del_page()" which ends up taking cpu_hotplug.lock.<br /><br />   Again, that doesn't sound "wrong" in any way.<br /><br /> - hibernate ends up with the sequence: _cpu_down (cpu_hotplug.lock) -&gt;  ..<br />   kref_put .. -&gt; sysfs_addrm_start (sysfs_mutex)<br /><br />   Again, nothing suspicious or "bad", and this part of the dependency <br />   chain has nothing to do with the DRM code itself.<br /><br /> - sysfs_readdir() (and this is the big problem) holds sysfs_mutex in its<br />   readdir implementation over the call to filldir. And filldir copies the <br />   data to user space, so now you have sysfs_mutex -&gt; mmap_sem.<br /><br />See? None of the chains look bad. Except sysfs_readdir() obviously has <br />that sysfs_mutex -&gt; mmap_sem thing, which is _very_ annoying, because now <br />you end up with a chain like<br /><br />   mmap_sem -&gt; dev-&gt;struct_mutex -&gt; cpu_hotplug.lock -&gt; sysfs_mutex -&gt; mmap_sem<br /><br />and I think you'll agree that of all the lock chains, the place to break <br />the association is at sysfs_mutex. And the obvious place to break it would <br />be that last "sysfs_mutex -&gt; mmap_sem" stage.<br /><br />&gt; &gt; Added Eric and Greg to the cc, in case the sysfs people want to solve it.<br />&gt; <br />&gt; There are scalability reasons for dropping the sysfs_mutex in sysfs_readdir<br />&gt; and I have some tenative patches for that.  I will take a look after I<br />&gt; come back from the holidays, in a couple of days.  I don't understand<br />&gt; the issue as described.<br /><br />Ok, hopefully the above chain explains it to you, and also makes it clear <br />that it's rather hard to break anywhere else, and it's not somebody else <br />doing anything "obviously bogus".<br /><br />Btw, the scalability issues with readdir() in general is why I'd be open <br />to try to change the rules for filldir(), and always make it a kernel <br />space copy. I suspect a number of users would like being able to use <br />spinlocks over filldir, but it's currently impossible. <br /><br />However, we have a lot of filldir implementations (knfsd and several <br />different system call interfaces), and while some of them already use <br />kernel buffers (eg knfsd) others would need to allocate temporary storage <br />and then do a double copy. And I suspect even things like knfsd do things <br />like sleep and take locks, so it's possible that actually getting to the <br />point where filldir could be spinlock-safe would be infeasible.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
