    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/11/15/118">First message in thread</a></li><li><a href="/lkml/2009/11/15/118">Stijn Devriendt</a><ul><li><a href="/lkml/2009/11/15/119">Stijn Devriendt</a></li><li><a href="/lkml/2009/11/16/28">Ingo Molnar</a><ul><li class="origin"><a href="/lkml/2009/11/16/259">Linus Torvalds</a><ul><li><a href="/lkml/2009/11/16/259">Linus Torvalds</a></li><li><a href="/lkml/2009/11/16/260">Alan Cox</a></li><li><a href="/lkml/2009/11/16/289">Stijn Devriendt</a><ul><li><a href="/lkml/2009/11/16/297">Ingo Molnar</a></li></ul></li><li><a href="/lkml/2009/11/21/31">Stijn Devriendt</a></li></ul></li><li><a href="/lkml/2009/11/16/281">Stijn Devriendt</a><ul><li><a href="/lkml/2009/11/16/301">Ingo Molnar</a><ul><li><a href="/lkml/2009/11/18/75">Stijn Devriendt</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 16 Nov 2009 10:02:50 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [RFC] observe and act upon workload parallelism: PERF_TYPE_PARALLELISM (Was: [RFC][PATCH] sched_wait_block: wait for blocked threads)</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 16 Nov 2009, Ingo Molnar wrote:<br />&gt; <br />&gt; Regarding the API and your patch, i think we can and should do something <br />&gt; different and more capable - while still keeping your basic idea:<br /><br />Actually, I'd suggest exactly the reverse.<br /><br />Yes, do something different, but _less_ capable, and much simpler: <br />introduce the notion of "grouped thread scheduling", where a _group_ of <br />threads gets scheduled as one thread.<br /><br />Think of it like a classic user-level threading package, where one process <br />implements multiple threads entirely in user space, and switches between <br />them. Except we'd do the exact reverse: create multiple threads in the <br />kernel, but only run _one_ of them at a time. So as far as the scheduler <br />is concerned, it acts as just a single thread - except it's a single <br />thread that has multiple instances associated with it.<br /><br />And every time the "currently active" thread in that group runs out of CPU <br />time - or any time it sleeps - we'd just go on to the next thread in the <br />group.<br /><br />There are potentially lots of cases where you want to use multiple threads <br />not because you want multiple CPU's, but because you want to have "another <br />thread ready" for when one thread sleeps on IO. Or you may use threads as <br />a container - again, you may not need a lot of CPU, but you split your <br />single load up into multiple execution contexts just because you had some <br />independent things going on (think UI threads).<br /><br />As far as I can tell, that is pretty much what Stijn Devriendt wanted: he <br />may have lots of threads, but he effectively really just wants "one CPU" <br />worth of processing.<br /><br />It's also what we often want with AIO-like threads: it's not that we want <br />CPU parallelism, and if the data is in caches, we'd like to run the IO <br />thread immediately and not switch CPU's at all, and actually do it all <br />synchronously. It's just that _if_ the AIO thread blocks, we'd like to <br />resume the original thread that may have better things to do. <br /><br />No "observe CPU parallelism" or anything fancy at all. Just a "don't <br />consider these X threads to be parallel" flag to clone (or a separate <br />system call).<br /><br />Imagine doing async system calls with the equivalent of<br /><br /> - create such an "affine" thread in kernel space<br /> - run the IO in that affine thread - if it runs to completion without <br />   blocking and in a timeslice, never schedule at all.<br /><br />where these "affine" threads would be even more lightweight than regular <br />threads, because they don't even act as real scheduling entities, they are <br />grouped together with the original one.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
