    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/9/28/211">First message in thread</a></li><li><a href="/lkml/2009/11/18/203">Jiri Slaby</a><ul><li><a href="/lkml/2009/11/18/296">David Miller</a><ul><li class="origin"><a href="">Linus Torvalds</a></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 18 Nov 2009 10:09:05 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH 06/16] SPARC: use ACCESS_ONCE for rlimits</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 18 Nov 2009, David Miller wrote:<br />&gt; <br />&gt; But I wonder have we really seen the compiler create this<br />&gt; kind of situation?  Or is this patch series based upon the<br />&gt; fact that it "could happen"?<br /><br />We have seen things like that in practice - where the compiler re-loads a <br />value twice, rather than use a copy like the source code did.<br /><br />That said, it's rare, to the point of being _almost_ unheard of. It's much <br />more common that gcc generates bad code by doing the reverse (trying to <br />keep things in registers and spilling, instead of just re-generating the <br />value). There are very very few cases where ACCESS_ONCE() actually matters <br />for correctness.<br /><br />Because in practice, the value is either modified some way (and spilling <br />it is cheaper than re-computing the modification), or there's just some <br />operation that might act as a memory barrier and alias the original memory <br />location so gcc wouldn't dare re-load anyway.<br /><br />However, one of the nice things about ACCESS_ONCE() is that it's also a <br />big flag for "this value is loaded without locking, on purpose".<br /><br />So even if it doesn't then actually change code generation significantly <br />(most common end result especially on x86 that has most ALU instructions <br />taking memory operations: gcc generates slightly worse code due to getting <br />nervous about 'volatile' and not combining instructions), it's a big <br />honking piece of programmer documentation: look out!<br /><br />It's basically a heads-up for lockless programming like RCU. As such, it <br />can be something scary, but when it's done right, it's a good thing. And I <br />think that for rlimits, we do have a good reason to say "sure, somebody <br />else may change the limit values concurrently, but we don't really care: <br />we just want _one_ value, whether it's the old or the new one".<br /><br />That said, the patch you Ack'ed is in the series of patches that I hated, <br />and Nak'ed for other reasons (namely "-EEXPRESSIONTOOCOMPLICATEDTOLIVE").<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
