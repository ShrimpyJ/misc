    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/9/28/211">First message in thread</a></li><li><a href="/lkml/2009/11/18/195">Jiri Slaby</a><ul><li><a href="/lkml/2009/11/18/356">"Luck, Tony"</a><ul><li class="origin"><a href="/lkml/2009/11/18/495">Linus Torvalds</a><ul><li><a href="/lkml/2009/11/18/495">Ingo Molnar</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 18 Nov 2009 11:48:14 -0800 (PST)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">RE: [PATCH 03/16] IA64: use ACCESS_ONCE for rlimits</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 18 Nov 2009, Luck, Tony wrote:<br />&gt;<br />&gt; &gt; Make sure compiler won't do weird things with limits. E.g. fetching<br />&gt; &gt; them twice may return 2 different values after writable limits are<br />&gt; &gt; implemented.<br />&gt; <br />&gt; -	if (size &gt; task-&gt;signal-&gt;rlim[RLIMIT_MEMLOCK].rlim_cur)<br />&gt; +	if (size &gt; ACCESS_ONCE(task-&gt;signal-&gt;rlim[RLIMIT_MEMLOCK].rlim_cur))<br />&gt; <br />&gt; I don't see how this helps.  If someone else is changing limits while<br />&gt; we are looking at them, then there is a race.  We either get the old<br />&gt; or the new value.  Using ACCESS_ONCE (which on ia64 forces a "volatile"<br />&gt; access, which will make the compiler generate "ld.acq" rather than a<br />&gt; plain "ld") won't make any difference to this race.<br />&gt; <br />&gt; Please explain what issue you see with the current code.<br /><br />The problem may not be in _that_ particular code, but imagine code like <br />this:<br /><br />	if (a &gt; MEMORY) {<br />		do1;<br />		do2;<br />		do3;<br />	} else {<br />		do2;<br />	}<br /><br />where the compiler could actually turn this into (having noticed that <br />neither "do1" nor "do2" can alias with MEMORY):<br /><br />	if (a &gt; MEMORY)<br />		do1;<br />	do2;<br />	if (a &gt; MEMORY)<br />		do3;<br /><br />and now what you end up having is a situation where it's possible that <br />"do1" gets executed but "do3" does not (or vice versa).<br /><br />Notice how when you look at the code, it looks impossible, and then you <br />get subtle security bugs.<br /><br />Now, you may say that "but _my_ code doesn't have that "else" statement", <br />and maybe you're right. In fact, maybe the source code was really just<br /><br />	if (a &gt; MEMORY)<br />		return something();<br />	return do_something_else();<br /><br />and you are _sure_ that the ACCESS_ONCE() cannot possibly be needed. But <br />what if those 'something()' and 'do_something_else()' were inlines, and <br />the compiler internally turns it into<br /><br />	if (a &gt; MEMORY) {<br />		ret = something();<br />	} else {<br />		ret = do_something_else();<br />	}<br />	return ret;<br /><br />and you now hit the case above where part of it was shared after all, and <br />the compiler for some strange reason (register reload, whatever) ends up <br />doing it as two conditionals after all?<br /><br />The thing is, you can't _prove_ that the compiler won't do it, especially <br />if you end up changing the code later (without thinking about the fact <br />that you're loading things without locking).<br /><br />So the rule is: if you access unlocked values, you use ACCESS_ONCE(). You <br />don't say "but it can't matter". Because you simply don't know.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
