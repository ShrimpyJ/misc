    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/8/20/21">First message in thread</a></li><li><a href="/lkml/2009/8/24/391">Linus Torvalds</a><ul><li><a href="/lkml/2009/8/24/410">(Eric W. Biederman)</a></li><li><a href="/lkml/2009/8/24/425">Dave Young</a></li><li><a href="/lkml/2009/8/24/427">Xiaotian Feng</a><ul><li><a href="/lkml/2009/8/25/22">"Zhang, Yanmin"</a></li></ul></li><li><a href="/lkml/2009/8/24/431">Frederic Weisbecker</a><ul><li class="origin"><a href="/lkml/2009/8/25/6">Linus Torvalds</a><ul><li><a href="/lkml/2009/8/25/6">Linus Torvalds</a><ul><li><a href="/lkml/2009/8/25/243">Frederic Weisbecker</a></li></ul></li><li><a href="/lkml/2009/8/25/224">Frederic Weisbecker</a></li></ul></li></ul></li><li><a href="/lkml/2009/8/27/78">"Zhang, Yanmin"</a></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 24 Aug 2009 21:10:38 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: v2.6.31-rc6: BUG: unable to handle kernel NULL pointer dereference at 0000000000000008</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 25 Aug 2009, Frederic Weisbecker wrote:<br />&gt; <br />&gt; Now that also makes the TTY_LDISC flag clearing unprotected by<br />&gt; tty-&gt;ldisc_mutex.<br /><br />Yes.<br /><br />&gt; tty_set_ldisc() can play concurrently with these flags right?<br /><br />.. but that shouldn't matter.<br /><br />The actual bit-setting is "atomic" already - and any other atomicity is <br />pretty much unattainable, because all the routines in question drop the <br />lock they need to hold in order to make it really be reliably atomic.<br /><br />&gt; tty_ldisc_halt() could remain protected by the mutex, so that the<br />&gt; flag is safely toggled. Once it is cleared, we can ensure no more<br />&gt; user can ref it and the lock can be relaxed while the pending<br />&gt; work is flushed.<br /><br />That would make no difference at all. tty_set_ldisc() won't care about the <br />flag (in fact, it will do its own tty_ldisc_halt()), and will be happy to <br />replace the ldisc we just flushed with a new one regardless of whether it <br />was halted before or not. And it will do tty_ldisc_enable() regardless of <br />whether it was enabled or not before.<br /><br />In fact, because tty_set_ldisc() itself had to release the ldisc_mutex <br />(for the same reason), you have this issue regardless of whether you hold <br />the lock in tty_hangup() or not: the two will always be able to get "mixed <br />up", because they - by design - have to release that silly lock.<br /><br />That's why I said I was unhappy about the tty layer locking - it really <br />isn't very sane. Things like tty_set_ldisc() will drop the lock in the <br />middle because of that crazy workqueue deadlock - exactly for the same <br />reasons that tty_ldisc_hangup() will need to do that "wait for things to <br />flush" without the lock held.<br /><br />So I could have taken the ldisc_mutex, and then just dropped it <br />temporarily while waiting for any workqueue entries, but as far as I can <br />tell, it doesn't actually solve anything.<br /><br />I considered using the TTY_LDISC_CHANGING bit(*) there to protect against <br />tty_set_ldisc(), and it may even be the right solution. But there's no way <br />I'll do that kind of changes this late in the -rc series.<br /><br />We also have the "TTY_HUPPED" bit that disables tty_set_ldisc(), but that <br />is set too late by do_tty_hangup(), and so doesn't fix the problem either. <br />Again, moving it earlier may be a solution, but again, it's not <br />appropriate for this late in the -rc.<br /><br />Finally, the solution that is most likely the _real_ solution would be to <br />just fix the locking. The whole "ldisc_mutex" seems dubious. It's not even <br />a real lock - exactly because it's dropped - and we already really use <br />that TTY_LDISC_CHANGING bit to do the _real_ locking. I don't think it <br />needs to be a mutex at all. The locking is just very dubious. <br /><br />And that, least of all, is anything I'm willing to really do in -rc. <br /><br />Anyway, I'll happily be shown wrong. I think the (second) patch I sent out <br />is an acceptable hack in the presense of the current locking, but as I <br />said, I'm not exactly happy about it, because I do think the locking is <br />broken.<br /><br />		Linus<br /><br />(*) We already have that hacky open-coded "lock" using TTY_LDISC_CHANGING, <br />which protects two different tty_set_ldisc()'s from screwing up each other <br />when they drop the semaphore. It could be just separated out into a <br />function of its own, and then the hangup code would/could/should be taught <br />to use that logic.<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
