    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/7/23/289">First message in thread</a></li><li><a href="/lkml/2009/7/27/328">OGAWA Hirofumi</a><ul><li><a href="/lkml/2009/7/27/330">Linus Torvalds</a></li><li><a href="/lkml/2009/7/27/359">Alan Cox</a><ul><li class="origin"><a href="/lkml/2009/7/27/387">Linus Torvalds</a><ul><li><a href="/lkml/2009/7/27/387">Alan Cox</a></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2009/7/27/369/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 27 Jul 2009 15:04:03 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] kdesu broken</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 27 Jul 2009, Alan Cox wrote:<br />&gt; <br />&gt; It's theoretically imperfect in the case where you write a vast amount of<br />&gt; output in one go, the tty is blocked the other end and then you close.<br />&gt; However in practice that doesn't happen because with tty-&gt;low_latency = 1<br />&gt; we run the pty received n_tty ldisc code in our context so each write<br />&gt; fires through the entire n_tty ldisc and does flow control synchronously.<br /><br />An alternative might be something like this.<br /><br />THIS IS TOTALLY UNTESTED.<br /><br />This is just meant as a "this kind of approach may be a good idea", and <br />just tries to make sure that any delayed work is flushed by closing the <br />tty.<br /><br />No guarantees. It may or may not compile. It may or may not make any <br />difference. It might do unspeakable things to your pets. It really is <br />meant to be an example of what a "flush" function could/should do. There <br />are probably other things/buffers that may need flushing.<br /><br />		Linus<br /><br />---<br /> drivers/char/tty_io.c |   33 +++++++++++++++++++++++++++++++++<br /> 1 files changed, 33 insertions(+), 0 deletions(-)<br /><br />diff --git a/drivers/char/tty_io.c b/drivers/char/tty_io.c<br />index a3afa0c..1be69af 100644<br />--- a/drivers/char/tty_io.c<br />+++ b/drivers/char/tty_io.c<br />&#64;&#64; -143,6 +143,7 &#64;&#64; ssize_t redirected_tty_write(struct file *, const char __user *,<br /> static unsigned int tty_poll(struct file *, poll_table *);<br /> static int tty_open(struct inode *, struct file *);<br /> static int tty_release(struct inode *, struct file *);<br />+static int tty_flush(struct file *filp, fl_owner_t id);<br /> long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg);<br /> #ifdef CONFIG_COMPAT<br /> static long tty_compat_ioctl(struct file *file, unsigned int cmd,<br />&#64;&#64; -415,6 +416,7 &#64;&#64; static const struct file_operations tty_fops = {<br /> 	.unlocked_ioctl	= tty_ioctl,<br /> 	.compat_ioctl	= tty_compat_ioctl,<br /> 	.open		= tty_open,<br />+	.flush		= tty_flush,<br /> 	.release	= tty_release,<br /> 	.fasync		= tty_fasync,<br /> };<br />&#64;&#64; -1831,7 +1833,38 &#64;&#64; static int tty_open(struct inode *inode, struct file *filp)<br /> 	return ret;<br /> }<br /> <br />+/* This should probably be a generic function */<br />+static void flush_delayed_work(struct delayed_work *work)<br />+{<br />+	if (cancel_delayed_work(work)) {<br />+		schedule_delayed_work(work, 0);<br />+		flush_scheduled_work();<br />+	}<br />+}<br /> <br />+/**<br />+ *	tty_flush		-	vfs callback for close<br />+ *	&#64;filp: file pointer for handle to tty<br />+ *	&#64;id: struct files_struct of owner.<br />+ *<br />+ *	Called for every close(), whether the last or not<br />+ */<br />+static int tty_flush(struct file *filp, fl_owner_t id)<br />+{<br />+	struct tty_struct *tty, *o_tty;<br />+	struct inode *inode;<br />+<br />+	inode = filp-&gt;f_path.dentry-&gt;d_inode;<br />+	tty = (struct tty_struct *)filp-&gt;private_data;<br />+<br />+	if (tty_paranoia_check(tty, inode, "tty_flush"))<br />+		return 0;<br />+<br />+	o_tty = tty-&gt;link;<br />+	if (o_tty)<br />+		flush_delayed_work(&amp;o_tty-&gt;buf.work);<br />+	return 0;<br />+}<br /> <br /> <br /> /**<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
