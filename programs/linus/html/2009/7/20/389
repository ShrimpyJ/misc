    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/7/20/1">First message in thread</a></li><li><a href="/lkml/2009/7/20/377">Linus Torvalds</a><ul><li><a href="/lkml/2009/7/20/386">Marc Dionne</a><ul><li class="origin"><a href="/lkml/2009/7/21/47">Linus Torvalds</a><ul><li><a href="/lkml/2009/7/21/47">Krzysztof Oledzki</a></li></ul></li><li><a href="/lkml/2009/7/20/390">Linus Torvalds</a><ul><li><a href="/lkml/2009/7/20/419">Marc Dionne</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Mon, 20 Jul 2009 18:01:42 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: Linux 2.6.27.27</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Mon, 20 Jul 2009, Marc Dionne wrote:<br />&gt; &gt; <br />&gt; &gt; Hmm. This sounds more like the binutils bug that people had. Sounds like<br />&gt; &gt; an assembler bug if the *.o file ends up being empty or at some fixed<br />&gt; &gt; size. If it was cc1 that fails, I'd expect to not see an *.o file at all,<br />&gt; &gt; since it didn't generate good assembly.<br />&gt; &gt; <br />&gt; &gt; In fact, your behavior sounds like the thing that produces the *.o files<br />&gt; &gt; core-dumped or died for other reasons, and had a 64kB buffer that either<br />&gt; &gt; got flushed or not. That would explain the "zero or exactly 64kB" size.<br />&gt; &gt; <br />&gt; &gt; It could be ccache too, of course.<br />&gt; <br />&gt; Actually in my case it turns out that it is ccache after all - if I remove it<br />&gt; from the picture everything is fine.  If I re-enable it, even with a clean<br />&gt; cache, I get the problem.<br />&gt; <br />&gt; It might just be a coincidence that it's triggered by the -fwrapv change.<br /><br />Ok, so this is getting ridiculous. Do we have _three_ different kernel <br />issues going on at the same time, all subtly related to tools issues <br />rather than the kernel source tree itself?<br /><br />That's just completely bizarre.<br /><br />So right now we have:<br /><br /> - Krzysztof Oledzki: the only one who so far has really pinpointed it to <br />   the -fwrapv change itself.<br /><br />   It would be good to really double-check that this is not about ccache, <br />   since Marc apparently gets a good kernel without ccache, and -fwrapv <br />   seems to be involved. <br /><br /> - Marc Dionne: ccache getting confused, with 0-byte and 64kB object <br />   files. But why -fwrapv vs -fno-strict-overflow would matter is totally <br />   unclear. Just happenstance? Something silly like overflowing the <br />   length of the ccache argument buffer?<br /><br />   It would be wonderful to figure out what odd issue ccache might have. <br />   The kernel command line isn't _that_ long, but it does end up being <br />   something reasonably monstrous like<br /><br />	gcc -Wp,-MD,kernel/.fork.s.d -nostdinc -isystem <br />		/usr/lib/gcc/x86_64-redhat-linux/4.4.0/include -Iinclude <br />		-I/home/torvalds/v2.6/linux/arch/x86/include -include <br />		include/linux/autoconf.h -D__KERNEL__ -Wall -Wundef -Wstrict-prototypes <br />		-Wno-trigraphs -fno-strict-aliasing -fno-common <br />		-Werror-implicit-function-declaration -Wno-format-security <br />		-fno-delete-null-pointer-checks -Os -m64 -march=core2 -mno-red-zone <br />		-mcmodel=kernel -funit-at-a-time -maccumulate-outgoing-args <br />		-DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -pipe -Wno-sign-compare <br />		-fno-asynchronous-unwind-tables -mno-sse -mno-mmx -mno-sse2 -mno-3dnow <br />		-Wframe-larger-than=2048 -fno-stack-protector -fno-omit-frame-pointer <br />		-fno-optimize-sibling-calls -Wdeclaration-after-statement <br />		-Wno-pointer-sign -fwrapv -fno-dwarf2-cfi-asm -D"KBUILD_STR(s)=#s" <br />		-D"KBUILD_BASENAME=KBUILD_STR(fork)"  -D"KBUILD_MODNAME=KBUILD_STR(fork)"  <br />		-fverbose-asm -S -o kernel/fork.s kernel/fork.c<br /><br />   so we are getting into the kilobyte range for it, and mayeb simply the <br />   longer argument made something fail. But other build systems do even <br />   worse things, I'm sure.<br /><br /> - the Debian/sid binutils package failure, solved by downgrading <br />   binutils.<br /><br />Crazy, crazy.<br /><br />		Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
