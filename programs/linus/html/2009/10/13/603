    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/10/11/195">First message in thread</a></li><li><a href="/lkml/2009/10/13/557">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/13/561">Alan Cox</a></li><li><a href="/lkml/2009/10/13/587">Paul Fulghum</a><ul><li class="origin"><a href="/lkml/2009/10/13/604">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/13/604">Linus Torvalds</a></li><li><a href="/lkml/2009/10/13/611">Paul Fulghum</a></li><li><a href="/lkml/2009/10/14/147">Alan Cox</a><ul><li><a href="/lkml/2009/10/14/218">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/show_ads.js"></script><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 13 Oct 2009 18:03:40 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [Bug #14388] keyboard under X with 2.6.31</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 13 Oct 2009, Paul Fulghum wrote:<br />&gt; <br />&gt; This is correct, the last buffer is not passed to tty_buffer_free()<br />&gt; if it is the last in the list so tail is maintained.<br />&gt; There is no free space in it so no new data can be added.<br />&gt; There is no place where tail is null while the spinlock<br />&gt; is released in preparation for calling receive_buf.<br />&gt; I still can't spot any flaw in the current locking.<br /><br />Do you even bother reading my emails?<br /><br />Let me walk through an example of where the locking F*CKS UP, exactly <br />because it's broken.<br /><br />	thread1		thread2		thread3<br /><br />	flush_to_ldisc<br />	set_bit(TTY_FLUSHING)<br />	buf.head = NULL<br />	...<br />	..release lock..<br />	.. sleep in -&gt;receive_buf ..<br /><br />			flush_to_ldisc<br />			set_bit(TTY_FLUSHING)<br />			.. head==NULL ..<br />			clear_bit(TTY_FLUSHING)<br />			.. release lock ..<br /><br />					tty_ldisc_flush()<br />					-&gt; tty_buffer_flush()<br />					TTY_FLUSHING not set!<br />					-&gt; __tty_buffer_flush()<br />					-&gt; tty-&gt;buf.tail = NULL<br /><br />and now you're screwed. See? You have both 'buf.tail' and 'buf.head' both <br />being NULL, and look what happens in that case 'tty_buffer_request_room()' <br />if some new data comes in? Right: it will add the buffer to both tail and <br />head.<br /><br />And notice how 'thread1' is still inside flush_to_ldisc()! The buffer that <br />got added will be overwritten by the old one, and now tail and head no <br />longer match. Or another flush_to_ldisc() comes in, and now it won't be a <br />no-op any more, and it will find the new data, and run -&gt;receive_buf <br />concurrently with the old receive_buf from thread1.<br /><br />And the whole reason was that there were some very odd locking rules: <br />buf.head=NULL meant "don't flush", and "TTY_FLUSHING is set" meant "don't <br />clear 'buf.head'", and but the "don't flush" case still cleared <br />TTY_FLUSHING (after not flushing), and it all messed up.<br /><br />I could just have fixed it (move the "clear_bit(TTY_FLUSHING)" but up, but <br />the fact is, once you fix that, it then becomes obvious that <br />"buf.head=NULL" really is the wrong thing to test in the first place, and <br />we should just use TTY_FLUSHING instead, and simply _remove_ the odd <br />"buf.head=NULL is special" case. Which is what my patch did<br /><br />&gt; Your statement that the locking is too clever/subtle is<br />&gt; clearly true since I am struggling to work this out again.<br /><br />I have to say that the only case I could make up that is _clearly_ a bug <br />is the above very contrieved example. I don't really think something like <br />the above happens in reality. But it's an example of bad locking, and what <br />happens when the locking logic isn't obvious.<br /><br />There may be other cases where the locking fails, and I just didn't find <br />them. <br /><br />Or the patch may simply not fix anything in practice, and nobody has ever <br />actually triggered the bad locking in real life. I dunno. I just do know <br />that the locking was too damn subtle.<br /><br />Any time people do ad-hoc locking with "clever" schemes, it's almost <br />invariably buggy. So the rule is: just don't do that. Make the locking <br />rules "obvious".  Don't have subtle rules about "if head is NULL, then <br />we're not going to add any new buffers to it, except if tail is also <br />NULL". Because look above what happens, and see how complicated it was to <br />even see the bug.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
