    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/10/11/195">First message in thread</a></li><li><a href="/lkml/2009/10/13/304">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/13/456">Boyan</a><ul><li class="origin"><a href="/lkml/2009/10/13/489">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/13/489">Linus Torvalds</a></li><li><a href="/lkml/2009/10/13/505">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/13/602">"=?ISO-8859-15?Q?Fr=E9d=E9ric_L=2E_W=2E_Meunier?="</a></li><li><a href="/lkml/2009/10/14/89">Boyan</a></li></ul></li><li><a href="/lkml/2009/10/13/518">Alan Cox</a><ul><li><a href="/lkml/2009/10/13/560">Linus Torvalds</a></li></ul></li><li><a href="/lkml/2009/10/13/521">Paul Fulghum</a><ul><li><a href="/lkml/2009/10/13/557">Linus Torvalds</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2009/10/13/486/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 13 Oct 2009 13:53:18 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [Bug #14388] keyboard under X with 2.6.31</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 13 Oct 2009, Boyan wrote:<br />&gt; <br />&gt; Composite is enabled in my X config, but I don't have compiz or<br />&gt; something like that enabled. DRI is enabled.<br /><br />I think I may actually see the problem. And if I'm right, then the bug you <br />guys bisected down to is really the fundamental reason. Embarrassing. I <br />was so convinced it should only change flush timing, that I didn't think <br />through all the possibilities.<br /><br />The reason for thinking that it only really changes timing si fairly <br />simple: the only thing it really does is to call "flush_to_ldisc()" <br />synchronously when needed. On the face of it, that should be perfectly <br />safe.<br /><br />But flush_to_ldisc() itself has a real oddity: it uses "tty-&gt;buf.lock" to <br />protect everything, BUT NOT THE ACTUAL CALL TO -&gt;receive_buf()!<br /><br />So even though that function looks _trivially_ atomic, once you look <br />deeper it suddenly becomes clear how it's not really atomic at all: it <br />will do all the buffer handling with the spinlock held, but then after it <br />has figured out the buffer, it does:<br /><br />	...<br />        spin_unlock_irqrestore(&amp;tty-&gt;buf.lock, flags);<br />        disc-&gt;ops-&gt;receive_buf(tty, char_buf,<br />                                        flag_buf, count);<br />        spin_lock_irqsave(&amp;tty-&gt;buf.lock, flags);<br />	...<br /><br />and by releasing that lock it actually seems to break all the buffering <br />guarantees! What can happen is:<br /><br />	CPU1 (or thread1 with PREEMPTION)<br />					CPU2 (or thread2 with PREEMPTION)<br /><br />	flush_to_ldisc()<br />	...<br />	spin_lock_irqsave(..)<br />	.. get one buffer..<br />	spin_unlock_irqrestore(..);<br /><br />			&lt;- PREEMPTION POINT, anything can happen -&gt;<br />			&lt;- more buffers can be added, etc -&gt;<br /><br />					flush_to_ldisc()<br />					spin_lock_irqsave(..)<br />					.. get second buffer..<br />					spin_unlock_irqrestore(..);<br />					-&gt;receive_buf(tty, char_buf, ...<br />					spin_lock_irqrestore(..)<br />					.. all done ..<br /><br /><br />	-&gt;receive_buf(tty, char_buf, ...<br />        spin_lock_irqrestore(...)<br /><br />Notice how the "-&gt;receive_buf()" calls were done out of order, even if the <br />data was perfectly in-order in the buffers.<br /><br />And you can get the same race on SMP even without preemption, just thanks <br />to CPU's hitting that lock just right. CONFIG_PREEMPT just makes it easier <br />(probably _much_ easier) to trigger, and possible even on UP.<br /><br />As far as I can tell, this is not really a new bug (it could have happened <br />with low_latency before too), but on a tty without low_latency it would <br />never happen until the commit you bisected to because the workqueue itself <br />would serialize everything, and only one flush would ever be pending.<br /><br />Anyway, the above explanation "feels right". It would easily explain the <br />behavior, because if the -&gt;receive_buf() calls get re-ordered, then the <br />events get re-ordered, and one simple case of that would be to see the key <br />"release" event before the key "press" event.<br /><br />It also explains how that commit seems to be indicated so consistently. It <br />still requires some specific timing, but now it's not timing _introduced_ <br />by the commit, it's an old bug that that commit exposed, and then needs <br />some unlucky timing to actually happen.<br /><br />The sane fix would be to just run -&gt;receive_buf() under the tty-&gt;buf.lock, <br />but I assume we'd have a lot of unhappy ldiscs if we did that (and <br />possibly irq latency problems too).<br /><br />I think the<br /><br />	tty-&gt;buf.head = NULL;<br />	...<br />	/* Restore the queue head */<br />	tty-&gt;buf.head = head;<br /><br />around that loop is actually there to try to avoid this whole problem, but <br />whoever did that didn't realize that there are other things that could set <br />buf.head (in particular, tty_buffer_request_room() while the lock is <br />dropped, so that whole logic is totally broken anyway and might even <br />conspire to make the problem worse (ie if somebody tries to add data while <br />-&gt;receive_buf() is running and the lock is gone, you are now _really_ <br />screwing things up).<br /><br />So instead of playing games with buf.head, I think we should just rely on <br />the TTY_FLUSHING bit. I'm not _entirely_ happy with this, because now if <br />we call flush_to_ldisc() while somebody else is busy flushing it, it will <br />return early even though the flush hasn't completed yet. But that was <br />always true to some degree (ie the "buffer full" case).<br /><br />Anyway, I'm not entirely happy with this patch, and I haven't actually <br />TESTED it so it might well be totally broken, but something along the <br />lines of the appended may just fix it. It would be good if people who see <br />this problem tried it out.<br /><br />			Linus<br />---<br /> drivers/char/tty_buffer.c |   31 +++++++++++++------------------<br /> 1 files changed, 13 insertions(+), 18 deletions(-)<br /><br />diff --git a/drivers/char/tty_buffer.c b/drivers/char/tty_buffer.c<br />index 3108991..da59334 100644<br />--- a/drivers/char/tty_buffer.c<br />+++ b/drivers/char/tty_buffer.c<br />&#64;&#64; -402,28 +402,24 &#64;&#64; static void flush_to_ldisc(struct work_struct *work)<br /> 		container_of(work, struct tty_struct, buf.work.work);<br /> 	unsigned long 	flags;<br /> 	struct tty_ldisc *disc;<br />-	struct tty_buffer *tbuf, *head;<br />-	char *char_buf;<br />-	unsigned char *flag_buf;<br /> <br /> 	disc = tty_ldisc_ref(tty);<br /> 	if (disc == NULL)	/*  !TTY_LDISC */<br /> 		return;<br /> <br /> 	spin_lock_irqsave(&amp;tty-&gt;buf.lock, flags);<br />-	/* So we know a flush is running */<br />-	set_bit(TTY_FLUSHING, &amp;tty-&gt;flags);<br />-	head = tty-&gt;buf.head;<br />-	if (head != NULL) {<br />-		tty-&gt;buf.head = NULL;<br />-		for (;;) {<br />-			int count = head-&gt;commit - head-&gt;read;<br />+<br />+	if (test_and_set_bit(TTY_FLUSHING, &amp;tty-&gt;flags)) {<br />+		struct tty_buffer *head;<br />+		while ((head = tty-&gt;buf.head) != NULL) {<br />+			int count;<br />+			char *char_buf;<br />+			unsigned char *flag_buf;<br />+<br />+			count = head-&gt;commit - head-&gt;read;<br /> 			if (!count) {<br />-				if (head-&gt;next == NULL)<br />-					break;<br />-				tbuf = head;<br />-				head = head-&gt;next;<br />-				tty_buffer_free(tty, tbuf);<br />+				tty-&gt;buf.head = head-&gt;next;<br />+				tty_buffer_free(tty, head);<br /> 				continue;<br /> 			}<br /> 			/* Ldisc or user is trying to flush the buffers<br />&#64;&#64; -445,9 +441,9 &#64;&#64; static void flush_to_ldisc(struct work_struct *work)<br /> 							flag_buf, count);<br /> 			spin_lock_irqsave(&amp;tty-&gt;buf.lock, flags);<br /> 		}<br />-		/* Restore the queue head */<br />-		tty-&gt;buf.head = head;<br />+		clear_bit(TTY_FLUSHING, &amp;tty-&gt;flags);<br /> 	}<br />+<br /> 	/* We may have a deferred request to flush the input buffer,<br /> 	   if so pull the chain under the lock and empty the queue */<br /> 	if (test_bit(TTY_FLUSHPENDING, &amp;tty-&gt;flags)) {<br />&#64;&#64; -455,7 +451,6 &#64;&#64; static void flush_to_ldisc(struct work_struct *work)<br /> 		clear_bit(TTY_FLUSHPENDING, &amp;tty-&gt;flags);<br /> 		wake_up(&amp;tty-&gt;read_wait);<br /> 	}<br />-	clear_bit(TTY_FLUSHING, &amp;tty-&gt;flags);<br /> 	spin_unlock_irqrestore(&amp;tty-&gt;buf.lock, flags);<br /> <br /> 	tty_ldisc_deref(disc);<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
