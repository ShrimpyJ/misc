    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/10/11/195">First message in thread</a></li><li><a href="/lkml/2009/10/14/314">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/14/351">Oleg Nesterov</a><ul><li class="origin"><a href="/lkml/2009/10/14/415">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/14/415">Oleg Nesterov</a><ul><li><a href="/lkml/2009/10/14/439">Linus Torvalds</a></li><li><a href="/lkml/2009/10/14/447">Alan Cox</a></li></ul></li></ul></li></ul></li><li><a href="/lkml/2009/10/14/416">Boyan</a><ul><li><a href="/lkml/2009/10/14/441">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/14/455">Alan Cox</a></li><li><a href="/lkml/2009/10/15/48">Boyan</a></li></ul></li></ul></li><li><a href="/lkml/2009/10/15/248">OGAWA Hirofumi</a><ul><li><a href="/lkml/2009/10/15/281">Oleg Nesterov</a></li><li><a href="/lkml/2009/10/15/352">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/15/364">OGAWA Hirofumi</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 14 Oct 2009 11:51:23 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [Bug #14388] keyboard under X with 2.6.31</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 14 Oct 2009, Oleg Nesterov wrote:<br />&gt; <br />&gt; &gt;  void tty_flush_to_ldisc(struct tty_struct *tty)<br />&gt; &gt;  {<br />&gt; &gt; -	flush_to_ldisc(&amp;tty-&gt;buf.work.work);<br />&gt; &gt; +	flush_delayed_work(&amp;tty-&gt;buf.work);<br />&gt; &gt;  }<br />&gt; <br />&gt; Can't comment this change because I don't understand the problem.<br /><br />The work function is "flush_to_ldisc()", and what we want to make sure of <br />is that the work has been called. We used to just call the work function <br />directly - but that meant that now one CPU might be running that "direct" <br />call, while another CPU might be running flush_to_ldisc through keventd.<br /><br />So this makes the "flush_to_ldisc()" is now instead always called through <br />keventd (but there's still a possibility that two keventd threads run it <br />concurrently - although that is going to be _very_ rare).<br /><br />&gt; <br />&gt; &gt; + * flush_delayed_work - block until a dwork_struct's callback has terminated<br />&gt; &gt; + * &#64;dwork: the delayed work which is to be flushed<br />&gt; &gt; + *<br />&gt; &gt; + * Any timeout is cancelled, and any pending work is run immediately.<br />&gt; &gt; + */<br />&gt; &gt; +void flush_delayed_work(struct delayed_work *dwork)<br />&gt; &gt; +{<br />&gt; &gt; +	if (del_timer(&amp;dwork-&gt;timer)) {<br />&gt; &gt; +		struct cpu_workqueue_struct *cwq;<br />&gt; &gt; +		cwq = wq_per_cpu(keventd_wq, get_cpu());<br />&gt; &gt; +		__queue_work(cwq, &amp;dwork-&gt;work);<br />&gt; &gt; +		put_cpu();<br />&gt; &gt; +	}<br />&gt; &gt; +	flush_work(&amp;dwork-&gt;work);<br />&gt; &gt; +}<br />&gt; <br />&gt; I think this is correct. If del_timer() succeeds, we "own" _PENDING bit and<br />&gt; dwork-&gt;work must not be queued. But afaics this helper needs del_timer_sync(),<br />&gt; otherwise I am not sure about the "flush" part.<br /><br />Hmm. I wanted to avoid del_timer_sync(), because it's so expensive for the <br />case when the timer isn't running at all, but I do think you're correct.<br /><br />If the del_timer() fails, the timer might still be running on another CPU <br />right at that moment, but not quite have queued the work yet. And then <br />we'd potentially get the wrong 'cwq' in flush_work() (we'd use the 'saved' <br />work), and not wait for it.<br /><br />I wonder if we could mark the case of "workqueue is on timer" by setting <br />the "work-&gt;entry" list to some special value. That way<br /><br />	list_empty(&amp;work-&gt;entry)<br /><br />would always mean "it's neither pending _nor_ scheduled", and <br />flush_delayed_work() could have a fast-case check that at the top:<br /><br />	if (list_empty(&amp;work-&gt;entry))<br />		return;<br /><br />or similar. When we do the 'insert_work()' in the timer function, the <br />'list_empty()' invariant wouldn't change, so you could do that locklessly.<br /><br />Of course, I've just talked about how much I hate subtle locking in the <br />tty layer. This would be subtle, but we could document it, and it would be <br />in the core kernel rather than a driver layer. <br /><br />&gt; And just in case... Of course, if dwork was pending and running on another CPU,<br />&gt; then flush_delayed_work(dwork) can return before the running callback terminates.<br />&gt; But I guess this is what we want.<br /><br />No, we want to wait for the callback to terminate, so we do want to hit <br />that 'flush_work()' case.<br /><br />&gt; As for tty_flush_to_ldisc(), what if tty-&gt;buf.work.work was not scheduled?<br />&gt; In this case flush_delayed_work() does nothing. Is it OK?<br /><br />Yes. In fact, it would be a bonus over our current "we always call that <br />flush function whether it was scheduled or not" code.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
