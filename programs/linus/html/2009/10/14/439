    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/10/11/195">First message in thread</a></li><li><a href="/lkml/2009/10/14/369">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/14/415">Oleg Nesterov</a><ul><li class="origin"><a href="/lkml/2009/10/15/171">Linus Torvalds</a><ul><li><a href="/lkml/2009/10/15/171">Oleg Nesterov</a><ul><li><a href="/lkml/2009/10/15/203">Oleg Nesterov</a></li><li><a href="/lkml/2009/10/15/212">Linus Torvalds</a></li></ul></li></ul></li><li><a href="/lkml/2009/10/14/447">Alan Cox</a><ul><li><a href="/lkml/2009/10/14/459">David Miller</a></li></ul></li></ul></li></ul></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Wed, 14 Oct 2009 13:55:41 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [Bug #14388] keyboard under X with 2.6.31</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Wed, 14 Oct 2009, Oleg Nesterov wrote:<br /><br />&gt; On 10/14, Linus Torvalds wrote:<br />&gt; &gt;<br />&gt; &gt; On Wed, 14 Oct 2009, Oleg Nesterov wrote:<br />&gt; &gt; &gt;<br />&gt; &gt; &gt; &gt;  void tty_flush_to_ldisc(struct tty_struct *tty)<br />&gt; &gt; &gt; &gt;  {<br />&gt; &gt; &gt; &gt; -	flush_to_ldisc(&amp;tty-&gt;buf.work.work);<br />&gt; &gt; &gt; &gt; +	flush_delayed_work(&amp;tty-&gt;buf.work);<br />&gt; &gt; &gt; &gt;  }<br />&gt; &gt; &gt;<br />&gt; &gt; &gt; Can't comment this change because I don't understand the problem.<br />&gt; &gt;<br />&gt; &gt; The work function is "flush_to_ldisc()", and what we want to make sure of<br />&gt; &gt; is that the work has been called.<br />&gt; <br />&gt; Thanks... This contradicts with<br />&gt; <br />&gt; &gt; &gt; As for tty_flush_to_ldisc(), what if tty-&gt;buf.work.work was not scheduled?<br />&gt; &gt; &gt; In this case flush_delayed_work() does nothing. Is it OK?<br />&gt; &gt;<br />&gt; &gt; Yes. In fact, it would be a bonus over our current "we always call that<br />&gt; &gt; flush function whether it was scheduled or not" code.<br />&gt; <br />&gt; But I guess I understand what you meant.<br /><br />Yeah. Basically, we want to make sure that it has been called *since it <br />was scheduled*. In case it has already been called and is no longer <br />pending at all, not calling it again is fine.<br /><br />It's just that we didn't have any way to do that "force the pending <br />delayed work to be scheduled", so instead we ran the scheduled function by <br />hand synchronously. Which then seems to have triggered other problems.<br /><br />&gt; &gt; If the del_timer() fails, the timer might still be running on another CPU<br />&gt; &gt; right at that moment, but not quite have queued the work yet. And then<br />&gt; &gt; we'd potentially get the wrong 'cwq' in flush_work() (we'd use the 'saved'<br />&gt; &gt; work), and not wait for it.<br />&gt; <br />&gt; Or we can get the right cwq, but since the work is not queued and it is not<br />&gt; cwq-&gt;current_work, flush_work() correctly assumes there is nothing to do.<br /><br />Yes.<br /><br />&gt; &gt; I wonder if we could mark the case of "workqueue is on timer" by setting<br />&gt; &gt; the "work-&gt;entry" list to some special value. That way<br />&gt; &gt;<br />&gt; &gt; 	list_empty(&amp;work-&gt;entry)<br />&gt; &gt;<br />&gt; &gt; would always mean "it's neither pending _nor_ scheduled", and<br />&gt; &gt; flush_delayed_work() could have a fast-case check that at the top:<br />&gt; &gt;<br />&gt; &gt; 	if (list_empty(&amp;work-&gt;entry))<br />&gt; &gt; 		return;<br />&gt; <br />&gt; Yes, but we already have this - delayed_work_pending(). If it is<br />&gt; false, it is neither pending nor scheduled. But it may be running,<br />&gt; we can check cwq-&gt;current_work.<br /><br />Yes. But I was more worried about the locks that "del_timer_sync()" does: <br />the timer locks are more likely to be contended than the workqueue locks.<br /><br />Maybe. I dunno.<br /><br />&gt; &gt; &gt; And just in case... Of course, if dwork was pending and running on another CPU,<br />&gt; &gt; &gt; then flush_delayed_work(dwork) can return before the running callback terminates.<br />&gt; &gt; &gt; But I guess this is what we want.<br />&gt; &gt;<br />&gt; &gt; No, we want to wait for the callback to terminate, so we do want to hit<br />&gt; &gt; that 'flush_work()' case.<br />&gt; <br />&gt; Hmm. Now I am confused.<br />&gt; <br />&gt; OK. Lets suppose dwork's callback is running on CPU 0.<br />&gt; <br />&gt; A thread running on CPU 1 does queue_delayed_work(dwork, delay).<br />&gt; <br />&gt; Now, flush_workqueue() will flush the 2nd "queue_delayed_work" correctly,<br />&gt; but it can return before "running on CPU 0" completes.<br /><br />Well, this is actually similar to the larger issue of "the tty layer <br />doesn't want to ever run two works concurrently". So we already hit the <br />concurrency bug.<br /><br />That said, I had an earlier patch that should make that concurrency case <br />be ok (you were not cc'd on that, because that was purely internal to the <br />tty layer). And I think we want to do that regardless, especially since it <br />_can_ happen with workqueues too (although I suspect it's rare enough in <br />practice that nobody cares).<br /><br />And to some degree, true races are ok. If somebody is writing data on <br />another CPU at the same time as we are trying to flush it, not getting the <br />flush is fine. The case we have really cared about we had real <br />synchronization between the writer and the reader (ie the writer who added <br />the delayed work will have done a wakeup and other things to let the <br />reader know).<br /><br />The reason for flushing it was that without the flush, the reader wouldn't <br />necessarily see the data even though it's "old" by then - a delay of a <br />jiffy is a _loong_ time.. So the flush doesn't need to be horribly exact, <br />and after we have flushed, we will take locks that should serialize with <br />the flusher.<br /><br />So I don't think it really matters in practice, but I do think that we <br />have that nasty hole in workqueues in general with overlapping work. I <br />wish I could think of a way to fix it.<br /><br />			Linus<br /><br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
