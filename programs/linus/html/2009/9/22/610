    </div></td><td width="32">Â </td></tr><tr><td valign="top"><div class="es-jasper-simpleCalendar" baseurl="/lkml/"></div><div class="threadlist">Messages in this thread</div><ul class="threadlist"><li class="root"><a href="/lkml/2009/9/22/592">First message in thread</a></li><li><a href="/lkml/2009/9/22/592">Roland McGrath</a><ul><li class="origin"><a href="/lkml/2009/9/22/628">Linus Torvalds</a><ul><li><a href="/lkml/2009/9/22/628">Roland McGrath</a><ul><li><a href="/lkml/2009/9/23/26">Roland McGrath</a><ul><li><a href="/lkml/2009/9/23/27">Roland McGrath</a></li><li><a href="/lkml/2009/9/23/28">Roland McGrath</a></li><li><a href="/lkml/2009/9/23/29">Roland McGrath</a></li><li><a href="/lkml/2009/9/23/30">Roland McGrath</a></li><li><a href="/lkml/2009/9/23/255">Ingo Molnar</a></li></ul></li></ul></li></ul></li></ul></li></ul><div class="threadlist">Patch in this message</div><ul class="threadlist"><li><a href="/lkml/diff/2009/9/22/610/1">Get diff 1</a></li></ul></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerl.gif" width="32" height="32" alt="/" /></td><td class="c" rowspan="2" valign="top" style="padding-top: 1em"><table><tr><td colspan="2"><!--BuySellAds Zone Code--><div id="bsap_1297613" class="bsarocks bsap_5aa49c00cc06c882289a1dd6a5e50b62"></div><!--End BuySellAds Zone Code--></td></tr><tr><td><table><tr><td class="lp">Date</td><td class="rp" itemprop="datePublished">Tue, 22 Sep 2009 18:31:16 -0700 (PDT)</td></tr><tr><td class="lp">From</td><td class="rp" itemprop="author">Linus Torvalds &lt;&gt;</td></tr><tr><td class="lp">Subject</td><td class="rp" itemprop="name">Re: [PATCH] x86: ptrace: sign-extend eax with orig_eax&gt;=0</td></tr></table></td><td><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></td></tr></table><pre itemprop="articleBody"><br /><br />On Tue, 22 Sep 2009, Roland McGrath wrote:<br />&gt;<br />&gt; The 32-bit ptrace syscall on a 64-bit kernel (32-bit debugger on<br />&gt; 32-bit task) behaves differently than a native 32-bit kernel.  When<br />&gt; setting a register state of orig_eax&gt;=0 and eax=-ERESTART* when the<br />&gt; debugged task is NOT on its way out of a 32-bit syscall, the task will<br />&gt; fail to do the syscall restart logic that it should do.<br /><br />Hmm. This really smells extremely hacky to me.<br /><br />I see what you're doing, and I understand why, but it all makes me <br />shudder. I think we already do the wrong thing for 'orig_ax', and that we <br />should probably simply test just the low 32 bits of it (looks to be easily <br />done by just making the return type of 'syscall_get_nr()' be 'int') rather <br />than have that special "let's sign-extend orig_ax" code in ptrace.<br /><br />I also get the feeling that the TS_COMPAT testing is just hacky to begin <br />with. I think it was broken to do things that way, and I have this gut <br />feel that we really should have hidden the "am I a 32-bit or 64-bit <br />syscall" in that orig_ax field instead (ie make the 64-bit system calls <br />set a bit or whatever). That's the field we've always used for system call <br />flagging, and TS_COMPAT was broken.<br /><br />In this example, the problem for ptrace seems to be that TS_COMPAT ends up <br />being that "extra" bit of information that isn't visible in the register <br />set.<br /><br />But that's a bigger separate cleanup. In the meantime, I really get the <br />feeling that your patch is nasty, and could be replaced with something <br />like the following instead.. It just sets the TS_COMPAT bit if we use a <br />32-bit interface to set the system call number to positive (ie "inside <br />system call").<br /><br />THE BELOW IS TOTALLY UNTESTED! I haven't really thought it through. I just <br />reacted very negatively to your patch, and my gut feel is that the code is <br />fundamentally doing something wrong. The below may not work, and may be <br />seriously broken and miss the point, but I think it conceptually comes <br />closer to how things _should_ work.<br /><br />		Linus<br /><br />---<br /> arch/x86/include/asm/syscall.h |    2 +-<br /> arch/x86/kernel/ptrace.c       |    8 +++++++-<br /> 2 files changed, 8 insertions(+), 2 deletions(-)<br /><br />diff --git a/arch/x86/include/asm/syscall.h b/arch/x86/include/asm/syscall.h<br />index d82f39b..f2a0631 100644<br />--- a/arch/x86/include/asm/syscall.h<br />+++ b/arch/x86/include/asm/syscall.h<br />&#64;&#64; -16,7 +16,7 &#64;&#64;<br /> #include &lt;linux/sched.h&gt;<br /> #include &lt;linux/err.h&gt;<br /> <br />-static inline long syscall_get_nr(struct task_struct *task,<br />+static inline int syscall_get_nr(struct task_struct *task,<br /> 				  struct pt_regs *regs)<br /> {<br /> 	/*<br />diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c<br />index 8d7d5c9..90b67db 100644<br />--- a/arch/x86/kernel/ptrace.c<br />+++ b/arch/x86/kernel/ptrace.c<br />&#64;&#64; -1124,13 +1124,19 &#64;&#64; static int putreg32(struct task_struct *child, unsigned regno, u32 value)<br /> 	R32(eip, ip);<br /> 	R32(esp, sp);<br /> <br />-	case offsetof(struct user32, regs.orig_eax):<br />+	case offsetof(struct user32, regs.orig_eax): {<br />+		struct thread_info *thread = task_thread_info(child);<br /> 		/*<br /> 		 * Sign-extend the value so that orig_eax = -1<br /> 		 * causes (long)orig_ax &lt; 0 tests to fire correctly.<br /> 		 */<br /> 		regs-&gt;orig_ax = (long) (s32) value;<br />+		if ((s32) value &gt;= 0)<br />+			thread-&gt;status |= TS_COMPAT;<br />+		else<br />+			thread-&gt;status &amp;= ~TS_COMPAT;<br /> 		break;<br />+	}<br /> <br /> 	case offsetof(struct user32, regs.eflags):<br /> 		return set_flags(child, value);<br /><br /></pre><div align="center"><div class="shariff" data-services="[&quot;reddit&quot;]" data-theme="grey" data-lang="en" data-backend-url="//shariff.lkml.org/index.php"></div></div></td><td width="32" rowspan="2" class="c" valign="top"><img src="/images/icornerr.gif" width="32" height="32" alt="\" /></td></tr><tr><td align="right" valign="bottom">
